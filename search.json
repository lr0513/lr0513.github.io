[{"title":"java基础","url":"/2025/03/12/java基础/","content":"\n# 基础概念和常识\n## Java SE vs Java EE\n\n- Java SE（Java Platform，Standard Edition）: Java 平台==标准版==，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。\n- Java EE（Java Platform, Enterprise Edition ）：Java 平台==企业版==，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。\n\n简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。\n\n## JVM vs JDK vs JRE\n### JVM\nJava 虚拟机（Java Virtual Machine, JVM）是运行 ==Java 字节码==的虚拟机。JVM 有针对**不同系统**的特定实现（Windows，Linux，macOS），目的是**使用相同的字节码，它们都会给出相同的结果**。*字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在*。\n\n如下图所示，不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure ...）通过各自的编译器编译成 `.class` 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。\n![Pasted image 20250309183756](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309183756.png)\n\n### JDK和JRE\nJDK是一个功能齐全的java开发工具包，供开发者使用，用于**创建和编译**java程序。它包含了**JRE以及编译器javac和其他工具**（eg.javadoc文档生成器、jdb调试器、jconsole监控工具、javap反编辑工具）\nJRE是==运行已编译java程序所需要的环境==，主要包括：\n- JVM：java虚拟机\n- Java基础类库（**Class Library**）：一组标准的类库，提供常用的功能和API（eg.IO操作、网络通信、数据结构等）\n即：JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具\n![Pasted image 20250309184829|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309184829.png)\n**从JDK9开始**：用模块系统（94个模块）+ jlink工具取代传统JRE，**JDK11起不再单独提供JRE**。开发者可**用jlink打包应用仅依赖的模块**，生成**轻量级定制运行时镜像**（例如仅保留20个必要模块），使运行环境体积减少80%+，同时提升部署效率、降低内存占用、增强安全性，**完美适配容器化/微服务等云原生场景**\n**核心逻辑**：模块化 = 按需裁剪 + 轻量部署\n\n## 字节码\nJava字节码（`.class`文件）是**JVM**的通用指令，**独立于硬件平台**（不面向任何特定的处理器，只面向JVM虚拟机），由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。平衡了执行效率与跨移植性（虽效率仍低于C/C++等编译型语言）。\n**Java 程序从源代码到运行的过程**\n![Pasted image 20250309190054|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190054.png)\n程序运行时，JVM通过**解释器逐行翻译字节码为机器码** `.class->机器码`（初始速度较慢），而对高频调用的**热点代码**，**JIT编译器**（属于==运行==时编译）会动态编译并缓存对应机器码，后续直接执行加速。\n机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。\nJava高效跨平台 = **字节码中间层** + **解释与JIT编译协同**（冷代码解释执行，热代码编译缓存）\n热代码：方法和代码块是经常需要被调用的\n![Pasted image 20250309190159|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190159.png)\nHotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。\n\n![Pasted image 20250309190229|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190229.png)\n\n## 为什么说java语言”编译与解释并存“\nJava 的执行过程结合了**编译型语言**和**解释型语言**的特性，具体体现为以下两个阶段：\n- **编译型**：源码需预先编译为字节码（静态编译）\n- **解释型**：字节码由解释器逐行翻译执行（动态解释）\n![Pasted image 20250309191659|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309191659.png)\n改善：\n- **混合模式**：先将源码编译成字节码，到执行期间，再将字节码直译，之后执行。java和LLVM是这种技术的代表产物\n**为什么说 Java 语言“编译与解释并存”？**\n Java 语言既具有编译型语言的特征，也具有解释型语言的特征。 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。\nJava程序需**先编译为字节码**（平台无关的中间代码），再通过JVM的**解释器逐行翻译为机器码执行**，这一过程体现了解释型语言的特性；而针对高频执行的**热点代码**，JVM的**JIT编译器**会在运行时将其**动态编译为本地机器码并缓存**（类似编译型语言的特性），后续直接调用以大幅提升效率。这种“冷代码解释+热代码编译”的混合模式，既保留了跨平台灵活性，又通过运行时优化逼近了编译型语言的性能。\n\n\n## AOT\n**JDK9引入的AOT（预编译）直接在运行前将字节码==静态==编译为机器码**（C、 C++，Rust，Go 等语言就是静态编译），消除JIT预热开销，显著提升启动速度并降低内存消耗，尤其适配云原生场景对快速扩容的需求。相较于JIT的运行时动态优化，AOT牺牲了部分极限性能（如高并发吞吐量），但通过**预编译加固代码安全性**（防反编译和修改），在微服务等轻量级应用中优势明显。\n**JIT 与 AOT 两者的关键指标对比**:\n![Pasted image 20250309192909|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309192909.jpg)\n可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。\n\n**GraalVM作为技术桥梁**：不仅支持Java/JVM生态的AOT编译，还能运行JS/Python等非JVM语言，实现多语言混合编程（GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译）。\n**既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？**\nAOT虽在**启动速度和资源占用**上优势显著，但其**静态编译特性**与Java生态广泛依赖的**动态能力**存在根本冲突：\n1. **动态特性失效**\n   如反射（运行时获取/修改类信息）、动态代理（如Spring AOP）、字节码生成（如CGLIB基于ASM实时创建`.class`）等操作，均需**运行时动态修改或加载类**。而AOT要求所有代码**预先编译为机器码**，导致这些灵活机制无法实时生效，直接破坏Spring等框架的核心功能。\n2. **技术生态兼容性**\n   Java主流框架（Spring/Hibernate）大量通过注解、反射注入依赖关系，若强制AOT需**代码全量静态可分析**，开发者需大幅改写业务代码或框架适配（如Spring Native项目），显著增加复杂度。\n3. **性能取舍**\n   AOT的静态优化无法像JIT基于**运行时热点分析**做深度优化（如方法内联、逃逸分析），对长期运行的高并发服务，JIT的渐进式优化更能释放极限性能。\n**实例**：CGLIB动态代理通过ASM在内存中即时生成代理类的字节码，若用AOT提前编译，则代理逻辑无法动态插入，导致@Transactional等依赖代理的注解失效。\n\n**结论**：AOT与JIT是**场景互补**而非替代\n- **短时任务/云函数**：AOT优先（秒级启动）\n- **复杂业务/传统应用**：JIT维持动态灵活性\n- **混合方案**：GraalVM等工具允许部分AOT+JIT（如预编译基础库，核心业务保持动态）\n## Oracle JDK VS OpenJDK\n**开源与商业化的博弈**\nOpenJDK作为**开源参考实现**，遵循GPL协议允许自由修改与分发（如阿里基于其定制Dragonwell），而Oracle JDK虽衍生自OpenJDK，但**部分高级功能闭源**（如早期Java Flight Recorder），且受BCL/OTN协议约束——JDK 17后免费商用仅限3年，长期需付费许可。\n\n**功能与生态平衡**\n- **特性差异**：Oracle JDK曾独占JFR性能监控等工具，但**Java 11后两者核心功能趋同**，Oracle将多数组件开源捐赠，削弱了独家优势。\n- **更新策略**：OpenJDK以**3个月为周期快速迭代**（试水新特性），Oracle JDK则以6个月为周期整合稳定版本，实际通过第三方（如Amazon Corretto）提供OpenJDK的LTS支持，弥补了官方长期支持的缺失。\n\n**为何OpenJDK不可替代？**\n1. **开源自由**：企业可深度定制（如适配云环境、优化GC算法），避免受限于Oracle的商业策略；\n2. **零成本商用**：无版本时间锁，尤其适合需长期维护的遗留系统（如JDK 8无限期免费）；\n3. **云原生适配**：主流云厂商（AWS/Azure/AliCloud）均基于OpenJDK发行优化版，天然适配容器化、Serverless等场景。\n\n**协议风险警示**\nOracle JDK的OTN协议要求**Java 17+商用付费**，且禁止修改二进制代码；而OpenJDK的GPLv2允许自由使用与二次开发，这对企业构建自主技术栈至关重要。\n\n**选型结论**\n- **常规场景**：优先选择**OpenJDK发行版**（如Corretto/Dragonwell），兼顾免费、稳定与生态兼容；\n- **特殊需求**：若依赖Oracle独家工具（如JMC深度诊断），可短期使用Oracle JDK，但需评估后续版本付费风险。\n\n## Java VS C++\n- Java 不提供指针来直接访问内存，程序内存更加安全\n- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\n- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。\n- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。\n\n# 基本语法\n注释：单行、多行、文档\n## 移位运算符\n移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为==二进制数==，移位就是将其向左或向右移动若干位的运算。\n**一、三种移位运算符本质**\n1. **`<<` 左移**\n   二进制整体向左移动，**低位补0，高位丢弃**\n   - 示例：`5 << 2` → `0000 0101` → `0001 0100` = 20\n   - **等效计算**：`x * 2ⁿ`（适用于非溢出场景）\n\n2. **`>>` 带符号右移**\n   二进制向右移动，**高位补符号位（正补0，负补1），低位丢弃**\n   - 示例：`-8 >> 1` → `1111 1000` → `1111 1100` = -4\n   - **等效计算**：`x / 2ⁿ`（向下取整）\n\n3. **`>>>` 无符号右移**\n   二进制向右移动，**高位强制补0，低位丢弃**\n   - 示例：`-8 >>> 1` → `1111 1000` → `0111 1100` = 124（int类型）\n```java\npublic static int midPoint(int low, int high) {\n    // 核心公式：中间值 = low + ((high - low) >> 1)\n    return low + ((high - low) >> 1);\n}\n```\n\n**二、关键特性与使用场景**\n1. **高效计算**\n   - 直接映射CPU指令（如SHL/SHR），比乘除法快10倍以上（实测示例）\n   ```java\n   // 性能对比：移位 vs 乘法\n   long start = System.nanoTime();\n   int a = 1024 << 3; // 等效 1024*8\n   long end = System.nanoTime();\n   System.out.println(\"移位耗时：\" + (end - start) + \"ns\"); // 约5ns\n\n   start = System.nanoTime();\n   int b = 1024 * 8;\n   end = System.nanoTime();\n   System.out.println(\"乘法耗时：\" + (end - start) + \"ns\"); // 约20ns\n   ```\n\n2. **内存优化**\n   - 用int/long存储多个布尔标志（每个位表示一个状态）\n   ```java\n   // 权限管理示例：读(1<<0)、写(1<<1)、执行(1<<2)\n   final int READ = 1 << 0;   // 0001\n   final int WRITE = 1 << 1;  // 0010\n   final int EXECUTE = 1 << 2;// 0100\n\n   int userA = READ | WRITE; // 0011（有读写权限）\n   ```\n\n3. **哈希算法应用**\n   - **HashMap中的扰动函数**：通过无符号右移增强散列\n   ```java\n   static final int hash(Object key) {\n       int h;\n       return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n   }\n   ```\n   - **作用**：将高16位特征混合到低16位，减少哈希碰撞\n\n**三、注意**\n1. **移位位数超限**\n   - 移位位数超过类型位数时，实际移位数为 `位数 % 类型长度`\n   - 示例：\n     ```java\n     int x = 3 << 34;  // 等效 3 << (34%32)=2 → 3*4=12\n     long y = 5L << 66;// 等效 5L << (66%64)=2 → 5*4=20\n     ```\n\n2. **类型隐式转换**\n   - 对`byte/short/char`移位时，自动转为int操作\n   ```java\n   byte b = 0b1000_0000; // -128\n   int result = b << 2;  // 转换为int操作：-128 << 2 = -512\n   ```\n\n3. **符号位陷阱**\n   - 带符号右移保留符号位，无符号右移强制补零\n   ```java\n   int negative = -8;          // 1111...1000\n   int signedShift = negative >> 1;  // 1111...1100 (-4)\n   int unsignedShift = negative >>> 1; // 0111...1100 (2147483644)\n   ```\n\n## continue VS break VS return\n1. `continue`：指跳出当前的这一次循环，继续下一次循环。\n2. `break`：指跳出整个循环体，继续执行循环下面的语句。\n`return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：\n3. `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法\n4. `return value;`：return 一个特定值，用于有返回值函数的方法\n```java\npublic static void main(String[] args) {\n    boolean flag = false;\n    for (int i = 0; i <= 3; i++) {\n        if (i == 0) {\n            System.out.println(\"0\");\n        } else if (i == 1) {\n            System.out.println(\"1\");\n            continue;\n        } else if (i == 2) {\n            System.out.println(\"2\");\n            flag = true;\n        } else if (i == 3) {\n            System.out.println(\"3\");\n            break;\n        } else if (i == 4) {\n            System.out.println(\"4\");\n        }\n        System.out.println(\"xixi\");\n    }\n    if (flag) {\n        System.out.println(\"haha\");\n        return;\n    }\n    System.out.println(\"heihei\");\n}\n\n0\nxixi\n1\n2\nxixi\n3\nhaha\n```\n\n## 基本类型\nJava 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一\n\n| 类型     | 位数 | 字节 | 默认值       | 取值范围                                                                 |\n|----------|------|------|--------------|--------------------------------------------------------------------------|\n| `byte`   | 8    | 1    | 0            | -128 ~ 127                                                               |\n| `short`  | 16   | 2    | 0            | -32768（-\\(2^{15}\\)） ~ 32767（\\(2^{15}\\) - 1）                          |\n| `int`    | 32   | 4    | 0            | -2147483648 ~ 2147483647                                                 |\n| `long`   | 64   | 8    | 0L           | -9223372036854775808（-\\(2^{63}\\)） ~ 9223372036854775807（\\(2^{63}\\) -1）|\n| `char`   | 16   | 2    | '\\u0000'     | 0 ~ 65535（\\(2^{16}\\) - 1）                                              |\n| `float`  | 32   | 4    | 0.0f         | 1.4E-45 ~ 3.4028235E38                                                   |\n| `double` | 64   | 8    | 0.0d         | 4.9E-324 ~ 1.7976931348623157E308                                        |\n| `boolean`| 1（逻辑上） | - | false        | true、false                                                              |\n**补充说明**：\n1. **`boolean`类型**：\n   - 逻辑上为1位，但实际存储依赖JVM实现（通常用1字节或4字节存储）。\n   - 默认值为`false`，取值范围仅为`true`和`false`。\n\n2. **浮点数精度**：\n   - `float`为单精度浮点数，精度约6-7位小数。\n   - `double`为双精度浮点数，精度约15位小数。\n\n3. **字符类型**：\n   - `char`为16位无符号整数，表示Unicode字符，范围为`0`到`65535`。\n\n4. **默认值规则**：\n   - 类成员变量（字段）有默认值，局部变量必须显式初始化，否则编译报错。\n\n### 基本类 VS 包装类\n\n| **特性**   | **基本类型**                          | **包装类**                      |\n| -------- | --------------------------------- | ---------------------------- |\n| **存储位置** | - 局部变量：栈中<br>- 成员变量：堆中（未static修饰） | 堆中（对象实例）                     |\n| **占用空间** | 极小（如`int`：4字节，`boolean`：1位逻辑值）    | 较大（对象头+实例数据，通常16字节以上）        |\n| **默认值**  | 有默认值（如`int`：0，`boolean`：false）    | `null`（未赋值时）                 |\n| **比较方式** | == 比较值                            | equals()比较值，== 比较对象的内存地址     |\n| **泛型支持** | 不支持                               | 支持                           |\n| **逃逸分析** | 无（直接存储值）                          | 可能通过逃逸分析优化为栈上分配（如局部对象未逃逸出方法） |\n1. **局部变量**\n   - 基本类型：栈中（如方法内的`int a = 10;`）\n   - 包装类：堆中（如`Integer b = 20;`）\n\n2. **成员变量**\n   - 基本类型：堆中（如`int a = 10;`）\n   - 包装类：堆中（如`Integer b = 20;`）\n\n3. **静态变量**\n   - 基本类型：方法区（JDK 1.7及之前）或元空间（JDK 1.8+）\n   - 包装类：方法区（JDK 1.7及之前）或元空间（JDK 1.8+）\n\n⚠️ 注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。\n```java\npublic class Test {\n    // 成员变量（堆中）\n    int a = 10;\n    Integer b = 20;\n\n    // 静态变量（方法区/元空间）\n    static int c = 30;\n    static Integer d = 40;\n\n    public void method() {\n        // 局部变量（栈中）\n        int e = 50;\n        Integer f = 60;\n\n        // 逃逸分析优化：局部对象可能分配在栈中\n        Integer g = new Integer(70); // 可能栈上分配\n    }\n}\n```\n\n注：\n**为什么说是几乎所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存\n1. **栈与堆的误区**\n   - 基本类型的存储位置取决于作用域：局部变量在栈中，成员变量在堆中。\n   - 包装类始终是对象，通常分配在堆中，但可能通过逃逸分析优化为栈上分配。\n\n2. **性能权衡**\n   - **基本类型**：性能高，内存占用小，但功能受限（如不支持泛型）。\n   - **包装类**：功能强大（如支持泛型、集合操作），但内存开销大。\n\n3. **默认值与空指针**\n   - 基本类型有默认值，包装类未赋值时为`null`，使用时需注意空指针异常。\n\n4. **比较方式**\n   - 对于基本数据类型用== 比较值。包装类用equals()比较值，== 比较对象的内存地址\n### **适用场景**\n- **基本类型**：性能敏感场景（如循环计算、数组存储）。\n- **包装类**：泛型集合、数据库映射（如`List<Integer>`）、API设计（如方法参数可为`null`）。\n- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。\n\n## 包装类型的缓存机制\n\n| **包装类**   | **缓存范围**         | **缓存实现方式**                                                                 |\n|--------------|----------------------|--------------------------------------------------------------------------------|\n| `Byte`       | -128 ~ 127           | 全部缓存（256个对象）                                                          |\n| `Short`      | -128 ~ 127           | 全部缓存（256个对象）                                                          |\n| `Integer`    | -128 ~ 127           | 全部缓存（256个对象）                                                          |\n| `Long`       | -128 ~ 127           | 全部缓存（256个对象）                                                          |\n| `Character`  | 0 ~ 127              | 全部缓存（128个对象）                                                          |\n| `Boolean`    | `true` / `false`     | 全部缓存（2个对象）                                                            |\n| `Float`      | 无缓存               | 每次创建新对象                                                                 |\n| `Double`     | 无缓存               | 每次创建新对象                                                                 |\n\n**缓存机制的作用**\n1. **性能优化**\n   - 频繁使用的小范围数值直接复用缓存对象，避免重复创建。\n   - 示例：`Integer i1 = 40;` 直接从缓存中获取对象，无需`new`。\n\n2. **内存节省**\n   - 缓存常用对象，减少堆内存占用。\n   - 示例：`Byte`、`Short`、`Integer`、`Long`、`Character`的缓存对象总数仅约1000个。\n\n3. **代码简洁**\n   - 自动装箱（如`Integer i = 10;`）隐式调用`valueOf()`，利用缓存机制。\n\n**缓存机制的实现**\n1. **`Integer`缓存源码**\n   ```java\n   public static Integer valueOf(int i) {\n       if (i >= IntegerCache.low && i <= IntegerCache.high)\n           return IntegerCache.cache[i + (-IntegerCache.low)];\n       return new Integer(i); // 超出缓存范围，创建新对象\n   }\n\n   private static class IntegerCache {\n       static final int low = -128;\n       static final int high = 127;\n       static final Integer cache[];\n\n       static {\n           cache = new Integer[(high - low) + 1];\n           for (int k = 0; k < cache.length; k++)\n               cache[k] = new Integer(low + k);\n       }\n   }\n   ```\n\n2. **`Character`缓存源码**\n   ```java\n   public static Character valueOf(char c) {\n       if (c <= 127) // 仅缓存0~127\n           return CharacterCache.cache[(int)c];\n       return new Character(c); // 超出缓存范围，创建新对象\n   }\n\n   private static class CharacterCache {\n       static final Character cache[] = new Character[128];\n       static {\n           for (int i = 0; i < cache.length; i++)\n               cache[i] = new Character((char)i);\n       }\n   }\n   ```\n\n3. **`Boolean`缓存源码**\n   ```java\n   public static Boolean valueOf(boolean b) {\n       return (b ? TRUE : FALSE); // 直接返回缓存对象\n   }\n   ```\n如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\n两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。\n4. **比较方式**\n   - == 比较:仅适用于缓存范围内的对象（如Integeri1=40;Integer i2= 40;）\n   - **`equals()`比较**：适用于所有场景，推荐使用。\n\n2. **缓存范围外的对象**\n   - 超出缓存范围（如Integeri1=200;Integeri2=200;）会创建新对象，== 比较结果为 false\n\n3. **浮点数无缓存**\n   - Float 和 Double 每次装箱都会创建新对象，== 比较结果始终为 false\n\n**经典面试题**\n```java\nInteger i1 = 40;           // 使用缓存\nInteger i2 = new Integer(40); // 创建新对象\nSystem.out.println(i1 == i2); // false\n```\n- 发生装箱，`i1`通过`valueOf()`从==缓存==中获取对象，等价于 `Integer i1=Integer.valueOf(40)`，`i1` 直接使用的是缓存中的对象\n- `i2`通过`new`创建新对象。\n- == 比较内存地址，结果为 false\n\n### **最佳实践**\n1. **比较包装类对象**\n   - 始终使用`equals()`方法，避免== 的潜在问题。\n\n2. **自动装箱与缓存**\n   - 理解自动装箱（如`Integer i = 10;`）隐式调用`valueOf()`，利用缓存机制。\n\n3. **性能优化**\n   - 在频繁使用小范围数值时，优先使用基本类型（如`int`），避免包装类的内存开销。\n\n## 自动装箱和拆箱\n1. **装箱**\n   - 将基本类型转换为对应的包装类对象。\n   - 示例：`Integer i = 10;`\n   - 实际调用：`Integer.valueOf(10)`\n\n2. **拆箱**\n   - 将包装类对象转换为基本类型。\n   - 示例：`int n = i;`\n   - 实际调用：`i.intValue()`\n\n**性能问题**\n- **频繁拆装箱**会显著影响性能（如循环中大量使用包装类）。\n- **优化建议**：在性能敏感场景优先使用基本类型。\n\n**反例**：\n```java\nprivate static long sum() {\n    Long sum = 0L; // 每次循环都会装箱\n    for (long i = 0; i <= Integer.MAX_VALUE; i++)\n        sum += i; // 拆箱后再装箱\n    return sum;\n}\n```\n**优化后**：\n```java\nprivate static long sum() {\n    long sum = 0L; // 使用基本类型\n    for (long i = 0; i <= Integer.MAX_VALUE; i++)\n        sum += i; // 无拆装箱开销\n    return sum;\n}\n```\n\n\n## 为什么浮点数运算会有精度丢失的风险\n\n- 计算机以二进制存储浮点数，部分十进制小数无法精确表示（如0.2）。\n- 示例：\n  ```java\n  float a = 2.0f - 1.9f; // 0.100000024\n  float b = 1.8f - 1.7f; // 0.099999905\n  System.out.println(a == b); // false\n  ```\n### **解决方案：`BigDecimal`**\n1. **精确计算**\n   - 使用`BigDecimal`避免精度丢失。\n   - 示例：\n     ```java\n     BigDecimal a = new BigDecimal(\"1.0\");\n     BigDecimal b = new BigDecimal(\"0.8\");\n     BigDecimal result = a.subtract(b); // 0.2\n     ```\n\n2. **比较方式**\n   - **`equals()`**：比较值和精度（`1.0` ≠ `1.00`）。\n   - **`compareTo()`**：仅比较值（`1.0` = `1.00`）。\n   ```java\n   BigDecimal x = new BigDecimal(\"0.2\");\n   BigDecimal y = new BigDecimal(\"0.20\");\n   System.out.println(x.equals(y)); // false\n   System.out.println(x.compareTo(y) == 0); // true\n   ```\n\n## 大整数处理\n\n### BigInteger\n- 用于处理超出`long`范围的整数。\n- 内部通过`int[]`数组存储数据。\n- 示例：\n  ```java\n  BigInteger bigInt = new BigInteger(\"123456789012345678901234567890\");\n  System.out.println(bigInt.add(BigInteger.ONE)); // +1\n  ```\n### 数值溢出问题\n- 基本类型有固定范围，超出后会发生溢出。\n- 示例：\n  ```java\n  long l = Long.MAX_VALUE;\n  System.out.println(l + 1); // -9223372036854775808（溢出）\n  System.out.println(l + 1 == Long.MIN_VALUE); // true\n  ```\n\n\n## 变量\n### 成员变量 VS 局部变量\n\n| **对比维度** | **成员变量**                              | **局部变量**                     |\n| -------- | ------------------------------------- | ---------------------------- |\n| **语法形式** | 属于类，可被`public`/`private`/`static`等修饰  | 定义在方法/代码块中或作为参数，仅能被`final`修饰 |\n| **存储位置** | `static`修饰：方法区/元空间<br>非`static`修饰：堆内存 | 栈内存                          |\n| **生存时间** | 随对象创建而存在，随对象销毁而消亡                     | 随方法调用生成，随方法结束消亡              |\n| **默认值**  | 自动赋默认值（如`int`→0，`boolean`→false）      | 必须显式初始化，否则编译报错               |\n| **作用域**  | 类内全局可见（受访问修饰符限制）                      | 仅在定义的方法/代码块内有效               |\n<font color=\"#0070c0\">成堆</font>\n\n**为什么成员变量有默认值？**\n1. 先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。\n2. 默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。**成员变量在运行时可借助反射等方法手动赋值，而局部变量不行**\n3. 对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值\n```java\npublic class VariableExample {\n    // 成员变量（堆内存）\n    private String name;    // 默认值 null\n    private int age;        // 默认值 0\n\n    public void method() {\n        // 局部变量（栈内存）\n        int num1 = 10;      // 必须显式初始化\n        String str = \"Hello\";\n        System.out.println(num1 + str);\n    }\n\n    public VariableExample(String name, int age) {\n        this.name = name;   // 成员变量手动赋值\n        int num3 = 20;      // 局部变量\n        System.out.println(num3);\n    }\n}\n```\n\n### [静态变量有什么作用？](#静态变量有什么作用)\n1. **共享性**\n   - 被`static`修饰，属于类而非实例，所有对象共享同一份内存。\n   - 示例：计数器统计对象创建次数。\n     ```java\n     public class Counter {\n         public static int count = 0;\n         public Counter() { count++; }\n     }\n     ```\n\n2. **内存效率**\n   - 仅分配一次内存，节省资源。\n   - 示例：全局配置常量。\n     ```java\n     public class Config {\n         public static final int MAX_USERS = 1000;\n     }\n     ```\n\n3. **访问方式**\n   - 通过类名直接访问（如`Config.MAX_USERS`）。\n   - 若被`private`修饰，需通过类方法访问。\n\n| **场景**          | **示例**                                                                 |\n|-------------------|-------------------------------------------------------------------------|\n| 全局常量          | `public static final double PI = 3.14159;`                             |\n| 资源共享          | 数据库连接池的配置参数                                                  |\n| 工具类方法        | `Math`类中的`sqrt()`方法                                                |\n| 单例模式          | 通过静态变量持有唯一实例                                                |\n\n### 字符型常量 VS 字符串常量\n\n| **对比维度** | **字符常量**              | **字符串常量**                   |\n| -------- | --------------------- | --------------------------- |\n| **定义形式** | 单引号包裹单个字符：`'A'`       | 双引号包裹0-N个字符：`\"Hello\"`       |\n| **本质**   | `char`类型（2字节），可参与算术运算 | `String`对象（堆内存），存储地址值       |\n| **内存占用** | 固定2字节                 | 可变长度（UTF-8编码英文1字节/字符，中文3字节） |\n| **比较方式** | == 比较值                | `equals()`比较内容，== 比较地址      |\n⚠️ 注意 `char` 在 Java 中占两个字节。\n```java\npublic class ConstantExample {\n    // 字符常量\n    public static final char LETTER_A = 'A'; // 2字节\n\n    // 字符串常量\n    public static final String GREETING = \"Hello\";\n    // 内存占用：英文5字符→5字节（UTF-8）\n\n    public static void main(String[] args) {\n        char ch = '中'; // 2字节存储Unicode\n        String str = \"中国\"; // 6字节（UTF-8）\n\n        System.out.println(Character.BYTES); // 输出2\n        System.out.println(str.getBytes().length); // 输出6\n    }\n}\n```\n1. **字符常量**\n   - 用于单个字符处理（如ASCII运算）。\n   - 示例：`char c = 'A' + 1;` → `'B'`。\n\n2. **字符串常量**\n   - 用于文本处理，注意不可变性（每次修改生成新对象）。\n   - 示例：`String s = \"Hi\"; s += \"!\";` → 新建对象`\"Hi!\"`。\n\n3. **性能优化**\n   - 高频操作字符串时用`StringBuilder`减少内存开销。\n\n## 方法\n### [静态方法为什么不能调用非静态成员?](#静态方法为什么不能调用非静态成员)\n根本原因：==生命周期与内存分配==\n静态方法与非静态成员的**加载时机**和**内存归属**存在本质差异：\n\n| **特性**     | **静态方法**           | **非静态成员**                 |\n| ---------- | ------------------ | ------------------------- |\n| **内存分配时机** | 类加载阶段分配内存（JVM加载类时） | 对象实例化时分配内存（`new`关键字创建对象时） |\n| **内存归属**   | 类级别（方法区/元空间）       | 对象级别（堆内存）                 |\n| **访问依赖**   | 不依赖对象实例            | 必须通过对象实例访问                |\n1. **时序矛盾**\n    在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\n2. **内存安全**\n    非静态成员属于对象实例，不同实例的成员变量值可能不同。静态方法无对象上下文（无`this`指针），无法确定访问哪个实例的成员。\n``` java\npublic class Example {\n    // 非静态成员变量\n    private int instanceVar = 10;\n\n    // 静态方法尝试访问非静态成员 → 编译错误\n    public static void staticMethod() {\n        // System.out.println(instanceVar); // 错误：无法访问非静态成员\n    }\n\n    // 实例方法可自由访问非静态成员\n    public void instanceMethod() {\n        System.out.println(instanceVar); // 正确\n    }\n}\n```\n### 静态方法 VS 实例方法\n| **对比维度**     | **静态方法**      | **实例方法**       |\n| ------------ | ------------- | -------------- |\n| **调用方式**     | `类名.方法名()`    | `对象.方法名()`     |\n| **内存归属**     | 类级别（方法区/元空间）  | 对象级别（堆内存）      |\n| **`this`引用** | 不可用（无对象上下文）   | 可用（指向当前对象）     |\n| **访问成员权限**   | 仅能直接访问静态成员    | 可访问所有成员（静态+实例） |\n| **多态支持**     | 不支持重写（隐藏而非覆盖） | 支持重写（动态绑定）     |\n**静态方法**：仅能直接访问静态成员，需通过对象间接访问实例成员\n``` java\npublic class Person {\n    private static int population = 0; // 静态变量\n    private String name; // 实例变量\n\n    public static void staticMethod() {\n        population++; // 允许访问静态变量\n        // name = \"Alice\"; // 编译错误：无法直接访问实例变量\n        Person p = new Person();\n        p.name = \"Alice\"; // 通过对象间接访问\n    }\n}\n```\n\n## 重载 VS 重写\n\n> 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理\n>\n> 重写发生在运行期，就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\n\n| 区别点   | 重载方法 | 重写方法                             |\n| ----- | ---- | -------------------------------- |\n| 发生范围  | 同一个类 | 子类                               |\n| 参数列表  | 必须修改 | 一定不能修改                           |\n| 返回类型  | 可修改  | 子类方法返回值类型应比父类方法返回值类型更小或相等        |\n| 异常    | 可修改  | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改  | 一定不能做更严格的限制（可以降低限制）              |\n| 发生阶段  | 编译期  | 运行期                              |\n重写补充：\n1. 方法名、参数列表必须相同，子类方法返回值类型应<=父类方法返回值类型，抛出的异常范围<=父类，访问修饰符范围>=父类。\n2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。\n3. 构造方法无法被重写\n\n## 可变长参数\n从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。\n```\npublic static void method1(String... args) {\n   //......\n}\n```\n另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。\n```\npublic static void method2(String arg1, String... args) {\n   //......\n}\n```\n**遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？**\n- **固定参数优先**：当重载方法中存在固定参数和可变参数版本时，编译器优先匹配固定参数方法。\n- **可变参数本质**：可变参数在编译后会被转换为数组（如`String... args` → `String[] args`）。\n``` java\npublic class VariableLengthArgument {\n\n    // 固定参数方法\n    public static void printVariable(String arg1, String arg2) {\n        System.out.println(arg1 + arg2); // 优先匹配\n    }\n\n    // 可变参数方法\n    public static void printVariable(String... args) {\n        for (String s : args) {\n            System.out.println(s);\n        }\n    }\n\n    public static void main(String[] args) {\n        printVariable(\"a\", \"b\");      // 调用固定参数方法 → 输出 ab\n        printVariable(\"a\", \"b\", \"c\"); // 调用可变参数方法 → 输出 a b c\n    }\n}\n```\n**编译后的字节码分析**：\n可变参数方法`printVariable(String... args)`会被编译为：\n``` java\npublic static void printVariable(String[] args) {\n    // 循环遍历数组\n}\n```\n### **重载冲突场景**\n- **避免歧义**：若同时存在`method(String[])`和`method(String...)`，编译器会报错，因两者本质相同。\n- **类型明确性**：调用时传入明确数组会优先匹配数组参数方法。\n\n# 面向对象基础\n## 面向对象 (OOP) VS 面向过程 (POP)\n- **面向过程编程（POP）**：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\n- **面向对象编程（OOP）**：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\n\n| **维度**     | **面向过程 (POP)**                | **面向对象 (OOP)**         |\n| ---------- | ----------------------------- | ---------------------- |\n| **核心思想**   | 以**过程**为中心，将问题拆解为一系列步骤（方法/函数） | 以**对象**为中心，通过对象交互解决问题  |\n| **代码组织方式** | 按**执行流程**组织代码                 | 按**对象职责**组织代码（类、属性、方法） |\n| **数据与行为**  | 数据与操作分离（函数操作外部数据）             | 数据与行为封装在对象内部（对象管理自身状态） |\n| **典型语言**   | C、Pascal、Fortran              | Java、C++、Python        |\n### **OOP 的核心优势**\n1. **易维护**\n   - 封装性：隐藏对象内部状态，通过方法暴露安全操作。\n   - 示例：`Circle`类封装半径，外部无法直接修改非法值。\n2. **易复用**\n   - 继承与多态：复用父类逻辑，扩展子类行为。\n   - 示例：`Animal`类派生出`Dog`和`Cat`，复用`eat()`方法。\n3. **易扩展**\n   - 模块化设计：新增功能只需扩展类或接口，无需修改全局逻辑。\n   - 示例：新增`Square`类实现`Shape`接口，系统无需重构。\nPOP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。\n\n面向过程：**面向过程性能比面向对象高**。因为对象调用需要实例化，开销比较大，较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等，一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。\n\n面向对象：**面向对象易维护、易复用、易扩展**。因为面向对象有封装、继承、多态性的特性，所以可设计出低耦合的系统，使得系统更加灵活、更加易于维护。\n\n在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。\n\n**面向过程性能比面向对象高的背后原因？**\n> 面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是因为 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机器码。\n>\n> 而面向过程语言大多都是直接编译成机器码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。\n\n**代码示例对比**\n#### **面向对象实现**\n定义一个 `Circle` 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。\n```java\npublic class Circle {\n    private double radius; // 封装半径\n\n    public Circle(double radius) {\n        if (radius <= 0) throw new IllegalArgumentException(\"半径必须为正数\");\n        this.radius = radius;\n    }\n\n    public double getArea() {\n        return Math.PI * radius * radius; // 行为与数据绑定\n    }\n\n    public static void main(String[] args) {\n        Circle circle = new Circle(3.0);\n        System.out.println(\"面积: \" + circle.getArea());\n    }\n}\n```\n#### **面向过程实现**\n直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长\n```java\npublic class Main {\n    public static void main(String[] args) {\n        double radius = 3.0;\n        double area = calculateArea(radius); // 数据与逻辑分离\n        System.out.println(\"面积: \" + area);\n    }\n\n    public static double calculateArea(double r) {\n        return Math.PI * r * r;\n    }\n}\n```\n\n| **特性**       | **面向对象实现**                              | **面向过程实现**                              |\n|----------------|---------------------------------------------|---------------------------------------------|\n| **封装性**     | 数据与操作封装在类中，避免非法修改            | 数据暴露在外，需外部校验合法性                |\n| **复用性**     | 可通过继承/组合复用`Circle`类逻辑             | 函数可复用，但数据传递需重复管理              |\n| **扩展性**     | 新增功能（如颜色属性）只需扩展类               | 需修改全局函数或添加新函数，易破坏现有逻辑    |\n| **性能开销**   | 轻微对象创建开销（JVM优化后几乎可忽略）        | 无对象开销，直接计算                          |\n\n**如何选择编程范式？**\n\n| **场景**        | **推荐范式** | **理由**              |\n| ------------- | -------- | ------------------- |\n| 复杂业务系统（如电商平台） | OOP      | 模块化设计、易维护、团队协作高效    |\n| 底层驱动开发（如嵌入式）  | POP      | 资源受限、需直接操作硬件，逻辑简单直接 |\n| 脚本工具（如数据处理脚本） | POP      | 快速开发、无需复杂架构         |\n| 框架/库开发        | OOP      | 提供高扩展性API，支持多态和接口隔离 |\n\n1. **OOP核心价值**：提升代码可维护性、复用性和扩展性，适合中大型项目。\n2. **POP适用场景**：简单任务、资源敏感型开发，或与硬件直接交互的底层逻辑。\n3. **性能误区**：语言实现（如编译方式）对性能影响远大于编程范式本身。\n4. **现代语言趋势**：多数语言支持多范式（如Python、C++），开发者需灵活选择。\n\n**最终建议**：\n- 优先考虑代码结构和长期维护成本，而非单纯追求性能。\n- 在性能关键路径（如高频循环）中，可局部使用POP优化，但整体架构仍保持OOP优势。\n\n\n## 创建对象的运算符：对象实体 vs 对象引用\n- **`new` 运算符**：用于在堆内存中创建对象实例。\n- **对象引用**：指向堆内存中对象实例的变量，存储在栈内存中。\n\n| **比喻**          | **说明**                                                                 |\n|--------------------|--------------------------------------------------------------------------|\n| **对象实例（气球）** | 存在于堆内存中的实际数据。                                              |\n| **对象引用（绳子）** | 指向对象的变量，可以指向0个或1个对象（绳子不系或系一个气球）。           |\n| **多引用共享**      | 多个引用可指向同一对象（多条绳子系同一个气球）。                         |\n\n```java\n// 对象引用未指向任何对象\nString s1 = null;\n\n// 对象引用指向一个新对象\nString s2 = new String(\"Hello\");\n\n// 另一个引用指向同一对象\nString s3 = s2;\n```\n\n## 对象相等 vs 引用相等\n\n| **对比维度** | **引用相等（==）**   | **对象相等（equals()）**    |\n| -------- | -------------- | --------------------- |\n| **比较内容** | 内存地址是否相同       | 对象内部数据是否相同            |\n| **适用场景** | 判断两个引用是否指向同一对象 | 判断两个对象逻辑上是否相等（如字符串内容） |\n```java\nString str1 = \"hello\";          // 字符串常量池中的对象\nString str2 = new String(\"hello\"); // 堆中新对象\nString str3 = \"hello\";          // 指向常量池中的同一对象\n\n// 引用相等比较（内存地址）\nSystem.out.println(str1 == str2); // false（不同对象）\nSystem.out.println(str1 == str3); // true（同一对象）\n\n// 对象相等比较（内容）\nSystem.out.println(str1.equals(str2)); // true（内容相同）\nSystem.out.println(str1.equals(str3)); // true（内容相同）\n```\n\n## [如果一个类没有声明构造方法，程序能正确执行吗？](#如果一个类没有声明构造方法-该程序能正确执行吗)\n**默认构造方法**：\n   - 若类未显式定义任何构造方法，Java会自动生成一个**无参默认构造方法**。\n   - 若类显式定义了构造方法（无论是否有参数），Java不再生成默认构造方法。\n## [构造方法的特点与重写问题](#构造方法有哪些特点-是否可被-override)\n\n| **特性**            | **说明**                                                                 |\n|---------------------|--------------------------------------------------------------------------|\n| **名称与类名相同**  | 构造方法必须与类名完全一致（区分大小写）。                               |\n| **无返回值声明**    | 无返回类型（包括`void`）。                                              |\n| **自动执行**        | 创建对象时自动调用，无法手动调用。                                       |\n\n| **操作** | **是否支持** | **示例**                                      |\n| ------ | -------- | ------------------------------------------- |\n| **重载** | ✅ 支持     | 同一类中定义多个参数列表不同的构造方法。                        |\n| **重写** | ❌ 不支持    | 构造方法不能被继承，因此子类无法重写父类构造方法。子类需通过super调用父类构造方法 |\n```java\npublic class Animal {\n    // 无参构造方法（可被重载）\n    public Animal() {}\n\n    // 重载构造方法（参数不同）\n    public Animal(String name) {\n        System.out.println(\"动物名称：\" + name);\n    }\n}\n\npublic class Dog extends Animal {\n    // 子类构造方法默认调用父类无参构造方法\n    public Dog() {\n        super(); // 隐式调用\n    }\n\n    // 显式调用父类有参构造方法\n    public Dog(String name) {\n        super(name); // 必须通过super调用\n    }\n}\n```\n## 三大特征\n#### [封装](#封装)\n\n封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。\n\n```\npublic class Student {\n    private int id;//id属性私有化\n    private String name;//name属性私有化\n\n    //获取id的方法\n    public int getId() {\n        return id;\n    }\n\n    //设置id的方法\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    //获取name的方法\n    public String getName() {\n        return name;\n    }\n\n    //设置name的方法\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n#### [继承](#继承)\n\n不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。\n\n**关于继承如下 3 点请记住：**\n\n1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3. 子类可以用自己的方式实现父类的方法。（以后介绍）。\n\n#### [多态](#多态)\n多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。\n\n**多态的特点:**\n\n- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；\n- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；\n- 多态不能调用“只在子类存在但在父类不存在”的方法；\n- 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。\n\n### [接口和抽象类有什么共同点和区别？](#接口和抽象类有什么共同点和区别)\n\n#### [接口和抽象类的共同点](#接口和抽象类的共同点)\n\n- **实例化**：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。\n- **抽象方法**：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。\n\n#### [接口和抽象类的区别](#接口和抽象类的区别)\n- **设计目的**：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。\n- **继承和实现**：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。\n- **成员变量**：接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（`private`, `protected`, `public`），可以在子类中被重新定义或赋值。\n- **方法**：\n    - Java 8 之前，接口中的方法默认是 `public abstract` ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 `default`（默认） 方法和 `static` （静态）方法。 自 Java 9 起，接口可以包含 `private` 方法。\n    - 抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。\n\n在 Java 8 及以上版本中，接口引入了新的方法类型：`default` 方法、`static` 方法和 `private` 方法。这些方法让接口的使用更加灵活。\n\nJava 8 引入的`default` 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。\n```\npublic interface MyInterface {\n    default void defaultMethod() {\n        System.out.println(\"This is a default method.\");\n    }\n}\n```\n\nJava 8 引入的`static` 方法无法在实现类中被覆盖，只能通过接口名直接调用（ `MyInterface.staticMethod()`），类似于类中的静态方法。`static` 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。\n\n```\npublic interface MyInterface {\n    static void staticMethod() {\n        System.out.println(\"This is a static method in the interface.\");\n    }\n}\n```\n\nJava 9 允许在接口中使用 `private` 方法。`private`方法可以用于在接口内部共享代码，不对外暴露。\npublic interface MyInterface {\n    // default 方法\n    default void defaultMethod() {\n        commonMethod();\n    }\n\n    // static 方法\n    static void staticMethod() {\n        commonMethod();\n    }\n\n    // 私有静态方法，可以被 static 和 default 方法调用\n    private static void commonMethod() {\n        System.out.println(\"This is a private method used internally.\");\n    }\n\n      // 实例私有方法，只能被 default 方法调用。\n    private void instanceCommonMethod() {\n        System.out.println(\"This is a private instance method used internally.\");\n    }\n}\n\n\n### [深拷贝和浅拷贝区别了解吗？什么是引用拷贝？](#深拷贝和浅拷贝区别了解吗-什么是引用拷贝)\n\n关于深拷贝和浅拷贝区别，我这里先给结论：\n\n- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。\n\n上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！\n\n#### [浅拷贝](#浅拷贝)\n\n浅拷贝的示例代码如下，我们这里实现了 `Cloneable` 接口，并重写了 `clone()` 方法。\n\n`clone()` 方法的实现很简单，直接调用的是父类 `Object` 的 `clone()` 方法。\npublic class Address implements Cloneable{\n    private String name;\n    // 省略构造函数、Getter&Setter方法\n    @Override\n    public Address clone() {\n        try {\n            return (Address) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n\npublic class Person implements Cloneable {\n    private Address address;\n    // 省略构造函数、Getter&Setter方法\n    @Override\n    public Person clone() {\n        try {\n            Person person = (Person) super.clone();\n            return person;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n测试：\n\n```\nPerson person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// true\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n```\n\n从输出结构就可以看出， `person1` 的克隆对象和 `person1` 使用的仍然是同一个 `Address` 对象。\n\n#### [深拷贝](#深拷贝)\n\n这里我们简单对 `Person` 类的 `clone()` 方法进行修改，连带着要把 `Person` 对象内部的 `Address` 对象一起复制。\n```\n@Override\npublic Person clone() {\n    try {\n        Person person = (Person) super.clone();\n        person.setAddress(person.getAddress().clone());\n        return person;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n    }\n}\n```\n\n测试：\n\n```\nPerson person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// false\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n```\n\n从输出结构就可以看出，显然 `person1` 的克隆对象和 `person1` 包含的 `Address` 对象已经是不同的了。\n\n**那什么是引用拷贝呢？** 简单来说，引用拷贝就是两个不同的引用指向同一个对象。\n\n我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：\n![Pasted image 20250310210416](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310210416.png)\n---\n\n## Object\n### [Object 类的常见方法有哪些？](https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B)\n\nObject 类是一个特殊的类，是所有类的父类，主要提供了以下 11 个方法：\n/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class< ?> getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable { }\n\n\n### [== 和 equals() 的区别](#和-equals-的区别)\n\n**`==`** 对于基本类型和引用类型的作用效果是不同的：\n\n- 对于基本数据类型来说，`==` 比较的是值。\n- 对于引用数据类型来说，`==` 比较的是对象的内存地址。\n\n> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。\n\n**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。\n\n`Object` 类 `equals()` 方法：\n\n```\npublic boolean equals(Object obj) {\n     return (this == obj);\n}\n```\n\n`equals()` 方法存在两种使用情况：\n\n- **类没有重写 `equals()`方法**：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。\n- **类重写了 `equals()`方法**：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。\n\n举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 `==` 换成 `equals()` ）：\n```\nString a = new String(\"ab\"); // a 为一个引用\nString b = new String(\"ab\"); // b为另一个引用,对象的内容一样\nString aa = \"ab\"; // 放在常量池中\nString bb = \"ab\"; // 从常量池中查找\nSystem.out.println(aa == bb);// true\nSystem.out.println(a == b);// false\nSystem.out.println(a.equals(b));// true\nSystem.out.println(42 == 42.0);// true\n```\n\n`String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。\n\n当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。\n\n`String`类`equals()`方法：\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n\n### [hashCode() 有什么用？](#hashcode-有什么用)\n\n`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。\n\n![hashCode() 方法](https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png)\n\n`hashCode()` 定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n\n> ⚠️ 注意：该方法在 **Oracle OpenJDK8** 中默认是 \"使用线程局部状态来实现 Marsaglia's xor-shift 随机数生成\", 并不是 \"地址\" 或者 \"地址转换而来\", 不同 JDK/VM 可能不同。在 **Oracle OpenJDK8** 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。参考源码:\n>\n>```\npublic native int hashCode();\n\n散列表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）**\n\n### [为什么要有 hashCode？](#为什么要有-hashcode)\n\n我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 `hashCode`？\n> 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。\n\n其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。\n\n**那为什么 JDK 还要同时提供这两个方法呢？**\n这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！\n\n我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。\n\n**那为什么不只提供 `hashCode()` 方法呢？**\n\n这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。\n\n**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**\n\n因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。\n\n---总结下来就是：\n\n- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。\n- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。\n- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。\n\n相信大家看了我前面对 `hashCode()` 和 `equals()` 的介绍之后，下面这个问题已经难不倒你们了。\n\n### [为什么重写 equals() 时必须重写 hashCode() 方法？](#为什么重写-equals-时必须重写-hashcode-方法)\n因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。\n\n如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。\n\n**思考**：重写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现什么问题。\n\n**总结**：\n\n- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。\n- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。\n## [String](#string)\n\n### [String、StringBuffer、StringBuilder 的区别？](#string、stringbuffer、stringbuilder-的区别)\n\n**可变性**\n\n`String` 是不可变的（后面会详细分析原因）。\n\n`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n    //...\n}\n**线程安全性**\n\n`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。\n\n**性能**\n\n每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n**对于三者使用的总结：**\n\n- 操作少量的数据: 适用 `String`\n- 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`\n- 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`\n\n### [String 为什么是不可变的?](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84)\n`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，~~所以`String` 对象是不可变的。~~\n\n```\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    private final char value[];\n  //...\n}\n```\n\n> 🐛 修正：我们知道被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，`final` 关键字修饰的数组保存字符串并不是 `String` 不可变的根本原因，因为这个数组保存的字符串是可变的（`final` 修饰引用类型变量的情况）。\n>\n> `String` 真正不可变有下面几点原因：\n>\n> 1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。\n> 2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。\n>\n> 相关阅读：[如何理解 String 类型值的不可变？ - 知乎提问](https://www.zhihu.com/question/20618891/answer/114125846)\n>\n> 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。\n>\n> ```\n> public final class String implements java.io.Serializable,Comparable<String>, CharSequence {\n>     // @Stable 注解表示变量最多被修改一次，称为“稳定的”。\n>     @Stable\n>     private final byte[] value;\n> }\n>\n> abstract class AbstractStringBuilder implements Appendable, CharSequence {\n>     byte[] value;\n>\n> }\n> ```\n>\n> **Java 9 为何要将 `String` 的底层实现由 `char[]` 改成了 `byte[]` ?**\n>\n> 新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。\n>\n> JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。\n>\n> ![](https://oss.javaguide.cn/github/javaguide/jdk9-string-latin1.png)\n>\n> 如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，`byte` 和 `char` 所占用的空间是一样的。\n>\n> 这是官方的介绍：[https://openjdk.java.net/jeps/254](https://openjdk.java.net/jeps/254) 。\n\n### [字符串拼接用“+” 还是 StringBuilder?](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder)\n\nJava 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。\n\n```\nString str1 = \"he\";\nString str2 = \"llo\";\nString str3 = \"world\";\nString str4 = str1 + str2 + str3;\n```\n\n上面的代码对应的字节码如下：\n\n![](https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png)\n\n可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。\n\n不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。\n\n```\nString[] arr = {\"he\", \"llo\", \"world\"};\nString s = \"\";\nfor (int i = 0; i < arr.length; i++) {\n    s += arr[i];\n}\nSystem.out.println(s);\n```\n\n`StringBuilder` 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 `StringBuilder` 对象。\n\n![](https://oss.javaguide.cn/github/javaguide/java/image-20220422161320823.png)\n\n如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。\n\n```\nString[] arr = {\"he\", \"llo\", \"world\"};\nStringBuilder s = new StringBuilder();\nfor (String value : arr) {\n    s.append(value);\n}\nSystem.out.println(s);\n```\n\n![](https://oss.javaguide.cn/github/javaguide/java/image-20220422162327415.png)\n\n如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。\n\n在 JDK 9 中，字符串相加“+”改为用动态方法 `makeConcatWithConstants()` 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： `a+b+c` 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。这个改进是 JDK9 的 [JEP 280](https://openjdk.org/jeps/280) 提出的，关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 [StringBuilder？来重温一下字符串拼接吧](https://juejin.cn/post/7182872058743750715) 以及参考 [issue#2442](https://github.com/Snailclimb/JavaGuide/issues/2442)。\n\n### [String#equals() 和 Object#equals() 有何区别？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-equals-%E5%92%8C-object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB)\n\n`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。\n\n### [字符串常量池的作用了解吗？](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97)\n\n**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n\n```\n// 在字符串常量池中创建字符串对象 ”ab“\n// 将字符串对象 ”ab“ 的引用赋值给 aa\nString aa = \"ab\";\n// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb\nString bb = \"ab\";\nSystem.out.println(aa==bb); // true\n```\n\n更多关于字符串常量池的介绍可以看一下 [Java 内存区域详解](https://javaguide.cn/java/jvm/memory-area.html) 这篇文章。\n\n### [String s1 = new String(\"abc\");这句话创建了几个字符串对象？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-s1-new-string-abc-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1)\n\n先说答案：会创建 1 或 2 个字符串对象。\n\n1. 字符串常量池中不存在 \"abc\"：会创建 2 个 字符串对象。一个在字符串常量池中，由 `ldc` 指令触发创建。一个在堆中，由 `new String()` 创建，并使用常量池中的 \"abc\" 进行初始化。\n2. 字符串常量池中已存在 \"abc\"：会创建 1 个 字符串对象。该对象在堆中，由 `new String()` 创建，并使用常量池中的 \"abc\" 进行初始化。\n\n下面开始详细分析。\n\n1、如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 \"abc\"，然后在堆内存中再创建其中一个字符串对象 \"abc\"。\n\n示例代码（JDK 1.8）：\n\n```\nString s1 = new String(\"abc\");\n```\n\n对应的字节码：\n\n```\n// 在堆内存中分配一个尚未初始化的 String 对象。\n// #2 是常量池中的一个符号引用，指向 java/lang/String 类。\n// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。\n0 new #2 <java/lang/String>\n// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。\n// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。\n3 dup\n// JVM 先检查字符串常量池中是否存在 \"abc\"。\n// 如果常量池中已存在 \"abc\"，则直接返回该字符串的引用；\n// 如果常量池中不存在 \"abc\"，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。\n// 这个引用被压入操作数栈，用作构造函数的参数。\n4 ldc #3 <abc>\n// 调用构造方法，使用从常量池中加载的 \"abc\" 初始化堆中的 String 对象\n// 新的 String 对象将包含与常量池中的 \"abc\" 相同的内容，但它是一个独立的对象，存储于堆中。\n6 invokespecial #4 <java/lang/String.<init> : (Ljava/lang/String;)V>\n// 将堆中的 String 对象引用存储到局部变量表\n9 astore_1\n// 返回，结束方法\n10 return\n```\n\n`ldc (load constant)` 指令的确是从常量池中加载各种类型的常量，包括字符串常量、整数常量、浮点数常量，甚至类引用等。对于字符串常量，`ldc` 指令的行为如下：\n\n1. **从常量池加载字符串**：`ldc` 首先检查字符串常量池中是否已经有内容相同的字符串对象。\n2. **复用已有字符串对象**：如果字符串常量池中已经存在内容相同的字符串对象，`ldc` 会将该对象的引用加载到操作数栈上。\n3. **没有则创建新对象并加入常量池**：如果字符串常量池中没有相同内容的字符串对象，JVM 会在常量池中创建一个新的字符串对象，并将其引用加载到操作数栈中。\n\n2、如果字符串常量池中已存在字符串对象“abc”，则只会在堆中创建 1 个字符串对象“abc”。\n\n示例代码（JDK 1.8）：\n\n```\n// 字符串常量池中已存在字符串对象“abc”\nString s1 = \"abc\";\n// 下面这段代码只会在堆中创建 1 个字符串对象“abc”\nString s2 = new String(\"abc\");\n```\n\n对应的字节码：\n\n```\n0 ldc #2 <abc>\n2 astore_1\n3 new #3 <java/lang/String>\n6 dup\n7 ldc #2 <abc>\n9 invokespecial #4 <java/lang/String.<init> : (Ljava/lang/String;)V>\n12 astore_2\n13 return\n```\n\n这里就不对上面的字节码进行详细注释了，7 这个位置的 `ldc` 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 `ldc` 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 `ldc` 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。\n\n### [String#intern 方法有什么作用?](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8)\n\n`String.intern()` 是一个 `native` (本地) 方法，用来处理字符串常量池中的字符串对象引用。它的工作流程可以概括为以下两种情况：\n\n1. **常量池中已有相同内容的字符串对象**：如果字符串常量池中已经有一个与调用 `intern()` 方法的字符串内容相同的 `String` 对象，`intern()` 方法会直接返回常量池中该对象的引用。\n2. **常量池中没有相同内容的字符串对象**：如果字符串常量池中还没有一个与调用 `intern()` 方法的字符串内容相同的对象，`intern()` 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。\n\n总结：\n\n- `intern()` 方法的主要作用是确保字符串引用在常量池中的唯一性。\n- 当调用 `intern()` 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。\n\n示例代码（JDK 1.8） :\n\n```\n// s1 指向字符串常量池中的 \"Java\" 对象\nString s1 = \"Java\";\n// s2 也指向字符串常量池中的 \"Java\" 对象，和 s1 是同一个对象\nString s2 = s1.intern();\n// 在堆中创建一个新的 \"Java\" 对象，s3 指向它\nString s3 = new String(\"Java\");\n// s4 指向字符串常量池中的 \"Java\" 对象，和 s1 是同一个对象\nString s4 = s3.intern();\n// s1 和 s2 指向的是同一个常量池中的对象\nSystem.out.println(s1 == s2); // true\n// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同\nSystem.out.println(s3 == s4); // false\n// s1 和 s4 都指向常量池中的同一个对象\nSystem.out.println(s1 == s4); // true\n```\n\n### [String 类型的变量和常量做“+”运算时发生了什么？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A-%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)\n\n先来看字符串不加 `final` 关键字拼接的情况（JDK1.8）：\n\n```\nString str1 = \"str\";\nString str2 = \"ing\";\nString str3 = \"str\" + \"ing\";\nString str4 = str1 + str2;\nString str5 = \"string\";\nSystem.out.println(str3 == str4);//false\nSystem.out.println(str3 == str5);//true\nSystem.out.println(str4 == str5);//false\n```\n\n> **注意**：比较 String 字符串的值是否相等，可以使用 `equals()` 方法。 `String` 中的 `equals` 方法是被重写过的。 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是字符串的值是否相等。如果你使用 `==` 比较两个字符串是否相等的话，IDEA 还是提示你使用 `equals()` 方法替换。\n\n![](https://oss.javaguide.cn/java-guide-blog/image-20210817123252441.png)\n\n**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**\n\n在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：\n\n![](https://oss.javaguide.cn/javaguide/image-20210817142715396.png)\n\n常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。\n\n对于 `String str3 = \"str\" + \"ing\";` 编译器会给你优化成 `String str3 = \"string\";` 。\n\n并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：\n\n- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。\n- `final` 修饰的基本数据类型和字符串变量\n- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）\n\n**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**\n\n对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。\n\n```\nString str4 = new StringBuilder().append(str1).append(str2).toString();\n```\n\n我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。\n\n不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。\n\n示例代码：\n\n```\nfinal String str1 = \"str\";\nfinal String str2 = \"ing\";\n// 下面两个表达式其实是等价的\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 常量池中的对象\nSystem.out.println(c == d);// true\n```\n\n被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。\n\n如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。\n\n示例代码（`str2` 在运行时才能确定其值）：\n\n```\nfinal String str1 = \"str\";\nfinal String str2 = getStr();\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 在堆上创建的新的对象\nSystem.out.println(c == d);// false\npublic static String getStr() {\n      return \"ing\";\n}\n```","tags":["java"],"categories":["八股"]},{"title":"数据结构","url":"/2025/03/12/数据结构/","content":"\n数据的==逻辑==结构是指==数据元素之间==的逻辑关系，它与所使用的计算机无关。\n\n数据的==物理==结构，又称==存储结构==，是指数据结构在计算机中的表示，它包括数据元素的表示和元素的表示，其中数据元素之间的关系在计算机中有**顺序**存储结构和**链式**存储结构两种。\n\n==逻辑结构==\n集合，线性，树，图\n- 线性结构：线性表，栈，队列，串\n- 非线性结构：树，图\n\n物理结构(存储结构)\n- 顺序\n- 链式\n- 索引\n- 散列(Has存储)\n\n运算的定义针对:逻辑结构\n运算的实现针对:存储结构\n\n==数据>数据元素>数据项==\n\n算法特性(必须全具备)\n- 有穷性：算法必须有穷，程序可以无穷\n- 确定性\n- 可行性\n- 输入\n- 输出\n\n# 复杂度\n\n## **1. 线性查找时间复杂度**\n- **最坏情况**：目标元素在最后一个位置，需遍历整个链表，时间复杂度为 **O(n)**。\n- **平均情况**：假设目标元素在各位置概率相等，平均比较次数为 **(n+1)/2**，时间复杂度 **O(n)**\n## **2. 单循环链表的头尾访问**\n- **带尾指针的单循环链表**：\n  - 找表头结点：通过尾指针的 `next` 直接访问，时间复杂度 **O(1)**。\n  - 找表尾结点：直接访问尾指针，时间复杂度 **O(1)**。\n- **带头结点的单循环链表**：\n  - 找表头结点：直接访问头结点，时间复杂度 **O(1)**。\n  - 找表尾结点：需从头遍历到尾，时间复杂度 **O(n)**。\n## **3. 链表合并的时间复杂度**\n- **将长度为 n 的单链表链接到长度为 m 的单链表之后**：\n  - 需要找到链表 m 的尾节点（耗时 **O(m)**），然后修改其 `next` 指针指向链表 n 的头节点（耗时 **O(1)**）。\n  - 总时间复杂度为 **O(m)**。\n## **4. 插入操作的时间复杂度**\n- **数组的插入操作**（假设在位置 i 插入元素）：\n  - **移动次数**：需将第 i 个位置后的所有元素后移，共移动 **n - i** 次。\n  - **总移动次数**：插入所有可能位置（共 **n+1** 种）的移动次数总和为  **(n+1)/2**\n  - **平均移动次数**：n/2，时间复杂度 **O(n)**。\n- **链表的插入操作**（假设已知插入位置的前驱节点）：\n  - 仅需修改指针，时间复杂度 **O(1)**。\n  - 若需遍历找到插入位置，时间复杂度 **O(n)**。\n## **5. 删除操作的时间复杂度**\n- **数组的删除操作**（假设删除位置 i 的元素）：\n  - **移动次数**：需将第 i 个位置后的所有元素前移，共移动 **n - i - 1** 次。\n  - **总移动次数**：删除所有可能位置（共 **n** 种）的移动次数总和为  **n(n-1)/2**\n  - **平均移动次数**： **(n-1)/2**，时间复杂度 **O(n)**。\n- **链表的删除操作**（假设已知删除节点的前驱节点）：\n  - 仅需修改指针，时间复杂度 **O(1)**。\n  - 若需遍历找到删除节点，时间复杂度 **O(n)**。\n1. **链表与数组的差异**：\n   - **链表**的插入和删除操作时间复杂度取决于是否已知操作位置的前驱节点：\n     - 已知前驱节点：**O(1)**。\n     - 需遍历查找位置：**O(n)**。\n   - **数组**的插入和删除操作需移动元素，时间复杂度为 **O(n)**。\n\n| 操作        | 数组（平均 / 最坏）    | 链表（已知前驱节点）     | 链表（需遍历）        |\n| --------- | -------------- | -------------- | -------------- |\n| **插入元素**  | O(n)       | O(1)       | O(n)       |\n| **删除元素**  | O(n)       | O(1)       | O(n)       |\n| **查找元素**  | O(n)       | O(n)       | O(n)       |\n| **访问头节点** | O(1)       | O(1)       | O(1)       |\n| **访问尾节点** | O(1)（有尾指针） | O(1)（带尾指针） | O(n)（无尾指针） |\n\n# 线性表\n顺序存储的物理和逻辑是一一对应的\n链式存储可用于存储线性和非线性的数据结构\n\n```C++\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n#define LIST_INIT_SIZE 10    // 线性表初始容量\n#define LIST_INCREMENT 2     // 容量不足时的增量\n#define OK 1\n#define ERROR 0\n\ntypedef int ElemType;        // 元素类型\ntypedef int Status;          // 操作状态\n\n// 顺序表结构体\ntypedef struct {\n    ElemType* data;         // 存储空间基址\n    int length;             // 当前元素个数\n    int capacity;           // 当前分配的存储容量\n} SqList;\n\n// 初始化顺序表\nStatus InitList(SqList &L) {\n    L.data = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType));\n    if (!L.data) exit(OVERFLOW);\n    L.length = 0;\n    L.capacity = LIST_INIT_SIZE;\n    return OK;\n}\n\n// 销毁顺序表\nStatus DestroyList(SqList &L) {\n    if (L.data) {\n        free(L.data);\n        L.data = NULL;\n    }\n    L.length = 0;\n    L.capacity = 0;\n    return OK;\n}\n\n// 获取指定位置的元素\nStatus GetElem(SqList L, int i, ElemType &e) {\n    if (i < 1 || i > L.length) return ERROR;\n    e = L.data[i - 1];\n    return OK;\n}\n\n// 获取前驱元素\nStatus PriorElem(SqList L, ElemType cur_e, ElemType &pre_e) {\n    for (int i = 1; i < L.length; i++) {\n        if (L.data[i] == cur_e) {\n            pre_e = L.data[i - 1];\n            return OK;\n        }\n    }\n    return ERROR;\n}\n\n// 插入元素\nStatus ListInsert(SqList &L, int i, ElemType e) {\n    if (i < 1 || i > L.length + 1) return ERROR;\n\n    // 扩容处理\n    if (L.length >= L.capacity) {\n        ElemType* newbase = (ElemType*)realloc(L.data,\n            (L.capacity + LIST_INCREMENT) * sizeof(ElemType));\n        if (!newbase) exit(OVERFLOW);\n        L.data = newbase;\n        L.capacity += LIST_INCREMENT;\n    }\n\n    // 插入元素\n    for (int j = L.length; j >= i; j--) {\n        L.data[j] = L.data[j - 1];\n    }\n    L.data[i - 1] = e;\n    L.length++;\n    return OK;\n}\n\n// 删除元素\nStatus ListDelete(SqList &L, int i, ElemType &e) {\n    if (i < 1 || i > L.length) return ERROR;\n    e = L.data[i - 1];\n    for (int j = i; j < L.length; j++) {\n        L.data[j - 1] = L.data[j];\n    }\n    L.length--;\n    return OK;\n}\n\n// 遍历顺序表\nvoid ListTraverse(SqList L, void (*visit)(ElemType)) {\n    for (int i = 0; i < L.length; i++) {\n        visit(L.data[i]);\n    }\n    printf(\"\\n\");\n}\n\n// 合并两个有序顺序表\nStatus MergeSortedLists(SqList La, SqList Lb, SqList &Lc) {\n    // 初始化结果表\n    Lc.capacity = La.length + Lb.length;\n    Lc.data = (ElemType*)malloc(Lc.capacity * sizeof(ElemType));\n    if (!Lc.data) exit(OVERFLOW);\n\n    // 合并操作\n    int i = 0, j = 0, k = 0;\n    while (i < La.length && j < Lb.length) {\n        Lc.data[k++] = (La.data[i] <= Lb.data[j]) ? La.data[i++] : Lb.data[j++];\n    }\n\n    // 处理剩余元素\n    while (i < La.length) Lc.data[k++] = La.data[i++];\n    while (j < Lb.length) Lc.data[k++] = Lb.data[j++];\n\n    Lc.length = k;\n    return OK;\n}\n\nint main() {\n    SqList L;\n    InitList(L);\n\n    // 插入测试\n    for (int i = 1; i <= 5; i++) {\n        ListInsert(L, i, i * 10);\n    }\n    printf(\"插入元素后: \");\n    ListTraverse(L, PrintElement);\n\n    // 删除测试\n    ElemType e;\n    ListDelete(L, 3, e);\n    printf(\"删除第3个元素: %d\\n\", e);\n    printf(\"删除后: \");\n    ListTraverse(L, PrintElement);\n\n    // 合并测试\n    SqList La, Lb, Lc;\n    InitList(La);\n    InitList(Lb);\n\n    for (int i = 1; i <= 5; i++) {\n        ListInsert(La, i, i * 2);\n        ListInsert(Lb, i, i * 3);\n    }\n\n    MergeSortedLists(La, Lb, Lc);\n    printf(\"合并后结果: \");\n    ListTraverse(Lc, PrintElement);\n\n    // 资源清理\n    DestroyList(L);\n    DestroyList(La);\n    DestroyList(Lb);\n    DestroyList(Lc);\n\n    return 0;\n}\n```\n\n## 顺序表的合并\n![Untitled 8 70](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2070.png)\n![Untitled 9 67](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2067.png)\n  ![Untitled 10 63](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2063.png)时间复杂度Q(ListLength(La)+ListLength(Lb))\n  空间复杂度O(1)\n\n\n## 单链表\n```C\ntypedef struct LNode {\nElemType data;\nstruct LNode* next;\n}LNode,*LinkList;\n```\n普通变量是LNode.成员名，指针变量是LinkList->成员名\nLinklist强调单链表，LNode*强调结点\n\n定义链表L：LNode * L == LinkList L(更常用)\n定义结点指针：LNode *p(更常用) == LinkList p\nL->next有两层含义，可以表示L的后继节点指针，又可表示L的指针域（单链表的指针域只有后继指针域，双链表的指针域分为前驱指针域和后继指针域））\np = L就是p = 头结点，p = L->next就是让p = 头结点的后一个节点。\n\n头指针：是指向链表第一个结点的指针\n首元结点：是指向链表中存储第一个数据元素a1的结点\n头结点：是在链表的首元结点之前附设的一个结点。链表中的头结点仅起到标识的作用。\n![5e68616c9b390b7ef84a08401462f0d](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/5e68616c9b390b7ef84a08401462f0d.jpg)\n带==头结点==的好处：\n1. 便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。\n2. 便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此统一。\n3. 头结点的指针域可以为空，可以存放长度等，但==不计入链表的长度值==。\n\n表示空表\n- 无头结点：头指针为空\n- 有头结点：头结点的指针域为空\n\n链表特点：\n- 结点在存储器中位置任意\n- 只能通过头指针进入链表，顺序扫描。寻找第一个结点很容易。==顺序表是随机存储法==\n- 结点空间可以动态申请和释放\n- 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素\n- 缺点：存储密度小，利用率小，每个结点的指针域额外占用存储空间\n- 静态链表中的指针表示的是数组下标\n\n## 头插（逆序）\n带头结点\n![7ae0a7bd64d74b5d9a149f7849e38f93](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7ae0a7bd64d74b5d9a149f7849e38f93.gif)\n不带头结点\n![e062fe1ed673468681ecce4d84a865ae](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/e062fe1ed673468681ecce4d84a865ae.gif)\n## 尾插\n![Untitled 7 75|Untitled 7 75.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2075.png)\n![IMG_20231010_091813](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/IMG_20231010_091813.jpg)\n带头结点\n![f47832ac0b274b19b1fb2e5ba8d5fcb9](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/f47832ac0b274b19b1fb2e5ba8d5fcb9.gif)\n不带头结点同上\n\n\n![a9b4f515e81d49d9abbc6456ff2bb60e](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a9b4f515e81d49d9abbc6456ff2bb60e.jpg)\n\n## 带头结点的单链表\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int ElemType;\ntypedef int Status;\n#define OK 1\n#define ERROR 0\n\n// 链表节点结构\ntypedef struct LNode {\n    ElemType data;\n    struct LNode *next;\n} LNode, *LinkList;\n\n// 初始化带头结点的链表\nStatus InitList(LinkList &L) {\n    L = (LNode*)malloc(sizeof(LNode));  // 创建头结点\n    if (!L) return ERROR;\n    L->next = NULL;\n    return OK;\n}\n\n// 头插法建立链表\nvoid CreateList_H(LinkList &L, int n) {\n    L = (LNode*)malloc(sizeof(LNode));\n    L->next = NULL;\n\n    for(int i=0; i<n; i++) {\n        LNode *p = (LNode*)malloc(sizeof(LNode));\n        p->data = i*2;  // 测试数据\n        p->next = L->next;\n        L->next = p;\n    }\n}\n\n// 尾插法建立链表\nvoid CreateList_T(LinkList &L, int n) {\n    L = (LNode*)malloc(sizeof(LNode));\n    LNode *tail = L;\n\n    for(int i=0; i<n; i++) {\n        LNode *p = (LNode*)malloc(sizeof(LNode));\n        p->data = i*3;  // 测试数据\n        tail->next = p;\n        tail = p;\n    }\n    tail->next = NULL;\n}\n\n// 按位置插入\nStatus ListInsert(LinkList &L, int i, ElemType e) {\n    LNode *p = L;\n    int j = 0;\n\n    while(p && j<i-1) {  // 找到第i-1个结点\n        p = p->next;\n        j++;\n    }\n\n    if(!p || j>i-1) return ERROR;\n\n    LNode *s = (LNode*)malloc(sizeof(LNode));\n    s->data = e;\n    s->next = p->next;\n    p->next = s;\n    return OK;\n}\n\n// 按位置删除\nStatus ListDelete(LinkList &L, int i, ElemType &e) {\n    LNode *p = L;\n    int j = 0;\n\n    while(p->next && j<i-1) {\n        p = p->next;\n        j++;\n    }\n\n    if(!(p->next) || j>i-1) return ERROR;\n\n    LNode *q = p->next;\n    e = q->data;\n    p->next = q->next;\n    free(q);\n    return OK;\n}\n\n// 遍历链表\nvoid ListTraverse(LinkList L) {\n    LNode *p = L->next;\n    while(p) {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\n// 销毁链表\nvoid DestroyList(LinkList &L) {\n    LNode *p;\n    while(L) {\n        p = L;\n        L = L->next;\n        free(p);\n    }\n}\n```\n\n## 不带头结点的单链表\n```c\ntypedef struct Node {\n    ElemType data;\n    struct Node *next;\n} Node, *NoHeadList;\n\n// 初始化不带头结点的链表\nStatus InitList(NoHeadList &L) {\n    L = NULL;\n    return OK;\n}\n\n// 头插法建立链表\nvoid CreateList_H(NoHeadList &L, int n) {\n    L = NULL;\n    for(int i=0; i<n; i++) {\n        Node *p = (Node*)malloc(sizeof(Node));\n        p->data = i*2;\n        p->next = L;\n        L = p;\n    }\n}\n\n// 尾插法建立链表\nvoid CreateList_T(NoHeadList &L, int n) {\n    Node *tail = NULL;\n    L = NULL;\n\n    for(int i=0; i<n; i++) {\n        Node *p = (Node*)malloc(sizeof(Node));\n        p->data = i*3;\n        p->next = NULL;\n\n        if(!L) {\n            L = p;\n        } else {\n            tail->next = p;\n        }\n        tail = p;\n    }\n}\n\n// 按位置插入\nStatus ListInsert(NoHeadList &L, int i, ElemType e) {\n    if(i < 1) return ERROR;\n\n    if(i == 1) {  // 特殊处理第一个结点\n        Node *s = (Node*)malloc(sizeof(Node));\n        s->data = e;\n        s->next = L;\n        L = s;\n        return OK;\n    }\n\n    Node *p = L;\n    int j = 1;\n\n    while(p && j < i-1) {\n        p = p->next;\n        j++;\n    }\n\n    if(!p || j > i-1) return ERROR;\n\n    Node *s = (Node*)malloc(sizeof(Node));\n    s->data = e;\n    s->next = p->next;\n    p->next = s;\n    return OK;\n}\n\n// 按位置删除\nStatus ListDelete(NoHeadList &L, int i, ElemType &e) {\n    if(i < 1 || !L) return ERROR;\n\n    if(i == 1) {  // 特殊处理第一个结点\n        Node *q = L;\n        e = q->data;\n        L = L->next;\n        free(q);\n        return OK;\n    }\n\n    Node *p = L;\n    int j = 1;\n\n    while(p->next && j < i-1) {\n        p = p->next;\n        j++;\n    }\n\n    if(!(p->next) || j > i-1) return ERROR;\n\n    Node *q = p->next;\n    e = q->data;\n    p->next = q->next;\n    free(q);\n    return OK;\n}\n\n// 遍历链表\nvoid ListTraverse(NoHeadList L) {\n    Node *p = L;\n    while(p) {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\n// 销毁链表\nvoid DestroyList(NoHeadList &L) {\n    Node *p;\n    while(L) {\n        p = L;\n        L = L->next;\n        free(p);\n    }\n}\n```\n**为什么不是 `free(*r)`？**\n- `free()` 的参数必须是一个指针，指向动态分配的内存块的起始地址。\n- 如果 `r` 是一个指针变量（例如 `int* r`），则 `free(r)` 是正确的用法，因为 `r` 本身就是一个指针。\n- 如果 `r` 是一个指向指针的指针（例如 `int** r`），则 `free(*r)` 是正确的用法，因为 `*r` 是一个指针，指向动态分配的内存块\n## 代码思路整理\n\n## 1. 结构差异对比\n| 特性         | 带头结点                    | 不带头结点             |\n| - | -- | -- |\n| 初始化        | 需要创建头结点，头指针指向头结点        | 直接置空指针            |\n| 首元结点处理     | 统一通过头结点的 next 指针访问      | 直接通过头指针访问         |\n| 空表判断       | L->next == NULL         | L == NULL         |\n| 插入 / 删除首结点 | 不需要特殊处理                 | 需要单独处理头指针变化       |\n| 算法复杂度      | 各操作时间复杂度 O (n)，但边界处理更简单 | 时间复杂度相同，但需要更多条件判断 |\n\n## 2. 关键实现要点\n- **头插法**：新结点始终插入到链表头部\n- **尾插法**：需要维护尾指针以提高效率\n- **位置索引**：统一采用1-based索引\n- **内存管理**：每次操作后及时释放内存\n- **错误处理**：对非法位置进行有效性检查\n\n## 3. 推荐使用场景\n- **带头结点**：适合需要频繁进行首结点操作的场景\n- **不带头结点**：适合内存敏感或需要直接操作首结点的场景\n\n## 双链表\n在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了由两个方向不同的链，表头结点的prior指向NULL，表尾结点的next指向NULL\n```c\ntypedef struct DNode {\n    int data;               // 数据域\n    struct DNode *prior;    // 前驱指针\n    struct DNode *next;     // 后继指针\n} DNode, *DLinkList;\n```\n## **初始化双链表**\n```c\nvoid InitDLinkList(DLinkList &L) {\n    L = (DNode *)malloc(sizeof(DNode));  // 创建头结点\n    if (!L) exit(OVERFLOW);\n    L->prior = NULL;\n    L->next = NULL;\n}\n```\n## **插入操作（在节点 p 后插入节点 s）**\n```c\nvoid InsertAfterDNode(DNode *p, DNode *s) {\n    if (!p || !s) return;  // 检查参数合法性\n\n    s->next = p->next;     // 1. s 的后继指向 p 的后继\n    if (p->next)           // 如果 p 不是最后一个节点\n        p->next->prior = s; // 2. p 的后继的前驱指向 s\n    s->prior = p;          // 3. s 的前驱指向 p\n    p->next = s;           // 4. p 的后继指向 s\n}\n```\n## **删除操作（删除节点 p 的后继节点）**\n```c\nvoid DeleteAfterDNode(DNode *p) {\n    if (!p || !p->next) return;  // 检查参数合法性\n\n    DNode *q = p->next;  // q 指向待删除节点\n    p->next = q->next;   // 1. p 的后继指向 q 的后继\n    if (q->next)         // 如果 q 不是最后一个节点\n        q->next->prior = p; // 2. q 的后继的前驱指向 p\n    free(q);             // 3. 释放 q 的内存\n}\n```\n\n\n## 循环双链表\n表头结点的prior指向表尾结点，表尾结点的next指向头结点\n![Untitled 1 129](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20129.png)\n对称性：p→prior→next = p = p→next→prior\n```c\ntypedef struct CDNode {\n    int data;               // 数据域\n    struct CDNode *prior;   // 前驱指针\n    struct CDNode *next;    // 后继指针\n} CDNode, *CDLinkList;\n```\n## **初始化循环双链表**\n```c\nvoid InitCDLinkList(CDLinkList &L) {\n    L = (CDNode *)malloc(sizeof(CDNode));  // 创建头结点\n    if (!L) exit(OVERFLOW);\n    L->prior = L;  // 头结点的前驱指向自己\n    L->next = L;   // 头结点的后继指向自己\n}\n```\n## **插入操作（在节点 p 后插入节点 s）**\n```c\nvoid InsertAfterCDNode(CDNode *p, CDNode *s) {\n    if (!p || !s) return;  // 检查参数合法性\n\n    s->next = p->next;     // 1. s 的后继指向 p 的后继\n    s->prior = p;          // 2. s 的前驱指向 p\n    p->next->prior = s;    // 3. p 的后继的前驱指向 s\n    p->next = s;           // 4. p 的后继指向 s\n}\n```\n## **删除操作（删除节点 p 的后继节点）**\n```c\nvoid DeleteAfterCDNode(CDNode *p) {\n    if (!p || p->next == p) return;  // 检查参数合法性（空表或只有头结点）\n\n    CDNode *q = p->next;  // q 指向待删除节点\n    p->next = q->next;    // 1. p 的后继指向 q 的后继\n    q->next->prior = p;   // 2. q 的后继的前驱指向 p\n    free(q);              // 3. 释放 q 的内存\n}\n```\n![Pasted image 20250306144931](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306144931.jpg)\n1234——s的前驱和后继->pnext的前驱->p的后继\ns->prior=p;\ns->next=p->next;\np->next->perior=s;\np->next=s;\n3214——pnext的前驱->s的后继->s的前驱->p的后继\n3241——pnext的前驱->s的后继->p的后继->s的前驱\n![Untitled 3 96](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2096.png)\n不用头指针的原因：由表头找到表尾较费时，删表头O(1)，插表尾O(n)\n让L指向尾指针：都是O(1)\n终止条件：判断是否等于头指针\n单链表：\np≠NULL;\np→next≠NULL;\n单循环链表：\np≠L;\np→next≠L;\n\n带尾指针的循环链表的合并(Tb合并在Ta之后)\n![Untitled 225|Untitled 225.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20225.png)\np存表头结点（p = Ta→next）→Tb表头连接Ta表尾（Ta→next = Tb→next→next）→释放Tb表头结点（delete Tb→next）→修改指针（Tb→next = p）\n## **插入操作（以双链表为例）**\n1. **`s->next = p->next;`**：\n   - 将新节点 `s` 的后继指向 `p` 的后继。\n2. **`if (p->next) p->next->prior = s;`**：\n   - 如果 `p` 不是最后一个节点，将 `p` 的后继的前驱指向 `s`。\n3. **`s->prior = p;`**：\n   - 将新节点 `s` 的前驱指向 `p`。\n4. **`p->next = s;`**：\n   - 将 `p` 的后继指向 `s`。\n\n## **删除操作（以双链表为例）**\n1. **`p->next = q->next;`**：\n   - 将 `p` 的后继指向 `q` 的后继。\n2. **`if (q->next) q->next->prior = p;`**：\n   - 如果 `q` 不是最后一个节点，将 `q` 的后继的前驱指向 `p`。\n3. **`free(q);`**：\n   - 释放 `q` 的内存。\n## **双链表**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define OVERFLOW -1\n\ntypedef struct DNode {\n    int data;\n    struct DNode *prior;\n    struct DNode *next;\n} DNode, *DLinkList;\n\nvoid InitDLinkList(DLinkList &L) {\n    L = (DNode *)malloc(sizeof(DNode));\n    if (!L) exit(OVERFLOW);\n    L->prior = NULL;\n    L->next = NULL;\n}\n\nvoid InsertAfterDNode(DNode *p, DNode *s) {\n    if (!p || !s) return;\n    s->next = p->next;\n    if (p->next) p->next->prior = s;\n    s->prior = p;\n    p->next = s;\n}\n\nvoid DeleteAfterDNode(DNode *p) {\n    if (!p || !p->next) return;\n    DNode *q = p->next;\n    p->next = q->next;\n    if (q->next) q->next->prior = p;\n    free(q);\n}\n\nvoid PrintDLinkList(DLinkList L) {\n    DNode *p = L->next;\n    while (p) {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    DLinkList L;\n    InitDLinkList(L);\n\n    DNode *s1 = (DNode *)malloc(sizeof(DNode));\n    s1->data = 10;\n    InsertAfterDNode(L, s1);\n\n    DNode *s2 = (DNode *)malloc(sizeof(DNode));\n    s2->data = 20;\n    InsertAfterDNode(s1, s2);\n\n    PrintDLinkList(L);  // 输出：10 20\n\n    DeleteAfterDNode(L);\n    PrintDLinkList(L);  // 输出：20\n\n    return 0;\n}\n```\n\n## **循环双链表**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define OVERFLOW -1\n\ntypedef struct CDNode {\n    int data;\n    struct CDNode *prior;\n    struct CDNode *next;\n} CDNode, *CDLinkList;\n\nvoid InitCDLinkList(CDLinkList &L) {\n    L = (CDNode *)malloc(sizeof(CDNode));\n    if (!L) exit(OVERFLOW);\n    L->prior = L;\n    L->next = L;\n}\n\nvoid InsertAfterCDNode(CDNode *p, CDNode *s) {\n    if (!p || !s) return;\n    s->next = p->next;\n    s->prior = p;\n    p->next->prior = s;\n    p->next = s;\n}\n\nvoid DeleteAfterCDNode(CDNode *p) {\n    if (!p || p->next == p) return;\n    CDNode *q = p->next;\n    p->next = q->next;\n    q->next->prior = p;\n    free(q);\n}\n\nvoid PrintCDLinkList(CDLinkList L) {\n    CDNode *p = L->next;\n    while (p != L) {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    CDLinkList L;\n    InitCDLinkList(L);\n\n    CDNode *s1 = (CDNode *)malloc(sizeof(CDNode));\n    s1->data = 10;\n    InsertAfterCDNode(L, s1);\n\n    CDNode *s2 = (CDNode *)malloc(sizeof(CDNode));\n    s2->data = 20;\n    InsertAfterCDNode(s1, s2);\n\n    PrintCDLinkList(L);  // 输出：10 20\n\n    DeleteAfterCDNode(L);\n    PrintCDLinkList(L);  // 输出：20\n\n    return 0;\n}\n```\n\n## 静态链表\n用数组实现的链表结构，它通过数组的下标来模拟链表的指针。静态链表的特点是不需要动态分配内存，而是预先分配一个**固定大小**的数组来存储链表节点。\n静态链表的结构\n- **数组存储**：\n  - 静态链表使用数组来存储节点，每个节点包含两个部分：\n    - **数据域**：存储数据。\n    - **游标（或指针域）**：存储下一个节点的数组下标。\n  - 数组的每个位置可以看作一个节点，游标指向下一个节点的位置。\n\n- **头结点和空闲链表**：\n  - 静态链表通常有一个头结点，用于指向链表的第一个节点。\n  - 空闲链表用于管理未使用的数组位置，方便插入新节点。\n\n为什么不需要移动元素\n## **插入操作**\n- **插入新节点**：\n  - 从空闲链表中获取一个空闲位置（数组下标）。\n  - 修改游标，将新节点插入到链表中。\n  - **不需要移动其他元素**，只需修改游标。\n## **删除操作**\n- **删除节点**：\n  - 将要删除的节点从链表中移除。\n  - 将该节点的位置加入空闲链表。\n  - **不需要移动其他元素**，只需修改游标。\n## **修改游标**\n- 静态链表通过修改游标（数组下标）来维护链表结构，而不是通过移动数据元素。\n- 这种方式类似于动态链表，但使用数组下标代替指针。\n\n **与动态链表的对比**\n\n|**特性**|**动态链表**|**静态链表**|\n|---|---|---|\n|**存储结构**|使用指针连接节点|使用数组下标（游标）连接节点|\n|**内存分配**|动态分配内存|预先分配固定大小的数组|\n|**插入/删除**|修改指针|修改游标|\n|**移动元素**|不需要移动元素|不需要移动元素|\n|**内存管理**|需要动态内存管理|不需要动态内存管理|\n|**适用场景**|数据量不确定，频繁插入删除|数据量固定，内存受限的场景|\n\n```c\n#define MAX_SIZE 100\n\ntypedef struct {\n    int data;  // 数据域\n    int next;  // 游标（下一个节点的下标）\n} Node;\n\nNode staticList[MAX_SIZE];  // 静态链表数组\nint head;                   // 头结点下标\nint freeList;               // 空闲链表头结点下标\n```\n\n## **插入操作**\n```c\nvoid insert(int data) {\n    if (freeList == -1) {\n        printf(\"静态链表已满，无法插入新节点！\\n\");\n        return;\n    }\n\n    // 从空闲链表中获取一个节点\n    int newNodeIndex = freeList;\n    freeList = staticList[freeList].next;\n\n    // 插入新节点\n    staticList[newNodeIndex].data = data;\n    staticList[newNodeIndex].next = staticList[head].next;\n    staticList[head].next = newNodeIndex;\n}\n```\n\n## **删除操作**\n```c\nvoid delete(int data) {\n    int prev = head;\n    int curr = staticList[head].next;\n\n    while (curr != -1) {\n        if (staticList[curr].data == data) {\n            // 从链表中移除节点\n            staticList[prev].next = staticList[curr].next;\n\n            // 将节点加入空闲链表\n            staticList[curr].next = freeList;\n            freeList = curr;\n\n            return;\n        }\n        prev = curr;\n        curr = staticList[curr].next;\n    }\n\n    printf(\"未找到要删除的元素！\\n\");\n}\n```\n- **静态链表不需要移动元素**，因为它通过修改游标（数组下标）来维护链表结构。\n- 插入和删除操作只需修改游标，而不需要移动数据元素。\n- 静态链表适用于内存受限的场景，但灵活性不如动态链表。\n\n\n![Untitled 2 46](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2046.png)\n![Untitled 3 40](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2040.png)\n顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取\n在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂\n双链表中可以快速访问任何一个结点的前驱和后继结点,选项D正确。\n##  错题\n\n^3afb0f\n\n1. ![Pasted image 20250306152709](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png)c\n2. ![Pasted image 20250306152709](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png)c\n3. ![Pasted image 20250306152828](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152828.png)c\n4. ![Pasted image 20250306154314](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306154314.png)d\n5. ![Pasted image 20250306160930](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306160930.png)链式存储设计时，各个不同结点的==存储空间==可以不连续，但结点内的==存储单元地址==必须连续\n6. ![Pasted image 20250306161045](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161045.png)![Pasted image 20250306161310](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161310.png)\n7. ![Pasted image 20250306162035](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162035.png)![Pasted image 20250306162229](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162229.png)\n8. ![Pasted image 20250306163931](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163931.png)设单链表递增有序，首先要在单链表中找到第一个大于x的结点的直接前驱p，在p之后插入该结点。查找的时间复杂度为 O(n)，插入的时间复杂度为 0(1)，总时间复杂度为 O(n)。\n9. ![Pasted image 20250306162259](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162259.png)![Pasted image 20250306162245](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162245.png)\n10. ![Pasted image 20250306162348](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162348.png)b有关因为需要遍历链表找到倒数第二个节点。d无关，因为尾指针 r 直接指向最后一个节点，无需遍历\n11. ![Pasted image 20250306162745](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162745.png)d线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素 a50 不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。\n12. ![Pasted image 20250306163806](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163806.png)改四个指针域，分别是:新结点的前驱指针域，指向第一个结点:新结点的后继指针域，指向第二个结点;第一个结点的后继指针域，指向新结点;第二个结点的前驱指针域，指向新结点。\n13. ![Pasted image 20250306164359](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306164359.png)带头结点的循环单链表工为空表时，满足L->next == L，即头结点的指针域与L的值相等,而不是头结点的指针域与工的地址相等。注意，带头结点的循环单链表中不存在空指针。\n14. ![Pasted image 20250306165707](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306165707.png)a\n15. ![Pasted image 20250306170529](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170529.png)![Pasted image 20250306170531](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170531.png)对于选项 A，删除尾结点* p 时，需要找到* p的前一个结点，时间复杂度为 O(n)。对于选项B，删除首结点* p时，需要找到* p结点,这里没有直接给出头结点指针，而通过尾结点的 prior指针找到* p 结点的时间复杂度为 O(n)。对于选项 D，删除尾结点* p 时，需要找到* p 的前一个结点，时间复杂度为 O(n)。对于C，执行这四种算法的时间复杂度均为 O(1)。\n16. ![Pasted image 20250306171120](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171120.png)在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为 O(1)。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在 0(1)的时间找到尾结点:若只有表头指针，则需要遍历整个链表找到尾结点，时间为0(n)。\n17. ![Pasted image 20250306171301](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171301.png)对一个空循环单链表，有 head->next== head，推理 head->next->next== head->next== head。对含有一个元素的循环单链表，头结点(头指针 head 指示)的 next 域指向这个唯一的元素结点，该元素结点的next 域指向头结点，因此也有 head->next->next=head。\n18. ![Pasted image 20250306171913](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171913.png)对于两种双链表，删除首结点的时间复杂度都是 0(1)。对于非循环双链表，删除尾结点的时间复杂度是 0(m);对于循环双链表，删除尾结点的时间复杂度是0(1)。\n19. ![Pasted image 20250306172027](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172027.png)对于选项 A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为 O(n);而删除第一个元素时，为保持循环单链表的性质(尾结点指向第一个结点)，要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为 O(n)。对于选项 B,双链表的情况与单链表的相同，一个是 O(n),一个是 O(1)。对于选项C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置,时间复杂度为 0(n);删除第一个元素的时间复杂度为 O(1)。对于选项 D，与选项 A 的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为0(1)\n20. ![Pasted image 20250306172625](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172625.png)静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。\n21. ![Pasted image 20250306173426](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306173426.png)静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。并非每个空间都存储了元素，因此会造成存储空间的浪费。\n22. ![Pasted image 20250306174519](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174519.png)![Pasted image 20250306174543](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174543.png)\n23. ![Pasted image 20250306175206](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306175206.png)c\n24. ![Pasted image 20250306191738](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191738.png)![Pasted image 20250306191747](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191747.png)\n25.\n\n# 栈LIFO\n栈和队列都是**操作受限**线性表\n应用：撤销，递归，进制转换，迷宫求解，表达式求值，括号匹配，处理函数或过程调用时的局部变量、返回地址、参数，深度优先遍历DFS\n在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。\n栈只能操作栈顶\n\n## 顺序栈\n在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。\n```C\ntypedef struct{\n\tint data[MaxSize];\n\tint top;\n}SqStack;\n```\n![Pasted image 20250307111852](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307111852.png)栈顶指针：S.top，初始时设置S.top=-1\n栈底 0\n栈顶元素：S.data[S.top]\n入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶 S.data[++S.top] = x\n出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1 x = S.data[S.top--]\n栈空条件：S.top == -1\n栈满条件：S.top== MaxSize-1\n栈长：S.top+1\n另一种常见的方式是：\n初始设置栈顶指针 S.top=0\n入栈时先将值送到栈顶，栈顶指针再加 1\n出栈时，栈顶指针先减1，再取栈顶元素\n栈空条件是 S.top== 0\n栈满条件是S.top== MaxSize.\n顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。\n\n```C\ntypedef struct {\nSElemType* base;\nSElemType* top;\nint stacksize;//最大容量\n}SqStack;\n```\n![Pasted image 20250307121133|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307121133.png)\ntop指示真正栈顶元素之上的下标地址\nstacksize表示栈的最大容量，共stacksize-1个元素\n空栈：base== top\n栈满：top-base== stacksize\n下溢：栈空还要弹出元素，一般当作一种结束条件\n上溢：是错误\n\n3+2的前缀表达形式就是+ 3 2\n3+2的后缀表达形式就是3 2 +\n后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)\n\n## 共享栈\n两个栈共享一个数组空间的好处：存储空间，降低上溢出发生的机率。其存取数据的时间复杂度均为0(1)，所以对存取效率没有什么影响。\n![Pasted image 20250307112107](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112107.png)\n两个栈的栈顶指针都指向栈顶元素\ntop0=-1时0号栈为空，top1=Maxsize 时1号栈头空\n仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满\n当0号栈入栈时 top0 先加再赋值，1号栈入栈时 top1 先减1再赋值，出栈时则刚好相反![Untitled 2 47|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2047.png)\n\n## 链栈\n使用单链表实现，且所有操作都是在表头进行，没有头结点，Lhead指向栈顶元素\n栈顶->栈底\n![Pasted image 20250307112353](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112353.png)\n```C\ntypedef struct {\n\tint data;\n\tstruct LinkNode *next;\n}*LinkNode,LiStack;\n```\n采用链式存储，便于结点的插入与删除\n链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行\n需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同\n有多少种不同的出栈序列\n卡特兰数：\n![Screenshot_2023_1203_103148|90 ](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_1203_103148.png)\n- **时间复杂度**\n    - 链栈和顺序栈的进栈和出栈操作时间复杂度均为 O(1)\n- **空间性能**：\n    - 链栈不需要预先分配固定空间，但每个节点需要额外的指针域。\n    - 顺序栈需要预先分配固定空间，可能导致内存浪费，但存取方便。\n- **选择建议**\n    - 如果栈的长度变化不可预料，建议使用链栈。\n    - 如果栈的长度变化在可控范围内，建议使用顺序栈。\n\n## 错题\n1.![Pasted image 20250307112815](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112815.png)栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同\n2. ![Pasted image 20250307112922](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112922.png)栈和队列都是限制存取点的线性结构\n3. ![Pasted image 20250307113142](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113142.png)顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间\n4. ![Pasted image 20250307113421](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113421.png)对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而循环单链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于选项C，插入和删除结点后，找尾结点所需的时间为 O(n)。\n5. ![Pasted image 20250307114112](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114112.png)第n个元素第一个出栈，说明前n-1个元素都已经按顺序入栈d\n6. ![Pasted image 20250307114354](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114354.png)d\n7. ![Pasted image 20250307114611](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114611.png)p3=1第一个出栈，此时栈内有p1,p2;2第二个出栈，所以2只可能是p2或者p4,p5..;因此选C\n8. 将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-* -g+时,用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空,则转换过程中同时保存在栈中的操作符的最大个数是() A. 5 B. 7 C. 8 D. 11\n   在转换过程中，栈中的操作符最多有5个。这种情况出现在第二个“+”号入栈后，栈中的操作符分别为：“-”，“”，“(”，“(”，“+”。![Pasted image 20250307190631](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190631.png)\n9. ![Pasted image 20250307190913](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190913.png)![Pasted image 20250307190923](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190923.png)\n10.\n\n\n# 队列FIFO\n==头删尾插==\n栈和队列是受限的线性表，它们的共同点是只允许在端点处插入和删除元素。\n栈只允许在一端进行插入、删除操作\n队列只允许在一端进行插入,在另一端进行删除\n应用：缓冲区，层次遍历，CPU资源竞争，广度优先搜索BFS，消息队列\n采用==尾指针==的循环单链表适合作为队列的存储结构\n队列一般情况下需要修改队尾指针，但是当队列为空时需要同时修改头尾指针\n最适合用作链式队列的链表是带有队头指针和队尾指针的非循环单链表\n为了防止队列发生假溢出，应该使用循环队列\n\n![Pasted image 20250307122136|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307122136.png)\n```C++\ntypedef struct {\n\t int data[MaxSize];\n\t int front,rear;\n}SqQueue;\n```\n初始时:Q.front=Q.rear=0。\n入队操作：队不满时，先送值到队尾元素，再将队尾指针加1\n出队操作：队不空时，先取队首元素值，再将队首指针加1\n![Pasted image 20250307123048|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123048.png)\n不能用 Q.rear== Maxsize 作为队列满的条件(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出””，但这种溢出并不是真正的溢出，在 data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。\n## 循环队列\n因为每次入队或者出队都是font或者rear向后移动一位,font指针无法往前移动,此时就会造成删除的空间无法使用，循环队列即可解决问题\n把存储队列元素的表从逻辑上视为一个环,称为循环队列\n当队首指针 Q.front=Maxsize-1后，再前进一个位置就自动到0，这可以利用除法取模运算(%)来实现。\n初始时：Q.front=Q.rear=0。\n队首指针进1：Q.front=(Q.front+1)%Maxsize。\n队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。\n队列长度：(Q.rear+Maxsize-Q.front)%Maxsize。\n出入队时：指针都按顺时针方向进1\n循环队列需要几个参数来确定?以及各个参数的含义？\n需要2个参数,第一个参数是front,第二个参数是rear;\n![Pasted image 20250307123713|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123713.png)\n![Pasted image 20250307124944](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307124944.png)\n队满条件：（Q.rear+1）%MaxSize== Q.front\n队空条件：Q.front== Q.rear\n\n## 链式队列\n```C\ntypedef struct Qnode {\n\tQElemType data;\n\tstruct Qnode* next;\n}QNode,*QueuePtr;\n```\n不带头结点时，当Q.front== NULL且Q.rear== NULL 时，链式队列为空\n插入r→next=s;s->next=NULL;r=s;\n用链头作为队头\n\n\n\n## 静态队列\n基于数组实现的，如果是普通数组，规定front指向第一个元素的位置，rear指向最后一个元素位置的下一个位置\n如果front指向第一个的前一个元素，rear就指向最后一个元素。\n初始状态（队空条件）：Q->front == Q->rear == 0。\n进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。\n出队操作：队不空时，先取队头元素值，再将队头指针加1。\n\n## 双端队列\n允许两端都可以进行插入和删除操作的线性表\n输入受限：一端插入删除，另一端删除\n输出受限：一端插入删除，另一端插入\n\n## 错题\n1. ![Pasted image 20250307131237](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307131237.png)c\n2. ![Pasted image 20250307171220](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307171220.png)循环队列中，每删除一个元素，队首指针 front=(front+1)%6，每插入一个元素，队尾指针 rear=(rear+1)%6。上述操作后，front=0，rear=3\n3. ![Pasted image 20250307172039](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307172039.png)虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的入队和出队时间复杂度均为O(1)。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。\n4. ![Pasted image 20250307175308](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175308.png)a\n5. ![Pasted image 20250307174201](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174201.png)因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要 0(n)的时间。选项 B、C和D均可在 0(1)的时间内找到队首和队尾。\n6. ![Pasted image 20250307174444](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174444.png)队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素,则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，修改队尾指针为rear=front。\n7. ![Pasted image 20250307175540](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175540.png)![Pasted image 20250307175551](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175551.png)\n8. ![Pasted image 20250307180416](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180416.png)![Pasted image 20250307180430](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180430.png)\n9. ![Pasted image 20250307181119](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307181119.png)第一个元素进入队列后存储在A[0]处，此时 front 和 rear 值都为0。入队时因为要执行(rear+1)%n 操作，所以若入队后指针指向 0，则 rear 初值为 n-1，而因为第一个元素在A[0]中，插入操作只改变rear 指针，所以front为0不变\n10. ![Pasted image 20250307182400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182400.png)利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得 R1，C入栈，计算得 R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D依次计算得栈深为 4、3、3。因此选择选项 B\n11. ![Pasted image 20250307182639](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182639.png)![Pasted image 20250307182649](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182649.png)\n12. ![Pasted image 20250307182804](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182804.png)b\n13. ![Pasted image 20250307182833](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182833.png)c\n14.\n\n# 数组\n线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。\n特点：结构固定——定义后，维数和维界不再改变。\nLOC(aij)=基地址+偏移量\n数组偏移量基址\n![Untitled 138|Untitled 138.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20138.png)\n以行为例，地址=基地址+(i×n+j)×元素大小\n\n三维数组：a mno\n三维数组计算a ijk的公式为d=i* n* o+j* o+k，就是d高* 长* 宽+d长* 高+d宽\n\ntypedef elemtype array2【m】【n】;\n等价\ntypedef elemtype array1[n];\ntypedef array1 array2[m];\n\n## 压缩存储\n为多个值相同的元只分配一个存储空间；对零元不分配空间。\n**特殊矩阵的压缩存储**方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。目的：减少不必要的存储空间\n\n一维数组a[i]的存放地址=起始地址+i* sizeof(ElemType)\n存储目的：把一个**n维的数组定义为其数据元素为n-1维数组类型的一维数组**。\n二维数组的存储结构：\n==行优先存储==：定义二维数组 a：int a【4】【5】。由下图可知，对于行优先，a【2】【3】是第几个元素的求法为：行标2之前的行已填满元素，每行元素有5个，行标2所指的行的元素个数由列标指示出来，因此a【2】【3】是第2x5+3+1=14个元素，a【2】【3】之前有13个元素。\n==列优先存储==：对于列优先，a【2】【3】是第几个元素的求法为：列标3之前的列已填满元素，每列元素有4个，列标3所指的列的元素个数由行标指示出来，因此a【2】【3】是第3x4+2+1=15个元素，a【2】【3】之前有14个元素。\n![8ee2d0ea49804b7991042179b2c863fb](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/8ee2d0ea49804b7991042179b2c863fb.jpg)\n\n按列\n LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))* L\n按行\nLOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))* L\n\n\n## 特殊矩阵\n矩阵下标默认从1开始\n数组默认从0开始\n## 对称矩阵\nn阶方阵，aij=aji（1⩽i,j⩽n）\n![Pasted image 20250308104031|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104031.png)存储策略：只存储主对角线+上/下三角区\n元素个数为n(n+1)/2\nn阶矩阵A可以用一维数组B== [n(n+1)/2]== 以行序为主序存储其下三角（包括对角线）中的元素，那么B[k]与aij之间存在一一对应关系：![Pasted image 20250308104132|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104132.png)\n\n![c694632cf58d4933a61613c570a30ddb](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/c694632cf58d4933a61613c570a30ddb.jpg)\n\n一般存下三角+主对角线，用等差数列，上三角i，j互换就可以\n\n## 三角阵\n存储方法与对称矩阵类似，使用n(n+1)/2+1个存储空间，其中最后一个空间用来存放常数c，在一维数组中的存储结果如下图：\n![a588174886ae4654a8ae7fafcb71d526](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a588174886ae4654a8ae7fafcb71d526.jpg)\n下三角：i<j时，有aij=0\n上三角：i>j时，有aij=0 上三角为0\n![Untitled 1 131|Untitled 1 131.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20131.png)\n上三角矩阵的压缩存储公式\n![Screenshot_2023_0815_075029|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0815_075029.png)\n\n## 三对角矩阵\nn(n>=3)阶三对角矩阵中的非零元素都集中在以主对角线为中心的带状区域中，其他区域均为零元，也即当|i-j|>1时，有aij=0。![Pasted image 20250308120026](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308120026.png)\n- 对于 n×nn×n 的三对角矩阵：\n    - 第 1 行和最后 1 行只有 2 个非零元素。\n    - 中间的行有 3 个非零元素。\n那么以行序将这些非零元素存储到一维数组B[3n-3]中，那么对应关系是：\nk=2i+j−3（数组下标从0开始）\n那么以行序将这些非零元素存储到一维数组B[3n-2]中，那么对应关系是：\nk=2i+j−2（数组下标从1开始）\n![89d0f9130782418894dfe03158fe2059](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/89d0f9130782418894dfe03158fe2059.jpg)\n\n## 稀疏矩阵\n0的个数比非零的多\n稀疏矩阵进行压缩存储通常有两种方法:顺序存储(三元组)和链式存储(十字链表)\n稀疏矩阵采用压缩存储后的缺点主要是==丧失随机存取的特性==\n\n## 错题\n1. ![Pasted image 20250308111917](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308111917.png)A[0][0] 存放在 B[0]\n   对于第 i行，存储的元素为i0 i1 … ii\n   第 i 行的元素个数为 i+1\n   前 i 行的元素总数为：1+2+3+⋯+i=(i+1)i/2\n2. 二维数组 A 按行优先存储，其中每个元素占1个存储单元。若 A11的存储地址为420，A33的存储地址为446，则A55的存储地址为()\n   由行优先存储得到aij的地址地址=基地址+(i×n+j)×元素大小，得出基地址407，12列，故a55=472\n3. ![Pasted image 20250308114043](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114043.png)k=2i+j- 2，195\n4. ![Pasted image 20250308114656](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114656.png)![Pasted image 20250308114705](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114705.png)\n5. ![Pasted image 20250308115002](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115002.png)![Pasted image 20250308115013](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115013.png)\n6. ![Pasted image 20250308115654](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115654.png)总数=2+28×3+1=2+84=87或k=2i+j-3\n7. ![Pasted image 20250308122246](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122246.png)a\n8. ![Pasted image 20250308122545](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122545.png)按上三角存储，m7,2对应的是m2,7，在它之前有： 第1列：1 第2列：2 第6列：6 第7列：1 前面一共1+2+3+4+5+6+1个元素，共22个元素，数组下标从0开始，故下标为m2,7的数组下标为22。\n9. ![Pasted image 20250308122839](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122839.png)![Pasted image 20250308123055](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308123055.png)\n10. ![Pasted image 20250308124253|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308124253.png)按列优先次序存储，A[6,7]处于第7行第8列，前面有7列，每一列8x5个单元，再加上第8列前面的6个元素6x5，即7x8x5+6x5=310\n11.\n\n# 串\n定义：是由零个或多个字符组成的有限序列\nS=’a1a2a3……an’\n编号默认从1开始\n串值用单引号括起来\n子串：串中任意个连续的字符组成的子序列\n字符串的子串数目为n(n+1)/2 + 1\n主串：包含子串的串\n字符在主串中的位置：字符在串中的序号\n子串在主串中的位置：子串的第一个字符在主串中的位置\n例如，有串 A='china Beijing'，B='Beijing'，c='china'，则它们的长度分别头13、7 和 5。B 和C是A的子串，B在A中的位置是 7,c 在A中的位置是1。\n串是一种特殊的线性表，数据元素之间呈线性关系。但线性表以单个元素为操作对象，而串以整体（子串）为操作对象。\n## 串的存储结构\n## 定长顺序存储\n类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。\n定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。\n```C\ntypedef struct {\n\tchar ch[MaxLen]; // 每个分量存储一个字符\n\tint length; // 串的实际长度\n}SString;\n```\n## 堆分配存储表示\n堆分配存储表示仍然以一组地址==连续==的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中==动态==分配得到的。\n```C\ntypedef struct {\n\tchar *ch; // 按串长分配存储区，ch指向串的基地址\n\tint length; // 串的长度\n}HString;\n```\n## 块链存储表示\n类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a)是结点大小为4(每个结点存放4个字符)的链表，最后一个结点占不满时通常用“#”补上;图 4.1(b)是结点大小为1的链表。![Pasted image 20250308125233|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308125233.png)\n## 字符串的模式匹配\n字符串的模式匹配是指在主串中找到与模式串相同的子串，并返回其所在位置。常见的模式匹配算法包括朴素模式匹配算法和KMP算法。\n## **1. 朴素模式匹配算法**\n**基本思想**\n- 将主串中所有长度为  m  的子串依次与模式串对比，直到找到一个完全匹配的子串或所有子串都不匹配为止。\n- 最多需要对比  n - m + 1  个子串。![Pasted image 20250308131814|250](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308131814.png)\n**时间复杂度**\n- 最坏情况下，时间复杂度为  O(nm) ，其中  n  是主串长度， m  是模式串长度。\n```cpp\nint Index(HString S, HString T, int pos) {\n    int n, m, i;\n    HString sub;\n    InitString(sub);\n    if (pos > 0) {\n        n = StrLength(S);\n        m = StrLength(T);\n        i = pos;\n        while (i <= n - m + 1) {\n            SubString(sub, S, i, m);\n            if (StrCompare(sub, T) != 0)\n                i++;\n            else\n                return i;\n        }\n    }\n    return 0;\n}\n```\n**优化实现（直接通过数组下标）**\n```cpp\nint Index1(SString S, SString T, int pos) {\n    int i, j;\n    if (1 <= pos && pos <= S[0]) {\n        i = pos;\n        j = 1;\n        while (i <= S[0] && j <= T[0]) {\n            if (S[i] == T[j]) {\n                i++;\n                j++;\n            } else {\n                i = i - j + 2; // i 指向下一个子串的第一个位置\n                j = 1;\n            }\n        }\n        if (j > T[0]) // S 中存在 T\n            return i - T[0];\n        else\n            return 0;\n    } else {\n        return 0;\n    }\n}\n```\n## **2. KMP算法**\n**基本思想**\n- 利用已经匹配过的模式串信息，避免主串指针回溯。\n  - 特点是在模式匹配时，指示主串的指针不会变小\n- 通过预处理模式串，生成 `next` 数组，记录模式串中每个位置的最长公共前后缀长度。\n\n![Pasted image 20250308132051](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308132051.png)\n**时间复杂度**\n- 预处理 `next` 数组的时间复杂度为  O(m) 。\n- 匹配过程的时间复杂度为  O(n) 。\n- 总时间复杂度为  O(n + m) 。\n**核心思想**\n- 在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位j与主串位 i比较时，两个字符不相等，则i的位移方式是 `next[j]` ，而不是从头开始匹配。主串位指针i不变\n- `next` 数组的定义：`next[j]` 表示模式串中前  j  个字符的最长公共前后缀长度。\n```cpp\nvoid getNext(SString T, int next[]) {\n    int i = 1, j = 0;\n    next[1] = 0;\n    while (i < T[0]) {\n        if (j == 0 || T[i] == T[j]) {\n            i++;\n            j++;\n            next[i] = j;\n        } else {\n            j = next[j];\n        }\n    }\n}\n\nint Index_KMP(SString S, SString T, int pos) {\n    int i = pos, j = 1;\n    int next[T[0] + 1];\n    getNext(T, next);\n    while (i <= S[0] && j <= T[0]) {\n        if (j == 0 || S[i] == T[j]) {\n            i++;\n            j++;\n        } else {\n            j = next[j];\n        }\n    }\n    if (j > T[0])\n        return i - T[0];\n    else\n        return 0;\n}\n```\n**`next` 数组的优化（`nextval` 数组）**\n- 通过进一步优化 `next` 数组，减少不必要的比较。\n- 当 `T[i] == T[j]` 时，`nextval[i] = nextval[j]`；否则，`nextval[i] = j`。\n```cpp\nvoid getNextval(SString T, int nextval[]) {\n    int i = 1, j = 0;\n    nextval[1] = 0;\n    while (i < T[0]) {\n        if (j == 0 || T[i] == T[j]) {\n            i++;\n            j++;\n            if (T[i] != T[j])\n                nextval[i] = j;\n            else\n                nextval[i] = nextval[j];\n        } else {\n            j = nextval[j];\n        }\n    }\n}\n```\n\n| **特性**     | **朴素模式匹配算法** | **KMP算法**             |\n| ---------- | ------------ | --------------------- |\n| **时间复杂度**  |  O(nm)   |  O(n + m)         |\n| **空间复杂度**  |  O(1)    |  O(m) （`next` 数组） |\n| **主串指针回溯** | 需要回溯         | 不需要回溯                 |\n| **适用场景**   | 模式串较短，主串较小   | 模式串较长，主串较大            |\n- **朴素模式匹配算法**：实现简单，但效率较低，适合小规模数据。\n- **KMP算法**：通过预处理模式串，避免主串指针回溯，适合大规模数据。\n- **`nextval` 数组**：进一步优化 `next` 数组，减少不必要的比较。\n## 模式串示例\n![Pasted image 20250308141430](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308141430.png)\nnext：\n1. 前两个0,1\n2. 之后在当前索引前找两个正向的最大公共子串，next为第一个子串的下一个索引值，例如索引6，看1—5有aba公共子串，next6为4\n\nnextval：\n1. 第一个为0\n2. 之后看对应的next值所对应的索引字母，例如索引为3的nextval，对应的next为1，对应的索引字母为a，索引3的字母也为a，nextval为索引为1的nextval；若不是同一个字母，nextval则为对应的next值，例如索引为6的对应next4的字母为b，6为a，不一样，nextval为当前next值4\nT = \"abacab\"\nnext = [0, 1, 1, 0, 1, 2]\nnextval = [0, 1, 0, 1, 0, 1]\n\nababaaababaa\nnext=`[011234223456]`\n\naaab\nnext=`[0123]`\nnextval=`[0003]`\n\n## 错题\n1. ![Pasted image 20250308143227](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143227.png)![Pasted image 20250308143253](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143253.png)\n2. ![Pasted image 20250308143322](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143322.png)![Pasted image 20250308144541](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308144541.png)\n3. ![66d2e1adc05dd53c7bb762eebfa395b|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/66d2e1adc05dd53c7bb762eebfa395b.jpg)\n4. ![Pasted image 20250308145836](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308145836.png)next`[0112342]` nextval`[0101042]` j-nextval`[6]`=2\n5. ![Pasted image 20250308152637](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152637.png)a\n6.  ![Pasted image 20250308151042](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308151042.png)由于i=j=5时失效，故主串和模式串的位序都是从0开始的。此时i=5，next`[j]`=next`[5]`=2，c![Pasted image 20250308152257|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152257.png)\n7. ![Pasted image 20250308152151](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152151.png)b\n\n\n# 二叉树\n1. **树的定义**\n   - **m叉树**：每个结点最多有 `m` 个子结点，可以为空树。\n   - **树的度**：所有结点的度的最大值。\n     - **度为m的树**：各结点的度的最大值\n       至少有一个结点度=m\n       至少有m+1个结点\n   - **叶子结点**（终端结点）：没有子结点的结点。\n   - **分支结点**（非终端结点）：至少有一个子结点的结点。\n   - **根结点**：唯一没有前驱的结点，既可以是叶子结点（空树），也可以是分支结点。\n2. **结点与度的关系**\n   - **结点数 = 总度数 + 1**\n     （每个结点被父结点指向一次，根结点无父结点）\n   - **分支数 = 结点数 - 1 = 总度数**\n     （每个分支对应一个子结点）\n   - **节点度数关系** n0​=n2​+2n3​+…+(k−1)nk​+1\n   - ## **总节点数与度数关系**\n     对于完全二叉树或多叉树：\n     n=1+n1+2n2+3n3（总分支数 + 根节点）\n     n=n0+n1+n2+n3（总节点数）\n     总度数=n-1=n1+2n2+3n3\n3.**树的路径与高度**\n   - **路径长度**：根到每个结点的路径长度之和。\n   - **树的深度/深度**：根结点的层数（通常从 1 开始）。\n## 树的性质\n1. **结点数范围**\n   - **高度为 `h` 的 m 叉树**：\n     - **至少**有 `h` 个结点（每层仅 1 个结点）。\n     - **至多**有 `(m^h - 1)/(m - 1)` 个结点（满 m 叉树）\n       二叉树2^n-1个\n   - **高度为 `h`、度为 `m` 的树**：至少 `h + m - 1` 个结点\n   - 度为 m、具有 n个结点的树的最大高度h为n-m+1\n   - 度为m的树中**第i层**上至多有**m^(i-1)个结点(i≥1)\n2. **最小高度公式**\n   - **具有 `n` 个结点的 m 叉树**的最小高度logm(n(m-1)+1)\n3. **树的形态数**\n   - `n` 个结点的二叉树共有 `C(2n, n)/(n+1)` 种不同形态（卡塔兰数）。\n   - 例：3 个结点的二叉树有 5 种形态。\n## 二叉树\n1. **定义与性质**\n   - **二叉树**：每个结点最多有 2 个子结点，且左右子树**有序**。\n   - **度为2**的树至少有3个结点，而二叉树可以为空\n   - **非空二叉树**的叶子结点数 `n0` 与二分支结点数 `n2` 的关系：n0=n2+1\n   - **高度 H 的二叉树**：\n    - 最多节点数：2k − 1（满二叉树）\n    - 最少节点数：k（退化为链式结构）\n     - 第i层至多有2^(i-1)个结点\n2. **特殊二叉树**\n   - **满二叉树**：\n     - 高度 `h`，结点数 `2^h - 1`。\n     - 只有最后一层有叶子结点，不存在度为 1 的结点。\n   - **完全二叉树**：\n     - 由满二叉树删除最底层最右侧连续若干结点形成。\n     - **性质**：\n       - 叶子结点只出现在**最后两层**。\n       - 最多一个度为 1 的结点（左孩子），为最后一个分支结点，其结点编号为`[n/2]`，且n为偶数时，若为奇数，每个分支都有左右孩子\n       - 编号为 `i` 的结点，左孩子为 `2i`，右孩子为 `2i + 1`。\n       - 按层次编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点\n       - i≤`[n/2]`（向下取整）为**分支结点**，i>`[n/2]`（向上取整）为**叶子结点**\n       - 结点数为 `n` 时，叶子结点数 `n0 = ⌈n/2⌉`（向上取整）\n       - 满二叉树一定是完全二叉树\n       - 当结点数目一定时，具有最小深度的二叉树是完全二叉树\n       - 最少节点数：2^(h−1)\n       - 最多节点数：2^h − 1\n       - 深度（高度）公式：  log2(n+1)向上取整 或 (log2n)+1向下取整\n       - 度为0、1、2的节点关系：\n         n0=n2+1n0​=n2​+1，且 n0+n2n0​+n2​ 必为奇数。\n         - **偶数节点数 2k**：n1=1, n0=k, n2​=k−1\n         - **奇数节点数 2k−1**：n1​=0,n0​=k, n2​=k−1\n    - **偶数节点数**：编号最大的分支节点（编号 n/2）仅有左子女。\n    - **奇数节点数**：所有分支节点均有左右子女。\n\n## 二叉排序树（BST）\n1. **定义**\n   - 左子树所有结点值 < 根结点值 < 右子树所有结点值。\n   - **中序**遍历结果为==有序==序列。\n   - 左子树和右子树又各是一颗二叉排序树\n   - 最左结点数值最小\n   - 对于n个结点的二叉排序树，其最大高度值为n\n   - 可用于元素的排序、搜索\n\n2. **操作与性质**\n   - **插入与查找**：\n     - 平均时间复杂度 `O(log2n)`（平衡时）。\n     - 最坏时间复杂度 `O(n)`（退化为链表）。\n   - **删除操作**：\n     - **叶子结点**：直接删除。\n     - **单子树结点**：用子树替代被删结点。\n     - **双子树结点**：用前驱（左子树最大结点）或后继（右子树最小结点）替代。\n\n## 平衡二叉树（AVL 树）\n   - 任意结点的左右子树高度差绝对值 ≤ 1【胖、多 搜索效率更高】\n   - 查找时间复杂度稳定为 `O(log n)`。\n   - **平衡因子** = 左子树深度 - 右子树深度，取值范围为 {-1, 0, 1}。\n   - 若所有结点平衡因子为 0，则为**满二叉树**。\n   - 平均查找长度为O(log2n)\n   - - 最大深度：O(log⁡2n)O(log2​n)\n\n**二叉树的构造**\n\n\n\n**平衡调整操作**\n- **最小不平衡子树**：只需调整最近失衡的子树，上层结点会自动平衡。\n当插入或删除导致平衡因子超出范围时，需通过旋转调整树结构。调整分为四种情况：\n1. **LL 型（右单旋转）**：\n   - **触发条件**：新结点插入在左子树的左子树中。\n   - **操作**：以失衡结点为轴，向右旋转。\n   - **示例**：\n     ```\n          A (失衡)            B\n         /                  /   \\\n        B        →        C       A\n       /\n      C\n     ```\n\n2. **RR 型（左单旋转）**：\n   - **触发条件**：新结点插入在右子树的右子树中。\n   - **操作**：以失衡结点为轴，向左旋转。\n   - **示例**：\n     ```\n       A (失衡)                B\n        \\                   /   \\\n         B        →        A       C\n          \\\n           C\n     ```\n\n3. **LR 型（先左旋后右旋）**：\n   - **触发条件**：新结点插入在左子树的右子树中。\n   - **操作**：先对左子树左旋（转为 LL 型），再对失衡结点右旋。\n   - **示例**：\n     ```\n          A              A            C\n         /              /           /   \\\n        B      →       C     →    B       A\n         \\            /\n          C          B\n     ```\n\n4. **RL 型（先右旋后左旋）**：\n   - **触发条件**：新结点插入在右子树的左子树中。\n   - **操作**：先对右子树右旋（转为 RR 型），再对失衡结点左旋。\n   - **示例**：\n     ```\n       A              A                C\n        \\              \\             /   \\\n         B      →       C     →    A       B\n        /                \\\n       C                  B\n     ```\n![Pasted image 20250311120615|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311120615.png)\n\n从所插入结点的路径向上查找，找到违反平衡因子的根结点连续的三个结点，min-mid-max，再按二叉排序树的性质插入剩下的结点\n![Pasted image 20250309124217|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309124217.png)\n![Pasted image 20250311115540|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115540.png)\n![Pasted image 20250311115547|250](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115547.png)\n## B 树\n1. **阶数 m**：节点最多有 m 棵子树（m>=3）\n2. **节点子树数约束**：\n   - 根节点：至少 2 棵子树（除非仅一个节点）。\n   - 非根节点：至少`[m/2]`棵子树（如 m=5 ，至少 3 棵子树）\n**叶子结点**：均位于同一层，不存储数据（或存储空指针）。\n**关键字与子树关系**：\n   - 关键字数 = 子树数 - 1。\n   - 非叶节点有 j 棵子树时，含 j-1 个关键字。\n**关键字规则**：\n   - 所有关键字按升序排列。\n   - 关键字将子树划分为区间，如结点含关键字  k1, k2 ，则子树范围为 ( -∞, k1), ( k1, k2) , ( k2, +-∞)。\n1. **2-3树**：3阶B树，非叶节点有2或3棵子树。\n2. **B+树**：支持顺序查找；B树支持多路查找。\n   - **根结点**：至少 2 棵子树（除非树为空）。\n**B 树的操作**\n1. **插入**：\n   - 若结点关键字数超过上限( m-1 ），需**分裂**：\n     - 将中间关键字提升到父结点，左右部分形成新结点。\n     - 若父结点也溢出，递归分裂直到根结点。\n\n2. **删除**：\n   - **非叶子结点删除**：用前驱或后继关键字替代。\n   - **叶子结点删除**：\n     - 若删除后关键字数 ≥`[m/2]`-1，直接删除。\n     - 否则需向兄弟结点借关键字或合并结点。\n### **B+ 树与 B 树的区别**\n| **特性**         | **B 树**                          | **B+ 树**                        |\n|------------------|----------------------------------|----------------------------------|\n| **关键字存储**   | 所有结点均存储数据               | 仅叶子结点存储数据，非叶结点为索引 |\n| **叶子结点链接** | 无                               | 叶子结点通过指针链接，支持顺序遍历 |\n| **查询效率**     | 随机查询效率高                   | 范围查询和顺序遍历效率高          |\n| **结构复杂度**   | 结点结构简单                     | 非叶结点仅存索引，结构更紧凑      |\n- **AVL 树**：通过平衡因子和旋转操作维持平衡，适用于频繁查找的场景。\n- **B 树**：多路平衡查找树，减少磁盘 I/O 次数，适合文件系统和数据库索引。\n- **B+ 树**：在 B 树基础上优化范围查询，广泛应用于数据库和操作系统中。\n\n\n## 二叉树的存储结构\n## 顺序存储\n1. **适用场景**：完全二叉树。\n2. **原理**：\n   - 通过数组下标直接计算父子关系（如父结点 `i` 的左孩子为 `2i`，右孩子为 `2i+1`）。\n   - 若树非完全二叉树，需填充空结点以保证结构，导致内存浪费。\n3. **优缺点**：\n   - **优点**：快速定位父子结点，无需额外指针。\n   - **缺点**：\n     - 单支树（深度为 `k`）需数组长度为 `2^k - 1`（指数级内存消耗）。\n     - 非完全二叉树存在大量空位。\n   ```cpp\n   typedef struct TreeNode {\n       ElemType value;\n       bool isEmpty;\n   } t[MAXSIZE];\n   ```\n\n## 链式存储\n**空链域数量**：\n   - 在含 `n` 个结点的二叉链表中，共有 `n+1` 个空链域。\n   - **推导**：\n     - 每个结点有 2 个指针（左、右），总指针数为 `2n`。\n     - 树的边数为 `n-1`（树的性质），即使用的指针数为 `n-1`。\n     - 空链域数 = 总指针数 - 使用指针数 = `2n - (n-1) = n+1`。\n   - **用途**：空链域可用于构造线索二叉树（标记前驱/后继）。\n1. **二叉链表**：\n   ```cpp\n   typedef struct BiTNode {\n       ElemType data;\n       struct BiTNode *lchild, *rchild;\n   } BiTNode, *BiTree;\n   ```\n   - **特点**：无法直接找到父结点，需从根遍历。\n   - **空链域**：`n+1` 个（同前文推导）\n![Untitled 1 132|Untitled 1 132.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20132.png)\n **三叉链表**：\n 空链域：n+2个\n   ```cpp\n   typedef struct BiTNode {\n       ElemType data;\n       struct BiTNode *lchild, *rchild, *parent;\n   } BiTNode, *BiTree;\n   ```\n   - **特点**：增加父结点指针，方便反向查找  ![Pasted image 20250309152923|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309152923.png)\n\n## 二叉树的遍历\n1. **遍历顺序**：\n   - **先序遍历**：根 → 左 → 右\n   - **中序遍历**：左 → 根 → 右\n   - **后序遍历**：左 → 右 → 根\n   - **层序遍历**：自上而下、从左到右逐层遍历。\n\n2. **递归实现与栈的关系**：\n   - 递归遍历的本质是隐式使用系统调用栈，空间复杂度为树高  O(h) 。\n   - **前序序列与中序序列的关系**：\n     - 前序序列相当于**入栈顺序**，中序序列相当于**出栈顺序**。\n     - 例如：前序 `[A,B,C]` 和中序 `[B,A,C]`，可唯一确定一棵二叉树。\n\n3. **层序遍历实现**：\n   - ==**队列==辅助**：\n     1. 根结点入队。\n     2. 循环：出队结点访问，并将其左右孩子入队。\n     ```cpp\n     void LevelOrder(BiTree T) {\n         Queue Q;\n         InitQueue(Q);\n         EnQueue(Q, T);\n         while (!IsEmpty(Q)) {\n             BiTNode* p;\n             DeQueue(Q, p);\n             visit(p);\n             if (p->lchild) EnQueue(Q, p->lchild);\n             if (p->rchild) EnQueue(Q, p->rchild);\n         }\n     }\n     ```\n   - **特点**：按层输出，适合求树的最小宽度或层次相关操作。\n\n**遍历序列的唯一性**\n1. **单一遍历序列无法唯一确定二叉树**：\n   - 例如：前序 `[A,B]` 可对应两种结构（B为左孩子或右孩子）。\n2. **唯一确定条件**：\n   - **中序 + 前序/后序/层序**：可唯一还原二叉树。\n   - **前序 + 后序**：仅当树是满二叉树时可唯一确定。\n若只给出一棵二叉树的前/中/后/层 序遍历的一种，不能唯一确定一棵二叉树。\n一定是由中+前/后/序\n若有一个==叶结点==是二叉树中某个子树的==中序==遍历结果序列的最后一个结点，则它一定是该子树的==前序==遍历结果序列的最后一个结点\n**前、中、后遍历序列中==叶子结点==的相对位置是不变的**\n若一棵二叉树的中序序列和后序序列相同，则二叉树为空树或二叉树任一结点没有右子树；反之，前序和中序相同，左\n若先序和后序相反，则高度=结点数\n已知先/后序与中序：\nx轴是中序，y轴是 先序 或 倒的后序\n找最高点M，在M左侧找最高点L，右侧最高点R，连接，递归\n如果先序遍历序列和层序遍历序列相同，则这个二叉树是一个单支树\n\n## 线索二叉树\n**线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。**\n**由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在**==**遍历**==**的过程中修改空指针的过程。**\n若无左子树，令lchild指向其前驱结点；\n若无右子树，令rchild指向其后继结点。\n左前驱，右后继\n![v2-014d37e12cb6f8fa81143a1ae372f854_b|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/v2-014d37e12cb6f8fa81143a1ae372f854_b.png)\n还需要增加两个标志语表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。\nl\n1. ltag== 0，指向左孩子；ltag== 1，指向前驱结点【指线索/指针/地址】\n2. rtag== 0，指向右孩子；rtag== 1，指向后继结点\n   ```cpp\n   typedef struct ThreadNode {\n       ElemType data;\n       struct ThreadNode *lchild, *rchild;\n       int ltag, rtag; // 0:孩子指针；1:线索\n   } ThreadNode, *ThreadTree;\n   ```\n   - `ltag=1`：左指针指向前驱；`rtag=1`：右指针指向后继。\n![10ae36162db147adb9e3662d9072f8dd](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/10ae36162db147adb9e3662d9072f8dd.png)\n![Pasted image 20250310102313|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310102313.png)\n\n有了这些前驱后继信息的好处是：在查找某个结点时就可以类似链表那样很方便的从表头遍历到表尾，并且空间复杂度只有 O ( 1 ) 。而前面二叉树的遍历中，无论递归还是非递归，都要用到栈，空间复杂度跟二叉树的具体形态有关。\n二叉树在线索化后，仍不能有效求解的问题是==后序线索二叉树中求后序后继==\n\n- **逻辑结构**：描述数据元素之间的抽象关系，如二叉树、链表、图等。\n    - **二叉树**：一种分层结构，每个结点最多有两个子结点，用于表达数据间的层次关系，属于逻辑结构。\n- **物理结构**：描述数据在计算机内存中的具体存储方式，如顺序存储（数组）、链式存储（指针）等。\n    - **线索二叉树**：在链式存储的基础上，通过修改空指针为线索（前驱/后继），优化遍历效率，属于物理结构。\n\n**后序线索二叉树无法有效求解后序后继的原因**\n后序遍历的顺序为 **左→右→根**，根结点最后被访问。后序线索化的局限性体现在以下场景：\n**场景 1：分支结点的左右子树均为叶结点**\n假设结点 `A` 是父结点 `P` 的左孩子，且 `A` 的左右子树均为叶结点：\n- **后序遍历顺序**：左叶 → 右叶 → `A` → `P` 的右子树 → `P` → ...\n- **问题**：`A` 的后继应为 `P` 的右子树的最左下叶结点，但 `A` 的右指针可能直接指向 `P`（作为线索），无法跳转到 `P` 的右子树，导致无法直接找到正确后继。\n**场景 2：根结点的右子树非空**\n- **后序遍历顺序**：左子树 → 右子树 → 根结点。\n- **问题**：根结点的右指针指向实际右子结点，而非线索化的后继（因为根结点是最后一个被访问的结点，没有后继）。\n- **示例**：根结点 `R` 有右子树，遍历到 `R` 时，其右指针指向右子结点，而非空，无法通过线索直接确定后继。\n**关键限制**\n- **无法回溯父结点**：后序线索仅记录直接前驱/后继，但某些后继需要通过父结点的右子树路径确定。\n- **依赖栈或父指针**：在非线索化遍历中，栈用于记录路径以回溯父结点；而线索化无法提供此信息，导致必须额外维护栈。\n\n- 先序线索二叉树 ABDGECF\n    ![Untitled 6 80|Untitled 6 80.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%206%2080.png)\n    ![Untitled 7 76|Untitled 7 76.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2076.png)\n- 中序线索二叉树\n    ![Untitled 8 71|Untitled 8 71.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2071.png)\n1. **中序线索树**：\n   - 某结点有右孩子 → 其后继为右子树的最左下结点。\n   - 某结点有左孩子 → 其前驱为左子树的最右下结点。\n注意：\n1. **限制**：\n   - **后序线索二叉树**：无法高效求解后序后继（需栈支持）。\n   - **前序/中序线索树**：可无栈遍历，时间复杂度 O(n)，空间复杂度O(1)\n2. **线索化目的**：\n   - 利用空链域（`n+1`个）记录前驱/后继，加速遍历。\n   - **实质**：遍历时修改空指针为线索。\n\n**应用场景**\n1. **求树深度**：\n   - 递归遍历左右子树深度，取最大值加1。\n   ```cpp\n   int Depth(BiTree T) {\n       if (T == NULL) return 0;\n       int left = Depth(T->lchild);\n       int right = Depth(T->rchild);\n       return max(left, right) + 1;\n   }\n   ```\n\n2. **线索化优势**：\n   - 遍历无需栈，空间复杂度优化为  O(1) 。\n   - 适用于频繁遍历但插入/删除较少的场景。\n3. **设计选择**：\n   - 频繁查找前驱/后继 → 线索二叉树。\n   - 频繁插入/删除 → 普通链式存储。\n- 线索化本质是空间换时间，适用于遍历密集型操作。\n\n## 树的存储结构\n1. **双亲表示法**：\n   - **原理**：每个结点存储数据及其父结点索引（根结点的父结点索引为空）。\n   - **优点**：\n     - 快速查找父结点（时间复杂度  O(1) ）。\n     - 存储结构简单，仅需一个数组即可表示整棵树。\n   - **缺点**：\n     - 查找子结点需遍历整个表（时间复杂度  O(n) ）。\n     - 插入或删除结点时需维护索引一致性，复杂度较高。\n   - **适用场景**：频繁查找父结点且子结点操作较少的场景，如家谱关系管理。\n![Pasted image 20250310130809|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310130809.png)\n2. **孩子表示法**：\n   - **原理**：每个结点存储数据及子结点链表的头指针。\n   - **优点**：\n     - 快速查找子结点（直接通过链表访问，时间复杂度  O(k) ， k  为子结点数）。\n     - 适合动态增删子结点的场景。\n   - **缺点**：\n     - 查找父结点需从根结点遍历，效率低（时间复杂度  O(n) ）。\n     - 存储空间较大（每个结点需额外维护链表指针）。\n   - **适用场景**：需要频繁操作子结点（如文件系统目录树）。\n![Pasted image 20250310131023](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310131023.png)\n3. **二叉树表示法（孩子兄弟表示法）**：\n   - **原理**：将普通树转换为二叉树，规则如下：\n     - **左指针**指向第一个孩子结点（最左子结点）。\n     - **右指针**指向当前结点的下一个兄弟结点。\n   - **特点**：\n     - 一个普通树转化成的二叉树一定没有右子树。\n     - **森林转换**：先把森林转化为二叉树，再存储二叉树（如森林 {T1, T2}转换为 T1->T2）。\n   - **优点**：\n     - 统一使用二叉树结构，可复用二叉树的遍历、插入、删除等算法。\n     - 节省存储空间（仅需两个指针）。\n   - **缺点**：\n     - 逻辑结构需通过指针关系间接理解，初次接触可能较难适应。\n     - 遍历时需区分“孩子”与“兄弟”指针，逻辑稍复杂。\n   - **适用场景**：需要利用二叉树算法处理一般树或森林的场景（如编译器语法树）。\n  双亲表示法是顺序存储结构，孩子表示法和孩子兄弟表示法是链式存储结构\n\n\n- **存储效率**：\n  - 双亲表示法最节省空间，但功能单一；\n  - 孩子兄弟表示法在空间和功能间取得平衡，适合通用场景。\n\n- **操作效率**：\n  - 若需频繁查找父结点，双亲表示法最优；\n  - 若需频繁操作子结点，孩子表示法或双亲孩子表示法更优。\n\n- **转换：\n  - **树 → 二叉树**：  ![Pasted image 20250310160725|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310160725.png)\n  - **森林 <-> 二叉树**：  ![Pasted image 20250310161030|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310161030.png)\n    森林->二叉树，右子树非空（因为各树根节点通过右指针链接）\n     二叉树->森林，若根节点有右子树，则右子树拆分成独立的树\n     **森林与二叉树的转换**是唯一的，且右指针为空的数量与非终端结点数相关\n     森林树的数量=森林结点数-边数\n    **森林的非终端结点数 n → 二叉树右指针为空的结点数 n+1**：\n    非终端节点指有子结点的节点（包括跟根节点）\n    每个非终端结点对应一个右指针，最后一个兄弟右指针为空。\n    **森林的叶结点数 = 二叉树左指针为空的结点数**\n    原森林的叶结点在二叉树中无左孩子\n    高度为h的满二叉树对应森林所含树的个数为h\n- **树转二叉树**：无右子树。\n- **森林转二叉树**：右子树存在（各树根通过右指针链接）。\n\n## 树的遍历方式\n## 树的先根遍历（深度优先遍历）\n先访问树的根节点，然后依次先根遍历根的每棵子树。这种遍历方式和二叉树的先序遍历（先访问根节点，再访问左子树，最后访问右子树）类似。\n![Untitled 234|Untitled 234.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20234.png)\n## 树的后根遍历（深度优先遍历）\n先依次后根遍历根的每棵子树，然后再访问根节点。这种遍历方式类似于二叉树的中序遍历（先访问左子树，再访问根节点，最后访问右子树） 。\n![Untitled 1 135|Untitled 1 135.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20135.png)\n## 树的层次遍历（广度优先遍历）\n按照层次，从根节点开始，一层一层地访问节点，同一层的节点按照从左到右的顺序进行访问。\n![Untitled 2 119|Untitled 2 119.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%20119.png)\n## 森林的遍历方式\n森林是由 m（m≥0）棵互不相交的树组成的集合。\n## 森林的先序遍历\n依次对森林中的各个树进行先根遍历，这等同于依次对与森林对应的二叉树进行先序遍历。具体过程是：先访问森林中第一棵树的根节点，然后先序遍历第一棵树的子树森林，接着先序遍历除去第一棵树之后剩余的树组成的森林。\n## 森林的中序遍历\n依次对森林中的各个树进行后根遍历，也就相当于依次对与森林对应的二叉树进行中序遍历。具体过程为：先中序遍历森林中第一棵树的子树森林，然后访问第一棵树的根节点，接着中序遍历除去第一棵树之后剩余的树组成的森林。\n![Pasted image 20250310163959](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310163959.png)\n关键结论 ：\n- **顺序存储**适合完全二叉树，否则内存浪费严重。\n- **线索二叉树**通过利用空链域优化遍历，但后序线索化无法完全消除栈依赖。\n- **普通树转二叉树**后右子树为空（根无兄弟），森林转换则通过右指针链接各树根。\n- **三叉链表**以空间换时间，支持父结点快速访问。\n\n## 哈夫曼树和哈夫曼编码\n是对数据压缩和编码长度的优化\n1. **带权路径长度（WPL）**\n   - **定义**：树中所有叶结点的带权路径长度之和。\n   - **公式**：\n    ![Pasted image 20250310172719|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310172719.png)![Pasted image 20250310173324|450](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173324.png)\n    加权平均长度=带权路径长度/所有结点频次之和_\n1. **哈夫曼树（最优二叉树）**\n   - **目标**：构造 WPL 最小的二叉树。\n   - **特点**：\n     - 权值越小的叶结点离根越远，路径长度越大。\n     - 构造过程中新建  n-1  个内部结点，总结点数为  2n-1 。\n     - 不存在度为 1 的结点（n0=n2+1，已知n0叶结点可求n2双分支节点）\n     - n个初始节点构造哈夫曼树共新建n-1个双分支结点，因此哈夫曼树的节点总数是2n-1，是奇数\n     - 权值最小的两个结点互为兄弟。\n     - 用一组权值构造出的哈夫曼树可能不唯一（左右子树不同），但带权路径长度唯一\n![Pasted image 20250310173511|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173511.png)\n1. **前缀编码**\n   - **定义**：没有一个编码是另一个编码的前缀，保证解码唯一性【检查所有编码是否互不为前缀】\n   - **实现方式**：通过哈夫曼树生成可变长度编码，左分支标记为 `0`，右分支标记为 `1`。\n## 哈夫曼树构造步骤\n1. **初始化**：将  n  个权值作为独立的单结点树。\n2. **合并子树**：\n   - 每次选择权值最小的两棵树合并，生成新结点作为其父结点，权值为子树权值之和。\n   - 重复此过程直至只剩一棵树。\n1. **贪心算法依据**：局部最优选择（合并最小权值树）保证全局最优（WPL 最小）。\n![Pasted image 20250310173701|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173701.png)\n## 应用场景与优势\n1. **数据压缩**：\n   - 对高频字符分配短编码，低频字符分配长编码，显著减少总编码长度。\n2. **文件传输**：\n   - 结合前缀编码，实现高效无损压缩（如 ZIP、JPEG 中的哈夫曼编码）。\n\n1. **唯一性与最优性**：\n   - 哈夫曼树不唯一（左右分支标记可互换），但所有哈夫曼树的 WPL 相同且最小。\n2. **时间复杂度**：\n   - 构造哈夫曼树： O(n \\log n) （使用优先队列优化选择最小权值）。\n   - 生成编码： O(n) 。\n\n## 并查集\n**并查集**是一种用于管理**不相交集合**的数据结构，支持以下两种核心操作：\n1. **查询（Find）**：确定元素属于哪个集合（通常通过根节点标识）![Pasted image 20250311104951|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311104951.png)\n2. **合并（Union）**：将两个集合合并为一个集合。\n并查集的结构是一种==双亲表示法==存储的树\n\n**应用场景**：\n- 判断图的连通分支数（如判断森林中有几棵树）。\n- 动态连通性问题（如网络节点是否可达）。\n- Kruskal 算法中判断边是否会形成环。\n\n**核心构成**\n1. **数组 `parent[]`**：\n   - 记录每个节点的父节点。\n   - 根节点的父节点指向自身（即 `parent[root] = root`）。\n2. **函数 `find(x)`**：\n   - 查找节点 `x` 所属集合的根节点。\n3. **函数 `union(x, y)`**：\n   - 合并 `x` 和 `y` 所属的集合。\n\n**基本实现与时间复杂度**\n1. **未优化版本**：\n   - **`find(x)`**：逐层向上查找根节点，最坏时间复杂度为  O(n) 。\n   - **`union(x, y)`**：需要先调用 `find(x)` 和 `find(y)`，时间复杂度  O(n) 。\n   ```python\n   # 初始化：每个节点的父节点指向自己\n   parent = list(range(n))\n\n   def find(x):\n       while parent[x] != x:\n           x = parent[x]\n       return x\n\n   def union(x, y):\n       root_x = find(x)\n       root_y = find(y)\n       if root_x != root_y:\n           parent[root_y] = root_x\n   ```\n\n2. **优化目标**：\n   - 通过**路径压缩**和**按秩合并**，将操作的时间复杂度优化至  O(\\alpha(n)) ，其中α(n) 是阿克曼函数的反函数（实际应用中接近常数）。\n\n**优化方法**\n1. **按秩合并（Union by Rank）**：\n   - **原理**：将小树合并到大树中，避免树高度过高。\n   - **实现**：\n     - 用 `rank[]` 数组记录每个根节点的树高（或节点数）。\n     - 合并时，将小树的根节点指向大树的根节点。\n   ```python\n   rank = [1] * n\n\n   def union(x, y):\n       root_x = find(x)\n       root_y = find(y)\n       if root_x == root_y:\n           return\n       # 小树合并到大树\n       if rank[root_x] > rank[root_y]:\n           parent[root_y] = root_x\n       else:\n           parent[root_x] = root_y\n           if rank[root_x] == rank[root_y]:\n               rank[root_y] += 1\n   ```\n2. **路径压缩（Path Compression）**：\n   - **原理**：在 `find(x)` 过程中，将路径上的所有节点直接指向根节点，缩短后续查找路径。\n   - **实现**：\n   ```python\n   def find(x):\n       if parent[x] != x:\n           parent[x] = find(parent[x])  # 递归压缩路径\n       return parent[x]\n   ```\n\n| 操作            | 未优化  | 按秩合并     | 按秩合并 + 路径压缩 |\n| ------------- | ---- | -------- | ----------- |\n| `find(x)`     | O(n) | O(log n) | O(α(n)）     |\n| `union(x, y)` | O(n) | O(log n) | O(α(n)）     |\n\n- **阿克曼函数 α(n) ：增长极慢，对任何实际输入的n（如n <= 10^80），α(n) <= 5。\n\n**应用示例**\n1. **连通分支数统计**：\n   - 初始化每个节点为独立集合。\n   - 遍历所有边，执行 `union(u, v)`。\n   - 最终统计根节点数量即为连通分支数。\n\n2. **Kruskal 算法**：\n   - 按边权重排序后，依次选择边并检查是否连通（`find(u) == find(v)`）。\n   - 若未连通，执行 `union(u, v)` 并加入生成树。\n\n**常见问题**\n1. **如何判断编码是否合法？**\n   - **前缀编码冲突**：若某编码是另一编码的前缀，则无法唯一解码。\n   - **哈夫曼编码性质**：通过构造哈夫曼树生成的编码天然为前缀编码，保证唯一性。\n\n2. **为什么并查集适合动态连通性问题？**\n   - 并查集支持高效的动态合并与查询操作，时间复杂度接近常数，适合处理大规模数据。\n\n- **并查集的核心优化**：路径压缩 + 按秩合并，时间复杂度接近  O(1) 。\n- **应用场景**：连通性问题、图论算法、动态等价类划分。\n\n并查集：路径压缩 + 按秩合并 → 时间复杂度O(α(n))\n应用：连通分支数统计、Kruskal 算法、动态连通性检测。\n\n\n\n\n## 错题\n1. **完全二叉树结点数计算**\n   - 例：第 6 层有 8 个叶子结点，总结点数最多为 111，最少为 39。\n   - **最多**：第6层有8个叶结点，说明第7层不存在。前5层满（25−1=31），第6层最多有2^5=32个节点，其中8个为叶结点，非叶节点为24个。总节点数：31+24×2+8=111。\n   - **最少**：第6层的8个叶结点集中在左侧，第6层有8个节点（均为叶结点）。总节点数：前5层满（31） + 第6层8个 = 39。\n2. **完全二叉树叶结点数**\n   - 例：768 个结点的完全二叉树，叶结点数为 `384`（`n0 = ⌈768/2⌉`）。\n3. **B 树关键字数范围**：\n   - 对于 5 阶 B 树（ m=5 ）：\n     - 非根结点关键字数： 2 \\leq \\text{关键字数} \\leq 4 。\n     - 根结点关键字数： 1 \\leq \\text{关键字数} \\leq 4 。\n4. **B 树高度与结点数关系**：\n   - 含  n  个关键字的  m  阶 B 树，最小高度  h  满足：\n     n <= (m-1)(1 + m + m^2 + … + m^(h-1)) = m^h - 1\n   - 最大高度  h  满足：\n     n >= 2(`[m/2]`^(h-1) - 1)\n1. 设有一棵度为3的树，其中度为3的结点数n3=2，度为2的结点数n2=1，叶结点数n0=6，则该树的结点总数为() A. 12  B.9 C.10 D.>=9 的任意整数![Pasted image 20250311124831](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311124831.png)\n2. ![Pasted image 20250309134338](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134338.png)![Pasted image 20250309134401](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134401.png)\n3. ![Pasted image 20250309134836](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134836.png)若森林F有 15 条边、25 个结点，则下包含树的个数是( )。8/9/10/11\n![Pasted image 20250309134844](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134844.png)\n4. 二叉树为空意味着二叉树（）\n   A.根结点没有子树 B.不存在 C.没有结点 D.由一些没有赋值的空结点构成\n   二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图(图中不能没有结点)\n5. 设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为( )。 A. h B. 2h-1 C. 2h+1 D. h+1![Pasted image 20250309142623](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309142623.png)\n6. 具有n个结点且高度为n的二叉树的数目为()。A. log2n B. n/2 C. n D. 2^n-1\n   d\n7. 设二叉树有 2n个结点，且m<n，则不可能存在()的结点\n   A. n 个度为 0  B. 2m 个度为 0  C.2m 个度为1  D.2m 个度为2\n   叶子结点数 n0=n2+1，总结点数：n0+n1+n2=2n。带入A对；B是n0=2m，得4m-1+n1=2n，当m=1,n=2,n1=1符合；C是n1=2m，得n2=(2n-2m-1)/2，矛盾不存在；D是n2=2m，得4m+1+n1=2n，当m=1,n=3，符合\n8. ![Pasted image 20250309150857](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309150857.png)若一棵二叉树有 126 个结点，在第7层(根结点在第1层)至多有( )个结点。\n   A. 32 B.64 C.63 D.不存在第7层\n   要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有 127 个结点，126 仅比 127 少1个结点，只能少在第7层，所以第7层最多有 2^6-1=63 个结点。\n9. 一棵有 124 个叶结点的完全二叉树，最多有()个结点。\n   A. 247 B. 248 C.249 D.250\n  124<2^7=128，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120 个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1 个左孩子(不改变叶结点数)，因此结点总数=2^7-1+120+1=248。\n   也可以用总结点数为偶数2k，n1=1, n0=k, n2​=k−1，k=124，求出\n10. 某完全二叉树T中，结点个数最大的层有8个结点，则T中至多有()个结点。\n    A. 8  B.15  C.23  D. 31\n    在完全二叉树中，第4层刚好最多有8个结点(前4层对应高度为4的满二叉树)，若第5层也有8个结点，则对应于结点个数最多的情况，此时树高为5，总结点数为15+8=23。\n11. ![Pasted image 20250309153206](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153206.png)I正确；II若该结点非根结点，其双亲指针还会指向父结点，共 三个指针。但根结点度为 2 时，无双亲指针，仅被两个孩子指向，只有两个指针；IIIn=1（无双亲根节点） 时，唯一结点是叶结点且无指针指向\n12. ![Pasted image 20250309153328](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153328.png)![Pasted image 20250309153335](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153335.png)\n13. ![Pasted image 20250309154115](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309154115.png)**奇数节点数 2k−1**：n1​=0,n0​=k, n2​=k−1\n14. 对于任意一棵高度为5且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元(仅存放结点的数据信息)，则存放该二叉树需要的存储单元数量至少是()。A.31 B. 16 C.15 D.10\n    即使实际只有10个结点，存储时仍需覆盖所有可能的位置，以确保父结点与子结点的位置关系可通过下标直接计算。因此，存储单元数量至少为2^5-1=31\n15. 设n,m 为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D.n是m子孙\n    c\n16. 设n,m 为一棵二叉树上的两个结点，在后序遍历时，n在m前的充分条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D. n是m 子孙\n    d\n17. 对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用( )次序的遍历实现编号 A.先序 B.中序 C.后序 D.层次\n    c\n18. 一棵二叉树的先序遍历序列为 1234567，它的中序遍历序列可能是()。\n    A. 3124567 B. 1234567 C.4135627 D.1463572\n    b\n19. 某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用()遍历方法最合适。A. 中序 B.层次 C.后序 D.先序\n    删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。\n20. 某二叉树T采用二叉链表存储结构，T的中序遍历序列为一个升序序列，要求采用某种方法对 T进行某种操作之后得到一棵新的二叉树T,要求 T\"的中序遍历序列为一个降序序列，则下列关于该算法的叙述中，正确的是()\n    A. 采用中序遍历的方法最合适 B. 采用后序遍历的方法最合透\n    C.T中的根结点还是原T中的根结点 D. T中的叶结点不一定是原T中的叶结点\n    选项 B（采用后序遍历的方法最合适）\n    - 后序遍历（左→右→根）允许先递归处理左右子树，再交换当前结点的左右子树。这种顺序确保子树已完全处理后再调整父结点的结构，避免逻辑混乱。通过后序遍历交换所有分支结点的左右子树，最终中序遍历序列自然逆序为降序。因此，后序遍历是最合适的方法。\n    选项 C（T'中的根结点还是原T中的根结点）\n    - 镜像翻转操作仅交换分支结点的左右子树，不会改变根结点的位置或值。因此，根结点保持不变，选项 C 正确。\n    选项 D（T'中的叶结点不一定是原T中的叶结点）\n    - 叶结点没有左右子树，交换操作对其无影响，原叶结点在 T' 中仍为叶结点（仅位置可能变化）。因此，选项 D 错误\n21. 一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是()。\n    A. 不确定  B.0个  C.1个 D.2 个\n    根结点的左指针：1 个空链域，最右侧叶结点的右指针：1 个空链域，所以线索化后，树中空链域有2个。\n22. 某二叉树的先序序列和后序序列正好相反，则该二叉树一定是()。\n    A.空或只有一个结点           B.高度等于其结点数\n    C.任意一个结点无左孩子   D.任意一个结点无右孩子\n    最多只有一个子结点，即树退化为单链结构（如所有结点只有右孩子或只有左孩子）此时，树的高度等于结点数 h=n，b。C或D属于选项 B 的子集\n23. ![Pasted image 20250310122100](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310122100.png)d\n24. 若一棵二叉树的前序遍历序列为 a,e,b,d,c，后序遍历序列为 b,c,d,e,a，则根结点的孩子结点()。A.只有e  B.有e、b  C.有e、c  D.无法确定\n    根 `a` 的唯一孩子是左孩子 `e`\n25. 先序序列为 a,b,c,d的不同二叉树的个数是( )。13/14/15/16\n    (C4 8)/ 5 = 14\n26. 利用二叉链表存储森林时，根结点的右指针是()。\n    A. 指向最左兄弟 B.指向最右兄弟 C.一定为空 D.不一定为空\n    森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。\n27. 设森林F中有3棵树，第 1、2、3 棵树的结点个数分别为 M1,M2和M3，与森林F对应的二叉树根结点的右子树上的结点个数是()\n    A. M1 B.M1+M2 C.M3 D.M2+M3\n    d\n28. 设森林 F中有 4棵树，第 1、2、3、4 棵树的结点数分别为 a、b、c和 d，与森林F对应的二叉树的根结点的左子树上的结点数是()\n    A. a  B. b+c+d  C.a-1  D. a+b+c\n    c\n29. 设森林F对应的二叉树是一棵具有 16 个结点的完全二叉树，则森林F中树的数目和结点最多的树的结点数分别是() A. 2和8  B.2和9  C.4和8  D. 4和9![Pasted image 20250310165243|250](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310165243.png)\n30. 设X是树T中的一个非根结点，B是T所对应的二叉树。在B中，X是其双亲结点的右孩子，下列结论中正确的是()。\n    A.在树T中，X是其双亲结点的第一个孩子\n    B.在树T中，X一定无右边兄弟\n    C.在树T中，X一定是叶结点\n    D.在树T中，X一定有左边兄弟在二叉树\n    B中，X是其双亲的右孩子，因此在树T中，X必是其双亲结点的右兄弟，换句话说，X在树中必有左兄弟。\n31. ![Pasted image 20250310170049](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310170049.png)A. 双亲表示法中，每个非根结点有一个指向双亲的指针。若树有 n个结点，则双亲指针数为 n−1，正确；B对；C. O(n)；D对\n32. 已知一棵有 2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点个数是()。 A. 115  B. 116  C. 1895 D.1896\n33. 下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是\n    A. 24,10,5 和 24,10,7      B. 24,10,5 和 24,12,7\n    C. 24,10,10 和 24,14,11  D. 24,10,5 和 24,14,6\n34. 根据使用频率为5个字符设计的哈夫曼编码不可能是()\n    A. 000,001,010,011,1   B.0000,0001,001,01,1\n    C. 000,001,01,10,11     D. 00,100,101,110,111\n    D构造出来有度为1的结点，不对\n35. 设哈夫曼编码的长度不超过 4，若已对两个字符编码为1和 01，则还最多可对( )个字符编码。\n    根据前缀编码规则，得到新编码必须以00开头，且总长度<=4，0000，0001，0010，0011，共四个\n36. 一棵哈夫曼树共有 215 个结点，对其进行哈夫曼编码，共能得到( )个不同的码字。A. 107   B. 108  C.214   D. 215\n    树有 `n` 个叶子结点，则总结点数为 `2n - 1`，得到n=108\n37. 并查集中最核心的两个操作是:查找，查找两个元素是否属于同一个集合;合并，若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为 10(0~9)的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9 的顺序进行查找和合并操作，最终并查集共有( )个集合。A. 1 B.2 C.3D.4\n    初始时，0~9各自成一个集合。查找 1-2 时，合并{1}和{2};查找 3-4 时，合并{3}和{4};查找 5-6 时，合并(5}和(6};査找 7-8时，合并{7}和{8}:查找 8-9 时，合并{7,8,和{9};查找1-8 时，合并(1,2和{7,8,9}:查找 0-5 时，合并(0}和{5,6}:查找 1-9 时，它们属于同一个集合。最终的集合为10,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项 C。\n38. 下列关于大根堆(至少含2个元素)的叙述中正确的是\n    I. 可以将堆看成一棵完全二叉树      II. 可采用顺序存储方式保存堆\n    III. 可以将堆看成一棵二叉排序树    IV. 堆中的次大值一定在根的下一层\n    A. 仅1、II      B. 仅1、III       C. 仅I、II、IV        D. 仅I、II、IV\n    c\n39. 已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二又树中无右孩子的结点的个数是() A. 115    B. 116    C. 1895    D. 1896\n    非叶子结点=1895，数转换成的二叉树没有右孩子，原树中每个非叶结点对应一个无右孩子的结点，无右孩子结点数为1895，根节点也无右孩子+1，1896\n40. 有n(n>0)个分支结点的满二叉树的深度是\n    A. n^2-1    B. log2(n+1)+1    C. log2(n+1)     D. log2(n-1)\n    满二叉树的结点总数 N 与深度 h的关系为:N=2^h -1\n    分支结点数 n 与叶子结点数L的关系为:n=L-1\n    对于满二叉树，叶子结点数  L=2^(h-1)，因此:n=2^(h-1)-1\n    可得:h=log2(n+1)+1\n41. 若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的分支结点的个数是()![Pasted image 20250311115823|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115823.png)3\n42. 一个关键字序列为{50，20，60，30，35}，依次构造平衡二叉树，当插入25后引起不平衡，则应进行的平衡旋转是()型旋转 LL?![Pasted image 20250311123317](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123317.png)\n43. 对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是\n    A. 92，20，91，34，88，35              B. 95，22，91，24，94，71\n    C. 21，89，77，29，36，38              D. 12，25，71，68，33，34\n    由二叉排序树的性质可知，一个数后面的数字都要全部大于或全部小于它 b选项的91后面既有小于它的数，也有大于它的数\n44. ![Pasted image 20250311123606](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123606.png)\n45. 设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平3.在平衡二叉树中插入一个结点后造成了不平衡，因子为1，则应作()型调整以使其平衡。 A.LL B. LR C.RL D.RR![Pasted image 20250311130434](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311130434.png)c\n46.\n\n\n# 图\n![Pasted image 20250311143034|450](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311143034.png)由顶点集  V （非空）和边集  E  组成，记为G = (V, E)\n  - **注意**：线性表、树可以为空，但图不能为空（V ≠ ∅）\n## 无向图与有向图\n1. **无向图**：\n   - **边（Edge）**：无序对 (v, w) = (w, v)\n   - **度数性质**：所有顶点的度数之和= 2 × |E|（必为偶数）\n\n2. **有向图**：\n   - **弧（Arc）**：有序对  <v, w>≠ <w, v> 。\n   - **度数性质**：\n     - 入度：指向该顶点的边数。\n     - 出度：从该顶点出发的边数。\n- 稀疏图：顶点很多而边很少的图\n- 稠密图：顶点多边也多的图\n\n## 图的分类\n1. **简单图**：\n   - 无重复边，无自环（顶点到自身的边）。\n2. **多重图**：\n   - 允许两点间有多条边（适用于交通网络等场景）。\n3. **完全图**（也称简单完全图）： 对于给定的一组顶点，顶点间都存在边\n   - **无向完全图**：任意两顶点间均有边，边数=n(n-1)/2\n   - **有向完全图**：任意两顶点间有两条方向相反的弧，弧数= n(n-1)\n4. 生成子图：点都有\n5. **极大连通分量**：子图连通，且包含尽可能多的顶点和边\n   **极大连通子图**：要求子图必须连通，而且包含尽可能多的顶点和边\n   **极小连通子图**：既要保持子图连通又要使得边数最少的子图\n   **连通分量**：==无向==图中的**极大连通子图**\n   **强连通分量**：==有向==图中的极大连通分量（在有向图中考虑强连通性）\n6. 无向==连通图==的==生成树==：是包含**全部顶点**的一个**极小连通子图** n-1条边\n   ==非连通==的==生成森林==：非连通图分解的多个连通分量，多个连通分量对应的多棵生成树\n7. 有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。\n8. ==完全图一定是连通图，但连通图不一定是完全图==\n## 连通性与路径\n1. **无向图的连通性**：\n   - **连通图**：任意两顶点间存在路径，最少边数 = n-1（树结构）。\n   - **非连通图**：最多边数=(n-1)(n-2)/2（一个孤立顶点，其余构成完全图）。\n\n2. **有向图的连通性**：\n   - **强连通图**：任意两顶点间双向可达，最少弧数=n（环形结构）。\n   - **弱连通图**：忽略方向后为连通无向图。\n\n3. **路径与环**：\n   - **简单路径**：顶点不重复出现，最多 n 个顶点，n-1 条边。\n   - **回路（环）**：起点与终点相同的路径。\n   - 若一个图有n个顶点，且有大于n-1条边，此图一定有**环**\n\n\n\n## 生成树与生成森林\n1. **生成树**：\n   - **定义**：无向连通图的极小==连通==子图，包含所有顶点和n-1条边。\n   - **性质**：\n     - 删除任意一条边会破坏连通性。\n     - 添加任意一条边会形成回路。\n**生成树 G′** 是图 G 的一个子图，满足以下条件：\n1. **连通性**：G′ 是连通的。\n2. **无环性**：G′ 是无环的。\n3. **极小性**：G′ 是 GG 的极小连通子图（删除任意一条边会破坏连通性）。\n4. **顶点集**：G′ 包含 GG 的所有顶点（V′=V）。\n5. **生成森林**：\n   - **定义**：非连通图的多个连通分量对应的生成树的集合。\n\n### 关键公式与结论\n- 对于n个顶点的**无向图G**\n  - 若G是==连通==图，>= ==n-1==条边（树），若|E|>n-1，则一定有**回路**。\n  - 保证G在**任何**情况下均连通的最少边数:(n-1)(n-2)/2+1\n  - 若G是==非连通==图，<= ==C2 n − 1==条边【即(n-1)(n-2)/2】，若超过此值，图必**连通**\n  - 无向完全图共有C2 n条边【即n(n-1)/2】\n- 对于n个顶点的**有向图G**\n  - 若G是==强连通==图，>= ==n==条边（形成简单回路）\n  - ==有向完全==图共有==2C2 n== 条边【即n(n-1)】\n- 求有向图的强连通分量\n  - 找入度或出度为0的顶点\n  - 依次删掉这些顶点以及相连的弧，直到没有存在入度或出度为0的顶点、\n  - 删掉的顶点以及剩下的有向图，就是强连通分量![Pasted image 20250311164300|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311164300.png)\n- **顶点度数**：\n  - 无向图顶点最大度数 = n-1\n  - 有向图顶点最大度（入度 + 出度） = 2(n-1)\n\n### 算法与应用\n1. **判断回路**：\n   - **有向图**：拓扑排序、深度优先遍历（DFS）检测环。\n   - **无向图**：并查集或DFS检测环。\n\n2. **连通分量**：\n   - **无向图**：广度优先遍历（BFS）或DFS求所有连通分量。\n   - **有向图**：Kosaraju算法求强连通分量。\n\n3. **最小生成树**：\n   - **Kruskal算法**：按边权升序选择，避免成环。\n   - **Prim算法**：从顶点出发逐步扩展最小边。\n\n- **完全图边数**：\n  - 无向完全图边数  n(n-1)/2，有向完全图弧数n(n-1)\n- **邻接表结点数**：\n  - 无向图邻接表结点总数  2|E| ，有向图邻接表结点总数  |E| 。\n\n##  图的存储结构\n### 邻接矩阵（数组、顺序存储）\n   - 用 n×n 矩阵表示顶点间关系，适用于稠密图。\n![Pasted image 20250311142927|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311142927.jpg)\n无向图邻接矩阵：\n1. 无向图的邻接矩阵一定是一个**对称矩阵**。 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。\n2. 对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个顶点的度\n3. 求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍， `A[i][j]`为 1就是邻接点。\n4. 无向图非零元素至少有2 * 边数个\n5. 在含有 n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为n^2 - 2e\n6.\n\n有向图邻接矩阵：\n1. 主对角线上数值依然为0，但矩阵并不对称。\n2. 有向图入度是一列和，出度是一行和==（出行入列）==\n3. 与无向图同样的办法，判断顶点vi​到vj​是否存在弧，只需要查找矩阵中`A[i][j]`是否为1即可。\n\n邻接矩阵的 存储结构：\n``` C\n#define MaxVertexNum 100\t//顶点数目的最大值\ntypedef char VertexType;\t//顶点的数据类型\ntypedef int EdgeType;\t//带权图中边上权值的数据类型\ntypedef struct{\n\tVertexType Vex[MaxVertexNum];\t//顶点表\n\tEdgeType Edge[MaxVertexNum][MaxVertexNum];\t//邻接矩阵，边表\n\tint vexnum, arcnum;\t//图的当前顶点数和弧树\n}MGraph;\n```\n- 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。\n- 当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。\n- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。\n- 邻接矩阵表示法的空间复杂度为O(n^2)， 其中n为图的顶点数|V|\n- 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。\n- ==稠密图==适合使用邻接矩阵的存储表示。\n- `A^n[i][j]`表示从顶点 i 到 j 的长度为 n 的路径数目\n  ![Pasted image 20250312110923|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312110923.png)\n\n### 邻接表（顺序+链式）\n   结合顺序+链序存储，不唯一\n   对于==稀疏图==，采用邻接表表示将极大地节省存储空间\n![Pasted image 20250311145242|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311145242.png)\n   - **无向图**：每个顶点的邻接表存储其邻接顶点，总边结点数为 2|E|，所需的存储空间为==O(|V|+2|E|)==\n   - **有向图**：邻接表存储出边，逆邻接表存储入边，总边结点数为 |E|，所需的存储空间为 ==O(|V|+|E|)==\n   有向图邻接表的总结点个数 = 表头结点数（顶点数 ∣V∣） + 表结点数（边数 ∣E∣）\n\n| 操作            | 邻接表    | 邻接矩阵  |\n| ------------- | ------ | ----- |\n| **查找邻边**      | O(1)   | O(n)  |\n| **判断边是否存在**   | O(d)   | O(1)  |\n| **计算出度（有向图）** | O(1)   | O(n)  |\n| **计算入度（有向图）** | O(n+e) | O(n)  |\n| **空间复杂度**     | O(n+e) | O(n2) |\n- **邻接表**：\n    - 适合稀疏图（边数远小于 n^2）。\n    - 需要频繁查找邻边的场景（如DFS/BFS遍历）。\n- **邻接矩阵**：\n    - 适合稠密图（边数接近 n^2）。\n    - 需要频繁判断边是否存在的场景（如最短路径算法）\n\n### 十字链表（有向图）\n\n![Untitled 9 69|Untitled 9 69.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2069.png)\n\n![Screenshot_2023_0824_165443](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0824_165443.png)\n\n顶点节点表三个格子，边节点表四个格子\n弧节点表：\n第一个格子是当前节点的索引\n第二个格子是箭头所指节点的索引\n第三个格子先空着，前两个格子全部写完，再由节点表的第二个格子指向与弧节点表的第二个格子索引值一样的弧节点的第三个格子，弧节点表的第三个格子依次指向下一个索引值一样的边节点，后面没有了写”空“\n第四个格子是当前行的最后一个弧界点就写“空”\n![Pasted image 20250312111806|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312111806.png)\n在十字链表中，既容易找到Vi为尾的弧，也容易找到Vi为头的弧，因而容易求得顶点的出度和入度\n图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。\n\n### 邻接多重表（无向图）\n![Untitled 10 65|Untitled 10 65.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2065.png)\n顶点节点两个格子，弧节点四个格子\n弧节点：\n第一个格子是当前节点的索引\n第三个格子是箭头所指节点的索引（连完之后把线叉掉）\n两两节点一起，顶点节点空格指向所有弧节点中一/三节点索引一样的二/四空格，直到没有写“空 ”\n![Pasted image 20250312113325|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312113325.png)\n\n空间复杂度O(|V|+|E|)\n删除边、结点方便\n\n| 特性     | 邻接矩阵                      | 邻接表                                        | 十字链表             | 邻接多重表            |\n| ------ | ------------------------- | ------------------------------------------ | ---------------- | ---------------- |\n| 空间复杂度  | O(\\|V\\|^2)                | 无向图：O(\\|V\\| + 2\\|E\\|) 有向图：O(\\|V\\| + \\|E\\|) | O(\\|V\\| + \\|E\\|) | O(\\|V\\| + \\|E\\|) |\n| 找相邻边   | 遍历对应行或列，时间复杂度O(\\|V\\|) | 找有向图的入边需遍历整个邻接表                            | 很方便              | 很方便              |\n| 删除边或顶点 | 删边方便，删顶点需大量移动数据           | 无向图中删边或顶点都不方便                              | 很方便              | 很方便              |\n| 适用于    | 稠密图                       | 稀疏图和其他                                     | 只能存有向图           | 只能存无向图           |\n| 表示方式   | 唯一                        | 不唯一                                        | 不唯一              | 不唯一              |\n\n| 图类型     | 存储结构  | 操作类型         | 时间复杂度说明                                   |\n| ------- | ----- | ------------ | ----------------------------------------- |\n| **无向图** | 邻接矩阵  | 查找相邻边        | 遍历对应行 / 列，时间复杂度 O(\\|V\\|)（\\|V\\|为顶点数）       |\n|         |       | 删除边          | 直接修改矩阵元素，时间复杂度 O(1)                       |\n|         |       | 计算顶点的度       | 统计对应行 / 列非零元素个数，时间复杂度 O(\\|V\\|)            |\n|         | 邻接表   | 查找相邻边        | 遍历顶点对应链表，时间复杂度 O(d)（d为顶点度）                |\n|         |       | 删除边          | 需遍历链表找到对应边结点，时间复杂度 O(d)                   |\n|         |       | 计算顶点的度       | 统计顶点对应链表的结点数，时间复杂度 O(d)                   |\n|         | 邻接多重表 | 查找相邻边        | 通过指针直接定位关联边，时间复杂度 O(1)（理想情况，实际与存储组织相关）    |\n|         |       | 删除边          | 标记或移除边结点，时间复杂度 O(1)（需提前定位边，定位时间另计）        |\n|         |       | 计算顶点的度       | 统计顶点关联的边结点数，时间复杂度 O(d)                    |\n| **有向图** | 邻接矩阵  | 查找出边         | 遍历对应行，时间复杂度 O(\\|V\\|)                      |\n|         |       | 查找入边         | 遍历对应列，时间复杂度 O(\\|V\\|)                      |\n|         |       | 删除边（出边 / 入边） | 直接修改矩阵元素，时间复杂度 O(1)                       |\n|         |       | 计算出度         | 统计对应行非零元素个数，时间复杂度 O(\\|V\\|)                |\n|         |       | 计算入度         | 统计对应列非零元素个数，时间复杂度 O(\\|V\\|)                |\n|         | 邻接表   | 查找出边         | 遍历顶点对应链表，时间复杂度 O(d出)（d出为出度）               |\n|         |       | 查找入边         | 需遍历全表，时间复杂度 O(\\|V\\| + \\|E\\|)（\\|E\\|为边数）    |\n|         |       | 删除出边         | 遍历链表找到对应边结点，时间复杂度 O(d出)                   |\n|         |       | 计算出度         | 统计顶点对应链表的结点数，时间复杂度 O(d出)                  |\n|         |       | 计算入度         | 需遍历全表统计，时间复杂度 O(\\|V\\| + \\|E\\|)            |\n|         | 十字链表  | 查找出边 / 入边    | 通过结点指针直接定位，时间复杂度 O(1)（理想情况，实际与存储组织相关）     |\n|         |       | 删除边（出边 / 入边） | 调整指针关系，时间复杂度 O(1)（需提前定位边，定位时间另计）          |\n|         |       | 计算出度 / 入度    | 直接读取结点记录的出度 / 入度值（十字链表可存储度数信息），时间复杂度 O(1) |\n\n稀疏矩阵用三元组：(x,y,z):(行，列，非零值）的顺序表；十字链表（有向图）存储\n\n## 图的遍历\n### 深度优先遍历（DFS）\n1. **核心思想**：\n   - 类似树的**先序遍历**，沿着一条路径尽可能深入探索，直到无法继续时回溯。\n   - ==递归==或显式使用==栈==实现。\n\n2. **特点**：\n   - **树高较大**：DFS 的递归深度或栈深度可能接近图的顶点数（如单链结构）。\n   - **空间复杂度**：最坏情况下为O(|V|) ，由递归栈深度或显式栈大小决定。\n\n3. **时间复杂度**：\n   - **邻接矩阵**： O(|V|^2) 。\n     - 每个顶点需遍历所有其他顶点以查找邻接点。\n   - **邻接表**： O(|V| + |E|) 。\n     - 仅遍历实际存在的边。\n\n4. **适用场景**：\n   - **稠密图**（邻接矩阵效率更高）。\n   - **拓扑排序**、**强连通分量**（如 Tarjan 算法）。\n### 广度优先遍历（BFS）\n1. **核心思想**：\n   - 类似树的**层序遍历**，逐层访问顶点。\n   - 使用==队列==作为辅助数据结构，**每个顶点仅入队一次**。\n\n2. **特点**：\n   - **最短路径**：BFS 天然适合求解无权图的最短路径问题。\n   - **连通分量**：通过 BFS 可遍历一个连通分量中的所有顶点。\n\n3. **时间复杂度**：\n   - **邻接矩阵**： O(|V|^2) 。\n   - **邻接表**： O(|V| + |E|) 。\n\n4. **适用场景**：\n   - **稀疏图**（邻接表更高效）。\n   - **社交网络分析**（如六度分隔理论）。\n\n#### **生成树与生成森林**\n1. **广度优先生成树**：\n   - **邻接表不唯一性**：邻接表中顶点的邻接顺序不固定，导致生成树结构可能不同。\n   - **邻接矩阵唯一性**：邻接矩阵的邻接顺序固定（按顶点编号），生成树唯一。\n\n2. **广度优先生成森林**：\n   - 针对非连通图，每个连通分量生成一棵广度优先生成树。\n\n| 特性    | DFS                          | BFS                          |\n| ----- | ---------------------------- | ---------------------------- |\n| 遍历方式  | 深度优先（单路径深入）                  | 广度优先（逐层扩展）                   |\n| 数据结构  | 栈（递归或显式栈）                    | 队列                           |\n| 空间复杂度 | O(∣V∣)（最坏情况）                 | O(∣V∣)（队列存储顶点）               |\n| 时间复杂度 | 邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣) | 邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣) |\n| 应用场景  | 拓扑排序、路径存在性检测                 | 最短路径、连通分量统计                  |\n#### **关键结论**\n- **时间复杂度与存储结构的关系**：\n  - 邻接矩阵需遍历所有顶点，时间复杂度较高；邻接表仅遍历实际边，效率更高。\n- **生成树的唯一性**：\n  - 邻接表因邻接顺序不固定，生成树可能不唯一；邻接矩阵生成树唯一。\n- **空间复杂度**：\n  - DFS 和 BFS 的最坏空间复杂度均为O(|V|) ，与搜索路径无关。\n\n\n\n\n## 错题\n1. 一个有 28 条边的非连通无向图至少有()个顶点。7/8/9/10\n   为了使顶点数最小，应使其中一个连通分量为孤立顶点（无边），另一个连通分量为完全图（边数最多），完全图边数n(n-1)/2，可得n=8，总顶点数=n+1=9\n2. 在有n个顶点的有向图中，顶点的度最大可达() A. n B. n-1 C.2n D.2n-2\n   在有向图中，顶点的度等于入度与出度之和。n个顶点的有向图中，任意一个顶点最多还可以与其他n-1个顶点有一对指向相反的边相连。注意，数据结构中仅讨论简单图。\n3. ![Pasted image 20250311161002](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311161002.png)一个连通图的生成树是一个极小连通子图，显然它是无环的，因此选项 Ⅱ、 正确。极大连通子图称为连通分量，G'连通但非连通分量。这里再补充一下“极大连通子图”:若图本来就是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。\n4. 具有51个顶点和21条边的无向图的连通分量最多为 A. 33 B.34 C. 45 D.32\n   要想连通分量最多，就要使图中孤立的点数量最多（每一个孤立的点都是一个连通分量）  问题转为最少用多少点可连21条边，设用x个点.则有x(x-1)/2≥21，得xmin=7  ，这7个点作为1个连通分量，剩余51-7=44个孤立的点，每一个点作为一个连通分量，故连通分量最多为1+(51-7)=45个\n5. 在如下图所示的有向图中，共有()个强连通分量。1/2/3/4\n   ![Pasted image 20250311162046|150](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311162046.png)2个，b和其他\n6. 若具有 n个顶点的图是一个环，则它有()棵生成树 A. n B. n C. n-1 D.1\n   环图删除任意一条边可形成生成树，共有 nn 种选择\n7. 若一个具有 n个顶点、e条边的无向图是一个森林，则该森林中必有()棵树。\n   A.n  B.e  C.n-e  D.1\n   n个结点的树有n—1条边，假设有x棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是n+1，边数是e+x，从而可知x=n—e，也就是n—e棵树了\n8. 下列关于无向连通图特性的叙述中，正确的是()\n   I.所有顶点的度之和为偶数\n   II.边数大于顶点个数减1\n   III.至少有一个顶点的度为1\n   A. 只有I    B.只有II    C.I和II    D.I和III\n   - I正确（度数之和为边数两倍，必为偶数）。\n   - II错误（树结构边数 n−1，不大于顶点数减1）。\n   - III错误（环图所有顶点度为2）。\n1. 若无向图 G=(V,E)中含有6个顶点，要保证图 G在任何情况下都是连通的，则需要的边数最少是() 8/9/10/11\n   特定情况下6条，就连通；任意情况下，==n-1个点的完全图+单独出去的一条边连剩下一个点==，答案是11。如果题目求的是有向图，==n-1个点的有向完全图+单独出去的一条边连剩下一个点==，答案是21![Pasted image 20250311165458|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165458.png)\n2. 对于无向图G=(V,E)，下列选项中，正确的是()。\n    A.|V|>|E|时，G 一定是连通的\n    B.当|V|<|E|时，G一定是连通的\n    C.当|V|=|E|-1时，G一定是不连通的\n    D.当|V|=|E|+1时，G一定是不连通的\n    d![Pasted image 20250311171144](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311171144.png)\n3. 用有向无环图描述表达式(x+y)((x+y)/x)，需要的顶点个数至少是5/6/8/9\n    ![Pasted image 20250311165839|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165839.png)5\n4. ![Pasted image 20250312122108](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312122108.png)bd\n5. 假设有 n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)\n    **删出边**：遍历v的顶点表结点及其边表，删除出边，最多n-1条，时间复杂度O(n)。\n    **删入边**：扫描整个边表（含剩余顶点表结点及边表），删除v的入边，时间复杂度O(n+e)。\n6. 假设有 n个顶点、e条边的有向图用邻接表表示，则某个顶点v的入度时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)\n    为了求顶点v的入度，只需要遍历邻接表中的所有边表，检查每条边是否指向顶点\"，这相当于遍历整个邻接表，因此算法的时间复杂度为 O(n+e)。\n7. 无向图邻接多重表求顶点b，d的度![Pasted image 20250312125659|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312125659.png)\n    b的入度1，出度2；d的入度1，出度3\n8.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2024/11/23/Redis/","content":"# Redis\n\n[黑马点评1](https://www.notion.so/1-133d2775339a8027b65cf4a2fa4776a6?pvs=21)\n\n[黑马点评2](https://www.notion.so/2-137d2775339a807eaf12c3684a75bee5?pvs=21)\n\n[黑马点评3](https://www.notion.so/3-13dd2775339a80db9b7bfe8444b8a975?pvs=21)\n\n[黑马点评4](https://www.notion.so/4-13dd2775339a80078852e9fb3d26d39a?pvs=21)\n\n[https://redis.io/](https://redis.io/)\n\n# NoSQL\n\nRedis是一种键值型的NoSQL数据库\n\n`NoSql`可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为`非关系型数据库`。\n\n- **结构化与非结构化**\n\n    传统关系型数据库是结构化数据，每张表在创建的时候都有严格的约束信息，如字段名、字段数据类型、字段约束等，插入的数据必须遵循这些约束。而NoSQL则对数据库格式没有约束，可以是键值型，也可以是文档型，甚至是图格式\n\n- **关联与非关联**\n\n    传统数据库的表与表之间往往存在关联，例如外键约束\n\n    而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合\n\n    ![image.png](images/images/image.png)\n\n- 事务\n\n    传统关系型数据库能满足事务的ACID原则(原子性、一致性、独立性及持久性)，而非关系型数据库无法全部满足\n\n\n常见的NoSQL数据库有：`Redis`、`MemCache`、`MongoDB`等\n\n## SQL VS NoSQL\n\n|  | SQL | NoSQL |\n| --- | --- | --- |\n| 数据结构 | 结构化 | 非结构化 |\n| 数据关联 | 关联的 | 无关联的 |\n| 查询方式 | SQL查询 | 非SQL |\n| 事务特性 | ACID | BASE |\n| 存储方式 | 磁盘 | 内存 |\n| 扩展性 | 垂直 | 水平 |\n| 使用场景 | 1）数据结构固定2）相关业务对数据安全性、一致性要求较高 | 1）数据结构不固定2）对一致性、安全性要求不高3）对性能要求高 |\n- 存储方式\n    - 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响\n    - 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些\n- 扩展性\n    - 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。\n    - 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。\n    - 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦\n\n# Redis VS MySQL\n\n**Redis：**Remote Dictionary Server远程词典服务器\n\n- **内存存储**：Redis 是一个基于**内存**的 **Key-Value** 数据库，主要将数据存储在内存中，读写速度非常快。其性能优势在于数据能够在几微秒内完成读写操作，因此适合对响应时间要求较高的场景。\n- 单线程，每个命令具有原子性\n- 低延迟，速度快(基于内存、IO多路复用、良好的编码)\n- **持久化**：虽然 Redis 是内存数据库，但它支持将数据持久化到磁盘中以避免数据丢失。常见的持久化机制有 RDB 和 AOF。\n- **数据类型丰富**：除了简单的字符串类型，Redis 还支持哈希、列表、集合、有序集合等数据结构，适合不同业务场景的数据操作。\n- 支持主从集群、分片集群\n- 支持多语言客户端\n- **应用场景**：\n    - **缓存**：用于存储热点数据，如热点商品、新闻、排行榜等，减少对数据库的压力。\n    - **会话管理**：在分布式应用中，Redis 常用来存储用户会话信息。\n    - **计数器和限流器**：由于 Redis 的高性能，常用来实现各类实时计数操作，如商品点击量统计。\n    - **消息队列**：Redis 还可以用于实现简单的消息队列功能。\n\n**MySQL：**\n\n- **磁盘存储**：MySQL 是一个基于**磁盘**的关系型数据库，数据存储在磁盘中，并使用索引等机制来优化查询性能。\n- **结构化数据**：MySQL 适合处理结构化的**二维表**数据，支持复杂的 SQL 查询，事务处理能力强，保证数据一致性。\n- **持久化和事务性**：MySQL 的数据持久存储在磁盘上，即使服务器宕机，数据也能安全保存。同时，MySQL 支持 ACID 事务，确保数据操作的原子性和一致性。\n- **应用场景**：\n    - **结构化数据存储**：如用户信息、订单数据等需要通过关系表存储和查询的数据。\n    - **事务处理**：MySQL 在复杂的事务处理中表现良好，适合需要高数据一致性的场景，如银行、财务等系统。\n\n## 结合应用场景\n\n- **缓存**：Redis 通常作为 MySQL 的缓存层，用于加速查询。MySQL 负责持久存储，而 Redis 则存储热点数据，减轻 MySQL 压力，提升系统的整体性能。\n- **高并发场景**：对于短时间内大量访问的热点数据（如电商秒杀、新闻排行榜），将其存储在 Redis 中以提供更高效的读写性能。\n- **企业广泛应用**：Redis 和 MySQL 的结合在现代互联网公司中非常常见，既保障了数据的持久性和一致性（通过 MySQL），又提供了高速缓存和高并发处理能力（通过 Redis）。\n\n这种组合能够很好地满足企业级应用中对高并发处理和数据持久化的不同需求。\n\n中文文档：[Redis 教程_redis教程](https://www.redis.net.cn/tutorial/3501.html)\n\n# 使用\n\n## windows安装\n\n![image.png](images/image%201.png)\n\n在redis安装目录下打开cmd\n\n启动：输入redis-server.exe redis.windows.conf\n\n停止：Ctrl+C\n\n客户端连接：再次在redis安装目录下打开cmd，输入redis-cli.exe\n\n默认连接6379\n\n![image.png](images/images/image%202.png)\n\n更改连接地址\n\n![image.png](images/images/image%203.png)\n\n设置密码：删除注释，requirepass顶格，修改foobared为密码\n\n![image.png](images/images/image%204.png)\n\nredis-cli.exe -h localhost -p 6379 -a 123456\n\n可视化界面连接\n\n![image.png](images/image%205.png)\n\n## Linux安装\n\nsudo apt update\nsudo apt install -y gcc tcl\n\n下载redis-6.2.6.tar.gz\n\n**`cd`到`/usr/local/src`目录执行以下命令进行解压操作**\n\n```\ntar -xzf redis-6.2.6.tar.gz\n```\n\n**解压成功后依次执行以下命令**\n\n```\ncd redis-6.2.6\nmake\nmake install\n```\n\n![image.png](images/image%206.png)\n\n### 启动redis\n\n- 前台启动【不推荐】：会阻塞整个会话窗口，窗口关闭或者按下`CTRL + C`则Redis停止。不推荐使用。\n\n    **安装完成后，在任意目录输入`redis-server`命令即可启动Redis**\n\n- 后台启动【不推荐】：必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下\n    - 因为我们要修改配置文件，因此我们需要先将原文件备份一份\n\n        ```bash\n        cd /usr/local/src/redis-6.2.6\n        ```\n\n        ```bash\n        cp redis.conf redis.conf.bck\n        ```\n\n    - 然后修改`redis.conf`文件中的一些配置\n\n        ```bash\n        # 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0\n        # 守护进程，修改为yes后即可后台运行\n        daemonize yes\n        # 密码，设置后访问Redis必须输入密码\n        requirepass 123456\n        ```\n\n    - Redis其他常用配置\n\n        ```bash\n        # 监听的端口\n        port 6379\n        # 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录\n        dir .\n        # 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15\n        databases 1\n        # 设置redis能够使用的最大内存\n        maxmemory 512mb\n        # 日志文件，默认为空，不记录日志，可以指定日志文件名\n        logfile \"redis.log\"\n        ```\n\n    - **启动Redis**\n\n        ```bash\n        # 进入redis安装目录cd /usr/local/src/redis-6.2.6\n        # 启动\n        redis-server redis.conf\n        ```\n\n    - **停止Redis服务**\n\n        ```bash\n        通过 ps -ef | grep redis查询pid\n        # 通过kill命令直接杀死进程kill -9 redis进程ids\n        ```\n\n        ```bash\n        # 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -a 来指定密码\n        redis-cli -a 132537 shutdown\n        ```\n\n- **开机自启【推荐】**\n\n    通过配置来实现开机自启\n\n    - 首先，新建一个系统服务文件\n\n        ```bash\n        vi /etc/systemd/system/redis.service\n        ```\n\n    - 将以下命令粘贴进去\n\n        ```bash\n        [Unit]\n        Description=redis-server\n        After=network.target\n\n        [Service]\n        // Type=forking 不知道为什么这行不删掉启动超时\n        ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\n        PrivateTmp=true\n\n        [Install]\n        WantedBy=multi-user.target\n        ```\n\n    - 然后重载系统服务\n\n        ```bash\n        systemctl daemon-reload\n        ```\n\n    - 现在，我们可以用下面这组命令来操作redis了\n\n        ```bash\n        # 启动\n        systemctl start redis\n        # 停止\n        systemctl stop redis\n        # 重启\n        systemctl restart redis\n        # 查看状态\n        systemctl status redis\n        ```\n\n    - 执行下面的命令，可以让redis开机自启\n\n        ```bash\n        systemctl enable redis\n        ```\n\n\n# 数据类型\n\n**Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样**\n\n![image-20220524205926164.png](images/image-20220524205926164.png)\n\n![701cbe108e6e43bebf491be26887bf55.png](701cbe108e6e43bebf491be26887bf55.png)\n\n![image.png](images/image%207.png)\n\n- hash 适合存储对象\n- list 按照插入顺序排序，可以有重复元素 eg.朋友圈点赞列表\n- set 无序集合，没有重复元素 eg.qq共同好友\n- sorted set 有序集合，没有重复元素eg.排行榜\n\n### **Key结构**\n\n- Redis没有类似MySQL中Table的概念，那么我们该如何区分不同类型的Key呢？\n- 例如：需要存储用户、商品信息到Redis，有一个用户的id是1，有一个商品的id恰好也是1，如果此时使用id作为key，那么就回冲突，该怎么办？\n- 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范\n    - Redis的key允许有多个单词形成层级结构，多个单词之间用`:`隔开，格式如下`项目名:业务名:类型:id`\n    - 这个格式也并非是固定的，可以根据自己的需求来删除/添加词条，这样我们就可以把不同数据类型的数据区分开了，从而避免了key的冲突问题\n    - 例如我们的项目名叫reggie，有user和dish两种不同类型的数据，我们可以这样定义key\n        - user相关的key：`reggie:user:1`\n        - dish相关的key：`reggie:dish:1`\n- 如果value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储\n\n\n    | KEY | VALUE |\n    | --- | --- |\n    | reggie:user:1 | {“id”:1, “name”: “Jack”, “age”: 21} |\n    | reggie:dish:1 | {“id”:1, “name”: “鲟鱼火锅”, “price”: 4999} |\n- 并且在Redis的桌面客户端中，也会以相同前缀作为层次结构，让数据看起来层次分明，关系清晰\n\n### 1. **String（字符串）**\n\n- **描述**：Redis 中最基本的数据类型，每个键都对应一个字符串类型的值。可以是文本或二进制数据（如图片、视频等）。\n\n    value是字符串，不过根据字符串的格式不同，又可以分为3类\n\n    - `string`：普通字符串\n    - `int`：整数类型，可以做自增、自减操作\n    - `float`：浮点类型，可以做自增、自减操作不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同，字符串类型的最大空间不能超过512M\n\n    | 命令 | 描述 |\n    | --- | --- |\n    | SET | 添加或者修改一个已经存在的String类型的键值对 |\n    | GET | 根据key获取String类型的value |\n    | MEST | 批量添加多个String类型的键值对 |\n    | MGET | 根据多个key获取多个String类型的value |\n    | INCR | 让一个整型的key自增1，适用于计数器 |\n    | INCRBY | 让一个整形的key自增并指定步长值，例如：incrby num 2，让num值自增2 |\n    | INCRBYFLOAT | 让一个浮点类型的数字自增并指定步长值 |\n    | `SET key seconds value` | 设置键 `key` 对应的值为 `value` ，并将key的过期时间设为seconds秒。eg.验证码过期 |\n    | `SETNX key value` | 添加一个String类型的键值对，前提是这个key不存在，否则不执行，可以理解为真正的新增。eg.分布式锁 |\n    | `SETEX key seconds value` | 添加一个String类型的键值对，并指定有效期（s），一旦时间到了，Redis 会自动删除该键。 |\n    | APPEND | 在键 `key` 的值后追加内容 |\n- **应用场景**：\n    - **缓存对象的简单属性**：如用户的登录状态、验证码、单个配置项。\n    - **计数器**：用户浏览次数、点赞数等。\n\n更多命令：[Redis 字符串(String)_redis教程](https://www.redis.net.cn/tutorial/3508.html)\n\n```java\n127.0.0.1:6379> set name xiaoming\nOK\n127.0.0.1:6379> get name\n\"xiaoming\"\n127.0.0.1:6379> get age\n(nil)\n127.0.0.1:6379> set age 20\nOK\n127.0.0.1:6379> get age\n\"20\"\n127.0.0.1:6379> set age 30\nOK\n127.0.0.1:6379> get age\n\"30\"\n127.0.0.1:6379> setex city 10 beijing\nOK\n127.0.0.1:6379> get city\n\"beijing\"\n127.0.0.1:6379> get city\n(nil)\n127.0.0.1:6379> setnx k1 v1\n(integer) 1\n127.0.0.1:6379> setnx k1 v2\n(integer) 0\n127.0.0.1:6379> get k1\n\"v1\"\n```\n\nset命令会转成字符串存储\n\n### 2. **Hash（哈希）**\n\n- **描述**：也叫散列，其中value是一个无序字典，类似于Java中的HashMap结构。适用于存储对象，类似于一个小型的键值对集合。一个键对应一个哈希表，可以存储多个字段和字段值\n\n    ![image.png](images/image%208.png)\n\n    String结构是将对象序列化为JSON字符串后存储，当我们要修改对象的某个属性值的时候很不方便\n\n    Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD\n\n    ![image.png](images/image%209.png)\n\n    | 命令 | 描述 |\n    | --- | --- |\n    | HSET key field value | 添加或者修改hash类型key的field的值 |\n    | HGET key field | 获取一个hash类型key的field的值 |\n    | HDEL key field | 删除指定字段 |\n    | HMSET | 批量添加多个hash类型key的field的值 |\n    | HMGET | 批量获取多个hash类型key的field的值 |\n    | HGETALL | 获取一个hash类型的key中的所有的field和value |\n    | HKEYS key | 获取一个hash类型的key中的所有的字段 |\n    | HVALS key | 获取一个hash类型的key中的所有的值 |\n    | HINCRBY | 让一个hash类型key的字段值自增并指定步长 |\n    | HSETNX | 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 |\n    | HGETALL key | 获取一个hash类型的key中的所有的字段和值 |\n- **应用场景**：\n    - **存储用户信息**：如用户的基本资料（姓名、年龄、地址等），将用户的各个属性存储为哈希表的字段。\n\n```java\n127.0.0.1:6379> hset 001 name xiaoming\n(integer) 1\n127.0.0.1:6379> hset 001 age 20\n(integer) 1\n127.0.0.1:6379> hget 001 name\n\"xiaoming\"\n127.0.0.1:6379> hget 001 age\n\"20\"\n127.0.0.1:6379> hdel 001 age\n(integer) 1\n127.0.0.1:6379> hget 001 age\n(nil)\n127.0.0.1:6379> hkeys 001\n1) \"name\"\n127.0.0.1:6379> hset 001 age 30\n(integer) 1\n127.0.0.1:6379> hkeys 001\n1) \"name\"\n2) \"age\"\n127.0.0.1:6379> hvals 001\n1) \"xiaoming\"\n2) \"30\"\n127.0.0.1:6379> hgetall 001\n1) \"name\"\n2) \"xiaoming\"\n3) \"age\"\n4) \"30\"\n```\n\n### 3. **List（列表）**\n\n- **描述**：列表类型是**有序**的字符串集合，可以包含**重复**元素。列表中的元素按照插入顺序排序。支持从两端插入或删除元素。与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\n\n    ![image.png](images/image%2010.png)\n\n    - 特征也与LinkedList类似：\n        - 有序\n        - 元素可以重复\n        - 插入和删除快\n        - 查询速度一般\n\n    常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\n\n    | 命令 | 描述 |\n    | --- | --- |\n    | LPUSH key value1 … | 向列表左侧插入一个或多个元素 |\n    | RPUSH key value1 … | 向列表右侧插入一个或多个元素 |\n    | LPOP key | 移除并返回列表左侧的第一个元素，没有则返回nil |\n    | RPOP key | 移除并返回列表右侧的第一个元素 |\n    | LLEN key | 获取列表长度 |\n    | LRANGE key star end | 返回一段角标范围内的所有元素。 lrange list 0 -1返回所有元素 |\n    | BLPOP和BRPOP | 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil |\n    | BRPOP key1 [key2] timeout | 移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 |\n\n    如何利用List结构模拟一个栈?\n    入口和出口在同一边\n\n    如何利用List结构模拟一个队列?\n    入口和出口在不同边\n\n    如何利用List结构模拟一个阻塞队列?\n    入口和出口在不同边\n    出队时采用BLPOP或BRPOP\n\n- **应用场景**：适合存储按时间顺序排列的数据\n    - **消息队列**：利用 `LPUSH` 和 `RPOP` 可以实现先进先出的消息队列。\n    - **朋友圈点赞列表**：按时间顺序存储点赞用户的列表。\n    - **评论区**\n\n```java\n127.0.0.1:6379> lpush list a b c\n(integer) 3\n127.0.0.1:6379> lrange list 0 -1\n1) \"c\"\n2) \"b\"\n3) \"a\"\n127.0.0.1:6379> lpush list zhang\n(integer) 4\n127.0.0.1:6379> lrange list 0 -1\n1) \"zhang\"\n2) \"c\"\n3) \"b\"\n4) \"a\"\n127.0.0.1:6379> lpush list a\n(integer) 5\n127.0.0.1:6379> lrange list 0 -1\n1) \"a\"\n2) \"zhang\"\n3) \"c\"\n4) \"b\"\n5) \"a\"\n127.0.0.1:6379> rpop list\n\"a\"\n127.0.0.1:6379> lrange list 0 -1\n1) \"a\"\n2) \"zhang\"\n3) \"c\"\n4) \"b\"\n127.0.0.1:6379> llen list\n(integer) 4\n127.0.0.1:6379> brpop list 10\n1) \"list\"\n2) \"b\"\n127.0.0.1:6379> brpop list 10\n1) \"list\"\n2) \"c\"\n127.0.0.1:6379> brpop list 10\n1) \"list\"\n2) \"zhang\"\n127.0.0.1:6379> brpop list 10\n1) \"list\"\n2) \"a\"\n127.0.0.1:6379> lrange list 0 -1\n(empty list or set)\n127.0.0.1:6379> brpop list 10\n(nil)\n(10.04s)\n```\n\n`0 -1`：这些参数指定了要检索的元素的范围，从索引 0 开始到索引 `-1` 结束（`-1` 在 Redis 中表示列表的最后一个元素）\n\n`lpush` 命令会将元素添加到列表的头部，所以最后插入的元素 `c` 会成为列表的第一个元素（索引 0），而 `a` 会成为最后一个元素。\n\nbrpop*移除并获取列表 \"list\" 的最后一个元素，如果列表为空，则等待 10 秒，*如果操作成功，`BRPOP` 返回一个包含两个元素的数组：第一个元素是被移除的元素，第二个元素是它所属的列表的键名。\n\n### 4. **Set（集合）**\n\n- **描述**：**无序**集合，集合中的元素是**唯一**的，不能重复。通过**哈希表**实现，所以查找、插入、删除操作的时间复杂度都是 O(1)。\n\n    ![image.png](images/image%2011.png)\n\n    与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\n\n    - 无序\n    - 元素不可重复\n    - 查找快\n    - 支持交集、并集、差集等功能\n\n    | 命令 | 描述 |\n    | --- | --- |\n    | SADD key member … | 向set中添加一个或多个元素 |\n    | SREM key member … | 移除set中的指定元素 |\n    | SCARD key | 返回set中元素的个数 |\n    | SISMEMBER key member | 判断一个元素是否存在于set中 |\n    | SMEMBERS key | 获取key中的所有元素 |\n    | SINTER key1 key2 … | 求key1与key2的交集 |\n    | SUNION key1 key2 … | 求key1与key2的并集 |\n    | SDIFF key1 key2 … | 求key1与key2的差集 |\n- **应用场景**：\n    - **共同好友**：存储用户的好友列表，可以很方便地取两个用户的共同好友。\n    - **标签系统**：存储用户的兴趣标签，方便进行交集和并集的操作。\n\n```java\n127.0.0.1:6379> sadd set a b c d\n(integer) 4\n127.0.0.1:6379> smembers set\n1) \"c\"\n2) \"b\"\n3) \"a\"\n4) \"d\"\n127.0.0.1:6379> sadd set a d\n(integer) 0\n127.0.0.1:6379> smembers set\n1) \"a\"\n2) \"d\"\n3) \"b\"\n4) \"c\"\n127.0.0.1:6379> scard set\n(integer) 4\n127.0.0.1:6379> sadd s a d s o\n(integer) 4\n127.0.0.1:6379> smembers s\n1) \"a\"\n2) \"o\"\n3) \"s\"\n4) \"d\"\n127.0.0.1:6379> sinter set s\n1) \"a\"\n2) \"d\"\n127.0.0.1:6379> sunion set s\n1) \"b\"\n2) \"c\"\n3) \"a\"\n4) \"d\"\n5) \"s\"\n6) \"o\"\n127.0.0.1:6379> sdiff set s\n1) \"c\"\n2) \"b\"\n127.0.0.1:6379> sdiff s set\n1) \"s\"\n2) \"o\"\n127.0.0.1:6379> srem s a b c d\n(integer) 2\n127.0.0.1:6379> smembers s\n1) \"o\"\n2) \"s\"\n```\n\n### 5. **Sorted Set（有序集合）**\n\n- **描述**：是一个可排序的set集合，与集合类似，元素也是**唯一**的，但每个元素都会关联一个double类型的分数（score），Redis 会根据分数从小到大自动排序。元素不能重复，但分数可以相同。与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\n\n    ![image.png](images/image%2012.png)\n\n    - 可排序\n    - 元素不重复\n    - 查询速度快\n\n    | 命令 | 描述 |\n    | --- | --- |\n    | ZADD key score member1… | 添加一个或多个元素到sorted set ，如果已经存在则更新其score值 |\n    | ZREM key member | 删除sorted set中的一个指定元素 |\n    | ZSCORE key member | 获取sorted set中的指定元素的score值 |\n    | ZRANK key member | 获取sorted set 中的指定元素的排名 |\n    | ZCARD key | 获取sorted set中的元素个数 |\n    | ZCOUNT key min max | 统计score值在给定范围内的所有元素的个数 |\n    | ZINCRBY key increment member | 让sorted set中的指定元素自增，步长为指定的increment值 |\n    | ZRANGE key min max | 按照score排序后，获取指定排名范围内的元素 |\n    | ZRANGEBYSCORE key min max | 按照score排序后，获取指定score范围内的元素 |\n    | ZDIFF、ZINTER、ZUNION | 求差集、交集、并集 |\n\n    注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：\n\n    - `升序`获取sorted set 中的指定元素的排名：ZRANK key member\n    - `降序`获取sorted set 中的指定元素的排名：ZREVRANK key memeber\n- **应用场景**：\n    - **排行榜**：如游戏中的积分排行榜，用户的分数决定排名。\n    - **延时队列**：通过分数来表示任务的执行时间，按时间顺序执行任务。\n\n按value排序\n\n```java\n127.0.0.1:6379> zadd sset 10.0 a 9.0 b\n(integer) 2\n127.0.0.1:6379> zrange sset 0 -1\n1) \"b\"\n2) \"a\"\n127.0.0.1:6379> zadd sset 9.5 c\n(integer) 1\n127.0.0.1:6379> zrange sset 0 -1\n1) \"b\"\n2) \"c\"\n3) \"a\"\n127.0.0.1:6379> zrange sset 0 -1 withscores\n1) \"b\"\n2) \"9\"\n3) \"c\"\n4) \"9.5\"\n5) \"a\"\n6) \"10\"\n127.0.0.1:6379> zincrby sset 20 b\n\"29\"\n127.0.0.1:6379> zrange sset 0 -1\n1) \"c\"\n2) \"a\"\n3) \"b\"\n127.0.0.1:6379> zrem sset b\n(integer) 1\n127.0.0.1:6379> zrange sset 0 -1\n1) \"c\"\n2) \"a\"\n```\n\n### **通用命令**\n\n| **指令** | **描述** |\n| --- | --- |\n| KEYS | 查看符合模板的所有key，不建议在生产环境设备上使用，因为Redis是单线程的，执行查询的时候会阻塞其他命令，当数据量很大的时候，使用KEYS进行模糊查询，效率很差 |\n| DEL | 删除一个或多个指定的key |\n| EXISTS | 判断key是否存在，1在0不在 |\n| EXPIRE | 给一个key设置有效期，有效期到期时该key会被自动删除，s单位 |\n| TTL | 查看一个KEY的剩余有效期，s单位，若未设置有效期返回-1 |\n| TYPE | 返回key所存储的值的类型 |\n\n可以通过`help [command]` 可以查看一个命令的具体用法！\n\n```java\n127.0.0.1:6379> keys *\n1) \"001\"\n2) \"sset\"\n3) \"name\"\n4) \"k1\"\n5) \"set\"\n6) \"age\"\n7) \"s\"\n127.0.0.1:6379> exists name\n(integer) 1\n127.0.0.1:6379> exists aaa\n(integer) 0\n127.0.0.1:6379> type name\nstring\n127.0.0.1:6379> type set\nset\n127.0.0.1:6379> type sset\nzset\n127.0.0.1:6379> ttl name\n(integer) -1\n127.0.0.1:6379> setex test 100 zhang\nOK\n127.0.0.1:6379> ttl test\n(integer) 97\n127.0.0.1:6379> del test\n(integer) 1\n```\n\n### Redis 应用广泛的原因：\n\n1. **高性能**：Redis 基于内存存储，具有极高的读写性能，适合存储和访问热点数据。\n2. **多种数据结构**：支持丰富的数据类型，能够处理多种业务场景。\n3. **简单易用**：Redis 提供的命令十分直观，可以快速上手。\n4. **持久化**：虽然 Redis 是内存数据库，但它提供了多种持久化选项以保证数据的安全性。\n5. **企业应用场景**：\n    - 高并发情况下的数据缓存（如商品、新闻、排行榜等）。\n    - 实时统计和计数功能。\n    - 用户会话管理和社交功能中的好友关系处理等。\n\n# **在 Java 中操作 Redis**\n\n目前主流的Redis的Java客户端有三种\n\n- Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。\n- Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。\n\nSpring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即\nspring-boot-starter-data-redis\n\n在 Java 中操作 Redis 时，**Jedis** 和 **Spring Data Redis** 是两种常用的库，它们各有优缺点。以下是它们的比较和使用场景：\n\n- **选择**：\n    - 如果你需要一个简单的、直接的 Redis 客户端，Jedis 是一个不错的选择。\n    - 如果你的应用程序已经使用 Spring，或者你需要更多的功能和集成，Spring Data Redis 将是更好的选择。\n\n## [**Jedis**](https://so.csdn.net/so/search?q=Jedis&spm=1001.2101.3001.7020)\n\n- **概述**：\n    - Jedis 是一个简单的、直观的 Redis 客户端库，提供了基本的 Redis 操作API。\n    - 它是一个轻量级的库，适合直接与 Redis 交互。\n- **优点**：\n    - **简单易用**：Jedis 的 API 设计简单，容易上手。\n    - **直接控制**：开发者可以直接使用 Redis 命令，提供了较高的灵活性。\n- **缺点**：\n    - **管理连接**：需要手动管理 Redis 连接，可能会导致连接池管理和性能问题。\n    - **缺少集成**：与 Spring 的集成不如 Spring Data Redis 方便。\n\nMaven 坐标：\n\n```\n<!--jedis-->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n<!--单元测试-->\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.7.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n注意，运行前要先启动 Redis\n\n使用：\n\n```java\n\npublic class JedisTest {\n\tprivate Jedis jedis;\n\n\t@BeforeEach\n\tvoid setUp() {\n\t\t// 1. 建立连接\n\t\tjedis = new Jedis(\"192.168.40.128\", 6379);\n\t\t// 2. 设置密码\n\t\t// jedis.auth(\"123456\");\n\t\t// 3. 选择库\n\t\tjedis.select(0);\n\t}\n\n\t@Test\n\tvoid testString() {\n\t\tString res = jedis.set(\"name\", \"lr\");\n\t\tSystem.out.println(res);\n\n\t\tString name = jedis.get(\"name\");\n\t\tSystem.out.println(name);\n\t}\n\n\t@AfterEach\n\tvoid testDowm() {\n\t\tif (jedis != null) {\n\t\t\tjedis.close();\n\t\t}\n\t}\n\n\t@Test\n\tvoid testHash() {\n\t\tjedis.hset(\"user:1\", \"name\", \"Jack\");\n\t\tjedis.hset(\"user:1\", \"age\", \"17\");\n\t\tjedis.hset(\"user:2\", \"name\", \"Rose\");\n\t\tMap<String, String> map = jedis.hgetAll(\"user:1\");\n\t\tSystem.out.println(map);\n\t}\n}\n```\n\n- `Jedis`本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。\n- 新建一个`util`，用于存放我们编写的工具类\n\n    ```java\n    public class JedisConnectionFactory {\n    \tprivate static final JedisPool jedisPool;\n\n    \tstatic {\n    \t\t// 配置连接池\n    \t\tJedisPoolConfig poolConfig = new JedisPoolConfig();\n    \t\t// 最大连接\n    \t\tpoolConfig.setMaxTotal(8);\n    \t\t// 最大空闲连接\n    \t\tpoolConfig.setMaxIdle(8);\n    \t\t// 最小空闲连接\n    \t\tpoolConfig.setMinIdle(0);\n    \t\t// 设置最长等待时间，ms\n    \t\tpoolConfig.setMaxWaitMillis(200);\n    \t\t// 创建连接池对象\n    \t\tjedisPool = new JedisPool(poolConfig, \"192.168.40.128\", 6379, 1000); // host,port,timeout,[password]\n    \t}\n\n    \tpublic static Jedis getJedis() {\n    \t\treturn jedisPool.getResource();\n    \t}\n    }\n\n    \t\tjedis = JedisConnectionFactory.getJedis();\n    ```\n\n- 但后面我们使用`SpringDataRedis`的时候，可以直接在`yml`配置文件里配置这些内容\n\n## **Spring Data Redis**\n\n[https://spring.io/projects/spring-data-redis](https://spring.io/projects/spring-data-redis)\n\n- **概述**：\n    - Spring Data Redis 是一个用于 Spring 应用程序的 Redis 数据访问库，提供了更高级别的抽象和 Spring 生态系统的集成。\n- **优点**：\n    - **易于集成**：与 Spring 框架无缝集成，支持 Spring 的注解和依赖注入。\n    - **自动化管理**：提供了对连接池的管理，简化了 Redis 连接的创建和管理。\n    - **高级特性**：支持 Redis 的许多高级特性，如事务、发布/订阅、消息队列、哨兵、集群等\n    - 提供了对不同Redis客户端的整合（Lettuce和Jedis）\n    - 提供了RedisTemplate统一API来操作Redis\n    - 支持基于Lettuce的响应式编程\n    - 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化\n    - 支持基于Redis的JDKCollection实现\n\nSpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：\n\n| API | 返回值类型 | 说明 |\n| --- | --- | --- |\n| redisTemplate.opsForValue() | ValueOperations | 操作String类型数据 |\n| redisTemplate.opsForHash() | HashOperations | 操作Hash类型数据 |\n| redisTemplate.opsForList() | ListOperations | 操作List类型数据 |\n| redisTemplate.opsForSet() | SetOperations | 操作Set类型数据 |\n| redisTemplate.opsForzSet() | ZSetOperations | 操作SortedSet类型数据 |\n| redisTemplate |  | 通用的命令 |\n\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class RedisService {\n\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    public void setValue(String key, String value) {\n        redisTemplate.opsForValue().set(key, value);\n    }\n\n    public String getValue(String key) {\n        return redisTemplate.opsForValue().get(key);\n    }\n}\n```\n\n### 操作步骤：\n\n- 导入Spring Data Redis 的maven坐标\n- 配置Redis数据源\n- 编写配置类，创建RedisTemplate对象\n- 通过RedisTemplate对象操作Redis\n\n### **1. 导入依赖**\n\nMaven 坐标：\n\n```xml\n<!--redis依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<!--common-pool-->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n<!--Jackson依赖-->\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n</dependency>\n<!--lombok-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n### **2. application.yml**\n\n```java\nspring:\n  data:\n    redis:\n      host: 192.168.40.128\n      port: 6379\n      #      password: '123456'\n      database: 1\n      jedis:\n        pool:\n          max-active: 8\n          max-idle: 8\n          min-idle: 0\n          max-wait: 100ms\n```\n\n### 3. 编写配置类，创建RedisTemplate对象\n\n```java\npackage com.sky.config;\n@Configuration\n@Slf4j\npublic class RedisConfiguration {\n\t@Bean\n\tpublic RedisTemplate redisTemplate (RedisConnectionFactory redisConnectionFactory) {\n\t\tlog.info(\"开始创建redis模板对象\");\n\t\t// 是 Spring Data Redis 提供的核心类，用于对 Redis 进行各种操作\n\t\tRedisTemplate redisTemplate = new RedisTemplate();\n\t\t// 设置 Redis 的连接工厂，用来与 Redis 服务器建立连接\n\t\tredisTemplate.setConnectionFactory(redisConnectionFactory);\n\t\t// 将 Redis 的 key 设置为字符串序列化，这样所有 key 会以可读的字符串形式存储。\n\t\tredisTemplate.setKeySerializer(new StringRedisSerializer());\n\t\treturn redisTemplate;\n\t}\n}\n```\n\n### **RedisTemplate 的序列化器设置**\n\nRedisTemplate可以接收任意Object作为值写入Redis\n\n只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果\\xAC\\xED\\x00\\x05t\\x00\\x06\\xE5\\xBC\\xA0\\xE4\\xB8\\x89\n\n缺点：\n\n- 可读性差\n- 内存占用较大\n\n在Spring Data Redis中，`RedisTemplate` 是一个核心组件，用于操作Redis数据库。默认情况下，`RedisTemplate` 使用 `JdkSerializationRedisSerializer` 作为其键（Key）的序列化器，这意味着键将使用Java标准序列化机制进行序列化。\n\n当您执行如下操作：\n\n```java\nredisTemplate.opsForValue().set(\"city123\", \"beijing\");\n```\n\n键 `\"city123\"` 将被序列化为一个二进制形式，如在Redis命令行中通过 `keys *` 命令看到的那样。\n\n为了避免使用Java标准序列化，您可以通过自定义 `RedisTemplate` 的序列化器来更改这一行为。通常，对于值（Value），不需要更改序列化器，因为从Redis中获取时将自动进行反序列化。\n\n1. 默认行为\n\n    `RedisTemplate` 默认使用 `JdkSerializationRedisSerializer` 来序列化键。这意味着键会被序列化为二进制格式，可能不利于可读性和调试。\n\n2. 自定义序列化器\n\n    通过将键序列化器设置为 `StringRedisSerializer`，你可以确保所有的键都以字符串形式存储和读取。这提高了可读性，并且使得在使用 Redis CLI 或其他工具时，更容易查看和管理数据。\n\n    ```java\n    @Configuration\n    public class RedisConfig extends CachingConfigurerSupport {\n        @Bean\n        public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n            RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n\n            // 设置键的序列化器\n            redisTemplate.setKeySerializer(new StringRedisSerializer());\n            redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n\n            // 设置连接工厂\n            redisTemplate.setConnectionFactory(connectionFactory);\n\n            return redisTemplate;\n        }\n    }\n    ```\n\n3. 值的序列化器\n\n    对于值的序列化，通常你可以保持默认设置，因为当你从 Redis 中获取值时，它会自动反序列化为 Java 对象。你可以根据需求更改值的序列化器，例如使用 `Jackson2JsonRedisSerializer` 以便将对象序列化为 JSON 格式：\n\n    ```java\n    @Configuration\n    @Slf4j\n    public class RedisConfiguration {\n    \t@Bean\n    \tpublic RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n    \t\tRedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n\n    \t\t// 键的序列化器\n    \t\tredisTemplate.setKeySerializer(new StringRedisSerializer());\n    \t\tredisTemplate.setHashKeySerializer(new StringRedisSerializer());\n\n    \t\t// 值的序列化器\n    \t\tGenericJackson2JsonRedisSerializer jsonRedisSerializer =\n    \t\t\t\tnew GenericJackson2JsonRedisSerializer();\n    \t\tredisTemplate.setValueSerializer(jsonRedisSerializer);\n    \t\tredisTemplate.setHashValueSerializer(jsonRedisSerializer);\n\n    \t\tredisTemplate.setConnectionFactory(connectionFactory);\n\n    \t\treturn redisTemplate;\n    \t}\n    }\n    ```\n\n\n### 4. 通过RedisTemplate对象操作Redis\n\nSpring Data Redis中提供了一个高度封装的类：RedisTemplate，针对jedis客户端中大量api进行了归类封装，将同一类型操作封装为operation接口，具体分类如下:\n\n- **ValueOperations**：用于操作字符串类型的数据。\n- **HashOperations**：用于操作哈希类型的数据（键值对）。\n- **ListOperations**：用于操作列表类型的数据。\n- **SetOperations**：用于操作集合类型的数据。\n- **ZSetOperations**：用于操作有序集合类型的数据。\n\n```java\npackage com.sky.test;\n@SpringBootTest\n// 启动整个 Spring 应用上下文，模拟一个真实的 Spring 环境，用于集成测试\npublic class SpringDataRedisTest {\n\t@Autowired\n\tprivate RedisTemplate redisTemplate;\n\n\t@Test\n\tpublic void testRedisTemplate() {\n\t\tSystem.out.println(redisTemplate); // 非null证明连接成功\n\t}\n\n\t// 操作字符串类型的数据\n\t@Test\n\tpublic void testString() {\n\t\tValueOperations valueOperations = redisTemplate.opsForValue();\n\t\t// set\n\t\tvalueOperations.set(\"username\", \"lr\");\n\t\t// get\n\t\tString username = (String) valueOperations.get(\"username\");\n\t\tSystem.out.println(username);\n\t\t// del\n\t\tredisTemplate.delete(\"username\");\n\t\t// setex\n\t\tvalueOperations.set(\"code\", \"1234\", 3, TimeUnit.MINUTES);\n\t\t// setnx\n\t\tvalueOperations.setIfAbsent(\"lock\", \"1\");\n\t\tvalueOperations.setIfAbsent(\"lock\", \"2\"); // fale\n\t}\n\n\t// 操作哈希类型的数据\n\t@Test\n\tpublic void testHash() {\n\t\tHashOperations hashOperations = redisTemplate.opsForHash();\n\t\t// hset\n\t\thashOperations.put(\"k1\", \"name\", \"lr\");\n\t\thashOperations.put(\"k2\", \"age\", \"20\");\n\t\t// hget\n\t\tString age = (String) hashOperations.get(\"k1\", \"name\");\n\t\tSystem.out.println(age); // lr\n\t\t// hkeys 用set集合\n\t\tSet keys = hashOperations.keys(\"k1\");\n\t\tSystem.out.println(keys); // [name]\n\t\t// hvals 用list集合\n\t\tList values = hashOperations.values(\"k1\");\n\t\tSystem.out.println(values); // [lr]\n\t\t// hdel\n\t\thashOperations.delete(\"k1\", \"name\");\n\t}\n\n\t// 操作列表类型的数据\n\t@Test\n\tpublic void testList() {\n\t\tListOperations listOperations = redisTemplate.opsForList();\n\t\t// lpush\n\t\tlistOperations.leftPushAll(\"mylist\", \"a\", \"b\", \"c\");\n\t\tlistOperations.leftPush(\"mylist\", \"d\");\n\t\t// lrange\n\t\tList mylist = listOperations.range(\"mylist\", 0, -1);\n\t\tSystem.out.println(mylist);\n\t\t// rpop\n\t\tlistOperations.rightPop(\"mylist\");\n\t\t// llen\n\t\tLong size = listOperations.size(\"mylist\");\n\t\tSystem.out.println(size);\n\t}\n\n\t// 操作列表类型的数据\n\t@Test\n\tpublic void testSet() {\n\t\tSetOperations setOperations = redisTemplate.opsForSet();\n\t\t// sadd\n\t\tsetOperations.add(\"set1\", \"a\", \"b\", \"c\", \"d\");\n\t\tsetOperations.add(\"set2\", \"a\", \"b\", \"x\", \"y\");\n\t\t// smembers\n\t\tSet set1 = setOperations.members(\"set1\");\n\t\tSystem.out.println(set1);\n\t\t// scard\n\t\tLong size = setOperations.size(\"set1\");\n\t\tSystem.out.println(size);\n\t\t// sinter\n\t\tSet intersect = setOperations.intersect(\"set1\", \"set2\");\n\t\tSystem.out.println(intersect);\n\t\t// sunion\n\t\tSet union = setOperations.union(\"set1\", \"set2\");\n\t\tSystem.out.println(union);\n\t\t// srem\n\t\tsetOperations.remove(\"set1\", \"b\", \"c\");\n\t}\n\n\t// 操作有序集合类型的数据\n\t@Test\n\tpublic void testZset() {\n\t\tZSetOperations zSetOperations = redisTemplate.opsForZSet();\n\t\t// zadd\n\t\tzSetOperations.add(\"zset1\", \"a\", 10);\n\t\tzSetOperations.add(\"zset1\", \"b\", 12);\n\t\tzSetOperations.add(\"zset1\", \"c\", 9);\n\t\t// zrange\n\t\tSet zset = zSetOperations.range(\"zset1\", 0, -1);\n\t\tSystem.out.println(zset);\n\t\t// zincrby\n\t\tzSetOperations.incrementScore(\"zset1\", \"c\", 10);\n\t\t// zrem\n\t\tzSetOperations.remove(\"zset1\", \"a\", \"b\");\n\t}\n\n\t@Test\n\tpublic void testUser() { // 定义一个User类，name，age\n\t\tredisTemplate.opsForValue().set(\"user:10\", new User(\"lr\", 45));\n\t\tUser o = (User) redisTemplate.opsForValue().get(\"user:10\");\n\t\tSystem.out.println(o);\n\t}\n\n\t// 通用命令操作\n\t@Test\n\tpublic void testCommon() {\n\t\t// keys\n\t\tSet keys = redisTemplate.keys(\"*\");\n\t\tSystem.out.println(keys);\n\t\t// exists\n\t\tBoolean name = redisTemplate.hasKey(\"name\");\n\t\tBoolean set1 = redisTemplate.hasKey(\"set1\");\n\t\t// type\n\t\tfor (Object key : keys) {\n\t\t\tDataType type = redisTemplate.type(key);\n\t\t\tSystem.out.println(type.name());\n\t\t}\n\t\t// del\n\t\tredisTemplate.delete(\"mylist\");\n\t}\n}\n```\n\n## **StringRedisTemplate**\n\n![image.png](images/image%2013.png)\n\n- 为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。\n\n    ![image.png](images/image%2014.png)\n\n- 因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了\n- 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。\n\n    ```java\n    StringRedisTemplate源码：\n    public class StringRedisTemplate extends RedisTemplate<String, String> {\n      public StringRedisTemplate() {\n          this.setKeySerializer(RedisSerializer.string());\n          this.setValueSerializer(RedisSerializer.string());\n          this.setHashKeySerializer(RedisSerializer.string());\n          this.setHashValueSerializer(RedisSerializer.string());\n      }\n    ```\n\n- 不需要自己定义RedisConfiguration，直接使用：\n\n    ```java\n    // 创建对象\n    User user = new User(\"张三\", 18);\n    // 手动序列化\n    String json = mapper.writeValueAsString(user);\n    // 写入数据\n    stringRedisTemplate.opsForValue().set(\"userdata\", json);\n    // 获取数据\n    String userdata = stringRedisTemplate.opsForValue().get(\"userdata\");\n    // 手动反序列化\n    User readValue = mapper.readValue(userdata, User.class);\n    System.out.println(readValue);\n    ```\n\n    ```\n    {\n      \"name\": \"张三\",\n      \"age\": 18\n    }\n    ```\n\n\n[高级篇](https://www.notion.so/147d2775339a80fba43fcec357283b64?pvs=21)"}]