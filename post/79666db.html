<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | 蜡笔梦工厂</title><meta name="author" content="Lorinda"><meta name="copyright" content="Lorinda"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="数据结构的核心是高效组织数据，区分逻辑结构（线性 &#x2F; 非线性）与物理结构（顺序 &#x2F; 链式），覆盖数组、树、图等核心类型，为优化算法效率、支撑工程应用奠定基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://labi.com/post/79666db.html">
<meta property="og:site_name" content="蜡笔梦工厂">
<meta property="og:description" content="数据结构的核心是高效组织数据，区分逻辑结构（线性 &#x2F; 非线性）与物理结构（顺序 &#x2F; 链式），覆盖数组、树、图等核心类型，为优化算法效率、支撑工程应用奠定基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png">
<meta property="article:published_time" content="2025-03-12T08:47:00.000Z">
<meta property="article:modified_time" content="2025-08-28T22:42:05.274Z">
<meta property="article:author" content="Lorinda">
<meta property="article:tag" content="c">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png"><link rel="shortcut icon" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155552.png"><link rel="canonical" href="http://labi.com/post/79666db.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bf06f078fafddfd82b474ce179303666";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":{"enable":true},"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2264842_b004iy0kk2b.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/loading.css"><link rel="stylesheet" href="/css/about.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160015.png"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/af380cb8a5ed3f047e66dbfe731f488.jpg);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155535.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-hexoa-homezhuyefangzijia"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-hexoa-homezhuyefangzijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-hexoshouhuiban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoshouhuiban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexohuanjiaowenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexofenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexobiaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoguidang"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoicon_liebiao"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoyinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexotubiaozhizuomoban"></use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-hexopengyou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexopengyou"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-hexowode"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexowode"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155552.png" alt="Logo"><span class="site-name">蜡笔梦工厂</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-hexoa-homezhuyefangzijia"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-hexoa-homezhuyefangzijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-hexoshouhuiban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoshouhuiban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexohuanjiaowenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexofenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexobiaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoguidang"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoicon_liebiao"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoyinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexotubiaozhizuomoban"></use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-hexopengyou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexopengyou"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-hexowode"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexowode"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-12T08:47:00.000Z" title="发表于 2025-03-12 16:47:00">2025-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-28T22:42:05.274Z" title="更新于 2025-08-29 06:42:05">2025-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">28.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>100分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>数据的<mark>逻辑</mark>结构是指<mark>数据元素之间</mark>的逻辑关系，它与所使用的计算机无关。</p>
<p>数据的<mark>物理</mark>结构，又称<mark>存储结构</mark>，是指数据结构在计算机中的表示，它包括数据元素的表示和元素的表示，其中数据元素之间的关系在计算机中有<strong>顺序</strong>存储结构和<strong>链式</strong>存储结构两种。</p>
<p><mark>逻辑结构</mark><br>
集合，线性，树，图</p>
<ul>
<li>线性结构：线性表，栈，队列，串</li>
<li>非线性结构：树，图</li>
</ul>
<p>物理结构(存储结构)</p>
<ul>
<li>顺序</li>
<li>链式</li>
<li>索引</li>
<li>散列(Has存储)</li>
</ul>
<p>运算的定义针对:逻辑结构<br>
运算的实现针对:存储结构</p>
<p><mark>数据&gt;数据元素&gt;数据项</mark></p>
<p>算法特性(必须全具备)</p>
<ul>
<li>有穷性：算法必须有穷，程序可以无穷</li>
<li>确定性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
<h1>复杂度</h1>
<h2 id="1-线性查找时间复杂度"><strong>1. 线性查找时间复杂度</strong></h2>
<ul>
<li><strong>最坏情况</strong>：目标元素在最后一个位置，需遍历整个链表，时间复杂度为 <strong>O(n)</strong>。</li>
<li><strong>平均情况</strong>：假设目标元素在各位置概率相等，平均比较次数为 <strong>(n+1)/2</strong>，时间复杂度 <strong>O(n)</strong></li>
</ul>
<h2 id="2-单循环链表的头尾访问"><strong>2. 单循环链表的头尾访问</strong></h2>
<ul>
<li><strong>带尾指针的单循环链表</strong>：
<ul>
<li>找表头结点：通过尾指针的 <code>next</code> 直接访问，时间复杂度 <strong>O(1)</strong>。</li>
<li>找表尾结点：直接访问尾指针，时间复杂度 <strong>O(1)</strong>。</li>
</ul>
</li>
<li><strong>带头结点的单循环链表</strong>：
<ul>
<li>找表头结点：直接访问头结点，时间复杂度 <strong>O(1)</strong>。</li>
<li>找表尾结点：需从头遍历到尾，时间复杂度 <strong>O(n)</strong>。</li>
</ul>
</li>
</ul>
<h2 id="3-链表合并的时间复杂度"><strong>3. 链表合并的时间复杂度</strong></h2>
<ul>
<li><strong>将长度为 n 的单链表链接到长度为 m 的单链表之后</strong>：
<ul>
<li>需要找到链表 m 的尾节点（耗时 <strong>O(m)</strong>），然后修改其 <code>next</code> 指针指向链表 n 的头节点（耗时 <strong>O(1)</strong>）。</li>
<li>总时间复杂度为 <strong>O(m)</strong>。</li>
</ul>
</li>
</ul>
<h2 id="4-插入操作的时间复杂度"><strong>4. 插入操作的时间复杂度</strong></h2>
<ul>
<li><strong>数组的插入操作</strong>（假设在位置 i 插入元素）：
<ul>
<li><strong>移动次数</strong>：需将第 i 个位置后的所有元素后移，共移动 <strong>n - i</strong> 次。</li>
<li><strong>总移动次数</strong>：插入所有可能位置（共 <strong>n+1</strong> 种）的移动次数总和为  <strong>(n+1)/2</strong></li>
<li><strong>平均移动次数</strong>：n/2，时间复杂度 <strong>O(n)</strong>。</li>
</ul>
</li>
<li><strong>链表的插入操作</strong>（假设已知插入位置的前驱节点）：
<ul>
<li>仅需修改指针，时间复杂度 <strong>O(1)</strong>。</li>
<li>若需遍历找到插入位置，时间复杂度 <strong>O(n)</strong>。</li>
</ul>
</li>
</ul>
<h2 id="5-删除操作的时间复杂度"><strong>5. 删除操作的时间复杂度</strong></h2>
<ul>
<li><strong>数组的删除操作</strong>（假设删除位置 i 的元素）：
<ul>
<li><strong>移动次数</strong>：需将第 i 个位置后的所有元素前移，共移动 <strong>n - i - 1</strong> 次。</li>
<li><strong>总移动次数</strong>：删除所有可能位置（共 <strong>n</strong> 种）的移动次数总和为  <strong>n(n-1)/2</strong></li>
<li><strong>平均移动次数</strong>： <strong>(n-1)/2</strong>，时间复杂度 <strong>O(n)</strong>。</li>
</ul>
</li>
<li><strong>链表的删除操作</strong>（假设已知删除节点的前驱节点）：
<ul>
<li>仅需修改指针，时间复杂度 <strong>O(1)</strong>。</li>
<li>若需遍历找到删除节点，时间复杂度 <strong>O(n)</strong>。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>链表与数组的差异</strong>：
<ul>
<li><strong>链表</strong>的插入和删除操作时间复杂度取决于是否已知操作位置的前驱节点：
<ul>
<li>已知前驱节点：<strong>O(1)</strong>。</li>
<li>需遍历查找位置：<strong>O(n)</strong>。</li>
</ul>
</li>
<li><strong>数组</strong>的插入和删除操作需移动元素，时间复杂度为 <strong>O(n)</strong>。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>数组（平均 / 最坏）</th>
<th>链表（已知前驱节点）</th>
<th>链表（需遍历）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>插入元素</strong></td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>删除元素</strong></td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>查找元素</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>访问头节点</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>访问尾节点</strong></td>
<td>O(1)（有尾指针）</td>
<td>O(1)（带尾指针）</td>
<td>O(n)（无尾指针）</td>
</tr>
</tbody>
</table>
<h1>线性表</h1>
<p>顺序存储的物理和逻辑是一一对应的<br>
链式存储可用于存储线性和非线性的数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10    <span class="comment">// 线性表初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INCREMENT 2     <span class="comment">// 容量不足时的增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;        <span class="comment">// 元素类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;          <span class="comment">// 操作状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType* data;         <span class="comment">// 存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;             <span class="comment">// 当前元素个数</span></span><br><span class="line">    <span class="type">int</span> capacity;           <span class="comment">// 当前分配的存储容量</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.data = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.data) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.capacity = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.data) &#123;</span><br><span class="line">        <span class="built_in">free</span>(L.data);</span><br><span class="line">        L.data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前驱元素</span></span><br><span class="line"><span class="function">Status <span class="title">PriorElem</span><span class="params">(SqList L, ElemType cur_e, ElemType &amp;pre_e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == cur_e) &#123;</span><br><span class="line">            pre_e = L.data[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容处理</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.capacity) &#123;</span><br><span class="line">        ElemType* newbase = (ElemType*)<span class="built_in">realloc</span>(L.data,</span><br><span class="line">            (L.capacity + LIST_INCREMENT) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.data = newbase;</span><br><span class="line">        L.capacity += LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListTraverse</span><span class="params">(SqList L, <span class="type">void</span> (*visit)(ElemType))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">MergeSortedLists</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化结果表</span></span><br><span class="line">    Lc.capacity = La.length + Lb.length;</span><br><span class="line">    Lc.data = (ElemType*)<span class="built_in">malloc</span>(Lc.capacity * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Lc.data) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length &amp;&amp; j &lt; Lb.length) &#123;</span><br><span class="line">        Lc.data[k++] = (La.data[i] &lt;= Lb.data[j]) ? La.data[i++] : Lb.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length) Lc.data[k++] = La.data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; Lb.length) Lc.data[k++] = Lb.data[j++];</span><br><span class="line"></span><br><span class="line">    Lc.length = k;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L, i, i * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入元素后: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(L, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">ListDelete</span>(L, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除第3个元素: %d\n&quot;</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(L, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并测试</span></span><br><span class="line">    SqList La, Lb, Lc;</span><br><span class="line">    <span class="built_in">InitList</span>(La);</span><br><span class="line">    <span class="built_in">InitList</span>(Lb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(La, i, i * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">ListInsert</span>(Lb, i, i * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MergeSortedLists</span>(La, Lb, Lc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;合并后结果: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(Lc, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源清理</span></span><br><span class="line">    <span class="built_in">DestroyList</span>(L);</span><br><span class="line">    <span class="built_in">DestroyList</span>(La);</span><br><span class="line">    <span class="built_in">DestroyList</span>(Lb);</span><br><span class="line">    <span class="built_in">DestroyList</span>(Lc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的合并">顺序表的合并</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2070.png" alt="Untitled 8 70"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2067.png" alt="Untitled 9 67"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2063.png" alt="Untitled 10 63">时间复杂度Q(ListLength(La)+ListLength(Lb))<br>
空间复杂度O(1)</p>
<h2 id="单链表">单链表</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>
<p>普通变量是LNode.成员名，指针变量是LinkList-&gt;成员名<br>
Linklist强调单链表，LNode*强调结点</p>
<p>定义链表L：LNode * L == LinkList L(更常用)<br>
定义结点指针：LNode *p(更常用) == LinkList p<br>
L-&gt;next有两层含义，可以表示L的后继节点指针，又可表示L的指针域（单链表的指针域只有后继指针域，双链表的指针域分为前驱指针域和后继指针域））<br>
p = L就是p = 头结点，p = L-&gt;next就是让p = 头结点的后一个节点。</p>
<p>头指针：是指向链表第一个结点的指针<br>
首元结点：是指向链表中存储第一个数据元素a1的结点<br>
头结点：是在链表的首元结点之前附设的一个结点。链表中的头结点仅起到标识的作用。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/5e68616c9b390b7ef84a08401462f0d.jpg" alt="5e68616c9b390b7ef84a08401462f0d"><br>
带<mark>头结点</mark>的好处：</p>
<ol>
<li>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。</li>
<li>便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此统一。</li>
<li>头结点的指针域可以为空，可以存放长度等，但<mark>不计入链表的长度值</mark>。</li>
</ol>
<p>表示空表</p>
<ul>
<li>无头结点：头指针为空</li>
<li>有头结点：头结点的指针域为空</li>
</ul>
<p>链表特点：</p>
<ul>
<li>结点在存储器中位置任意</li>
<li>只能通过头指针进入链表，顺序扫描。寻找第一个结点很容易。<mark>顺序表是随机存储法</mark></li>
<li>结点空间可以动态申请和释放</li>
<li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li>
<li>缺点：存储密度小，利用率小，每个结点的指针域额外占用存储空间</li>
<li>静态链表中的指针表示的是数组下标</li>
</ul>
<h2 id="头插（逆序）">头插（逆序）</h2>
<p>带头结点<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7ae0a7bd64d74b5d9a149f7849e38f93.gif" alt="7ae0a7bd64d74b5d9a149f7849e38f93"><br>
不带头结点<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/e062fe1ed673468681ecce4d84a865ae.gif" alt="e062fe1ed673468681ecce4d84a865ae"></p>
<h2 id="尾插">尾插</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2075.png" alt="Untitled 7 75|Untitled 7 75.png"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/IMG_20231010_091813.jpg" alt="IMG_20231010_091813"><br>
带头结点<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/f47832ac0b274b19b1fb2e5ba8d5fcb9.gif" alt="f47832ac0b274b19b1fb2e5ba8d5fcb9"><br>
不带头结点同上</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a9b4f515e81d49d9abbc6456ff2bb60e.jpg" alt="a9b4f515e81d49d9abbc6456ff2bb60e"></p>
<h2 id="带头结点的单链表">带头结点的单链表</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化带头结点的链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="keyword">return</span> ERROR;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = i*<span class="number">2</span>;  <span class="comment">// 测试数据</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_T</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LNode *tail = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = i*<span class="number">3</span>;  <span class="comment">// 测试数据</span></span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置插入</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;  <span class="comment">// 找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListTraverse</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不带头结点的单链表">不带头结点的单链表</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *NoHeadList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化不带头结点的链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(NoHeadList &amp;L)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i*<span class="number">2</span>;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_T</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Node *tail = <span class="literal">NULL</span>;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i*<span class="number">3</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!L) &#123;</span><br><span class="line">            L = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置插入</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;  <span class="comment">// 特殊处理第一个结点</span></span><br><span class="line">        Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || !L) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;  <span class="comment">// 特殊处理第一个结点</span></span><br><span class="line">        Node *q = L;</span><br><span class="line">        e = q-&gt;data;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node *q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListTraverse</span><span class="params">(NoHeadList L)</span> &#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(NoHeadList &amp;L)</span> &#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么不是 <code>free(*r)</code>？</strong></p>
<ul>
<li><code>free()</code> 的参数必须是一个指针，指向动态分配的内存块的起始地址。</li>
<li>如果 <code>r</code> 是一个指针变量（例如 <code>int* r</code>），则 <code>free(r)</code> 是正确的用法，因为 <code>r</code> 本身就是一个指针。</li>
<li>如果 <code>r</code> 是一个指向指针的指针（例如 <code>int** r</code>），则 <code>free(*r)</code> 是正确的用法，因为 <code>*r</code> 是一个指针，指向动态分配的内存块</li>
</ul>
<h2 id="代码思路整理">代码思路整理</h2>
<h2 id="1-结构差异对比">1. 结构差异对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>带头结点</th>
<th>不带头结点</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>需要创建头结点，头指针指向头结点</td>
<td>直接置空指针</td>
</tr>
<tr>
<td>首元结点处理</td>
<td>统一通过头结点的 next 指针访问</td>
<td>直接通过头指针访问</td>
</tr>
<tr>
<td>空表判断</td>
<td>L-&gt;next == NULL</td>
<td>L == NULL</td>
</tr>
<tr>
<td>插入 / 删除首结点</td>
<td>不需要特殊处理</td>
<td>需要单独处理头指针变化</td>
</tr>
<tr>
<td>算法复杂度</td>
<td>各操作时间复杂度 O (n)，但边界处理更简单</td>
<td>时间复杂度相同，但需要更多条件判断</td>
</tr>
</tbody>
</table>
<h2 id="2-关键实现要点">2. 关键实现要点</h2>
<ul>
<li><strong>头插法</strong>：新结点始终插入到链表头部</li>
<li><strong>尾插法</strong>：需要维护尾指针以提高效率</li>
<li><strong>位置索引</strong>：统一采用1-based索引</li>
<li><strong>内存管理</strong>：每次操作后及时释放内存</li>
<li><strong>错误处理</strong>：对非法位置进行有效性检查</li>
</ul>
<h2 id="3-推荐使用场景">3. 推荐使用场景</h2>
<ul>
<li><strong>带头结点</strong>：适合需要频繁进行首结点操作的场景</li>
<li><strong>不带头结点</strong>：适合内存敏感或需要直接操作首结点的场景</li>
</ul>
<h2 id="双链表">双链表</h2>
<p>在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了由两个方向不同的链，表头结点的prior指向NULL，表尾结点的next指向NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span>    <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span>     <span class="comment">// 后继指针</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br></pre></td></tr></table></figure>
<h2 id="初始化双链表"><strong>初始化双链表</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入操作（在节点-p-后插入节点-s）"><strong>插入操作（在节点 p 后插入节点 s）</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterDNode</span><span class="params">(DNode *p, DNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;     <span class="comment">// 1. s 的后继指向 p 的后继</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)           <span class="comment">// 如果 p 不是最后一个节点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">// 2. p 的后继的前驱指向 s</span></span><br><span class="line">    s-&gt;prior = p;          <span class="comment">// 3. s 的前驱指向 p</span></span><br><span class="line">    p-&gt;next = s;           <span class="comment">// 4. p 的后继指向 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作（删除节点-p-的后继节点）"><strong>删除操作（删除节点 p 的后继节点）</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterDNode</span><span class="params">(DNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;next) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    DNode *q = p-&gt;next;  <span class="comment">// q 指向待删除节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">// 1. p 的后继指向 q 的后继</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next)         <span class="comment">// 如果 q 不是最后一个节点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// 2. q 的后继的前驱指向 p</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">// 3. 释放 q 的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环双链表">循环双链表</h2>
<p>表头结点的prior指向表尾结点，表尾结点的next指向头结点<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20129.png" alt="Untitled 1 129"><br>
对称性：p→prior→next = p = p→next→prior</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">prior</span>;</span>   <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 后继指针</span></span><br><span class="line">&#125; CDNode, *CDLinkList;</span><br></pre></td></tr></table></figure>
<h2 id="初始化循环双链表"><strong>初始化循环双链表</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCDLinkList</span><span class="params">(CDLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = L;  <span class="comment">// 头结点的前驱指向自己</span></span><br><span class="line">    L-&gt;next = L;   <span class="comment">// 头结点的后继指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入操作（在节点-p-后插入节点-s）-2"><strong>插入操作（在节点 p 后插入节点 s）</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterCDNode</span><span class="params">(CDNode *p, CDNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;     <span class="comment">// 1. s 的后继指向 p 的后继</span></span><br><span class="line">    s-&gt;prior = p;          <span class="comment">// 2. s 的前驱指向 p</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;    <span class="comment">// 3. p 的后继的前驱指向 s</span></span><br><span class="line">    p-&gt;next = s;           <span class="comment">// 4. p 的后继指向 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作（删除节点-p-的后继节点）-2"><strong>删除操作（删除节点 p 的后继节点）</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterCDNode</span><span class="params">(CDNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || p-&gt;next == p) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性（空表或只有头结点）</span></span><br><span class="line"></span><br><span class="line">    CDNode *q = p-&gt;next;  <span class="comment">// q 指向待删除节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;    <span class="comment">// 1. p 的后继指向 q 的后继</span></span><br><span class="line">    q-&gt;next-&gt;prior = p;   <span class="comment">// 2. q 的后继的前驱指向 p</span></span><br><span class="line">    <span class="built_in">free</span>(q);              <span class="comment">// 3. 释放 q 的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306144931.jpg" alt="Pasted image 20250306144931"><br>
1234——s的前驱和后继-&gt;pnext的前驱-&gt;p的后继<br>
s-&gt;prior=p;<br>
s-&gt;next=p-&gt;next;<br>
p-&gt;next-&gt;perior=s;<br>
p-&gt;next=s;<br>
3214——pnext的前驱-&gt;s的后继-&gt;s的前驱-&gt;p的后继<br>
3241——pnext的前驱-&gt;s的后继-&gt;p的后继-&gt;s的前驱<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2096.png" alt="Untitled 3 96"><br>
不用头指针的原因：由表头找到表尾较费时，删表头O(1)，插表尾O(n)<br>
让L指向尾指针：都是O(1)<br>
终止条件：判断是否等于头指针<br>
单链表：<br>
p≠NULL;<br>
p→next≠NULL;<br>
单循环链表：<br>
p≠L;<br>
p→next≠L;</p>
<p>带尾指针的循环链表的合并(Tb合并在Ta之后)<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20225.png" alt="Untitled 225|Untitled 225.png"><br>
p存表头结点（p = Ta→next）→Tb表头连接Ta表尾（Ta→next = Tb→next→next）→释放Tb表头结点（delete Tb→next）→修改指针（Tb→next = p）</p>
<h2 id="插入操作（以双链表为例）"><strong>插入操作（以双链表为例）</strong></h2>
<ol>
<li><strong><code>s-&gt;next = p-&gt;next;</code></strong>：
<ul>
<li>将新节点 <code>s</code> 的后继指向 <code>p</code> 的后继。</li>
</ul>
</li>
<li><strong><code>if (p-&gt;next) p-&gt;next-&gt;prior = s;</code></strong>：
<ul>
<li>如果 <code>p</code> 不是最后一个节点，将 <code>p</code> 的后继的前驱指向 <code>s</code>。</li>
</ul>
</li>
<li><strong><code>s-&gt;prior = p;</code></strong>：
<ul>
<li>将新节点 <code>s</code> 的前驱指向 <code>p</code>。</li>
</ul>
</li>
<li><strong><code>p-&gt;next = s;</code></strong>：
<ul>
<li>将 <code>p</code> 的后继指向 <code>s</code>。</li>
</ul>
</li>
</ol>
<h2 id="删除操作（以双链表为例）"><strong>删除操作（以双链表为例）</strong></h2>
<ol>
<li><strong><code>p-&gt;next = q-&gt;next;</code></strong>：
<ul>
<li>将 <code>p</code> 的后继指向 <code>q</code> 的后继。</li>
</ul>
</li>
<li><strong><code>if (q-&gt;next) q-&gt;next-&gt;prior = p;</code></strong>：
<ul>
<li>如果 <code>q</code> 不是最后一个节点，将 <code>q</code> 的后继的前驱指向 <code>p</code>。</li>
</ul>
</li>
<li><strong><code>free(q);</code></strong>：
<ul>
<li>释放 <code>q</code> 的内存。</li>
</ul>
</li>
</ol>
<h2 id="双链表-2"><strong>双链表</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterDNode</span><span class="params">(DNode *p, DNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterDNode</span><span class="params">(DNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next) q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDLinkList</span><span class="params">(DLinkList L)</span> &#123;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line"></span><br><span class="line">    DNode *s1 = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s1-&gt;data = <span class="number">10</span>;</span><br><span class="line">    InsertAfterDNode(L, s1);</span><br><span class="line"></span><br><span class="line">    DNode *s2 = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s2-&gt;data = <span class="number">20</span>;</span><br><span class="line">    InsertAfterDNode(s1, s2);</span><br><span class="line"></span><br><span class="line">    PrintDLinkList(L);  <span class="comment">// 输出：10 20</span></span><br><span class="line"></span><br><span class="line">    DeleteAfterDNode(L);</span><br><span class="line">    PrintDLinkList(L);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环双链表-2"><strong>循环双链表</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CDNode, *CDLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCDLinkList</span><span class="params">(CDLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterCDNode</span><span class="params">(CDNode *p, CDNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterCDNode</span><span class="params">(CDNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || p-&gt;next == p) <span class="keyword">return</span>;</span><br><span class="line">    CDNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintCDLinkList</span><span class="params">(CDLinkList L)</span> &#123;</span><br><span class="line">    CDNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != L) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CDLinkList L;</span><br><span class="line">    InitCDLinkList(L);</span><br><span class="line"></span><br><span class="line">    CDNode *s1 = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    s1-&gt;data = <span class="number">10</span>;</span><br><span class="line">    InsertAfterCDNode(L, s1);</span><br><span class="line"></span><br><span class="line">    CDNode *s2 = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    s2-&gt;data = <span class="number">20</span>;</span><br><span class="line">    InsertAfterCDNode(s1, s2);</span><br><span class="line"></span><br><span class="line">    PrintCDLinkList(L);  <span class="comment">// 输出：10 20</span></span><br><span class="line"></span><br><span class="line">    DeleteAfterCDNode(L);</span><br><span class="line">    PrintCDLinkList(L);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态链表">静态链表</h2>
<p>用数组实现的链表结构，它通过数组的下标来模拟链表的指针。静态链表的特点是不需要动态分配内存，而是预先分配一个<strong>固定大小</strong>的数组来存储链表节点。<br>
静态链表的结构</p>
<ul>
<li>
<p><strong>数组存储</strong>：</p>
<ul>
<li>静态链表使用数组来存储节点，每个节点包含两个部分：
<ul>
<li><strong>数据域</strong>：存储数据。</li>
<li><strong>游标（或指针域）</strong>：存储下一个节点的数组下标。</li>
</ul>
</li>
<li>数组的每个位置可以看作一个节点，游标指向下一个节点的位置。</li>
</ul>
</li>
<li>
<p><strong>头结点和空闲链表</strong>：</p>
<ul>
<li>静态链表通常有一个头结点，用于指向链表的第一个节点。</li>
<li>空闲链表用于管理未使用的数组位置，方便插入新节点。</li>
</ul>
</li>
</ul>
<p>为什么不需要移动元素</p>
<h2 id="插入操作"><strong>插入操作</strong></h2>
<ul>
<li><strong>插入新节点</strong>：
<ul>
<li>从空闲链表中获取一个空闲位置（数组下标）。</li>
<li>修改游标，将新节点插入到链表中。</li>
<li><strong>不需要移动其他元素</strong>，只需修改游标。</li>
</ul>
</li>
</ul>
<h2 id="删除操作"><strong>删除操作</strong></h2>
<ul>
<li><strong>删除节点</strong>：
<ul>
<li>将要删除的节点从链表中移除。</li>
<li>将该节点的位置加入空闲链表。</li>
<li><strong>不需要移动其他元素</strong>，只需修改游标。</li>
</ul>
</li>
</ul>
<h2 id="修改游标"><strong>修改游标</strong></h2>
<ul>
<li>静态链表通过修改游标（数组下标）来维护链表结构，而不是通过移动数据元素。</li>
<li>这种方式类似于动态链表，但使用数组下标代替指针。</li>
</ul>
<p><strong>与动态链表的对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>动态链表</strong></th>
<th><strong>静态链表</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储结构</strong></td>
<td>使用指针连接节点</td>
<td>使用数组下标（游标）连接节点</td>
</tr>
<tr>
<td><strong>内存分配</strong></td>
<td>动态分配内存</td>
<td>预先分配固定大小的数组</td>
</tr>
<tr>
<td><strong>插入/删除</strong></td>
<td>修改指针</td>
<td>修改游标</td>
</tr>
<tr>
<td><strong>移动元素</strong></td>
<td>不需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>需要动态内存管理</td>
<td>不需要动态内存管理</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>数据量不确定，频繁插入删除</td>
<td>数据量固定，内存受限的场景</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">// 游标（下一个节点的下标）</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node staticList[MAX_SIZE];  <span class="comment">// 静态链表数组</span></span><br><span class="line"><span class="type">int</span> head;                   <span class="comment">// 头结点下标</span></span><br><span class="line"><span class="type">int</span> freeList;               <span class="comment">// 空闲链表头结点下标</span></span><br></pre></td></tr></table></figure>
<h2 id="插入操作-2"><strong>插入操作</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (freeList == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;静态链表已满，无法插入新节点！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲链表中获取一个节点</span></span><br><span class="line">    <span class="type">int</span> newNodeIndex = freeList;</span><br><span class="line">    freeList = staticList[freeList].next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    staticList[newNodeIndex].data = data;</span><br><span class="line">    staticList[newNodeIndex].next = staticList[head].next;</span><br><span class="line">    staticList[head].next = newNodeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作-2"><strong>删除操作</strong></h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev = head;</span><br><span class="line">    <span class="type">int</span> curr = staticList[head].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticList[curr].data == data) &#123;</span><br><span class="line">            <span class="comment">// 从链表中移除节点</span></span><br><span class="line">            staticList[prev].next = staticList[curr].next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将节点加入空闲链表</span></span><br><span class="line">            staticList[curr].next = freeList;</span><br><span class="line">            freeList = curr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = staticList[curr].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未找到要删除的元素！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>静态链表不需要移动元素</strong>，因为它通过修改游标（数组下标）来维护链表结构。</li>
<li>插入和删除操作只需修改游标，而不需要移动数据元素。</li>
<li>静态链表适用于内存受限的场景，但灵活性不如动态链表。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2046.png" alt="Untitled 2 46"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2040.png" alt="Untitled 3 40"><br>
顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取<br>
在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂<br>
双链表中可以快速访问任何一个结点的前驱和后继结点,选项D正确。</p>
<h2 id="错题">错题</h2>
<p>^3afb0f</p>
<ol>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png" alt="Pasted image 20250306152709">c</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png" alt="Pasted image 20250306152709">c</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152828.png" alt="Pasted image 20250306152828">c</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306154314.png" alt="Pasted image 20250306154314">d</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306160930.png" alt="Pasted image 20250306160930">链式存储设计时，各个不同结点的<mark>存储空间</mark>可以不连续，但结点内的<mark>存储单元地址</mark>必须连续</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161045.png" alt="Pasted image 20250306161045"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161310.png" alt="Pasted image 20250306161310"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162035.png" alt="Pasted image 20250306162035"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162229.png" alt="Pasted image 20250306162229"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163931.png" alt="Pasted image 20250306163931">设单链表递增有序，首先要在单链表中找到第一个大于x的结点的直接前驱p，在p之后插入该结点。查找的时间复杂度为 O(n)，插入的时间复杂度为 0(1)，总时间复杂度为 O(n)。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162259.png" alt="Pasted image 20250306162259"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162245.png" alt="Pasted image 20250306162245"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162348.png" alt="Pasted image 20250306162348">b有关因为需要遍历链表找到倒数第二个节点。d无关，因为尾指针 r 直接指向最后一个节点，无需遍历</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162745.png" alt="Pasted image 20250306162745">d线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素 a50 不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163806.png" alt="Pasted image 20250306163806">改四个指针域，分别是:新结点的前驱指针域，指向第一个结点:新结点的后继指针域，指向第二个结点;第一个结点的后继指针域，指向新结点;第二个结点的前驱指针域，指向新结点。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306164359.png" alt="Pasted image 20250306164359">带头结点的循环单链表工为空表时，满足L-&gt;next == L，即头结点的指针域与L的值相等,而不是头结点的指针域与工的地址相等。注意，带头结点的循环单链表中不存在空指针。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306165707.png" alt="Pasted image 20250306165707">a</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170529.png" alt="Pasted image 20250306170529"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170531.png" alt="Pasted image 20250306170531">对于选项 A，删除尾结点* p 时，需要找到* p的前一个结点，时间复杂度为 O(n)。对于选项B，删除首结点* p时，需要找到* p结点,这里没有直接给出头结点指针，而通过尾结点的 prior指针找到* p 结点的时间复杂度为 O(n)。对于选项 D，删除尾结点* p 时，需要找到* p 的前一个结点，时间复杂度为 O(n)。对于C，执行这四种算法的时间复杂度均为 O(1)。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171120.png" alt="Pasted image 20250306171120">在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为 O(1)。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在 0(1)的时间找到尾结点:若只有表头指针，则需要遍历整个链表找到尾结点，时间为0(n)。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171301.png" alt="Pasted image 20250306171301">对一个空循环单链表，有 head-&gt;next== head，推理 head-&gt;next-&gt;next== head-&gt;next== head。对含有一个元素的循环单链表，头结点(头指针 head 指示)的 next 域指向这个唯一的元素结点，该元素结点的next 域指向头结点，因此也有 head-&gt;next-&gt;next=head。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171913.png" alt="Pasted image 20250306171913">对于两种双链表，删除首结点的时间复杂度都是 0(1)。对于非循环双链表，删除尾结点的时间复杂度是 0(m);对于循环双链表，删除尾结点的时间复杂度是0(1)。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172027.png" alt="Pasted image 20250306172027">对于选项 A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为 O(n);而删除第一个元素时，为保持循环单链表的性质(尾结点指向第一个结点)，要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为 O(n)。对于选项 B,双链表的情况与单链表的相同，一个是 O(n),一个是 O(1)。对于选项C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置,时间复杂度为 0(n);删除第一个元素的时间复杂度为 O(1)。对于选项 D，与选项 A 的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为0(1)</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172625.png" alt="Pasted image 20250306172625">静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306173426.png" alt="Pasted image 20250306173426">静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。并非每个空间都存储了元素，因此会造成存储空间的浪费。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174519.png" alt="Pasted image 20250306174519"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174543.png" alt="Pasted image 20250306174543"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306175206.png" alt="Pasted image 20250306175206">c</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191738.png" alt="Pasted image 20250306191738"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191747.png" alt="Pasted image 20250306191747"></li>
<li></li>
</ol>
<h1>栈LIFO</h1>
<p>栈和队列都是<strong>操作受限</strong>线性表<br>
应用：撤销，递归，进制转换，迷宫求解，表达式求值，括号匹配，处理函数或过程调用时的局部变量、返回地址、参数，深度优先遍历DFS<br>
在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。<br>
栈只能操作栈顶</p>
<h2 id="顺序栈">顺序栈</h2>
<p>在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307111852.png" alt="Pasted image 20250307111852">栈顶指针：S.top，初始时设置S.top=-1<br>
栈底 0<br>
栈顶元素：S.data[S.top]<br>
入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶 S.data[++S.top] = x<br>
出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1 x = S.data[S.top–]<br>
栈空条件：S.top == -1<br>
栈满条件：S.top== MaxSize-1<br>
栈长：S.top+1<br>
另一种常见的方式是：<br>
初始设置栈顶指针 S.top=0<br>
入栈时先将值送到栈顶，栈顶指针再加 1<br>
出栈时，栈顶指针先减1，再取栈顶元素<br>
栈空条件是 S.top== 0<br>
栈满条件是S.top== MaxSize.<br>
顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">SElemType* base;</span><br><span class="line">SElemType* top;</span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307121133.png" alt="Pasted image 20250307121133|200"><br>
top指示真正栈顶元素之上的下标地址<br>
stacksize表示栈的最大容量，共stacksize-1个元素<br>
空栈：base== top<br>
栈满：top-base== stacksize<br>
下溢：栈空还要弹出元素，一般当作一种结束条件<br>
上溢：是错误</p>
<p>3+2的前缀表达形式就是+ 3 2<br>
3+2的后缀表达形式就是3 2 +<br>
后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)</p>
<h2 id="共享栈">共享栈</h2>
<p>两个栈共享一个数组空间的好处：存储空间，降低上溢出发生的机率。其存取数据的时间复杂度均为0(1)，所以对存取效率没有什么影响。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112107.png" alt="Pasted image 20250307112107"><br>
两个栈的栈顶指针都指向栈顶元素<br>
top0=-1时0号栈为空，top1=Maxsize 时1号栈头空<br>
仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满<br>
当0号栈入栈时 top0 先加再赋值，1号栈入栈时 top1 先减1再赋值，出栈时则刚好相反<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2047.png" alt="Untitled 2 47|500"></p>
<h2 id="链栈">链栈</h2>
<p>使用单链表实现，且所有操作都是在表头进行，没有头结点，Lhead指向栈顶元素<br>
栈顶-&gt;栈底<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112353.png" alt="Pasted image 20250307112353"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkNode,LiStack;</span><br></pre></td></tr></table></figure>
<p>采用链式存储，便于结点的插入与删除<br>
链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行<br>
需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同<br>
有多少种不同的出栈序列<br>
卡特兰数：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_1203_103148.png" alt="Screenshot_2023_1203_103148|90 "></p>
<ul>
<li><strong>时间复杂度</strong>
<ul>
<li>链栈和顺序栈的进栈和出栈操作时间复杂度均为 O(1)</li>
</ul>
</li>
<li><strong>空间性能</strong>：
<ul>
<li>链栈不需要预先分配固定空间，但每个节点需要额外的指针域。</li>
<li>顺序栈需要预先分配固定空间，可能导致内存浪费，但存取方便。</li>
</ul>
</li>
<li><strong>选择建议</strong>
<ul>
<li>如果栈的长度变化不可预料，建议使用链栈。</li>
<li>如果栈的长度变化在可控范围内，建议使用顺序栈。</li>
</ul>
</li>
</ul>
<h2 id="错题-2">错题</h2>
<p>1.<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112815.png" alt="Pasted image 20250307112815">栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同<br>
2. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112922.png" alt="Pasted image 20250307112922">栈和队列都是限制存取点的线性结构<br>
3. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113142.png" alt="Pasted image 20250307113142">顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间<br>
4. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113421.png" alt="Pasted image 20250307113421">对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而循环单链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于选项C，插入和删除结点后，找尾结点所需的时间为 O(n)。<br>
5. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114112.png" alt="Pasted image 20250307114112">第n个元素第一个出栈，说明前n-1个元素都已经按顺序入栈d<br>
6. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114354.png" alt="Pasted image 20250307114354">d<br>
7. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114611.png" alt="Pasted image 20250307114611">p3=1第一个出栈，此时栈内有p1,p2;2第二个出栈，所以2只可能是p2或者p4,p5…;因此选C<br>
8. 将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-* -g+时,用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空,则转换过程中同时保存在栈中的操作符的最大个数是() A. 5 B. 7 C. 8 D. 11<br>
在转换过程中，栈中的操作符最多有5个。这种情况出现在第二个“+”号入栈后，栈中的操作符分别为：“-”，“”，“(”，“(”，“+”。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190631.png" alt="Pasted image 20250307190631"><br>
9. <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190913.png" alt="Pasted image 20250307190913"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190923.png" alt="Pasted image 20250307190923"><br>
10.</p>
<h1>队列FIFO</h1>
<p><mark>头删尾插</mark><br>
栈和队列是受限的线性表，它们的共同点是只允许在端点处插入和删除元素。<br>
栈只允许在一端进行插入、删除操作<br>
队列只允许在一端进行插入,在另一端进行删除<br>
应用：缓冲区，层次遍历，CPU资源竞争，广度优先搜索BFS，消息队列<br>
采用<mark>尾指针</mark>的循环单链表适合作为队列的存储结构<br>
队列一般情况下需要修改队尾指针，但是当队列为空时需要同时修改头尾指针<br>
最适合用作链式队列的链表是带有队头指针和队尾指针的非循环单链表<br>
为了防止队列发生假溢出，应该使用循环队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307122136.png" alt="Pasted image 20250307122136|400"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	 <span class="type">int</span> data[MaxSize];</span><br><span class="line">	 <span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>初始时:Q.front=Q.rear=0。<br>
入队操作：队不满时，先送值到队尾元素，再将队尾指针加1<br>
出队操作：队不空时，先取队首元素值，再将队首指针加1<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123048.png" alt="Pasted image 20250307123048|500"><br>
不能用 Q.rear== Maxsize 作为队列满的条件(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出””，但这种溢出并不是真正的溢出，在 data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。</p>
<h2 id="循环队列">循环队列</h2>
<p>因为每次入队或者出队都是font或者rear向后移动一位,font指针无法往前移动,此时就会造成删除的空间无法使用，循环队列即可解决问题<br>
把存储队列元素的表从逻辑上视为一个环,称为循环队列<br>
当队首指针 Q.front=Maxsize-1后，再前进一个位置就自动到0，这可以利用除法取模运算(%)来实现。<br>
初始时：Q.front=Q.rear=0。<br>
队首指针进1：Q.front=(Q.front+1)%Maxsize。<br>
队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。<br>
队列长度：(Q.rear+Maxsize-Q.front)%Maxsize。<br>
出入队时：指针都按顺时针方向进1<br>
循环队列需要几个参数来确定?以及各个参数的含义？<br>
需要2个参数,第一个参数是front,第二个参数是rear;<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123713.png" alt="Pasted image 20250307123713|500"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307124944.png" alt="Pasted image 20250307124944"><br>
队满条件：（Q.rear+1）%MaxSize== Q.front<br>
队空条件：Q.front== Q.rear</p>
<h2 id="链式队列">链式队列</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> &#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br></pre></td></tr></table></figure>
<p>不带头结点时，当Q.front== NULL且Q.rear== NULL 时，链式队列为空<br>
插入r→next=s;s-&gt;next=NULL;r=s;<br>
用链头作为队头</p>
<h2 id="静态队列">静态队列</h2>
<p>基于数组实现的，如果是普通数组，规定front指向第一个元素的位置，rear指向最后一个元素位置的下一个位置<br>
如果front指向第一个的前一个元素，rear就指向最后一个元素。<br>
初始状态（队空条件）：Q-&gt;front == Q-&gt;rear == 0。<br>
进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。<br>
出队操作：队不空时，先取队头元素值，再将队头指针加1。</p>
<h2 id="双端队列">双端队列</h2>
<p>允许两端都可以进行插入和删除操作的线性表<br>
输入受限：一端插入删除，另一端删除<br>
输出受限：一端插入删除，另一端插入</p>
<h2 id="错题-3">错题</h2>
<ol>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307131237.png" alt="Pasted image 20250307131237">c</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307171220.png" alt="Pasted image 20250307171220">循环队列中，每删除一个元素，队首指针 front=(front+1)%6，每插入一个元素，队尾指针 rear=(rear+1)%6。上述操作后，front=0，rear=3</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307172039.png" alt="Pasted image 20250307172039">虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的入队和出队时间复杂度均为O(1)。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175308.png" alt="Pasted image 20250307175308">a</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174201.png" alt="Pasted image 20250307174201">因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要 0(n)的时间。选项 B、C和D均可在 0(1)的时间内找到队首和队尾。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174444.png" alt="Pasted image 20250307174444">队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素,则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，修改队尾指针为rear=front。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175540.png" alt="Pasted image 20250307175540"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175551.png" alt="Pasted image 20250307175551"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180416.png" alt="Pasted image 20250307180416"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180430.png" alt="Pasted image 20250307180430"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307181119.png" alt="Pasted image 20250307181119">第一个元素进入队列后存储在A[0]处，此时 front 和 rear 值都为0。入队时因为要执行(rear+1)%n 操作，所以若入队后指针指向 0，则 rear 初值为 n-1，而因为第一个元素在A[0]中，插入操作只改变rear 指针，所以front为0不变</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182400.png" alt="Pasted image 20250307182400">利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得 R1，C入栈，计算得 R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D依次计算得栈深为 4、3、3。因此选择选项 B</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182639.png" alt="Pasted image 20250307182639"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182649.png" alt="Pasted image 20250307182649"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182804.png" alt="Pasted image 20250307182804">b</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182833.png" alt="Pasted image 20250307182833">c</li>
<li></li>
</ol>
<h1>数组</h1>
<p>线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。<br>
特点：结构固定——定义后，维数和维界不再改变。<br>
LOC(aij)=基地址+偏移量<br>
数组偏移量基址<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20138.png" alt="Untitled 138|Untitled 138.png|300"><br>
以行为例，地址=基地址+(i×n+j)×元素大小</p>
<p>三维数组：a mno<br>
三维数组计算a ijk的公式为d=i* n* o+j* o+k，就是d高* 长* 宽+d长* 高+d宽</p>
<p>typedef elemtype array2【m】【n】;<br>
等价<br>
typedef elemtype array1[n];<br>
typedef array1 array2[m];</p>
<h2 id="压缩存储">压缩存储</h2>
<p>为多个值相同的元只分配一个存储空间；对零元不分配空间。<br>
<strong>特殊矩阵的压缩存储</strong>方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。目的：减少不必要的存储空间</p>
<p>一维数组a[i]的存放地址=起始地址+i* sizeof(ElemType)<br>
存储目的：把一个<strong>n维的数组定义为其数据元素为n-1维数组类型的一维数组</strong>。<br>
二维数组的存储结构：<br>
<mark>行优先存储</mark>：定义二维数组 a：int a【4】【5】。由下图可知，对于行优先，a【2】【3】是第几个元素的求法为：行标2之前的行已填满元素，每行元素有5个，行标2所指的行的元素个数由列标指示出来，因此a【2】【3】是第2x5+3+1=14个元素，a【2】【3】之前有13个元素。<br>
<mark>列优先存储</mark>：对于列优先，a【2】【3】是第几个元素的求法为：列标3之前的列已填满元素，每列元素有4个，列标3所指的列的元素个数由行标指示出来，因此a【2】【3】是第3x4+2+1=15个元素，a【2】【3】之前有14个元素。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/8ee2d0ea49804b7991042179b2c863fb.jpg" alt="8ee2d0ea49804b7991042179b2c863fb"></p>
<p>按列<br>
 LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))* L<br>
按行<br>
LOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))* L</p>
<h2 id="特殊矩阵">特殊矩阵</h2>
<p>矩阵下标默认从1开始<br>
数组默认从0开始</p>
<h2 id="对称矩阵">对称矩阵</h2>
<p>n阶方阵，aij=aji（1⩽i,j⩽n）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104031.png" alt="Pasted image 20250308104031|200">存储策略：只存储主对角线+上/下三角区<br>
元素个数为n(n+1)/2<br>
n阶矩阵A可以用一维数组B== [n(n+1)/2]== 以行序为主序存储其下三角（包括对角线）中的元素，那么B[k]与aij之间存在一一对应关系：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104132.png" alt="Pasted image 20250308104132|350"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/c694632cf58d4933a61613c570a30ddb.jpg" alt="c694632cf58d4933a61613c570a30ddb"></p>
<p>一般存下三角+主对角线，用等差数列，上三角i，j互换就可以</p>
<h2 id="三角阵">三角阵</h2>
<p>存储方法与对称矩阵类似，使用n(n+1)/2+1个存储空间，其中最后一个空间用来存放常数c，在一维数组中的存储结果如下图：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a588174886ae4654a8ae7fafcb71d526.jpg" alt="a588174886ae4654a8ae7fafcb71d526"><br>
下三角：i&lt;j时，有aij=0<br>
上三角：i&gt;j时，有aij=0 上三角为0<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20131.png" alt="Untitled 1 131|Untitled 1 131.png|300"><br>
上三角矩阵的压缩存储公式<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0815_075029.png" alt="Screenshot_2023_0815_075029|350"></p>
<h2 id="三对角矩阵">三对角矩阵</h2>
<p>n(n&gt;=3)阶三对角矩阵中的非零元素都集中在以主对角线为中心的带状区域中，其他区域均为零元，也即当|i-j|&gt;1时，有aij=0。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308120026.png" alt="Pasted image 20250308120026"></p>
<ul>
<li>对于 n×nn×n 的三对角矩阵：
<ul>
<li>第 1 行和最后 1 行只有 2 个非零元素。</li>
<li>中间的行有 3 个非零元素。<br>
那么以行序将这些非零元素存储到一维数组B[3n-3]中，那么对应关系是：<br>
k=2i+j−3（数组下标从0开始）<br>
那么以行序将这些非零元素存储到一维数组B[3n-2]中，那么对应关系是：<br>
k=2i+j−2（数组下标从1开始）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/89d0f9130782418894dfe03158fe2059.jpg" alt="89d0f9130782418894dfe03158fe2059"></li>
</ul>
</li>
</ul>
<h2 id="稀疏矩阵">稀疏矩阵</h2>
<p>0的个数比非零的多<br>
稀疏矩阵进行压缩存储通常有两种方法:顺序存储(三元组)和链式存储(十字链表)<br>
稀疏矩阵采用压缩存储后的缺点主要是<mark>丧失随机存取的特性</mark></p>
<h2 id="错题-4">错题</h2>
<ol>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308111917.png" alt="Pasted image 20250308111917">A[0][0] 存放在 B[0]<br>
对于第 i行，存储的元素为i0 i1 … ii<br>
第 i 行的元素个数为 i+1<br>
前 i 行的元素总数为：1+2+3+⋯+i=(i+1)i/2</li>
<li>二维数组 A 按行优先存储，其中每个元素占1个存储单元。若 A11的存储地址为420，A33的存储地址为446，则A55的存储地址为()<br>
由行优先存储得到aij的地址地址=基地址+(i×n+j)×元素大小，得出基地址407，12列，故a55=472</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114043.png" alt="Pasted image 20250308114043">k=2i+j- 2，195</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114656.png" alt="Pasted image 20250308114656"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114705.png" alt="Pasted image 20250308114705"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115002.png" alt="Pasted image 20250308115002"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115013.png" alt="Pasted image 20250308115013"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115654.png" alt="Pasted image 20250308115654">总数=2+28×3+1=2+84=87或k=2i+j-3</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122246.png" alt="Pasted image 20250308122246">a</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122545.png" alt="Pasted image 20250308122545">按上三角存储，m7,2对应的是m2,7，在它之前有： 第1列：1 第2列：2 第6列：6 第7列：1 前面一共1+2+3+4+5+6+1个元素，共22个元素，数组下标从0开始，故下标为m2,7的数组下标为22。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122839.png" alt="Pasted image 20250308122839"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308123055.png" alt="Pasted image 20250308123055"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308124253.png" alt="Pasted image 20250308124253|400">按列优先次序存储，A[6,7]处于第7行第8列，前面有7列，每一列8x5个单元，再加上第8列前面的6个元素6x5，即7x8x5+6x5=310</li>
<li></li>
</ol>
<h1>串</h1>
<p>定义：是由零个或多个字符组成的有限序列<br>
S=’a1a2a3……an’<br>
编号默认从1开始<br>
串值用单引号括起来<br>
子串：串中任意个连续的字符组成的子序列<br>
字符串的子串数目为n(n+1)/2 + 1<br>
主串：包含子串的串<br>
字符在主串中的位置：字符在串中的序号<br>
子串在主串中的位置：子串的第一个字符在主串中的位置<br>
例如，有串 A=‘china Beijing’，B=‘Beijing’，c=‘china’，则它们的长度分别头13、7 和 5。B 和C是A的子串，B在A中的位置是 7,c 在A中的位置是1。<br>
串是一种特殊的线性表，数据元素之间呈线性关系。但线性表以单个元素为操作对象，而串以整体（子串）为操作对象。</p>
<h2 id="串的存储结构">串的存储结构</h2>
<h2 id="定长顺序存储">定长顺序存储</h2>
<p>类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。<br>
定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> ch[MaxLen]; <span class="comment">// 每个分量存储一个字符</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<h2 id="堆分配存储表示">堆分配存储表示</h2>
<p>堆分配存储表示仍然以一组地址<mark>连续</mark>的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中<mark>动态</mark>分配得到的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *ch; <span class="comment">// 按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">// 串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
<h2 id="块链存储表示">块链存储表示</h2>
<p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a)是结点大小为4(每个结点存放4个字符)的链表，最后一个结点占不满时通常用“#”补上;图 4.1(b)是结点大小为1的链表。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308125233.png" alt="Pasted image 20250308125233|400"></p>
<h2 id="字符串的模式匹配">字符串的模式匹配</h2>
<p>字符串的模式匹配是指在主串中找到与模式串相同的子串，并返回其所在位置。常见的模式匹配算法包括朴素模式匹配算法和KMP算法。</p>
<h2 id="1-朴素模式匹配算法"><strong>1. 朴素模式匹配算法</strong></h2>
<p><strong>基本思想</strong></p>
<ul>
<li>将主串中所有长度为  m  的子串依次与模式串对比，直到找到一个完全匹配的子串或所有子串都不匹配为止。</li>
<li>最多需要对比  n - m + 1  个子串。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308131814.png" alt="Pasted image 20250308131814|250"><br>
<strong>时间复杂度</strong></li>
<li>最坏情况下，时间复杂度为  O(nm) ，其中  n  是主串长度， m  是模式串长度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(HString S, HString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, i;</span><br><span class="line">    HString sub;</span><br><span class="line">    <span class="built_in">InitString</span>(sub);</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="built_in">StrLength</span>(S);</span><br><span class="line">        m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">        i = pos;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">SubString</span>(sub, S, i, m);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">StrCompare</span>(sub, T) != <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化实现（直接通过数组下标）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index1</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= pos &amp;&amp; pos &lt;= S[<span class="number">0</span>]) &#123;</span><br><span class="line">        i = pos;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">2</span>; <span class="comment">// i 指向下一个子串的第一个位置</span></span><br><span class="line">                j = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) <span class="comment">// S 中存在 T</span></span><br><span class="line">            <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-KMP算法"><strong>2. KMP算法</strong></h2>
<p><strong>基本思想</strong></p>
<ul>
<li>利用已经匹配过的模式串信息，避免主串指针回溯。
<ul>
<li>特点是在模式匹配时，指示主串的指针不会变小</li>
</ul>
</li>
<li>通过预处理模式串，生成 <code>next</code> 数组，记录模式串中每个位置的最长公共前后缀长度。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308132051.png" alt="Pasted image 20250308132051"><br>
<strong>时间复杂度</strong></p>
<ul>
<li>预处理 <code>next</code> 数组的时间复杂度为  O(m) 。</li>
<li>匹配过程的时间复杂度为  O(n) 。</li>
<li>总时间复杂度为  O(n + m) 。<br>
<strong>核心思想</strong></li>
<li>在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位j与主串位 i比较时，两个字符不相等，则i的位移方式是 <code>next[j]</code> ，而不是从头开始匹配。主串位指针i不变</li>
<li><code>next</code> 数组的定义：<code>next[j]</code> 表示模式串中前  j  个字符的最长公共前后缀长度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(SString T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> next[T[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">getNext</span>(T, next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>next</code> 数组的优化（<code>nextval</code> 数组）</strong></p>
<ul>
<li>通过进一步优化 <code>next</code> 数组，减少不必要的比较。</li>
<li>当 <code>T[i] == T[j]</code> 时，<code>nextval[i] = nextval[j]</code>；否则，<code>nextval[i] = j</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>朴素模式匹配算法</strong></th>
<th><strong>KMP算法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>O(nm)</td>
<td>O(n + m)</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(1)</td>
<td>O(m) （<code>next</code> 数组）</td>
</tr>
<tr>
<td><strong>主串指针回溯</strong></td>
<td>需要回溯</td>
<td>不需要回溯</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>模式串较短，主串较小</td>
<td>模式串较长，主串较大</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>朴素模式匹配算法</strong>：实现简单，但效率较低，适合小规模数据。</li>
<li><strong>KMP算法</strong>：通过预处理模式串，避免主串指针回溯，适合大规模数据。</li>
<li><strong><code>nextval</code> 数组</strong>：进一步优化 <code>next</code> 数组，减少不必要的比较。</li>
</ul>
<h2 id="模式串示例">模式串示例</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308141430.png" alt="Pasted image 20250308141430"><br>
next：</p>
<ol>
<li>前两个0,1</li>
<li>之后在当前索引前找两个正向的最大公共子串，next为第一个子串的下一个索引值，例如索引6，看1—5有aba公共子串，next6为4</li>
</ol>
<p>nextval：</p>
<ol>
<li>第一个为0</li>
<li>之后看对应的next值所对应的索引字母，例如索引为3的nextval，对应的next为1，对应的索引字母为a，索引3的字母也为a，nextval为索引为1的nextval；若不是同一个字母，nextval则为对应的next值，例如索引为6的对应next4的字母为b，6为a，不一样，nextval为当前next值4<br>
T = “abacab”<br>
next = [0, 1, 1, 0, 1, 2]<br>
nextval = [0, 1, 0, 1, 0, 1]</li>
</ol>
<p>ababaaababaa<br>
next=<code>[011234223456]</code></p>
<p>aaab<br>
next=<code>[0123]</code><br>
nextval=<code>[0003]</code></p>
<h2 id="错题-5">错题</h2>
<ol>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143227.png" alt="Pasted image 20250308143227"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143253.png" alt="Pasted image 20250308143253"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143322.png" alt="Pasted image 20250308143322"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308144541.png" alt="Pasted image 20250308144541"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/66d2e1adc05dd53c7bb762eebfa395b.jpg" alt="66d2e1adc05dd53c7bb762eebfa395b|400"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308145836.png" alt="Pasted image 20250308145836">next<code>[0112342]</code> nextval<code>[0101042]</code> j-nextval<code>[6]</code>=2</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152637.png" alt="Pasted image 20250308152637">a</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308151042.png" alt="Pasted image 20250308151042">由于i=j=5时失效，故主串和模式串的位序都是从0开始的。此时i=5，next<code>[j]</code>=next<code>[5]</code>=2，c<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152257.png" alt="Pasted image 20250308152257|300"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152151.png" alt="Pasted image 20250308152151">b</li>
</ol>
<h1>二叉树</h1>
<ol>
<li><strong>树的定义</strong>
<ul>
<li><strong>m叉树</strong>：每个结点最多有 <code>m</code> 个子结点，可以为空树。</li>
<li><strong>树的度</strong>：所有结点的度的最大值。
<ul>
<li><strong>度为m的树</strong>：各结点的度的最大值<br>
至少有一个结点度=m<br>
至少有m+1个结点</li>
</ul>
</li>
<li><strong>叶子结点</strong>（终端结点）：没有子结点的结点。</li>
<li><strong>分支结点</strong>（非终端结点）：至少有一个子结点的结点。</li>
<li><strong>根结点</strong>：唯一没有前驱的结点，既可以是叶子结点（空树），也可以是分支结点。</li>
</ul>
</li>
<li><strong>结点与度的关系</strong>
<ul>
<li><strong>结点数 = 总度数 + 1</strong><br>
（每个结点被父结点指向一次，根结点无父结点）</li>
<li><strong>分支数 = 结点数 - 1 = 总度数</strong><br>
（每个分支对应一个子结点）</li>
<li><strong>节点度数关系</strong> n0​=n2​+2n3​+…+(k−1)nk​+1</li>
<li>
<h2 id="总节点数与度数关系"><strong>总节点数与度数关系</strong></h2>
对于完全二叉树或多叉树：<br>
n=1+n1+2n2+3n3（总分支数 + 根节点）<br>
n=n0+n1+n2+n3（总节点数）<br>
总度数=n-1=n1+2n2+3n3<br>
3.<strong>树的路径与高度</strong></li>
<li><strong>路径长度</strong>：根到每个结点的路径长度之和。</li>
<li><strong>树的深度/深度</strong>：根结点的层数（通常从 1 开始）。</li>
</ul>
</li>
</ol>
<h2 id="树的性质">树的性质</h2>
<ol>
<li><strong>结点数范围</strong>
<ul>
<li><strong>高度为 <code>h</code> 的 m 叉树</strong>：
<ul>
<li><strong>至少</strong>有 <code>h</code> 个结点（每层仅 1 个结点）。</li>
<li><strong>至多</strong>有 <code>(m^h - 1)/(m - 1)</code> 个结点（满 m 叉树）<br>
二叉树2^n-1个</li>
</ul>
</li>
<li><strong>高度为 <code>h</code>、度为 <code>m</code> 的树</strong>：至少 <code>h + m - 1</code> 个结点</li>
<li>度为 m、具有 n个结点的树的最大高度h为n-m+1</li>
<li>度为m的树中<strong>第i层</strong>上至多有**m^(i-1)个结点(i≥1)</li>
</ul>
</li>
<li><strong>最小高度公式</strong>
<ul>
<li><strong>具有 <code>n</code> 个结点的 m 叉树</strong>的最小高度logm(n(m-1)+1)</li>
</ul>
</li>
<li><strong>树的形态数</strong>
<ul>
<li><code>n</code> 个结点的二叉树共有 <code>C(2n, n)/(n+1)</code> 种不同形态（卡塔兰数）。</li>
<li>例：3 个结点的二叉树有 5 种形态。</li>
</ul>
</li>
</ol>
<h2 id="二叉树">二叉树</h2>
<ol>
<li><strong>定义与性质</strong>
<ul>
<li><strong>二叉树</strong>：每个结点最多有 2 个子结点，且左右子树<strong>有序</strong>。</li>
<li><strong>度为2</strong>的树至少有3个结点，而二叉树可以为空</li>
<li><strong>非空二叉树</strong>的叶子结点数 <code>n0</code> 与二分支结点数 <code>n2</code> 的关系：n0=n2+1</li>
<li><strong>高度 H 的二叉树</strong>：</li>
<li>最多节点数：2k − 1（满二叉树）</li>
<li>最少节点数：k（退化为链式结构）</li>
<li>第i层至多有2^(i-1)个结点</li>
</ul>
</li>
<li><strong>特殊二叉树</strong>
<ul>
<li><strong>满二叉树</strong>：
<ul>
<li>高度 <code>h</code>，结点数 <code>2^h - 1</code>。</li>
<li>只有最后一层有叶子结点，不存在度为 1 的结点。</li>
</ul>
</li>
<li><strong>完全二叉树</strong>：
<ul>
<li>由满二叉树删除最底层最右侧连续若干结点形成。</li>
<li><strong>性质</strong>：
<ul>
<li>叶子结点只出现在<strong>最后两层</strong>。</li>
<li>最多一个度为 1 的结点（左孩子），为最后一个分支结点，其结点编号为<code>[n/2]</code>，且n为偶数时，若为奇数，每个分支都有左右孩子</li>
<li>编号为 <code>i</code> 的结点，左孩子为 <code>2i</code>，右孩子为 <code>2i + 1</code>。</li>
<li>按层次编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点</li>
<li>i≤<code>[n/2]</code>（向下取整）为<strong>分支结点</strong>，i&gt;<code>[n/2]</code>（向上取整）为<strong>叶子结点</strong></li>
<li>结点数为 <code>n</code> 时，叶子结点数 <code>n0 = ⌈n/2⌉</code>（向上取整）</li>
<li>满二叉树一定是完全二叉树</li>
<li>当结点数目一定时，具有最小深度的二叉树是完全二叉树</li>
<li>最少节点数：2^(h−1)</li>
<li>最多节点数：2^h − 1</li>
<li>深度（高度）公式：  log2(n+1)向上取整 或 (log2n)+1向下取整</li>
<li>度为0、1、2的节点关系：<br>
n0=n2+1n0​=n2​+1，且 n0+n2n0​+n2​ 必为奇数。
<ul>
<li><strong>偶数节点数 2k</strong>：n1=1, n0=k, n2​=k−1</li>
<li><strong>奇数节点数 2k−1</strong>：n1​=0,n0​=k, n2​=k−1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>偶数节点数</strong>：编号最大的分支节点（编号 n/2）仅有左子女。</li>
<li><strong>奇数节点数</strong>：所有分支节点均有左右子女。</li>
</ul>
</li>
</ol>
<h2 id="二叉排序树（BST）">二叉排序树（BST）</h2>
<ol>
<li>
<p><strong>定义</strong></p>
<ul>
<li>左子树所有结点值 &lt; 根结点值 &lt; 右子树所有结点值。</li>
<li><strong>中序</strong>遍历结果为<mark>有序</mark>序列。</li>
<li>左子树和右子树又各是一颗二叉排序树</li>
<li>最左结点数值最小</li>
<li>对于n个结点的二叉排序树，其最大高度值为n</li>
<li>可用于元素的排序、搜索</li>
</ul>
</li>
<li>
<p><strong>操作与性质</strong></p>
<ul>
<li><strong>插入与查找</strong>：
<ul>
<li>平均时间复杂度 <code>O(log2n)</code>（平衡时）。</li>
<li>最坏时间复杂度 <code>O(n)</code>（退化为链表）。</li>
</ul>
</li>
<li><strong>删除操作</strong>：
<ul>
<li><strong>叶子结点</strong>：直接删除。</li>
<li><strong>单子树结点</strong>：用子树替代被删结点。</li>
<li><strong>双子树结点</strong>：用前驱（左子树最大结点）或后继（右子树最小结点）替代。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="平衡二叉树（AVL-树）">平衡二叉树（AVL 树）</h2>
<ul>
<li>任意结点的左右子树高度差绝对值 ≤ 1【胖、多 搜索效率更高】</li>
<li>查找时间复杂度稳定为 <code>O(log n)</code>。</li>
<li><strong>平衡因子</strong> = 左子树深度 - 右子树深度，取值范围为 {-1, 0, 1}。</li>
<li>若所有结点平衡因子为 0，则为<strong>满二叉树</strong>。</li>
<li>平均查找长度为O(log2n)</li>
<li>
<ul>
<li>最大深度：O(log⁡2n)O(log2​n)</li>
</ul>
</li>
</ul>
<p><strong>二叉树的构造</strong></p>
<p><strong>平衡调整操作</strong></p>
<ul>
<li><strong>最小不平衡子树</strong>：只需调整最近失衡的子树，上层结点会自动平衡。<br>
当插入或删除导致平衡因子超出范围时，需通过旋转调整树结构。调整分为四种情况：</li>
</ul>
<ol>
<li>
<p><strong>LL 型（右单旋转）</strong>：</p>
<ul>
<li><strong>触发条件</strong>：新结点插入在左子树的左子树中。</li>
<li><strong>操作</strong>：以失衡结点为轴，向右旋转。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A (失衡)            B</span><br><span class="line">   /                  /   \</span><br><span class="line">  B        →        C       A</span><br><span class="line"> /</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>RR 型（左单旋转）</strong>：</p>
<ul>
<li><strong>触发条件</strong>：新结点插入在右子树的右子树中。</li>
<li><strong>操作</strong>：以失衡结点为轴，向左旋转。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A (失衡)                B</span><br><span class="line"> \                   /   \</span><br><span class="line">  B        →        A       C</span><br><span class="line">   \</span><br><span class="line">    C</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>LR 型（先左旋后右旋）</strong>：</p>
<ul>
<li><strong>触发条件</strong>：新结点插入在左子树的右子树中。</li>
<li><strong>操作</strong>：先对左子树左旋（转为 LL 型），再对失衡结点右旋。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A              A            C</span><br><span class="line"> /              /           /   \</span><br><span class="line">B      →       C     →    B       A</span><br><span class="line"> \            /</span><br><span class="line">  C          B</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>RL 型（先右旋后左旋）</strong>：</p>
<ul>
<li><strong>触发条件</strong>：新结点插入在右子树的左子树中。</li>
<li><strong>操作</strong>：先对右子树右旋（转为 RR 型），再对失衡结点左旋。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A              A                C</span><br><span class="line"> \              \             /   \</span><br><span class="line">  B      →       C     →    A       B</span><br><span class="line"> /                \</span><br><span class="line">C                  B</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311120615.png" alt="Pasted image 20250311120615|400"></p>
<p>从所插入结点的路径向上查找，找到违反平衡因子的根结点连续的三个结点，min-mid-max，再按二叉排序树的性质插入剩下的结点<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309124217.png" alt="Pasted image 20250309124217|400"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115540.png" alt="Pasted image 20250311115540|300"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115547.png" alt="Pasted image 20250311115547|250"></p>
<h2 id="B-树">B 树</h2>
<ol>
<li>
<p><strong>阶数 m</strong>：节点最多有 m 棵子树（m&gt;=3）</p>
</li>
<li>
<p><strong>节点子树数约束</strong>：</p>
<ul>
<li>根节点：至少 2 棵子树（除非仅一个节点）。</li>
<li>非根节点：至少<code>[m/2]</code>棵子树（如 m=5 ，至少 3 棵子树）<br>
<strong>叶子结点</strong>：均位于同一层，不存储数据（或存储空指针）。<br>
<strong>关键字与子树关系</strong>：</li>
<li>关键字数 = 子树数 - 1。</li>
<li>非叶节点有 j 棵子树时，含 j-1 个关键字。<br>
<strong>关键字规则</strong>：</li>
<li>所有关键字按升序排列。</li>
<li>关键字将子树划分为区间，如结点含关键字  k1, k2 ，则子树范围为 ( -∞, k1), ( k1, k2) , ( k2, ±∞)。</li>
</ul>
</li>
<li>
<p><strong>2-3树</strong>：3阶B树，非叶节点有2或3棵子树。</p>
</li>
<li>
<p><strong>B+树</strong>：支持顺序查找；B树支持多路查找。</p>
<ul>
<li><strong>根结点</strong>：至少 2 棵子树（除非树为空）。<br>
<strong>B 树的操作</strong></li>
</ul>
</li>
<li>
<p><strong>插入</strong>：</p>
<ul>
<li>若结点关键字数超过上限( m-1 ），需<strong>分裂</strong>：
<ul>
<li>将中间关键字提升到父结点，左右部分形成新结点。</li>
<li>若父结点也溢出，递归分裂直到根结点。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>删除</strong>：</p>
<ul>
<li><strong>非叶子结点删除</strong>：用前驱或后继关键字替代。</li>
<li><strong>叶子结点删除</strong>：
<ul>
<li>若删除后关键字数 ≥<code>[m/2]</code>-1，直接删除。</li>
<li>否则需向兄弟结点借关键字或合并结点。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="B-树与-B-树的区别"><strong>B+ 树与 B 树的区别</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>B 树</strong></th>
<th><strong>B+ 树</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>关键字存储</strong></td>
<td>所有结点均存储数据</td>
<td>仅叶子结点存储数据，非叶结点为索引</td>
</tr>
<tr>
<td><strong>叶子结点链接</strong></td>
<td>无</td>
<td>叶子结点通过指针链接，支持顺序遍历</td>
</tr>
<tr>
<td><strong>查询效率</strong></td>
<td>随机查询效率高</td>
<td>范围查询和顺序遍历效率高</td>
</tr>
<tr>
<td><strong>结构复杂度</strong></td>
<td>结点结构简单</td>
<td>非叶结点仅存索引，结构更紧凑</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>AVL 树</strong>：通过平衡因子和旋转操作维持平衡，适用于频繁查找的场景。</li>
<li><strong>B 树</strong>：多路平衡查找树，减少磁盘 I/O 次数，适合文件系统和数据库索引。</li>
<li><strong>B+ 树</strong>：在 B 树基础上优化范围查询，广泛应用于数据库和操作系统中。</li>
</ul>
<h2 id="二叉树的存储结构">二叉树的存储结构</h2>
<h2 id="顺序存储">顺序存储</h2>
<ol>
<li><strong>适用场景</strong>：完全二叉树。</li>
<li><strong>原理</strong>：
<ul>
<li>通过数组下标直接计算父子关系（如父结点 <code>i</code> 的左孩子为 <code>2i</code>，右孩子为 <code>2i+1</code>）。</li>
<li>若树非完全二叉树，需填充空结点以保证结构，导致内存浪费。</li>
</ul>
</li>
<li><strong>优缺点</strong>：
<ul>
<li><strong>优点</strong>：快速定位父子结点，无需额外指针。</li>
<li><strong>缺点</strong>：
<ul>
<li>单支树（深度为 <code>k</code>）需数组长度为 <code>2^k - 1</code>（指数级内存消耗）。</li>
<li>非完全二叉树存在大量空位。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="type">bool</span> isEmpty;</span><br><span class="line">&#125; t[MAXSIZE];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="链式存储">链式存储</h2>
<p><strong>空链域数量</strong>：</p>
<ul>
<li>在含 <code>n</code> 个结点的二叉链表中，共有 <code>n+1</code> 个空链域。</li>
<li><strong>推导</strong>：
<ul>
<li>每个结点有 2 个指针（左、右），总指针数为 <code>2n</code>。</li>
<li>树的边数为 <code>n-1</code>（树的性质），即使用的指针数为 <code>n-1</code>。</li>
<li>空链域数 = 总指针数 - 使用指针数 = <code>2n - (n-1) = n+1</code>。</li>
</ul>
</li>
<li><strong>用途</strong>：空链域可用于构造线索二叉树（标记前驱/后继）。</li>
</ul>
<ol>
<li><strong>二叉链表</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：无法直接找到父结点，需从根遍历。</li>
<li><strong>空链域</strong>：<code>n+1</code> 个（同前文推导）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20132.png" alt="Untitled 1 132|Untitled 1 132.png|300"><br>
<strong>三叉链表</strong>：<br>
空链域：n+2个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild, *parent;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特点</strong>：增加父结点指针，方便反向查找  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309152923.png" alt="Pasted image 20250309152923|400"></li>
</ul>
</li>
</ol>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<ol>
<li>
<p><strong>遍历顺序</strong>：</p>
<ul>
<li><strong>先序遍历</strong>：根 → 左 → 右</li>
<li><strong>中序遍历</strong>：左 → 根 → 右</li>
<li><strong>后序遍历</strong>：左 → 右 → 根</li>
<li><strong>层序遍历</strong>：自上而下、从左到右逐层遍历。</li>
</ul>
</li>
<li>
<p><strong>递归实现与栈的关系</strong>：</p>
<ul>
<li>递归遍历的本质是隐式使用系统调用栈，空间复杂度为树高  O(h) 。</li>
<li><strong>前序序列与中序序列的关系</strong>：
<ul>
<li>前序序列相当于<strong>入栈顺序</strong>，中序序列相当于<strong>出栈顺序</strong>。</li>
<li>例如：前序 <code>[A,B,C]</code> 和中序 <code>[B,A,C]</code>，可唯一确定一棵二叉树。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>层序遍历实现</strong>：</p>
<ul>
<li><mark>**队列</mark>辅助**：
<ol>
<li>根结点入队。</li>
<li>循环：出队结点访问，并将其左右孩子入队。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        BiTNode* p;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>特点</strong>：按层输出，适合求树的最小宽度或层次相关操作。</li>
</ul>
</li>
</ol>
<p><strong>遍历序列的唯一性</strong></p>
<ol>
<li><strong>单一遍历序列无法唯一确定二叉树</strong>：
<ul>
<li>例如：前序 <code>[A,B]</code> 可对应两种结构（B为左孩子或右孩子）。</li>
</ul>
</li>
<li><strong>唯一确定条件</strong>：
<ul>
<li><strong>中序 + 前序/后序/层序</strong>：可唯一还原二叉树。</li>
<li><strong>前序 + 后序</strong>：仅当树是满二叉树时可唯一确定。<br>
若只给出一棵二叉树的前/中/后/层 序遍历的一种，不能唯一确定一棵二叉树。<br>
一定是由中+前/后/序<br>
若有一个<mark>叶结点</mark>是二叉树中某个子树的<mark>中序</mark>遍历结果序列的最后一个结点，则它一定是该子树的<mark>前序</mark>遍历结果序列的最后一个结点<br>
<strong>前、中、后遍历序列中<mark>叶子结点</mark>的相对位置是不变的</strong><br>
若一棵二叉树的中序序列和后序序列相同，则二叉树为空树或二叉树任一结点没有右子树；反之，前序和中序相同，左<br>
若先序和后序相反，则高度=结点数<br>
已知先/后序与中序：<br>
x轴是中序，y轴是 先序 或 倒的后序<br>
找最高点M，在M左侧找最高点L，右侧最高点R，连接，递归<br>
如果先序遍历序列和层序遍历序列相同，则这个二叉树是一个单支树</li>
</ul>
</li>
</ol>
<h2 id="线索二叉树">线索二叉树</h2>
<p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。</strong><br>
<strong>由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在</strong><mark><strong>遍历</strong></mark><strong>的过程中修改空指针的过程。</strong><br>
若无左子树，令lchild指向其前驱结点；<br>
若无右子树，令rchild指向其后继结点。<br>
左前驱，右后继<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/v2-014d37e12cb6f8fa81143a1ae372f854_b.png" alt="v2-014d37e12cb6f8fa81143a1ae372f854_b|400"><br>
还需要增加两个标志语表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。<br>
l</p>
<ol>
<li>ltag== 0，指向左孩子；ltag== 1，指向前驱结点【指线索/指针/地址】</li>
<li>rtag== 0，指向右孩子；rtag== 1，指向后继结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag; <span class="comment">// 0:孩子指针；1:线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ltag=1</code>：左指针指向前驱；<code>rtag=1</code>：右指针指向后继。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/10ae36162db147adb9e3662d9072f8dd.png" alt="10ae36162db147adb9e3662d9072f8dd"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310102313.png" alt="Pasted image 20250310102313|400"></li>
</ul>
</li>
</ol>
<p>有了这些前驱后继信息的好处是：在查找某个结点时就可以类似链表那样很方便的从表头遍历到表尾，并且空间复杂度只有 O ( 1 ) 。而前面二叉树的遍历中，无论递归还是非递归，都要用到栈，空间复杂度跟二叉树的具体形态有关。<br>
二叉树在线索化后，仍不能有效求解的问题是<mark>后序线索二叉树中求后序后继</mark></p>
<ul>
<li><strong>逻辑结构</strong>：描述数据元素之间的抽象关系，如二叉树、链表、图等。
<ul>
<li><strong>二叉树</strong>：一种分层结构，每个结点最多有两个子结点，用于表达数据间的层次关系，属于逻辑结构。</li>
</ul>
</li>
<li><strong>物理结构</strong>：描述数据在计算机内存中的具体存储方式，如顺序存储（数组）、链式存储（指针）等。
<ul>
<li><strong>线索二叉树</strong>：在链式存储的基础上，通过修改空指针为线索（前驱/后继），优化遍历效率，属于物理结构。</li>
</ul>
</li>
</ul>
<p><strong>后序线索二叉树无法有效求解后序后继的原因</strong><br>
后序遍历的顺序为 <strong>左→右→根</strong>，根结点最后被访问。后序线索化的局限性体现在以下场景：<br>
<strong>场景 1：分支结点的左右子树均为叶结点</strong><br>
假设结点 <code>A</code> 是父结点 <code>P</code> 的左孩子，且 <code>A</code> 的左右子树均为叶结点：</p>
<ul>
<li>
<p><strong>后序遍历顺序</strong>：左叶 → 右叶 → <code>A</code> → <code>P</code> 的右子树 → <code>P</code> → …</p>
</li>
<li>
<p><strong>问题</strong>：<code>A</code> 的后继应为 <code>P</code> 的右子树的最左下叶结点，但 <code>A</code> 的右指针可能直接指向 <code>P</code>（作为线索），无法跳转到 <code>P</code> 的右子树，导致无法直接找到正确后继。<br>
<strong>场景 2：根结点的右子树非空</strong></p>
</li>
<li>
<p><strong>后序遍历顺序</strong>：左子树 → 右子树 → 根结点。</p>
</li>
<li>
<p><strong>问题</strong>：根结点的右指针指向实际右子结点，而非线索化的后继（因为根结点是最后一个被访问的结点，没有后继）。</p>
</li>
<li>
<p><strong>示例</strong>：根结点 <code>R</code> 有右子树，遍历到 <code>R</code> 时，其右指针指向右子结点，而非空，无法通过线索直接确定后继。<br>
<strong>关键限制</strong></p>
</li>
<li>
<p><strong>无法回溯父结点</strong>：后序线索仅记录直接前驱/后继，但某些后继需要通过父结点的右子树路径确定。</p>
</li>
<li>
<p><strong>依赖栈或父指针</strong>：在非线索化遍历中，栈用于记录路径以回溯父结点；而线索化无法提供此信息，导致必须额外维护栈。</p>
</li>
<li>
<p>先序线索二叉树 ABDGECF<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%206%2080.png" alt="Untitled 6 80|Untitled 6 80.png|400"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2076.png" alt="Untitled 7 76|Untitled 7 76.png|400"></p>
</li>
<li>
<p>中序线索二叉树<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2071.png" alt="Untitled 8 71|Untitled 8 71.png|400"></p>
</li>
</ul>
<ol>
<li><strong>中序线索树</strong>：
<ul>
<li>某结点有右孩子 → 其后继为右子树的最左下结点。</li>
<li>某结点有左孩子 → 其前驱为左子树的最右下结点。<br>
注意：</li>
</ul>
</li>
<li><strong>限制</strong>：
<ul>
<li><strong>后序线索二叉树</strong>：无法高效求解后序后继（需栈支持）。</li>
<li><strong>前序/中序线索树</strong>：可无栈遍历，时间复杂度 O(n)，空间复杂度O(1)</li>
</ul>
</li>
<li><strong>线索化目的</strong>：
<ul>
<li>利用空链域（<code>n+1</code>个）记录前驱/后继，加速遍历。</li>
<li><strong>实质</strong>：遍历时修改空指针为线索。</li>
</ul>
</li>
</ol>
<p><strong>应用场景</strong></p>
<ol>
<li>
<p><strong>求树深度</strong>：</p>
<ul>
<li>递归遍历左右子树深度，取最大值加1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">Depth</span>(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>线索化优势</strong>：</p>
<ul>
<li>遍历无需栈，空间复杂度优化为  O(1) 。</li>
<li>适用于频繁遍历但插入/删除较少的场景。</li>
</ul>
</li>
<li>
<p><strong>设计选择</strong>：</p>
<ul>
<li>频繁查找前驱/后继 → 线索二叉树。</li>
<li>频繁插入/删除 → 普通链式存储。</li>
</ul>
</li>
</ol>
<ul>
<li>线索化本质是空间换时间，适用于遍历密集型操作。</li>
</ul>
<h2 id="树的存储结构">树的存储结构</h2>
<ol>
<li><strong>双亲表示法</strong>：
<ul>
<li><strong>原理</strong>：每个结点存储数据及其父结点索引（根结点的父结点索引为空）。</li>
<li><strong>优点</strong>：
<ul>
<li>快速查找父结点（时间复杂度  O(1) ）。</li>
<li>存储结构简单，仅需一个数组即可表示整棵树。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>查找子结点需遍历整个表（时间复杂度  O(n) ）。</li>
<li>插入或删除结点时需维护索引一致性，复杂度较高。</li>
</ul>
</li>
<li><strong>适用场景</strong>：频繁查找父结点且子结点操作较少的场景，如家谱关系管理。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310130809.png" alt="Pasted image 20250310130809|500"></li>
</ul>
</li>
<li><strong>孩子表示法</strong>：
<ul>
<li><strong>原理</strong>：每个结点存储数据及子结点链表的头指针。</li>
<li><strong>优点</strong>：
<ul>
<li>快速查找子结点（直接通过链表访问，时间复杂度  O(k) ， k  为子结点数）。</li>
<li>适合动态增删子结点的场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>查找父结点需从根结点遍历，效率低（时间复杂度  O(n) ）。</li>
<li>存储空间较大（每个结点需额外维护链表指针）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：需要频繁操作子结点（如文件系统目录树）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310131023.png" alt="Pasted image 20250310131023"></li>
</ul>
</li>
<li><strong>二叉树表示法（孩子兄弟表示法）</strong>：
<ul>
<li><strong>原理</strong>：将普通树转换为二叉树，规则如下：
<ul>
<li><strong>左指针</strong>指向第一个孩子结点（最左子结点）。</li>
<li><strong>右指针</strong>指向当前结点的下一个兄弟结点。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>一个普通树转化成的二叉树一定没有右子树。</li>
<li><strong>森林转换</strong>：先把森林转化为二叉树，再存储二叉树（如森林 {T1, T2}转换为 T1-&gt;T2）。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>统一使用二叉树结构，可复用二叉树的遍历、插入、删除等算法。</li>
<li>节省存储空间（仅需两个指针）。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>逻辑结构需通过指针关系间接理解，初次接触可能较难适应。</li>
<li>遍历时需区分“孩子”与“兄弟”指针，逻辑稍复杂。</li>
</ul>
</li>
<li><strong>适用场景</strong>：需要利用二叉树算法处理一般树或森林的场景（如编译器语法树）。<br>
双亲表示法是顺序存储结构，孩子表示法和孩子兄弟表示法是链式存储结构</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><strong>存储效率</strong>：</p>
<ul>
<li>双亲表示法最节省空间，但功能单一；</li>
<li>孩子兄弟表示法在空间和功能间取得平衡，适合通用场景。</li>
</ul>
</li>
<li>
<p><strong>操作效率</strong>：</p>
<ul>
<li>若需频繁查找父结点，双亲表示法最优；</li>
<li>若需频繁操作子结点，孩子表示法或双亲孩子表示法更优。</li>
</ul>
</li>
<li>
<p>**转换：</p>
<ul>
<li><strong>树 → 二叉树</strong>：  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310160725.png" alt="Pasted image 20250310160725|300"></li>
<li><strong>森林 &lt;-&gt; 二叉树</strong>：  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310161030.png" alt="Pasted image 20250310161030|400"><br>
森林-&gt;二叉树，右子树非空（因为各树根节点通过右指针链接）<br>
二叉树-&gt;森林，若根节点有右子树，则右子树拆分成独立的树<br>
<strong>森林与二叉树的转换</strong>是唯一的，且右指针为空的数量与非终端结点数相关<br>
森林树的数量=森林结点数-边数<br>
<strong>森林的非终端结点数 n → 二叉树右指针为空的结点数 n+1</strong>：<br>
非终端节点指有子结点的节点（包括跟根节点）<br>
每个非终端结点对应一个右指针，最后一个兄弟右指针为空。<br>
<strong>森林的叶结点数 = 二叉树左指针为空的结点数</strong><br>
原森林的叶结点在二叉树中无左孩子<br>
高度为h的满二叉树对应森林所含树的个数为h</li>
</ul>
</li>
<li>
<p><strong>树转二叉树</strong>：无右子树。</p>
</li>
<li>
<p><strong>森林转二叉树</strong>：右子树存在（各树根通过右指针链接）。</p>
</li>
</ul>
<h2 id="树的遍历方式">树的遍历方式</h2>
<h2 id="树的先根遍历（深度优先遍历）">树的先根遍历（深度优先遍历）</h2>
<p>先访问树的根节点，然后依次先根遍历根的每棵子树。这种遍历方式和二叉树的先序遍历（先访问根节点，再访问左子树，最后访问右子树）类似。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20234.png" alt="Untitled 234|Untitled 234.png"></p>
<h2 id="树的后根遍历（深度优先遍历）">树的后根遍历（深度优先遍历）</h2>
<p>先依次后根遍历根的每棵子树，然后再访问根节点。这种遍历方式类似于二叉树的中序遍历（先访问左子树，再访问根节点，最后访问右子树） 。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20135.png" alt="Untitled 1 135|Untitled 1 135.png"></p>
<h2 id="树的层次遍历（广度优先遍历）">树的层次遍历（广度优先遍历）</h2>
<p>按照层次，从根节点开始，一层一层地访问节点，同一层的节点按照从左到右的顺序进行访问。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%20119.png" alt="Untitled 2 119|Untitled 2 119.png"></p>
<h2 id="森林的遍历方式">森林的遍历方式</h2>
<p>森林是由 m（m≥0）棵互不相交的树组成的集合。</p>
<h2 id="森林的先序遍历">森林的先序遍历</h2>
<p>依次对森林中的各个树进行先根遍历，这等同于依次对与森林对应的二叉树进行先序遍历。具体过程是：先访问森林中第一棵树的根节点，然后先序遍历第一棵树的子树森林，接着先序遍历除去第一棵树之后剩余的树组成的森林。</p>
<h2 id="森林的中序遍历">森林的中序遍历</h2>
<p>依次对森林中的各个树进行后根遍历，也就相当于依次对与森林对应的二叉树进行中序遍历。具体过程为：先中序遍历森林中第一棵树的子树森林，然后访问第一棵树的根节点，接着中序遍历除去第一棵树之后剩余的树组成的森林。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310163959.png" alt="Pasted image 20250310163959"><br>
关键结论 ：</p>
<ul>
<li><strong>顺序存储</strong>适合完全二叉树，否则内存浪费严重。</li>
<li><strong>线索二叉树</strong>通过利用空链域优化遍历，但后序线索化无法完全消除栈依赖。</li>
<li><strong>普通树转二叉树</strong>后右子树为空（根无兄弟），森林转换则通过右指针链接各树根。</li>
<li><strong>三叉链表</strong>以空间换时间，支持父结点快速访问。</li>
</ul>
<h2 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h2>
<p>是对数据压缩和编码长度的优化</p>
<ol>
<li><strong>带权路径长度（WPL）</strong>
<ul>
<li><strong>定义</strong>：树中所有叶结点的带权路径长度之和。</li>
<li><strong>公式</strong>：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310172719.png" alt="Pasted image 20250310172719|400"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173324.png" alt="Pasted image 20250310173324|450"><br>
加权平均长度=带权路径长度/所有结点频次之和_</li>
</ul>
</li>
<li><strong>哈夫曼树（最优二叉树）</strong>
<ul>
<li><strong>目标</strong>：构造 WPL 最小的二叉树。</li>
<li><strong>特点</strong>：
<ul>
<li>权值越小的叶结点离根越远，路径长度越大。</li>
<li>构造过程中新建  n-1  个内部结点，总结点数为  2n-1 。</li>
<li>不存在度为 1 的结点（n0=n2+1，已知n0叶结点可求n2双分支节点）</li>
<li>n个初始节点构造哈夫曼树共新建n-1个双分支结点，因此哈夫曼树的节点总数是2n-1，是奇数</li>
<li>权值最小的两个结点互为兄弟。</li>
<li>用一组权值构造出的哈夫曼树可能不唯一（左右子树不同），但带权路径长度唯一<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173511.png" alt="Pasted image 20250310173511|500"></li>
</ul>
</li>
</ul>
</li>
<li><strong>前缀编码</strong>
<ul>
<li><strong>定义</strong>：没有一个编码是另一个编码的前缀，保证解码唯一性【检查所有编码是否互不为前缀】</li>
<li><strong>实现方式</strong>：通过哈夫曼树生成可变长度编码，左分支标记为 <code>0</code>，右分支标记为 <code>1</code>。</li>
</ul>
</li>
</ol>
<h2 id="哈夫曼树构造步骤">哈夫曼树构造步骤</h2>
<ol>
<li><strong>初始化</strong>：将  n  个权值作为独立的单结点树。</li>
<li><strong>合并子树</strong>：
<ul>
<li>每次选择权值最小的两棵树合并，生成新结点作为其父结点，权值为子树权值之和。</li>
<li>重复此过程直至只剩一棵树。</li>
</ul>
</li>
<li><strong>贪心算法依据</strong>：局部最优选择（合并最小权值树）保证全局最优（WPL 最小）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173701.png" alt="Pasted image 20250310173701|500"></li>
</ol>
<h2 id="应用场景与优势">应用场景与优势</h2>
<ol>
<li>
<p><strong>数据压缩</strong>：</p>
<ul>
<li>对高频字符分配短编码，低频字符分配长编码，显著减少总编码长度。</li>
</ul>
</li>
<li>
<p><strong>文件传输</strong>：</p>
<ul>
<li>结合前缀编码，实现高效无损压缩（如 ZIP、JPEG 中的哈夫曼编码）。</li>
</ul>
</li>
<li>
<p><strong>唯一性与最优性</strong>：</p>
<ul>
<li>哈夫曼树不唯一（左右分支标记可互换），但所有哈夫曼树的 WPL 相同且最小。</li>
</ul>
</li>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>构造哈夫曼树： O(n \log n) （使用优先队列优化选择最小权值）。</li>
<li>生成编码： O(n) 。</li>
</ul>
</li>
</ol>
<h2 id="并查集">并查集</h2>
<p><strong>并查集</strong>是一种用于管理<strong>不相交集合</strong>的数据结构，支持以下两种核心操作：</p>
<ol>
<li><strong>查询（Find）</strong>：确定元素属于哪个集合（通常通过根节点标识）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311104951.png" alt="Pasted image 20250311104951|400"></li>
<li><strong>合并（Union）</strong>：将两个集合合并为一个集合。<br>
并查集的结构是一种<mark>双亲表示法</mark>存储的树</li>
</ol>
<p><strong>应用场景</strong>：</p>
<ul>
<li>判断图的连通分支数（如判断森林中有几棵树）。</li>
<li>动态连通性问题（如网络节点是否可达）。</li>
<li>Kruskal 算法中判断边是否会形成环。</li>
</ul>
<p><strong>核心构成</strong></p>
<ol>
<li><strong>数组 <code>parent[]</code></strong>：
<ul>
<li>记录每个节点的父节点。</li>
<li>根节点的父节点指向自身（即 <code>parent[root] = root</code>）。</li>
</ul>
</li>
<li><strong>函数 <code>find(x)</code></strong>：
<ul>
<li>查找节点 <code>x</code> 所属集合的根节点。</li>
</ul>
</li>
<li><strong>函数 <code>union(x, y)</code></strong>：
<ul>
<li>合并 <code>x</code> 和 <code>y</code> 所属的集合。</li>
</ul>
</li>
</ol>
<p><strong>基本实现与时间复杂度</strong></p>
<ol>
<li>
<p><strong>未优化版本</strong>：</p>
<ul>
<li><strong><code>find(x)</code></strong>：逐层向上查找根节点，最坏时间复杂度为  O(n) 。</li>
<li><strong><code>union(x, y)</code></strong>：需要先调用 <code>find(x)</code> 和 <code>find(y)</code>，时间复杂度  O(n) 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化：每个节点的父节点指向自己</span></span><br><span class="line">parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">while</span> parent[x] != x:</span><br><span class="line">        x = parent[x]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">    root_x = find(x)</span><br><span class="line">    root_y = find(y)</span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        parent[root_y] = root_x</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>优化目标</strong>：</p>
<ul>
<li>通过<strong>路径压缩</strong>和<strong>按秩合并</strong>，将操作的时间复杂度优化至  O(\alpha(n)) ，其中α(n) 是阿克曼函数的反函数（实际应用中接近常数）。</li>
</ul>
</li>
</ol>
<p><strong>优化方法</strong></p>
<ol>
<li><strong>按秩合并（Union by Rank）</strong>：
<ul>
<li><strong>原理</strong>：将小树合并到大树中，避免树高度过高。</li>
<li><strong>实现</strong>：
<ul>
<li>用 <code>rank[]</code> 数组记录每个根节点的树高（或节点数）。</li>
<li>合并时，将小树的根节点指向大树的根节点。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rank = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">    root_x = find(x)</span><br><span class="line">    root_y = find(y)</span><br><span class="line">    <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 小树合并到大树</span></span><br><span class="line">    <span class="keyword">if</span> rank[root_x] &gt; rank[root_y]:</span><br><span class="line">        parent[root_y] = root_x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[root_x] = root_y</span><br><span class="line">        <span class="keyword">if</span> rank[root_x] == rank[root_y]:</span><br><span class="line">            rank[root_y] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><strong>路径压缩（Path Compression）</strong>：
<ul>
<li><strong>原理</strong>：在 <code>find(x)</code> 过程中，将路径上的所有节点直接指向根节点，缩短后续查找路径。</li>
<li><strong>实现</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">        parent[x] = find(parent[x])  <span class="comment"># 递归压缩路径</span></span><br><span class="line">    <span class="keyword">return</span> parent[x]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>未优化</th>
<th>按秩合并</th>
<th>按秩合并 + 路径压缩</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find(x)</code></td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(α(n)）</td>
</tr>
<tr>
<td><code>union(x, y)</code></td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(α(n)）</td>
</tr>
</tbody>
</table>
<ul>
<li>**阿克曼函数 α(n) ：增长极慢，对任何实际输入的n（如n &lt;= 10^80），α(n) &lt;= 5。</li>
</ul>
<p><strong>应用示例</strong></p>
<ol>
<li>
<p><strong>连通分支数统计</strong>：</p>
<ul>
<li>初始化每个节点为独立集合。</li>
<li>遍历所有边，执行 <code>union(u, v)</code>。</li>
<li>最终统计根节点数量即为连通分支数。</li>
</ul>
</li>
<li>
<p><strong>Kruskal 算法</strong>：</p>
<ul>
<li>按边权重排序后，依次选择边并检查是否连通（<code>find(u) == find(v)</code>）。</li>
<li>若未连通，执行 <code>union(u, v)</code> 并加入生成树。</li>
</ul>
</li>
</ol>
<p><strong>常见问题</strong></p>
<ol>
<li>
<p><strong>如何判断编码是否合法？</strong></p>
<ul>
<li><strong>前缀编码冲突</strong>：若某编码是另一编码的前缀，则无法唯一解码。</li>
<li><strong>哈夫曼编码性质</strong>：通过构造哈夫曼树生成的编码天然为前缀编码，保证唯一性。</li>
</ul>
</li>
<li>
<p><strong>为什么并查集适合动态连通性问题？</strong></p>
<ul>
<li>并查集支持高效的动态合并与查询操作，时间复杂度接近常数，适合处理大规模数据。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>并查集的核心优化</strong>：路径压缩 + 按秩合并，时间复杂度接近  O(1) 。</li>
<li><strong>应用场景</strong>：连通性问题、图论算法、动态等价类划分。</li>
</ul>
<p>并查集：路径压缩 + 按秩合并 → 时间复杂度O(α(n))<br>
应用：连通分支数统计、Kruskal 算法、动态连通性检测。</p>
<h2 id="错题-6">错题</h2>
<ol>
<li><strong>完全二叉树结点数计算</strong>
<ul>
<li>例：第 6 层有 8 个叶子结点，总结点数最多为 111，最少为 39。</li>
<li><strong>最多</strong>：第6层有8个叶结点，说明第7层不存在。前5层满（25−1=31），第6层最多有2^5=32个节点，其中8个为叶结点，非叶节点为24个。总节点数：31+24×2+8=111。</li>
<li><strong>最少</strong>：第6层的8个叶结点集中在左侧，第6层有8个节点（均为叶结点）。总节点数：前5层满（31） + 第6层8个 = 39。</li>
</ul>
</li>
<li><strong>完全二叉树叶结点数</strong>
<ul>
<li>例：768 个结点的完全二叉树，叶结点数为 <code>384</code>（<code>n0 = ⌈768/2⌉</code>）。</li>
</ul>
</li>
<li><strong>B 树关键字数范围</strong>：
<ul>
<li>对于 5 阶 B 树（ m=5 ）：
<ul>
<li>非根结点关键字数： 2 \leq \text{关键字数} \leq 4 。</li>
<li>根结点关键字数： 1 \leq \text{关键字数} \leq 4 。</li>
</ul>
</li>
</ul>
</li>
<li><strong>B 树高度与结点数关系</strong>：
<ul>
<li>含  n  个关键字的  m  阶 B 树，最小高度  h  满足：<br>
n &lt;= (m-1)(1 + m + m^2 + … + m^(h-1)) = m^h - 1</li>
<li>最大高度  h  满足：<br>
n &gt;= 2(<code>[m/2]</code>^(h-1) - 1)</li>
</ul>
</li>
<li>设有一棵度为3的树，其中度为3的结点数n3=2，度为2的结点数n2=1，叶结点数n0=6，则该树的结点总数为() A. 12  B.9 C.10 D.&gt;=9 的任意整数<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311124831.png" alt="Pasted image 20250311124831"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134338.png" alt="Pasted image 20250309134338"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134401.png" alt="Pasted image 20250309134401"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134836.png" alt="Pasted image 20250309134836">若森林F有 15 条边、25 个结点，则下包含树的个数是( )。8/9/10/11<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134844.png" alt="Pasted image 20250309134844"></li>
<li>二叉树为空意味着二叉树（）<br>
A.根结点没有子树 B.不存在 C.没有结点 D.由一些没有赋值的空结点构成<br>
二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图(图中不能没有结点)</li>
<li>设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为( )。 A. h B. 2h-1 C. 2h+1 D. h+1<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309142623.png" alt="Pasted image 20250309142623"></li>
<li>具有n个结点且高度为n的二叉树的数目为()。A. log2n B. n/2 C. n D. 2^n-1<br>
d</li>
<li>设二叉树有 2n个结点，且m&lt;n，则不可能存在()的结点<br>
A. n 个度为 0  B. 2m 个度为 0  C.2m 个度为1  D.2m 个度为2<br>
叶子结点数 n0=n2+1，总结点数：n0+n1+n2=2n。带入A对；B是n0=2m，得4m-1+n1=2n，当m=1,n=2,n1=1符合；C是n1=2m，得n2=(2n-2m-1)/2，矛盾不存在；D是n2=2m，得4m+1+n1=2n，当m=1,n=3，符合</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309150857.png" alt="Pasted image 20250309150857">若一棵二叉树有 126 个结点，在第7层(根结点在第1层)至多有( )个结点。<br>
A. 32 B.64 C.63 D.不存在第7层<br>
要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有 127 个结点，126 仅比 127 少1个结点，只能少在第7层，所以第7层最多有 2^6-1=63 个结点。</li>
<li>一棵有 124 个叶结点的完全二叉树，最多有()个结点。<br>
A. 247 B. 248 C.249 D.250<br>
124&lt;2^7=128，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120 个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1 个左孩子(不改变叶结点数)，因此结点总数=2^7-1+120+1=248。<br>
也可以用总结点数为偶数2k，n1=1, n0=k, n2​=k−1，k=124，求出</li>
<li>某完全二叉树T中，结点个数最大的层有8个结点，则T中至多有()个结点。<br>
A. 8  B.15  C.23  D. 31<br>
在完全二叉树中，第4层刚好最多有8个结点(前4层对应高度为4的满二叉树)，若第5层也有8个结点，则对应于结点个数最多的情况，此时树高为5，总结点数为15+8=23。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153206.png" alt="Pasted image 20250309153206">I正确；II若该结点非根结点，其双亲指针还会指向父结点，共 三个指针。但根结点度为 2 时，无双亲指针，仅被两个孩子指向，只有两个指针；IIIn=1（无双亲根节点） 时，唯一结点是叶结点且无指针指向</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153328.png" alt="Pasted image 20250309153328"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153335.png" alt="Pasted image 20250309153335"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309154115.png" alt="Pasted image 20250309154115"><strong>奇数节点数 2k−1</strong>：n1​=0,n0​=k, n2​=k−1</li>
<li>对于任意一棵高度为5且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元(仅存放结点的数据信息)，则存放该二叉树需要的存储单元数量至少是()。A.31 B. 16 C.15 D.10<br>
即使实际只有10个结点，存储时仍需覆盖所有可能的位置，以确保父结点与子结点的位置关系可通过下标直接计算。因此，存储单元数量至少为2^5-1=31</li>
<li>设n,m 为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D.n是m子孙<br>
c</li>
<li>设n,m 为一棵二叉树上的两个结点，在后序遍历时，n在m前的充分条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D. n是m 子孙<br>
d</li>
<li>对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用( )次序的遍历实现编号 A.先序 B.中序 C.后序 D.层次<br>
c</li>
<li>一棵二叉树的先序遍历序列为 1234567，它的中序遍历序列可能是()。<br>
A. 3124567 B. 1234567 C.4135627 D.1463572<br>
b</li>
<li>某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用()遍历方法最合适。A. 中序 B.层次 C.后序 D.先序<br>
删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。</li>
<li>某二叉树T采用二叉链表存储结构，T的中序遍历序列为一个升序序列，要求采用某种方法对 T进行某种操作之后得到一棵新的二叉树T,要求 T&quot;的中序遍历序列为一个降序序列，则下列关于该算法的叙述中，正确的是()<br>
A. 采用中序遍历的方法最合适 B. 采用后序遍历的方法最合透<br>
C.T中的根结点还是原T中的根结点 D. T中的叶结点不一定是原T中的叶结点<br>
选项 B（采用后序遍历的方法最合适）
<ul>
<li>后序遍历（左→右→根）允许先递归处理左右子树，再交换当前结点的左右子树。这种顺序确保子树已完全处理后再调整父结点的结构，避免逻辑混乱。通过后序遍历交换所有分支结点的左右子树，最终中序遍历序列自然逆序为降序。因此，后序遍历是最合适的方法。<br>
选项 C（T’中的根结点还是原T中的根结点）</li>
<li>镜像翻转操作仅交换分支结点的左右子树，不会改变根结点的位置或值。因此，根结点保持不变，选项 C 正确。<br>
选项 D（T’中的叶结点不一定是原T中的叶结点）</li>
<li>叶结点没有左右子树，交换操作对其无影响，原叶结点在 T’ 中仍为叶结点（仅位置可能变化）。因此，选项 D 错误</li>
</ul>
</li>
<li>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是()。<br>
A. 不确定  B.0个  C.1个 D.2 个<br>
根结点的左指针：1 个空链域，最右侧叶结点的右指针：1 个空链域，所以线索化后，树中空链域有2个。</li>
<li>某二叉树的先序序列和后序序列正好相反，则该二叉树一定是()。<br>
A.空或只有一个结点           B.高度等于其结点数<br>
C.任意一个结点无左孩子   D.任意一个结点无右孩子<br>
最多只有一个子结点，即树退化为单链结构（如所有结点只有右孩子或只有左孩子）此时，树的高度等于结点数 h=n，b。C或D属于选项 B 的子集</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310122100.png" alt="Pasted image 20250310122100">d</li>
<li>若一棵二叉树的前序遍历序列为 a,e,b,d,c，后序遍历序列为 b,c,d,e,a，则根结点的孩子结点()。A.只有e  B.有e、b  C.有e、c  D.无法确定<br>
根 <code>a</code> 的唯一孩子是左孩子 <code>e</code></li>
<li>先序序列为 a,b,c,d的不同二叉树的个数是( )。13/14/15/16<br>
(C4 8)/ 5 = 14</li>
<li>利用二叉链表存储森林时，根结点的右指针是()。<br>
A. 指向最左兄弟 B.指向最右兄弟 C.一定为空 D.不一定为空<br>
森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。</li>
<li>设森林F中有3棵树，第 1、2、3 棵树的结点个数分别为 M1,M2和M3，与森林F对应的二叉树根结点的右子树上的结点个数是()<br>
A. M1 B.M1+M2 C.M3 D.M2+M3<br>
d</li>
<li>设森林 F中有 4棵树，第 1、2、3、4 棵树的结点数分别为 a、b、c和 d，与森林F对应的二叉树的根结点的左子树上的结点数是()<br>
A. a  B. b+c+d  C.a-1  D. a+b+c<br>
c</li>
<li>设森林F对应的二叉树是一棵具有 16 个结点的完全二叉树，则森林F中树的数目和结点最多的树的结点数分别是() A. 2和8  B.2和9  C.4和8  D. 4和9<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310165243.png" alt="Pasted image 20250310165243|250"></li>
<li>设X是树T中的一个非根结点，B是T所对应的二叉树。在B中，X是其双亲结点的右孩子，下列结论中正确的是()。<br>
A.在树T中，X是其双亲结点的第一个孩子<br>
B.在树T中，X一定无右边兄弟<br>
C.在树T中，X一定是叶结点<br>
D.在树T中，X一定有左边兄弟在二叉树<br>
B中，X是其双亲的右孩子，因此在树T中，X必是其双亲结点的右兄弟，换句话说，X在树中必有左兄弟。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310170049.png" alt="Pasted image 20250310170049">A. 双亲表示法中，每个非根结点有一个指向双亲的指针。若树有 n个结点，则双亲指针数为 n−1，正确；B对；C. O(n)；D对</li>
<li>已知一棵有 2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点个数是()。 A. 115  B. 116  C. 1895 D.1896</li>
<li>下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是<br>
A. 24,10,5 和 24,10,7      B. 24,10,5 和 24,12,7<br>
C. 24,10,10 和 24,14,11  D. 24,10,5 和 24,14,6</li>
<li>根据使用频率为5个字符设计的哈夫曼编码不可能是()<br>
A. 000,001,010,011,1   B.0000,0001,001,01,1<br>
C. 000,001,01,10,11     D. 00,100,101,110,111<br>
D构造出来有度为1的结点，不对</li>
<li>设哈夫曼编码的长度不超过 4，若已对两个字符编码为1和 01，则还最多可对( )个字符编码。<br>
根据前缀编码规则，得到新编码必须以00开头，且总长度&lt;=4，0000，0001，0010，0011，共四个</li>
<li>一棵哈夫曼树共有 215 个结点，对其进行哈夫曼编码，共能得到( )个不同的码字。A. 107   B. 108  C.214   D. 215<br>
树有 <code>n</code> 个叶子结点，则总结点数为 <code>2n - 1</code>，得到n=108</li>
<li>并查集中最核心的两个操作是:查找，查找两个元素是否属于同一个集合;合并，若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为 10(0~9)的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9 的顺序进行查找和合并操作，最终并查集共有( )个集合。A. 1 B.2 C.3D.4<br>
初始时，0~9各自成一个集合。查找 1-2 时，合并{1}和{2};查找 3-4 时，合并{3}和{4};查找 5-6 时，合并(5}和(6};査找 7-8时，合并{7}和{8}:查找 8-9 时，合并{7,8,和{9};查找1-8 时，合并(1,2和{7,8,9}:查找 0-5 时，合并(0}和{5,6}:查找 1-9 时，它们属于同一个集合。最终的集合为10,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项 C。</li>
<li>下列关于大根堆(至少含2个元素)的叙述中正确的是<br>
I. 可以将堆看成一棵完全二叉树      II. 可采用顺序存储方式保存堆<br>
III. 可以将堆看成一棵二叉排序树    IV. 堆中的次大值一定在根的下一层<br>
A. 仅1、II      B. 仅1、III       C. 仅I、II、IV        D. 仅I、II、IV<br>
c</li>
<li>已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二又树中无右孩子的结点的个数是() A. 115    B. 116    C. 1895    D. 1896<br>
非叶子结点=1895，数转换成的二叉树没有右孩子，原树中每个非叶结点对应一个无右孩子的结点，无右孩子结点数为1895，根节点也无右孩子+1，1896</li>
<li>有n(n&gt;0)个分支结点的满二叉树的深度是<br>
A. n^2-1    B. log2(n+1)+1    C. log2(n+1)     D. log2(n-1)<br>
满二叉树的结点总数 N 与深度 h的关系为:N=2^h -1<br>
分支结点数 n 与叶子结点数L的关系为:n=L-1<br>
对于满二叉树，叶子结点数  L=2^(h-1)，因此:n=2^(h-1)-1<br>
可得:h=log2(n+1)+1</li>
<li>若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的分支结点的个数是()<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115823.png" alt="Pasted image 20250311115823|400">3</li>
<li>一个关键字序列为{50，20，60，30，35}，依次构造平衡二叉树，当插入25后引起不平衡，则应进行的平衡旋转是()型旋转 LL?<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123317.png" alt="Pasted image 20250311123317"></li>
<li>对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是<br>
A. 92，20，91，34，88，35              B. 95，22，91，24，94，71<br>
C. 21，89，77，29，36，38              D. 12，25，71，68，33，34<br>
由二叉排序树的性质可知，一个数后面的数字都要全部大于或全部小于它 b选项的91后面既有小于它的数，也有大于它的数</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123606.png" alt="Pasted image 20250311123606"></li>
<li>设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平3.在平衡二叉树中插入一个结点后造成了不平衡，因子为1，则应作()型调整以使其平衡。 A.LL B. LR C.RL D.RR<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311130434.png" alt="Pasted image 20250311130434">c</li>
<li></li>
</ol>
<h1>图</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311143034.png" alt="Pasted image 20250311143034|450">由顶点集  V （非空）和边集  E  组成，记为G = (V, E)</p>
<ul>
<li><strong>注意</strong>：线性表、树可以为空，但图不能为空（V ≠ ∅）</li>
</ul>
<h2 id="无向图与有向图">无向图与有向图</h2>
<ol>
<li>
<p><strong>无向图</strong>：</p>
<ul>
<li><strong>边（Edge）</strong>：无序对 (v, w) = (w, v)</li>
<li><strong>度数性质</strong>：所有顶点的度数之和= 2 × |E|（必为偶数）</li>
</ul>
</li>
<li>
<p><strong>有向图</strong>：</p>
<ul>
<li><strong>弧（Arc）</strong>：有序对  &lt;v, w&gt;≠ &lt;w, v&gt; 。</li>
<li><strong>度数性质</strong>：
<ul>
<li>入度：指向该顶点的边数。</li>
<li>出度：从该顶点出发的边数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>稀疏图：顶点很多而边很少的图</li>
<li>稠密图：顶点多边也多的图</li>
</ul>
<h2 id="图的分类">图的分类</h2>
<ol>
<li><strong>简单图</strong>：
<ul>
<li>无重复边，无自环（顶点到自身的边）。</li>
</ul>
</li>
<li><strong>多重图</strong>：
<ul>
<li>允许两点间有多条边（适用于交通网络等场景）。</li>
</ul>
</li>
<li><strong>完全图</strong>（也称简单完全图）： 对于给定的一组顶点，顶点间都存在边
<ul>
<li><strong>无向完全图</strong>：任意两顶点间均有边，边数=n(n-1)/2</li>
<li><strong>有向完全图</strong>：任意两顶点间有两条方向相反的弧，弧数= n(n-1)</li>
</ul>
</li>
<li>生成子图：点都有</li>
<li><strong>极大连通分量</strong>：子图连通，且包含尽可能多的顶点和边<br>
<strong>极大连通子图</strong>：要求子图必须连通，而且包含尽可能多的顶点和边<br>
<strong>极小连通子图</strong>：既要保持子图连通又要使得边数最少的子图<br>
<strong>连通分量</strong>：<mark>无向</mark>图中的<strong>极大连通子图</strong><br>
<strong>强连通分量</strong>：<mark>有向</mark>图中的极大连通分量（在有向图中考虑强连通性）</li>
<li>无向<mark>连通图</mark>的<mark>生成树</mark>：是包含<strong>全部顶点</strong>的一个<strong>极小连通子图</strong> n-1条边<br>
<mark>非连通</mark>的<mark>生成森林</mark>：非连通图分解的多个连通分量，多个连通分量对应的多棵生成树</li>
<li>有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。</li>
<li><mark>完全图一定是连通图，但连通图不一定是完全图</mark></li>
</ol>
<h2 id="连通性与路径">连通性与路径</h2>
<ol>
<li>
<p><strong>无向图的连通性</strong>：</p>
<ul>
<li><strong>连通图</strong>：任意两顶点间存在路径，最少边数 = n-1（树结构）。</li>
<li><strong>非连通图</strong>：最多边数=(n-1)(n-2)/2（一个孤立顶点，其余构成完全图）。</li>
</ul>
</li>
<li>
<p><strong>有向图的连通性</strong>：</p>
<ul>
<li><strong>强连通图</strong>：任意两顶点间双向可达，最少弧数=n（环形结构）。</li>
<li><strong>弱连通图</strong>：忽略方向后为连通无向图。</li>
</ul>
</li>
<li>
<p><strong>路径与环</strong>：</p>
<ul>
<li><strong>简单路径</strong>：顶点不重复出现，最多 n 个顶点，n-1 条边。</li>
<li><strong>回路（环）</strong>：起点与终点相同的路径。</li>
<li>若一个图有n个顶点，且有大于n-1条边，此图一定有<strong>环</strong></li>
</ul>
</li>
</ol>
<h2 id="生成树与生成森林">生成树与生成森林</h2>
<ol>
<li><strong>生成树</strong>：
<ul>
<li><strong>定义</strong>：无向连通图的极小<mark>连通</mark>子图，包含所有顶点和n-1条边。</li>
<li><strong>性质</strong>：
<ul>
<li>删除任意一条边会破坏连通性。</li>
<li>添加任意一条边会形成回路。<br>
<strong>生成树 G′</strong> 是图 G 的一个子图，满足以下条件：</li>
</ul>
</li>
</ul>
</li>
<li><strong>连通性</strong>：G′ 是连通的。</li>
<li><strong>无环性</strong>：G′ 是无环的。</li>
<li><strong>极小性</strong>：G′ 是 GG 的极小连通子图（删除任意一条边会破坏连通性）。</li>
<li><strong>顶点集</strong>：G′ 包含 GG 的所有顶点（V′=V）。</li>
<li><strong>生成森林</strong>：
<ul>
<li><strong>定义</strong>：非连通图的多个连通分量对应的生成树的集合。</li>
</ul>
</li>
</ol>
<h3 id="关键公式与结论">关键公式与结论</h3>
<ul>
<li>对于n个顶点的<strong>无向图G</strong>
<ul>
<li>若G是<mark>连通</mark>图，&gt;= <mark>n-1</mark>条边（树），若|E|&gt;n-1，则一定有<strong>回路</strong>。</li>
<li>保证G在<strong>任何</strong>情况下均连通的最少边数:(n-1)(n-2)/2+1</li>
<li>若G是<mark>非连通</mark>图，&lt;= <mark>C2 n − 1</mark>条边【即(n-1)(n-2)/2】，若超过此值，图必<strong>连通</strong></li>
<li>无向完全图共有C2 n条边【即n(n-1)/2】</li>
</ul>
</li>
<li>对于n个顶点的<strong>有向图G</strong>
<ul>
<li>若G是<mark>强连通</mark>图，&gt;= <mark>n</mark>条边（形成简单回路）</li>
<li><mark>有向完全</mark>图共有<mark>2C2 n</mark> 条边【即n(n-1)】</li>
</ul>
</li>
<li>求有向图的强连通分量
<ul>
<li>找入度或出度为0的顶点</li>
<li>依次删掉这些顶点以及相连的弧，直到没有存在入度或出度为0的顶点、</li>
<li>删掉的顶点以及剩下的有向图，就是强连通分量<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311164300.png" alt="Pasted image 20250311164300|400"></li>
</ul>
</li>
<li><strong>顶点度数</strong>：
<ul>
<li>无向图顶点最大度数 = n-1</li>
<li>有向图顶点最大度（入度 + 出度） = 2(n-1)</li>
</ul>
</li>
</ul>
<h3 id="算法与应用">算法与应用</h3>
<ol>
<li>
<p><strong>判断回路</strong>：</p>
<ul>
<li><strong>有向图</strong>：拓扑排序、深度优先遍历（DFS）检测环。</li>
<li><strong>无向图</strong>：并查集或DFS检测环。</li>
</ul>
</li>
<li>
<p><strong>连通分量</strong>：</p>
<ul>
<li><strong>无向图</strong>：广度优先遍历（BFS）或DFS求所有连通分量。</li>
<li><strong>有向图</strong>：Kosaraju算法求强连通分量。</li>
</ul>
</li>
<li>
<p><strong>最小生成树</strong>：</p>
<ul>
<li><strong>Kruskal算法</strong>：按边权升序选择，避免成环。</li>
<li><strong>Prim算法</strong>：从顶点出发逐步扩展最小边。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>完全图边数</strong>：
<ul>
<li>无向完全图边数  n(n-1)/2，有向完全图弧数n(n-1)</li>
</ul>
</li>
<li><strong>邻接表结点数</strong>：
<ul>
<li>无向图邻接表结点总数  2|E| ，有向图邻接表结点总数  |E| 。</li>
</ul>
</li>
</ul>
<h2 id="图的存储结构">图的存储结构</h2>
<h3 id="邻接矩阵（数组、顺序存储）">邻接矩阵（数组、顺序存储）</h3>
<ul>
<li>用 n×n 矩阵表示顶点间关系，适用于稠密图。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311142927.jpg" alt="Pasted image 20250311142927|500"><br>
无向图邻接矩阵：</li>
</ul>
<ol>
<li>无向图的邻接矩阵一定是一个<strong>对称矩阵</strong>。 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。</li>
<li>对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个顶点的度</li>
<li>求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍， <code>A[i][j]</code>为 1就是邻接点。</li>
<li>无向图非零元素至少有2 * 边数个</li>
<li>在含有 n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为n^2 - 2e</li>
<li></li>
</ol>
<p>有向图邻接矩阵：</p>
<ol>
<li>主对角线上数值依然为0，但矩阵并不对称。</li>
<li>有向图入度是一列和，出度是一行和==（出行入列）==</li>
<li>与无向图同样的办法，判断顶点vi​到vj​是否存在弧，只需要查找矩阵中<code>A[i][j]</code>是否为1即可。</li>
</ol>
<p>邻接矩阵的 存储结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100	<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;	<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;	<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VertexType Vex[MaxVertexNum];	<span class="comment">//顶点表</span></span><br><span class="line">	EdgeType Edge[MaxVertexNum][MaxVertexNum];	<span class="comment">//邻接矩阵，边表</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的当前顶点数和弧树</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<ul>
<li>在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。</li>
<li>当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。</li>
<li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。</li>
<li>邻接矩阵表示法的空间复杂度为O(n^2)， 其中n为图的顶点数|V|</li>
<li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li>
<li><mark>稠密图</mark>适合使用邻接矩阵的存储表示。</li>
<li><code>A^n[i][j]</code>表示从顶点 i 到 j 的长度为 n 的路径数目<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312110923.png" alt="Pasted image 20250312110923|400"></li>
</ul>
<h3 id="邻接表（顺序-链式）">邻接表（顺序+链式）</h3>
<p>结合顺序+链序存储，不唯一<br>
对于<mark>稀疏图</mark>，采用邻接表表示将极大地节省存储空间<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311145242.png" alt="Pasted image 20250311145242|400"></p>
<ul>
<li><strong>无向图</strong>：每个顶点的邻接表存储其邻接顶点，总边结点数为 2|E|，所需的存储空间为<mark>O(|V|+2|E|)</mark></li>
<li><strong>有向图</strong>：邻接表存储出边，逆邻接表存储入边，总边结点数为 |E|，所需的存储空间为 <mark>O(|V|+|E|)</mark><br>
有向图邻接表的总结点个数 = 表头结点数（顶点数 ∣V∣） + 表结点数（边数 ∣E∣）</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>邻接表</th>
<th>邻接矩阵</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>查找邻边</strong></td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>判断边是否存在</strong></td>
<td>O(d)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>计算出度（有向图）</strong></td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>计算入度（有向图）</strong></td>
<td>O(n+e)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(n+e)</td>
<td>O(n2)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>邻接表</strong>：
<ul>
<li>适合稀疏图（边数远小于 n^2）。</li>
<li>需要频繁查找邻边的场景（如DFS/BFS遍历）。</li>
</ul>
</li>
<li><strong>邻接矩阵</strong>：
<ul>
<li>适合稠密图（边数接近 n^2）。</li>
<li>需要频繁判断边是否存在的场景（如最短路径算法）</li>
</ul>
</li>
</ul>
<h3 id="十字链表（有向图）">十字链表（有向图）</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2069.png" alt="Untitled 9 69|Untitled 9 69.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0824_165443.png" alt="Screenshot_2023_0824_165443"></p>
<p>顶点节点表三个格子，边节点表四个格子<br>
弧节点表：<br>
第一个格子是当前节点的索引<br>
第二个格子是箭头所指节点的索引<br>
第三个格子先空着，前两个格子全部写完，再由节点表的第二个格子指向与弧节点表的第二个格子索引值一样的弧节点的第三个格子，弧节点表的第三个格子依次指向下一个索引值一样的边节点，后面没有了写”空“<br>
第四个格子是当前行的最后一个弧界点就写“空”<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312111806.png" alt="Pasted image 20250312111806|400"><br>
在十字链表中，既容易找到Vi为尾的弧，也容易找到Vi为头的弧，因而容易求得顶点的出度和入度<br>
图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。</p>
<h3 id="邻接多重表（无向图）">邻接多重表（无向图）</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2065.png" alt="Untitled 10 65|Untitled 10 65.png"><br>
顶点节点两个格子，弧节点四个格子<br>
弧节点：<br>
第一个格子是当前节点的索引<br>
第三个格子是箭头所指节点的索引（连完之后把线叉掉）<br>
两两节点一起，顶点节点空格指向所有弧节点中一/三节点索引一样的二/四空格，直到没有写“空 ”<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312113325.png" alt="Pasted image 20250312113325|400"></p>
<p>空间复杂度O(|V|+|E|)<br>
删除边、结点方便</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>邻接矩阵</th>
<th>邻接表</th>
<th>十字链表</th>
<th>邻接多重表</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td>O(|V|^2)</td>
<td>无向图：O(|V| + 2|E|) 有向图：O(|V| + |E|)</td>
<td>O(|V| + |E|)</td>
<td>O(|V| + |E|)</td>
</tr>
<tr>
<td>找相邻边</td>
<td>遍历对应行或列，时间复杂度O(|V|)</td>
<td>找有向图的入边需遍历整个邻接表</td>
<td>很方便</td>
<td>很方便</td>
</tr>
<tr>
<td>删除边或顶点</td>
<td>删边方便，删顶点需大量移动数据</td>
<td>无向图中删边或顶点都不方便</td>
<td>很方便</td>
<td>很方便</td>
</tr>
<tr>
<td>适用于</td>
<td>稠密图</td>
<td>稀疏图和其他</td>
<td>只能存有向图</td>
<td>只能存无向图</td>
</tr>
<tr>
<td>表示方式</td>
<td>唯一</td>
<td>不唯一</td>
<td>不唯一</td>
<td>不唯一</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>图类型</th>
<th>存储结构</th>
<th>操作类型</th>
<th>时间复杂度说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无向图</strong></td>
<td>邻接矩阵</td>
<td>查找相邻边</td>
<td>遍历对应行 / 列，时间复杂度 O(|V|)（|V|为顶点数）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>删除边</td>
<td>直接修改矩阵元素，时间复杂度 O(1)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算顶点的度</td>
<td>统计对应行 / 列非零元素个数，时间复杂度 O(|V|)</td>
</tr>
<tr>
<td></td>
<td>邻接表</td>
<td>查找相邻边</td>
<td>遍历顶点对应链表，时间复杂度 O(d)（d为顶点度）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>删除边</td>
<td>需遍历链表找到对应边结点，时间复杂度 O(d)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算顶点的度</td>
<td>统计顶点对应链表的结点数，时间复杂度 O(d)</td>
</tr>
<tr>
<td></td>
<td>邻接多重表</td>
<td>查找相邻边</td>
<td>通过指针直接定位关联边，时间复杂度 O(1)（理想情况，实际与存储组织相关）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>删除边</td>
<td>标记或移除边结点，时间复杂度 O(1)（需提前定位边，定位时间另计）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算顶点的度</td>
<td>统计顶点关联的边结点数，时间复杂度 O(d)</td>
</tr>
<tr>
<td><strong>有向图</strong></td>
<td>邻接矩阵</td>
<td>查找出边</td>
<td>遍历对应行，时间复杂度 O(|V|)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>查找入边</td>
<td>遍历对应列，时间复杂度 O(|V|)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>删除边（出边 / 入边）</td>
<td>直接修改矩阵元素，时间复杂度 O(1)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算出度</td>
<td>统计对应行非零元素个数，时间复杂度 O(|V|)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算入度</td>
<td>统计对应列非零元素个数，时间复杂度 O(|V|)</td>
</tr>
<tr>
<td></td>
<td>邻接表</td>
<td>查找出边</td>
<td>遍历顶点对应链表，时间复杂度 O(d出)（d出为出度）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>查找入边</td>
<td>需遍历全表，时间复杂度 O(|V| + |E|)（|E|为边数）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>删除出边</td>
<td>遍历链表找到对应边结点，时间复杂度 O(d出)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算出度</td>
<td>统计顶点对应链表的结点数，时间复杂度 O(d出)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算入度</td>
<td>需遍历全表统计，时间复杂度 O(|V| + |E|)</td>
</tr>
<tr>
<td></td>
<td>十字链表</td>
<td>查找出边 / 入边</td>
<td>通过结点指针直接定位，时间复杂度 O(1)（理想情况，实际与存储组织相关）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>删除边（出边 / 入边）</td>
<td>调整指针关系，时间复杂度 O(1)（需提前定位边，定位时间另计）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>计算出度 / 入度</td>
<td>直接读取结点记录的出度 / 入度值（十字链表可存储度数信息），时间复杂度 O(1)</td>
</tr>
</tbody>
</table>
<p>稀疏矩阵用三元组：(x,y,z):(行，列，非零值）的顺序表；十字链表（有向图）存储</p>
<h2 id="图的遍历">图的遍历</h2>
<h3 id="深度优先遍历（DFS）">深度优先遍历（DFS）</h3>
<ol>
<li>
<p><strong>核心思想</strong>：</p>
<ul>
<li>类似树的<strong>先序遍历</strong>，沿着一条路径尽可能深入探索，直到无法继续时回溯。</li>
<li><mark>递归</mark>或显式使用<mark>栈</mark>实现。</li>
</ul>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>树高较大</strong>：DFS 的递归深度或栈深度可能接近图的顶点数（如单链结构）。</li>
<li><strong>空间复杂度</strong>：最坏情况下为O(|V|) ，由递归栈深度或显式栈大小决定。</li>
</ul>
</li>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>邻接矩阵</strong>： O(|V|^2) 。
<ul>
<li>每个顶点需遍历所有其他顶点以查找邻接点。</li>
</ul>
</li>
<li><strong>邻接表</strong>： O(|V| + |E|) 。
<ul>
<li>仅遍历实际存在的边。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>稠密图</strong>（邻接矩阵效率更高）。</li>
<li><strong>拓扑排序</strong>、<strong>强连通分量</strong>（如 Tarjan 算法）。</li>
</ul>
</li>
</ol>
<h3 id="广度优先遍历（BFS）">广度优先遍历（BFS）</h3>
<ol>
<li>
<p><strong>核心思想</strong>：</p>
<ul>
<li>类似树的<strong>层序遍历</strong>，逐层访问顶点。</li>
<li>使用<mark>队列</mark>作为辅助数据结构，<strong>每个顶点仅入队一次</strong>。</li>
</ul>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>最短路径</strong>：BFS 天然适合求解无权图的最短路径问题。</li>
<li><strong>连通分量</strong>：通过 BFS 可遍历一个连通分量中的所有顶点。</li>
</ul>
</li>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>邻接矩阵</strong>： O(|V|^2) 。</li>
<li><strong>邻接表</strong>： O(|V| + |E|) 。</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>稀疏图</strong>（邻接表更高效）。</li>
<li><strong>社交网络分析</strong>（如六度分隔理论）。</li>
</ul>
</li>
</ol>
<h4 id="生成树与生成森林-2"><strong>生成树与生成森林</strong></h4>
<ol>
<li>
<p><strong>广度优先生成树</strong>：</p>
<ul>
<li><strong>邻接表不唯一性</strong>：邻接表中顶点的邻接顺序不固定，导致生成树结构可能不同。</li>
<li><strong>邻接矩阵唯一性</strong>：邻接矩阵的邻接顺序固定（按顶点编号），生成树唯一。</li>
</ul>
</li>
<li>
<p><strong>广度优先生成森林</strong>：</p>
<ul>
<li>针对非连通图，每个连通分量生成一棵广度优先生成树。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>DFS</th>
<th>BFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>遍历方式</td>
<td>深度优先（单路径深入）</td>
<td>广度优先（逐层扩展）</td>
</tr>
<tr>
<td>数据结构</td>
<td>栈（递归或显式栈）</td>
<td>队列</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(∣V∣)（最坏情况）</td>
<td>O(∣V∣)（队列存储顶点）</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣)</td>
<td>邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣)</td>
</tr>
<tr>
<td>应用场景</td>
<td>拓扑排序、路径存在性检测</td>
<td>最短路径、连通分量统计</td>
</tr>
</tbody>
</table>
<h4 id="关键结论"><strong>关键结论</strong></h4>
<ul>
<li><strong>时间复杂度与存储结构的关系</strong>：
<ul>
<li>邻接矩阵需遍历所有顶点，时间复杂度较高；邻接表仅遍历实际边，效率更高。</li>
</ul>
</li>
<li><strong>生成树的唯一性</strong>：
<ul>
<li>邻接表因邻接顺序不固定，生成树可能不唯一；邻接矩阵生成树唯一。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：
<ul>
<li>DFS 和 BFS 的最坏空间复杂度均为O(|V|) ，与搜索路径无关。</li>
</ul>
</li>
</ul>
<h2 id="错题-7">错题</h2>
<ol>
<li>一个有 28 条边的非连通无向图至少有()个顶点。7/8/9/10<br>
为了使顶点数最小，应使其中一个连通分量为孤立顶点（无边），另一个连通分量为完全图（边数最多），完全图边数n(n-1)/2，可得n=8，总顶点数=n+1=9</li>
<li>在有n个顶点的有向图中，顶点的度最大可达() A. n B. n-1 C.2n D.2n-2<br>
在有向图中，顶点的度等于入度与出度之和。n个顶点的有向图中，任意一个顶点最多还可以与其他n-1个顶点有一对指向相反的边相连。注意，数据结构中仅讨论简单图。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311161002.png" alt="Pasted image 20250311161002">一个连通图的生成树是一个极小连通子图，显然它是无环的，因此选项 Ⅱ、 正确。极大连通子图称为连通分量，G’连通但非连通分量。这里再补充一下“极大连通子图”:若图本来就是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。</li>
<li>具有51个顶点和21条边的无向图的连通分量最多为 A. 33 B.34 C. 45 D.32<br>
要想连通分量最多，就要使图中孤立的点数量最多（每一个孤立的点都是一个连通分量）  问题转为最少用多少点可连21条边，设用x个点.则有x(x-1)/2≥21，得xmin=7  ，这7个点作为1个连通分量，剩余51-7=44个孤立的点，每一个点作为一个连通分量，故连通分量最多为1+(51-7)=45个</li>
<li>在如下图所示的有向图中，共有()个强连通分量。1/2/3/4<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311162046.png" alt="Pasted image 20250311162046|150">2个，b和其他</li>
<li>若具有 n个顶点的图是一个环，则它有()棵生成树 A. n B. n C. n-1 D.1<br>
环图删除任意一条边可形成生成树，共有 nn 种选择</li>
<li>若一个具有 n个顶点、e条边的无向图是一个森林，则该森林中必有()棵树。<br>
A.n  B.e  C.n-e  D.1<br>
n个结点的树有n—1条边，假设有x棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是n+1，边数是e+x，从而可知x=n—e，也就是n—e棵树了</li>
<li>下列关于无向连通图特性的叙述中，正确的是()<br>
I.所有顶点的度之和为偶数<br>
II.边数大于顶点个数减1<br>
III.至少有一个顶点的度为1<br>
A. 只有I    B.只有II    C.I和II    D.I和III
<ul>
<li>I正确（度数之和为边数两倍，必为偶数）。</li>
<li>II错误（树结构边数 n−1，不大于顶点数减1）。</li>
<li>III错误（环图所有顶点度为2）。</li>
</ul>
</li>
<li>若无向图 G=(V,E)中含有6个顶点，要保证图 G在任何情况下都是连通的，则需要的边数最少是() 8/9/10/11<br>
特定情况下6条，就连通；任意情况下，<mark>n-1个点的完全图+单独出去的一条边连剩下一个点</mark>，答案是11。如果题目求的是有向图，<mark>n-1个点的有向完全图+单独出去的一条边连剩下一个点</mark>，答案是21<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165458.png" alt="Pasted image 20250311165458|300"></li>
<li>对于无向图G=(V,E)，下列选项中，正确的是()。<br>
A.|V|&gt;|E|时，G 一定是连通的<br>
B.当|V|&lt;|E|时，G一定是连通的<br>
C.当|V|=|E|-1时，G一定是不连通的<br>
D.当|V|=|E|+1时，G一定是不连通的<br>
d<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311171144.png" alt="Pasted image 20250311171144"></li>
<li>用有向无环图描述表达式(x+y)((x+y)/x)，需要的顶点个数至少是5/6/8/9<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165839.png" alt="Pasted image 20250311165839|300">5</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312122108.png" alt="Pasted image 20250312122108">bd</li>
<li>假设有 n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)<br>
<strong>删出边</strong>：遍历v的顶点表结点及其边表，删除出边，最多n-1条，时间复杂度O(n)。<br>
<strong>删入边</strong>：扫描整个边表（含剩余顶点表结点及边表），删除v的入边，时间复杂度O(n+e)。</li>
<li>假设有 n个顶点、e条边的有向图用邻接表表示，则某个顶点v的入度时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)<br>
为了求顶点v的入度，只需要遍历邻接表中的所有边表，检查每条边是否指向顶点&quot;，这相当于遍历整个邻接表，因此算法的时间复杂度为 O(n+e)。</li>
<li>无向图邻接多重表求顶点b，d的度<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312125659.png" alt="Pasted image 20250312125659|400"><br>
b的入度1，出度2；d的入度1，出度3</li>
<li></li>
</ol>
<div class="main-hero-waves-area"><div class="waves-area"><svg class="waves-svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 1440 140" preserveAspectRatio="none"><path class="parallax" d="M 0 44 C 355 167 415 0 725 44 L 725 44 L 0 44 Z"></path><use class="parallax" xlink:href="#wave1" x="48" y="3"></use><use class="parallax" xlink:href="#wave1" x="48" y="5"></use><use class="parallax" xlink:href="#wave1" x="48" y="7"></use><use class="parallax" xlink:href="#wave1" x="48" y="9"></use></svg></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://labi.com">Lorinda</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://labi.com/post/79666db.html">http://labi.com/post/79666db.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://labi.com" target="_blank">蜡笔梦工厂</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/b8b0eacd.html" title="java基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">java基础</div></div><div class="info-2"><div class="info-item-1">Java基础</div></div></div></a><a class="pagination-related" href="/post/bae4ff13.html" title="Redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis</div></div><div class="info-2"><div class="info-item-1">Redis 作为内存 NoSQL 数据库的定位，支持 String/Hash 等多数据结构，具备 RDB/AOF 持久化与主从高可用，核心用于缓存、分布式锁，性能高效。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/post/77666db.html" title="王道计组pdf"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-07</div><div class="info-item-2">王道计组pdf</div></div><div class="info-2"><div class="info-item-1">计算机组成原理</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155535.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info-name">Lorinda</div><div class="author-info-description">欢迎来到Lorinda的个人博客\^o^/</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://lr0513.github.io/"><i class="fab fa-github"></i><span>你回来了~</span><i class="faa-passing animated" style="padding-left:20px;display:inline-block;vertical-align:middle;"><svg class="icon" style="height:28px;width:28px;fill:currentColor;position:relative;top:5px"><use xlink:href="#icon-hexolabixiaoxin1"></use></svg></i></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div><div id="welcome-info"></div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"><div id="newYear-main"><div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">1. 线性查找时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%B0%BE%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2. 单循环链表的头尾访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">3. 链表合并的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">4. 插入操作的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">5. 删除操作的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">2.1.</span> <span class="toc-text">顺序表的合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%EF%BC%88%E9%80%86%E5%BA%8F%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">头插（逆序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92"><span class="toc-number">2.4.</span> <span class="toc-text">尾插</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">带头结点的单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">不带头结点的单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">代码思路整理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94"><span class="toc-number">2.8.</span> <span class="toc-text">1. 结构差异对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9"><span class="toc-number">2.9.</span> <span class="toc-text">2. 关键实现要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.10.</span> <span class="toc-text">3. 推荐使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.11.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.12.</span> <span class="toc-text">初始化双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9C%A8%E8%8A%82%E7%82%B9-p-%E5%90%8E%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-s%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">插入操作（在节点 p 后插入节点 s）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%88%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-p-%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">删除操作（删除节点 p 的后继节点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.15.</span> <span class="toc-text">循环双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.16.</span> <span class="toc-text">初始化循环双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9C%A8%E8%8A%82%E7%82%B9-p-%E5%90%8E%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-s%EF%BC%89-2"><span class="toc-number">2.17.</span> <span class="toc-text">插入操作（在节点 p 后插入节点 s）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%88%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-p-%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9%EF%BC%89-2"><span class="toc-number">2.18.</span> <span class="toc-text">删除操作（删除节点 p 的后继节点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BB%A5%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.19.</span> <span class="toc-text">插入操作（以双链表为例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BB%A5%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.20.</span> <span class="toc-text">删除操作（以双链表为例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8-2"><span class="toc-number">2.21.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8-2"><span class="toc-number">2.22.</span> <span class="toc-text">循环双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">2.23.</span> <span class="toc-text">静态链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.24.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.25.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%B8%B8%E6%A0%87"><span class="toc-number">2.26.</span> <span class="toc-text">修改游标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-2"><span class="toc-number">2.27.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">2.28.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98"><span class="toc-number">2.29.</span> <span class="toc-text">错题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">栈LIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">共享栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">链栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98-2"><span class="toc-number">3.4.</span> <span class="toc-text">错题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">队列FIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">链式队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%98%9F%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">静态队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.4.</span> <span class="toc-text">双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98-3"><span class="toc-number">4.5.</span> <span class="toc-text">错题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">5.1.</span> <span class="toc-text">压缩存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">5.2.</span> <span class="toc-text">特殊矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">5.3.</span> <span class="toc-text">对称矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E9%98%B5"><span class="toc-number">5.4.</span> <span class="toc-text">三角阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">5.5.</span> <span class="toc-text">三对角矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">5.6.</span> <span class="toc-text">稀疏矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98-4"><span class="toc-number">5.7.</span> <span class="toc-text">错题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">串的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.</span> <span class="toc-text">定长顺序存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.3.</span> <span class="toc-text">堆分配存储表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E9%93%BE%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.4.</span> <span class="toc-text">块链存储表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">6.5.</span> <span class="toc-text">字符串的模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text">1. 朴素模式匹配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-KMP%E7%AE%97%E6%B3%95"><span class="toc-number">6.7.</span> <span class="toc-text">2. KMP算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%B2%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.8.</span> <span class="toc-text">模式串示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98-5"><span class="toc-number">6.9.</span> <span class="toc-text">错题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%8A%82%E7%82%B9%E6%95%B0%E4%B8%8E%E5%BA%A6%E6%95%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.</span> <span class="toc-text">总节点数与度数关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">7.2.</span> <span class="toc-text">树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">二叉排序树（BST）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL-%E6%A0%91%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">平衡二叉树（AVL 树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">7.6.</span> <span class="toc-text">B 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E4%B8%8E-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.1.</span> <span class="toc-text">B+ 树与 B 树的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.7.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">7.8.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">7.9.</span> <span class="toc-text">链式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.10.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.11.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.12.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">7.13.</span> <span class="toc-text">树的遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">7.14.</span> <span class="toc-text">树的先根遍历（深度优先遍历）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">7.15.</span> <span class="toc-text">树的后根遍历（深度优先遍历）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">7.16.</span> <span class="toc-text">树的层次遍历（广度优先遍历）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">7.17.</span> <span class="toc-text">森林的遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">7.18.</span> <span class="toc-text">森林的先序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">7.19.</span> <span class="toc-text">森林的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">7.20.</span> <span class="toc-text">哈夫曼树和哈夫曼编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.21.</span> <span class="toc-text">哈夫曼树构造步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">7.22.</span> <span class="toc-text">应用场景与优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">7.23.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98-6"><span class="toc-number">7.24.</span> <span class="toc-text">错题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%8E%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">8.1.</span> <span class="toc-text">无向图与有向图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">图的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E6%80%A7%E4%B8%8E%E8%B7%AF%E5%BE%84"><span class="toc-number">8.3.</span> <span class="toc-text">连通性与路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97"><span class="toc-number">8.4.</span> <span class="toc-text">生成树与生成森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA"><span class="toc-number">8.4.1.</span> <span class="toc-text">关键公式与结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">8.4.2.</span> <span class="toc-text">算法与应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.5.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%95%B0%E7%BB%84%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">8.5.1.</span> <span class="toc-text">邻接矩阵（数组、顺序存储）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%EF%BC%89"><span class="toc-number">8.5.2.</span> <span class="toc-text">邻接表（顺序+链式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">8.5.3.</span> <span class="toc-text">十字链表（有向图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">8.5.4.</span> <span class="toc-text">邻接多重表（无向图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.6.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="toc-number">8.6.1.</span> <span class="toc-text">深度优先遍历（DFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="toc-number">8.6.2.</span> <span class="toc-text">广度优先遍历（BFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97-2"><span class="toc-number">8.6.2.1.</span> <span class="toc-text">生成树与生成森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">8.6.2.2.</span> <span class="toc-text">关键结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98-7"><span class="toc-number">8.7.</span> <span class="toc-text">错题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/g86c4e7a.html" title="第 7 章 计算机系统结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 7 章 计算机系统结构"/></a><div class="content"><a class="title" href="/post/g86c4e7a.html" title="第 7 章 计算机系统结构">第 7 章 计算机系统结构</a><time datetime="2025-08-28T21:20:00.000Z" title="发表于 2025-08-29 05:20:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f75b3d6f.html" title="第 6 章 输入输出系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 6 章 输入输出系统"/></a><div class="content"><a class="title" href="/post/f75b3d6f.html" title="第 6 章 输入输出系统">第 6 章 输入输出系统</a><time datetime="2025-08-28T21:19:00.000Z" title="发表于 2025-08-29 05:19:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 5 章 输入输出管理：设备协同与优化"/></a><div class="content"><a class="title" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化">第 5 章 输入输出管理：设备协同与优化</a><time datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d64a2c5e.html" title="第 5 章 中央处理器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 5 章 中央处理器"/></a><div class="content"><a class="title" href="/post/d64a2c5e.html" title="第 5 章 中央处理器">第 5 章 中央处理器</a><time datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 4 章 文件管理：存储与访问机制"/></a><div class="content"><a class="title" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制">第 4 章 文件管理：存储与访问机制</a><time datetime="2025-08-28T21:17:00.000Z" title="发表于 2025-08-29 05:17:00">2025-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> By Lorinda</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="日间和夜间模式切换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="to_comment" type="button" title="前往评论" onclick="FixedCommentBtn();"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-three-beta.vercel.app/',
      region: 'ap-beijing',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-three-beta.vercel.app/',
      region: 'ap-beijing',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async src="//at.alicdn.com/t/c/font_4860073_9duzoqyl2cn.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="/js/pagination-jump.js"></script><script async src="/js/fps.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async data-pjax src="/js/music.js"></script><script defer src="/js/lunar.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script> let backimg =["url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/d42bcc24810cda2c22eaed769b79a93.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/2f5e89ae13329dd89bdcdbfc68c5fde.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/48b137c38cc79ad960ecf2a9a12fc20.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/4474312751631fedb37381e37cdb9c0.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/be978bd80f41d2781455513ba1676a2.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a01223e0819746191dd135670a2d7da.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/af380cb8a5ed3f047e66dbfe731f488.jpg)"];let index = Math.floor(Math.random() * backimg.length);;document.getElementById("web_bg").style.backgroundImage = backimg[index]</script><script type="text/javascript" src="/js/rightmenu.js"></script><script src="/js/history.js"></script><script src="/js/historyroll.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script defer src="/js/day.js"></script><script async src="/js/title.js"></script><script defer src="/js/random.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="/js/sun_moon.js" async></script><script>
  document.addEventListener('copy', function(e) {
    const selection = window.getSelection().toString()
    if (selection.length > 30) {
      const notice = document.createElement('div')
      notice.className = 'copy-notification'
      notice.textContent = '内容已复制到剪贴板'

      document.body.appendChild(notice)
      setTimeout(() => notice.classList.add('show'), 10)

      setTimeout(() => {
        notice.classList.remove('show')
        setTimeout(() => notice.remove(), 300)
      }, 2000)
    }
  })
</script>
<div class="aplayer no-destroy" data-id="7338633309" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script async data-pjax src="/js/newYear.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-nest.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-show-text.min.js" data-mobile="false" data-text="Ha,Ha,Ha" data-fontsize="15px" data-random="false" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = { startHidden: true }
  
    window.chatBtnFn = () => {
      document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => Chatra('hide'),
      show: () => Chatra('show')
    }
  }

  (function(d, w, c) {
    w.ChatraID = 'E3NZpK6rk4cR7jmwK'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
      (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')
})()</script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementsByClassName('recent-posts')[0];
      var item_html = '<div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155818.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术栈/&quot;);" href="javascript:void(0);">技术栈</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">java指南</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机基础/&quot;);" href="javascript:void(0);">计算机基础</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">java技术栈</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机基础/专业课/&quot;);" href="javascript:void(0);">专业课</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">计算机基础指南</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/4e357962b00044466380f6850a120ec.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程语言/&quot;);" href="javascript:void(0);">编程语言</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">专业课</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementsByClassName('recent-posts')[0] && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '9aac1b5db191491a8993c445d664de8f';
  var gaud_map_key = '3cc01a5a19f500daa0e9e680ef0f6db2';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '120.780172,40.624088';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt="">第 7 章 计算机系统结构</a><div class="blog-slider__text">阐述计算机系统结构的基本概念，分析并行处理技术的实现方式，详解存储层次的优化策略，介绍系统性能的评价指标与方法。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt="">第 6 章 输入输出系统</a><div class="blog-slider__text">介绍I/O设备的分类与特性，详解程序查询、中断与DMA三种控制方式，分析中断系统的处理机制，理解设备与主机的信息交换过程。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt="">第 5 章 中央处理器</a><div class="blog-slider__text">详解CPU的功能组成与工作原理，分析时序系统的作用，对比微程序与硬布线控制方式，介绍流水线技术的性能优化机制。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt="">第 4 章 指令系统</a><div class="blog-slider__text">详解指令的基本格式与寻址方式，对比CISC与RISC体系结构特点，分析指令的执行流程，理解指令系统对硬件的适配关系。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt="">第 3 章 存储系统</a><div class="blog-slider__text">分析存储系统的层次结构设计，详解主存储器的组成与工作流程，阐述Cache的映射方式与替换策略，介绍存储器性能优化方法。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt="">第 2 章 数据的表示与计算</a><div class="blog-slider__text">详解数制转换规则，阐述定点数与浮点数的表示方法，分析补码运算机制，介绍ALU的功能与实现，掌握数据在计算机中的处理方式。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt="">Redis</a><div class="blog-slider__text">Redis 作为内存 NoSQL 数据库的定位，支持 String/Hash 等多数据结构，具备 RDB/AOF 持久化与主从高可用，核心用于缓存、分布式锁，性能高效。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt="">第 2 章 进程与线程：并发管理核心</a><div class="blog-slider__text">讲解进程与线程的定义、状态转换及控制逻辑，分析进程调度策略，阐述进程同步互斥（PV 操作）与死锁的处理机制，是操作系统并发管理的核心。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt="">第 5 章 输入输出管理：设备协同与优化</a><div class="blog-slider__text">详解I/O设备分类与控制方式（程序直接控制/DMA/通道），分析磁盘结构与调度策略，介绍SPOOLing等I/O优化技术，保障设备与CPU、内存的高效协同。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt="">第 3 章 内存管理：地址映射与虚拟内存</a><div class="blog-slider__text">覆盖内存分配方式（连续/分页/分段）与地址转换机制，详解虚拟内存技术、请求分页流程及页面置换策略，解决多道程序下内存利用率与地址映射问题。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt="">第 4 章 文件管理：存储与访问机制</a><div class="blog-slider__text">介绍文件的逻辑与物理结构，讲解目录管理（按名存取）、索引节点功能及外存空闲空间分配策略，实现文件的安全存储与高效共享。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt="">第 1 章 操作系统概述：计算机系统基础</a><div class="blog-slider__text">阐述操作系统的定义与核心功能，详解四大特征（并发 / 共享 / 虚拟 / 异步）、处理器运行模式及系统结构分类，介绍 OS 引导流程，奠定操作系统认知基础。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt="">第 1 章 计算机系统概述</a><div class="blog-slider__text">介绍计算机系统的硬件与软件组成，详解五大功能部件及总线工作机制，阐述指令集体系结构的核心作用，建立计算机系统的整体认知。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt="">java基础</a><div class="blog-slider__text">Java基础</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt="">数据结构</a><div class="blog-slider__text">数据结构的核心是高效组织数据，区分逻辑结构（线性 / 非线性）与物理结构（顺序 / 链式），覆盖数组、树、图等核心类型，为优化算法效率、支撑工程应用奠定基础。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt="">王道计组pdf</a><div class="blog-slider__text">计算机组成原理</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>