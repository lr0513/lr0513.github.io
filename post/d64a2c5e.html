<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第 5 章 中央处理器 | 蜡笔梦工厂</title><meta name="author" content="Lorinda"><meta name="copyright" content="Lorinda"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="详解CPU的功能组成与工作原理，分析时序系统的作用，对比微程序与硬布线控制方式，介绍流水线技术的性能优化机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="第 5 章 中央处理器">
<meta property="og:url" content="http://labi.com/post/d64a2c5e.html">
<meta property="og:site_name" content="蜡笔梦工厂">
<meta property="og:description" content="详解CPU的功能组成与工作原理，分析时序系统的作用，对比微程序与硬布线控制方式，介绍流水线技术的性能优化机制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png">
<meta property="article:published_time" content="2025-08-28T21:18:00.000Z">
<meta property="article:modified_time" content="2025-08-28T22:28:56.535Z">
<meta property="article:author" content="Lorinda">
<meta property="article:tag" content="CPU功能组成（控制器&#x2F;运算器）">
<meta property="article:tag" content="时序系统（节拍&#x2F;周期）">
<meta property="article:tag" content="微程序控制与硬布线控制">
<meta property="article:tag" content="流水线技术（时空图&#x2F;冲突处理）">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png"><link rel="shortcut icon" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155552.png"><link rel="canonical" href="http://labi.com/post/d64a2c5e.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bf06f078fafddfd82b474ce179303666";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":{"enable":true},"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第 5 章 中央处理器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2264842_b004iy0kk2b.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/loading.css"><link rel="stylesheet" href="/css/about.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160015.png"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/af380cb8a5ed3f047e66dbfe731f488.jpg);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155535.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">112</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-hexoa-homezhuyefangzijia"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-hexoa-homezhuyefangzijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-hexoshouhuiban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoshouhuiban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexohuanjiaowenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexofenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexobiaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoguidang"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoicon_liebiao"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoyinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexotubiaozhizuomoban"></use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-hexopengyou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexopengyou"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-hexowode"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexowode"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155552.png" alt="Logo"><span class="site-name">蜡笔梦工厂</span></a><a class="nav-page-title" href="/"><span class="site-name">第 5 章 中央处理器</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-hexoa-homezhuyefangzijia"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-hexoa-homezhuyefangzijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-hexoshouhuiban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoshouhuiban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexohuanjiaowenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexofenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexobiaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoguidang"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoicon_liebiao"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoyinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexotubiaozhizuomoban"></use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-hexopengyou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexopengyou"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-hexowode"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexowode"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div></nav><div id="post-info"><h1 class="post-title">第 5 章 中央处理器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-28T22:28:56.535Z" title="更新于 2025-08-29 06:28:56">2025-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">43.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>134分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div class="series-navigation"><h4 class="series-title">计算机组成原理核心知识系列</h4><ol class="series-list"><li class="series-item"><a class="series-link" href="/post/c45d1e8a.html"><span class="series-icon">•</span><span class="series-text"> 🎯 计算机系统概述</span></a></li><li class="series-item"><a class="series-link" href="/post/e72f3b9c.html"><span class="series-icon">•</span><span class="series-text"> 🔢 数据的表示与计算</span></a></li><li class="series-item"><a class="series-link" href="/post/a81d4c7b.html"><span class="series-icon">•</span><span class="series-text"> 💾 存储系统</span></a></li><li class="series-item"><a class="series-link" href="/post/b93e5f6d.html"><span class="series-icon">•</span><span class="series-text"> 📝 指令系统</span></a></li><li class="series-item series-current"><a class="series-link" href="/post/d64a2c5e.html"><span class="series-icon">•</span><span class="series-text"> ⚙️ 中央处理器</span></a><span class="series-current-tag">← 当前位置 🛸</span></li><li class="series-item"><a class="series-link" href="/post/f75b3d6f.html"><span class="series-icon">•</span><span class="series-text"> 🔌 输入输出系统</span></a></li><li class="series-item"><a class="series-link" href="/post/g86c4e7a.html"><span class="series-icon">•</span><span class="series-text"> 🏗️ 计算机系统结构</span></a></li></ol></div><h2 id="CPU-的功能和基本结构">CPU 的功能和基本结构</h2>
<h3 id="CPU-的功能">CPU 的功能</h3>
<ol>
<li><strong>指令控制</strong>：
<ul>
<li>完成取指令、分析指令和执行指令的操作，即程序的顺序控制</li>
</ul>
</li>
<li><strong>操作控制</strong>：
<ul>
<li>管理并产生由内存取出的每条指令的操作信号</li>
<li>把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作</li>
</ul>
</li>
<li><strong>时间控制</strong>：
<ul>
<li>严格控制各种操作信号的出现时间、持续时间及出现的时间顺序</li>
</ul>
</li>
<li><strong>数据加工</strong>：
<ul>
<li>对数据进行算术和逻辑运算</li>
</ul>
</li>
<li><strong>中断处理</strong>：
<ul>
<li>对计算机运行过程中出现的异常情况和特殊请求进行处理</li>
</ul>
</li>
</ol>
<h3 id="CPU-的基本结构">CPU 的基本结构</h3>
<h4 id="组成部分">组成部分</h4>
<ol>
<li>CPU = 运算器 + 控制器
<ul>
<li>运算器：对数据进行加工</li>
<li>控制器：负责协调并控制计算机各部件执行程序的指令</li>
</ul>
</li>
<li>CPU = 数据通路 + 控制部件<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240428133932.png" alt="image.png"></li>
</ol>
<h4 id="CPU-寄存器的分类">CPU 寄存器的分类</h4>
<p>按汇编语言（或机器语言）程序是否可以访问</p>
<h5 id="用户可见的寄存器">用户可见的寄存器</h5>
<ul>
<li>可对这类寄存器编程</li>
<li>使用这类寄存器可减少对主存储器的访问次数</li>
<li>如：**通用寄存器GPRs（含基址 / 变址）、程序状态字寄存器PSW、程序计数器PC、累加寄存器AC、移位寄存器SR **</li>
</ul>
<h5 id="用户不可见的寄存器">用户不可见的寄存器</h5>
<ul>
<li>对用户透明，不可编程</li>
<li>被控制部件使用，以控制 CPU 的操作</li>
<li>保留各种状态信息：溢出标志 OF，符号标志 SF，零标志 ZF，进位标志 CF</li>
<li>如：<strong>存储器地址寄存器MAR、存储器数据寄存器MDR、指令寄存器IR、暂存寄存器</strong></li>
</ul>
<h4 id="运算器基本结构-ALU-PSW-ACC-GPRs-暂-移-计">运算器基本结构(ALU,PSW,ACC,GPRs,暂,移,计)</h4>
<ul>
<li>运算器是计算机对数据进行加工处理的中心</li>
<li>接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理</li>
</ul>
<h5 id="组成">组成</h5>
<ul>
<li><strong>算术逻辑单元（ALU）</strong>：进行算术 / 逻辑运算</li>
<li><strong>程序状态字寄存器（PSW）</strong>：
<ul>
<li>PSW 存放<strong>程序状态字</strong>【标志位的组合】，用于保存系统的运行状态</li>
<li>PSW 包括<strong>状态标志和控制标志</strong></li>
<li>溢出标志 OF，符号标志 SF，零标志 ZF，进位标志 CF</li>
<li>中断标志，陷阱标志</li>
</ul>
</li>
<li><strong>累加寄存器（ACC）</strong>：
<ul>
<li>是一个通用寄存器</li>
<li>暂放 ALU 运算的结果信息，可作为加法运算的输入端</li>
</ul>
</li>
<li><strong>通用寄存器组（GPRS）</strong>：
<ul>
<li>如 AX，BX，CX，DX，SP</li>
<li>通用寄存器可变成指令多种功能的寄存器</li>
<li>用于<strong>存放操作数和各种地址信息</strong>，所以<font color="#ff0000">其位数与机器字长相等</font></li>
<li>SP 是堆栈指针，用于指示栈顶的地址</li>
</ul>
</li>
<li><strong>暂存寄存器</strong>：
<ul>
<li>暂存从数据总线或通用寄存器读来的操作数，为了保护通用寄存器中的原有数据不被破坏</li>
<li><strong>对应用程序员透明</strong></li>
</ul>
</li>
<li><strong>移位寄存器（SR）</strong>：移位运算包括逻辑移位和算术移位，对操作数或运算结果进行移位运算</li>
<li><strong>计数器</strong>：在乘法运算中，计数器用于记录重复加法的次数。在除法运算中，计数器可用于记录试商的次数，以及判断除法运算是否完成 。</li>
</ul>
<h4 id="控制器基本结构-PC-IR-ID-MAR-MDR">控制器基本结构(PC,IR,ID,MAR,MDR)</h4>
<ul>
<li>协调并控制计算机各部件执行程序的指令序列</li>
<li>基本功能包括<strong>取指令、分析指令、执行指令</strong>
<ul>
<li>取指令：自动形成指令地址；自动发出取指令的命令</li>
<li>分析指令：操作码译码（分析本条指令要完成什么操作），产生操作数的有效地址</li>
<li>执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作</li>
</ul>
</li>
<li>中断处理：管理总线及输入输出；处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）</li>
</ul>
<h5 id="组成-2">组成</h5>
<ul>
<li><strong>程序计数器（PC）</strong>：
<ul>
<li>用于<strong>指出下一条指令在主存中的存放地址（PC 总是存放指令地址）</strong></li>
<li>PC 有<strong>自增功能</strong></li>
<li>PC 的值会根据 CPU 在执行指令过程中<strong>自增或转移到程序的某处</strong> (跳转指令)</li>
<li>PC 的<strong>位数等于主存储器地址位数</strong></li>
</ul>
</li>
<li><strong>指令寄存器（IR）</strong>：
<ul>
<li>用于保存<strong>当前正在执行</strong>的那条指令</li>
<li>IR 的<strong>位数取决于指令字长</strong></li>
</ul>
</li>
<li><strong>指令译码器（ID）</strong>：
<ul>
<li>仅对<strong>操作码字段进行译码</strong>，以确定指令的操作功能</li>
</ul>
</li>
<li><strong>存储器地址寄存器（MAR）</strong>：
<ul>
<li>存放要访问的主存储器单元的地址</li>
<li>MAR 的位数等于主存储器地址线位数</li>
</ul>
</li>
<li><strong>存储器数据寄存器（MDR）</strong>：
<ul>
<li>存放向主存储器写入的信息或从主存储器读出的信息</li>
<li>MDR 的位数等于存储字长</li>
</ul>
</li>
<li><strong>时序系统</strong>：用于产生各种时序信号，都由统一时钟 CLOCK 分频得到</li>
<li><strong>微操作信号发生器</strong>：
<ul>
<li>根据 IR 的内容 (指令)，PSW 的内容 (状态信息) 和时序信号产生控制计算机系统所需的各种控制信号</li>
<li>有<strong>组合逻辑型和存储逻辑型</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250531203238827.png" alt="image.png"></li>
</ul>
</li>
</ul>
<p><strong>运算器部分</strong></p>
<ul>
<li><strong>算术逻辑单元（ALU）</strong>：核心运算部件，能执行算术运算（如加、减、乘、除 ）和逻辑运算（如与、或、非 ）。它有两个数据输入端 A 和 B ，接收来自其他部件的数据进行运算 。</li>
<li><strong>通用寄存器组（R0 - R3 ）</strong>：用于存放操作数、中间结果等。每个寄存器都有输入控制信号（如 R0in ）和输出控制信号（如 R0out ） ，控制数据的进出。例如， R0in 信号有效时，数据可存入 R0 寄存器 。</li>
<li><strong>累加寄存器（ACC）</strong>：可暂存 ALU 运算结果，也能作为加法运算的一个输入端。通过 ACCin 和 ACCout 信号控制其数据的输入和输出 。</li>
<li><strong>暂存寄存器</strong>：临时存储从主存或其他寄存器读取的操作数，防止破坏原寄存器数据，为运算提供临时数据存储 。</li>
<li><strong>移位寄存器</strong>：对操作数或运算结果进行移位操作，实现逻辑移位或算术移位，辅助运算器进行特定的数据处理 。</li>
</ul>
<p><strong>控制器部分</strong></p>
<ul>
<li><strong>程序计数器（PC）</strong>：存放即将执行的下一条指令在主存中的地址。具有自增功能，每执行完一条指令自动加 1 指向下一条指令地址（遇到跳转指令时会改变 ） 。 PCin 和 PCout 控制其数据输入输出 。</li>
<li><strong>指令寄存器（IR）</strong>：保存当前正在执行的指令，指令分为操作码（OP ）和地址码（Ad ）两部分。 IRin 用于将指令存入 IR ， AdIRout 用于输出地址码部分 。</li>
<li><strong>CU控制单元：负责协调和管理计算机的操作</strong>
<ul>
<li><strong>指令译码器（ID）</strong>：对指令寄存器中操作码字段进行译码，生成特定操作信号，告知控制器各部件如何执行指令 。</li>
<li><strong>微操作信号发生器</strong>：依据 IR 内容（指令 ）、程序状态字寄存器（PSW ）内容（状态信息 ）及时序信号，产生控制整个计算机系统的各种控制信号，有组合逻辑型和存储逻辑型两种结构 。</li>
<li><strong>时序系统</strong>：通过对统一时钟（CLOCK ）分频，产生各种时序信号，为各部件操作提供时间基准和协调控制 。</li>
</ul>
</li>
<li><strong>存储器地址寄存器（MAR）</strong>：存储要访问的主存单元地址，通过 MARin 信号控制地址输入 ，用于定位主存中数据或指令的位置 。</li>
<li><strong>存储器数据寄存器（MDR）</strong>：用于暂存向主存写入或从主存读出的信息。 MDRin 、 MDRinE控制数据写入， MDRout 、 MDRoutE控制数据输出<br>
MDRinE指从系统总线输入的端; MDRin 指从CPU内部总线输入的端</li>
</ul>
<p><strong>总线部分</strong></p>
<ul>
<li><strong>CPU 内部总线</strong>：作为内部各部件之间数据传输的通道，实现运算器和控制器内部以及它们之间的数据交互 。</li>
<li><strong>数据总线</strong>：用于在 CPU 与主存、I/O 设备等之间传输数据 。</li>
<li><strong>地址总线</strong>：传输 CPU 要访问的主存单元或 I/O 设备的地址信息 。</li>
</ul>
<h4 id="数据通路基本结构">数据通路基本结构</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>元件名称</th>
<th>功能简述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>操作元件</strong></td>
<td>算术逻辑单元（ALU）</td>
<td>执行算术和逻辑运算</td>
</tr>
<tr>
<td></td>
<td>译码器</td>
<td>将指令操作码等转换为控制信号</td>
</tr>
<tr>
<td></td>
<td>数据选择器（多路选择器）</td>
<td>依据控制信号从多个输入选一个输出</td>
</tr>
<tr>
<td></td>
<td>加法器</td>
<td>实现二进制数相加</td>
</tr>
<tr>
<td><strong>状态元件</strong></td>
<td>通用寄存器</td>
<td>暂存操作数、运算结果等</td>
</tr>
<tr>
<td></td>
<td>程序计数器（PC）</td>
<td>存储下条指令在主存的地址</td>
</tr>
<tr>
<td></td>
<td>指令寄存器（IR）</td>
<td>存放当前执行指令</td>
</tr>
<tr>
<td></td>
<td>存储器地址寄存器（MAR）</td>
<td>保存要访问主存单元的地址</td>
</tr>
<tr>
<td></td>
<td>存储器数据寄存器（MDR）</td>
<td>暂存主存读出或准备写入的数据</td>
</tr>
<tr>
<td></td>
<td>移位寄存器</td>
<td>存储并对数据进行移位操作</td>
</tr>
<tr>
<td></td>
<td>存储器</td>
<td>存储数据和程序代码</td>
</tr>
<tr>
<td>一般不包含在数据通路的元件</td>
<td>控制器部分控制逻辑电路</td>
<td>负责控制流程和决策</td>
</tr>
<tr>
<td></td>
<td>电源电路、时钟发生电路等辅助电路</td>
<td>供电和产生时钟信号</td>
</tr>
</tbody>
</table>
<h5 id="专用数据通路方式">专用数据通路方式</h5>
<ul>
<li>根据指令执行过程中的数据和地址的流动方向安排连线线路<br>
比如对于 “从内存读取数据并与寄存器中的数据相加” 这条指令，数据从内存经数据总线到运算器、操作数在寄存器间以及到算术逻辑单元（ALU ）的流动路径，会被专门铺设线路。</li>
<li>通俗解释：专门为指令的执行设计一条专属通道，避免使用共享的总线，没有冲突</li>
<li>使用<strong>多路选择器</strong>控制一路的输出</li>
<li>使用<strong>三态门</strong>控制输出</li>
<li><strong>优点</strong>：性能较高，基本<strong>不存在数据冲突现象</strong></li>
<li><strong>缺点</strong>：结构复杂，硬件量大，不易实现，成本高</li>
</ul>
<h5 id="CPU-内部单总线方式">CPU 内部单总线方式</h5>
<ul>
<li>将所有寄存器的输入端和控制端都连接到一条公共通路上，所有数据都要走这条路来传输数据</li>
<li>通俗解释：计算机中的所有寄存器的输入输出端都连接到一条公共通路上</li>
<li><strong>优点</strong>：结构简单，容易实现</li>
<li><strong>缺点</strong>：传输存在较多冲突现象，性能较低</li>
</ul>
<p><strong>管理多条通路</strong>：多路选择器MUX与三态门</p>
<ul>
<li><strong>多路选择器 MUX</strong>：在管理多条通路时，MUX 是关键组件。它可以<strong>从多个输入信号中选择一个输出，通过控制信号来决定选择哪一路输入</strong>。例如在具有多条数据通路的系统中，MUX 可根据指令需求，从不同寄存器或数据源的输出中选择合适的数据传输到目标部件，避免数据通路之间的干扰和冲突 。</li>
<li><strong>三态门</strong>：<strong>三态门用于控制通路的连接与断开</strong>。在多条通路的系统中，通过三态门可以控制每一条通路是否输出数据。当三态门处于高阻态时，该通路与其他部件之间的连接相当于断开，不会对其他通路的数据传输产生影响；当处于导通状态时，数据可以在该通路中正常传输，从而实现对多条通路的有效管理</li>
</ul>
<h3 id="CPU-常混淆点">CPU 常混淆点</h3>
<ul>
<li><strong>转移指令</strong>时，需要判别转移是否成功，若成功则 PC 修改为转移指令的目标地址，否则下一条指令的地址仍然为 PC 自增后的地址</li>
<li><strong>计算机分两大部分</strong>：<strong>控制</strong>部件和<strong>执行</strong>部件
<ul>
<li>控制器就是控制部件，<strong>指令寄存器，操作控制器，程序计数器</strong>都是控制部件</li>
<li>运算器（例如PSW、ALU、通用寄存器），<strong>存储器，外围设备</strong>就是执行部件</li>
</ul>
</li>
<li><strong>各寄存器的位数等于什么？</strong>【和<strong>地址</strong>有关的（PC、MAR）就取决于<strong>机器字长</strong>，和<strong>数据大小</strong>有关的（MDR、GPRs）就取决于<strong>容量</strong>】
<ul>
<li><strong>通用寄存器</strong>：<strong>机器字长</strong></li>
<li><strong>PC</strong>：
<ul>
<li>按<strong>字节</strong>编址：与<strong>存储器地址的位数</strong>相等，取决于存储器容量</li>
<li>按<strong>字</strong>编址：位数 = <strong>存储器地址的位数 - $log_2(指令字长的字节数)$</strong> 【指令必须按边界对齐的方式存放】，取决于存储器容量和存储字长</li>
</ul>
</li>
<li><strong>IR：指令字长</strong></li>
<li><strong>MAR：存储器容量</strong></li>
<li><strong>MDR：存储字长</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>位数决定因素</th>
<th>假设存储器 1KB，指令字长 4 字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用寄存器</td>
<td>机器字长</td>
<td>32 位</td>
</tr>
<tr>
<td>PC（字节编址）</td>
<td>存储器地址位数</td>
<td>10 位</td>
</tr>
<tr>
<td>PC（字编址）</td>
<td>存储器地址位数，指令字长</td>
<td>10 - log2​(4) = 8 位</td>
</tr>
<tr>
<td>IR</td>
<td>指令字长</td>
<td>32 位</td>
</tr>
<tr>
<td>MAR</td>
<td>存储器地址位数</td>
<td>10 位</td>
</tr>
<tr>
<td>MDR</td>
<td>存储字长，数据总线的宽度</td>
<td>8 位（按字节编址）</td>
</tr>
</tbody>
</table>
<h2 id="指令执行过程">指令执行过程</h2>
<h3 id="指令周期相关概念">指令周期相关概念</h3>
<ul>
<li>
<p><strong>指令周期</strong>：CPU 从主存中每<strong>取出并执行</strong>一条指令所需的全部时间，一个指令周期由多个机器周期组成<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602193858760.png" alt="image.png"></p>
</li>
<li>
<p>指令周期最多有 4 种机器周期：<strong>取指周期、间址周期、执行周期、中断周期</strong>（都有访问主存的操作）</p>
</li>
<li>
<p>分别对应标志触发器：<strong>FE、IND、EX、INT</strong>（“1”表示有效，如 1–&gt;FE 表示有取值周期）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="" alt="Uploading file...o6lc6"><br>
<a target="_blank" rel="noopener" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602194709866.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602194709866.png</a></p>
</li>
<li>
<p>取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p>
</li>
</ul>
<h4 id="易混淆知识点">易混淆知识点</h4>
<ul>
<li>
<p><strong>指令</strong>：</p>
<ul>
<li>CPU 区分指令和数据的依据是<strong>指令周期的不同阶段</strong>【<strong>取指周期取指令</strong>，<strong>执行周期取数据</strong>】<br>
例：取指阶段，PC 指向指令地址，主存返回指令；执行阶段，指令中的操作数地址指向数据，主存返回数据。</li>
<li>不同长度的指令，取指操作可能不同（如双字指令，三字指令和单字指令）</li>
<li>指令长度相同的情况下，指令的取指操作是相同的</li>
<li><strong>指令总是根据 PC 从主存中读出</strong>（<strong>无条件转移指令</strong>或<strong>中断返回指令</strong>也是如此，最终的结果还是根据 PC 从主存读出）</li>
</ul>
</li>
<li>
<p><strong>取指</strong>：</p>
<ul>
<li>取指操作是控制器固有的功能，<strong>不需要操作码的控制</strong>，由硬件逻辑自动触发（如时钟信号驱动 PC 递增并访存）</li>
<li>取指操作是<strong>自动进行</strong>的，控制器不需要得到相应的指令<br>
控制器在每个指令周期开始时，自动执行 “取指 - 译码 - 执行” 流程，无需额外指令控制取指动作。</li>
<li>取指周期简单来说是取指，即<strong>从主存中取出指令字</strong>，存入IR，供后续译码使用。</li>
</ul>
</li>
<li>
<p><strong>字长</strong>：</p>
<ul>
<li>为了硬件设计方便，<strong>指令字长一般取存储字长的整数倍</strong></li>
<li>如果指令字长=存储字长的 2 倍，则取一条指令需要访存 2 次，取指周期是机器周期的 2 倍</li>
<li><strong>指令字长由指令集设计决定，与机器字长（CPU 一次处理的数据宽度）无直接关联。</strong></li>
</ul>
</li>
<li>
<p><strong>中断</strong>：</p>
<ul>
<li>CPU 在<strong>每条指令执行结束前</strong>发送中断查询信号，检测是否有中断请求。</li>
<li>中断响应必须在<strong>一条指令执行结束后</strong>，不能在指令执行过程中响应（确保指令原子性）</li>
</ul>
</li>
<li>
<p><strong>周期</strong>：指令周期 &gt; 机器周期 &gt; 时钟周期，机器周期由存取周期决定</p>
<ul>
<li><strong>指令周期</strong>：CPU 从主存中取指并执行一条指令的总时间，一个指令周期由多个机器周期组成</li>
<li><strong>机器周期（CPU 周期）</strong>：完成一个基本操作（如取指、访存）的时间，由<strong>存取周期</strong>决定（因存取周期最长）</li>
<li><strong>时钟周期（节拍 / T 周期）</strong>：计算机工作的<strong>最小时间周期</strong>，是 CPU 操作的<strong>基本单位</strong>；一个时钟周期内控制信号不发生改变</li>
<li><strong>存取周期</strong>：连续两次独立访存操作的最短间隔时间。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250601212657960.png" alt="image.png|300"></li>
</ul>
</li>
<li>
<p><strong>周期的可变性</strong>：</p>
<ul>
<li>不同指令的机器周期数可变（如简单指令 1 个机器周期，复杂指令多个）。</li>
<li>每个机器周期内的时钟周期数可变（根据操作复杂度调整）。</li>
<li>DMA（直接内存访问）传输数据时，每传送一个数据需占用一个<strong>存取周期</strong>，此时 CPU 无法访存（总线控制权被 DMA 控制器接管）。</li>
</ul>
</li>
<li>
<p><strong>其他</strong>：</p>
<ul>
<li>若不使用 Cache，每次取指令都需<strong>直接访问主存</strong>（即<strong>每个取指周期必须访存一次</strong>）</li>
<li>若不采用<strong>指令预取</strong>，<strong>每个指令周期都需从主存取指令</strong>（无法提前缓存下一条指令，可能降低效率）。</li>
</ul>
</li>
</ul>
<h3 id="不同指令的指令周期举例">不同指令的指令周期举例</h3>
<ol>
<li><strong>无条件转移指令 JMP X</strong>：
<ul>
<li>指令周期 = <strong>取指周期+执行周期</strong>，无需访问操作数（因转移地址直接在指令中）</li>
<li><strong>PC 被修改两次</strong>
<ul>
<li><strong>取指周期结束</strong>：PC 自动加 1（指向下一条指令的地址）。</li>
<li><strong>执行周期</strong>：PC 被修改为目标地址 X（实现程序跳转）。</li>
<li>eg.假设当前指令地址为 A，取指后 PC=A+1；执行 JMP X 时，PC 被置为 X，下一条指令从 X 地址读取。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>无需访问操作数，执行速度快，常用于流程控制（如循环、条件分支）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>间接寻址的指令</strong>：
<ul>
<li>指令周期 = <strong>取指周期 + 间址周期 + 执行周期</strong>，需两次访存（取指令 + 取操作数地址）</li>
<li>各周期的作用
<ul>
<li><strong>取指周期</strong>：从主存读取指令，PC 自动加 1。</li>
<li><strong>间址周期</strong>：根据指令中的间接地址（如形式地址 D）访问主存，读取操作数的有效地址 EA（存入 MDR）。
<ul>
<li>间址周期结束时，MDR 中存储的是<strong>操作数的有效地址 EA</strong>，而非操作数本身。</li>
</ul>
</li>
</ul>
</li>
<li><strong>执行周期</strong>：根据 EA 访问主存，读取操作数并执行运算。</li>
</ul>
</li>
<li><strong>CPU 采用中断方式实现主机和 I/O 设备的信息交换且有中断请求</strong>：
<ul>
<li>指令周期 = <strong>取指周期 + 间址周期（若有间接寻址） + 执行周期 + 中断周期</strong>，适用于 CPU 响应 I/O 中断的场景。</li>
<li>CPU 在每条指令执行结束前发送中断查询信号，若检测到中断请求，则进入<strong>中断周期</strong>。</li>
<li><strong>中断周期进栈操作是将 SP-1</strong>，计算机的堆栈都是向低地址（栈顶）增加，所有进栈操作减 1 而不是加 1</li>
<li>中断周期的核心操作
<ul>
<li><strong>保存断点</strong>：将当前 PC 值（下一条指令地址）和程序状态字（PSW）压入堆栈。
<ul>
<li>堆栈向低地址增长，因此进栈操作是SP-1（SP 为堆栈指针）：
<ul>
<li>先SP = SP - 1，将 PC 值存入 SP 指向的单元；</li>
<li>再SP = SP - 1，将 PSW 存入新的 SP 指向的单元。</li>
</ul>
</li>
</ul>
</li>
<li><strong>设置中断服务程序入口</strong>：PC 被置为中断向量地址，准备执行中断处理程序。</li>
</ul>
</li>
<li>与普通指令周期的区别
<ul>
<li>中断周期是指令周期的扩展阶段，仅在有中断请求时出现，用于保存现场和切换程序流程。</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>周期构成</th>
<th>访存次数</th>
<th>PC 修改次数</th>
<th>核心操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无条件转移</strong>指令</td>
<td>取指周期 + 执行周期</td>
<td>1 次（取指令）</td>
<td>2 次（自动加 1 + 目标地址）</td>
<td>直接修改 PC 实现跳转，无需操作数</td>
</tr>
<tr>
<td><strong>间接</strong>寻址指令</td>
<td>取指周期 + 间址周期 + 执行周期</td>
<td>3 次（取指令 + 取 EA + 取操作数）</td>
<td>1 次（自动加 1）</td>
<td>两次访存获取操作数地址，执行周期处理操作数</td>
</tr>
<tr>
<td><strong>中断</strong>响应指令</td>
<td>取指周期 + 间址周期 + 执行周期 + 中断周期</td>
<td>取决于是否间接寻址</td>
<td>2 次（自动加 1 + 中断向量地址）</td>
<td>执行结束后进入中断周期，保存断点并切换到中断服务程序</td>
</tr>
</tbody>
</table>
<h3 id="指令周期的数据流">指令周期的数据流</h3>
<ul>
<li><strong>数据流</strong>：根据指令要求一次访问的数据序列</li>
<li>指令执行不同阶段，访问的数据序列不同</li>
<li>不同的指令，数据流也不同</li>
</ul>
<h4 id="取指周期">取指周期</h4>
<ul>
<li><strong>任务</strong>：根据 PC 中的内容从主存中<strong>取出指令代码</strong>并放在 IR 中</li>
<li>取值操作是控制器自动进行的</li>
<li>在指令字长相同的情况下，所有指令的取值操作是相同的</li>
<li><strong>数据流向</strong>：PC 中存放的是指令的地址，根据此地址从内存单元中取出的指令，并放在指令寄存器 IR 中，取指同时，PC+1
<ol>
<li>PC—&gt;MAR—&gt;地址总线—&gt;主存</li>
<li>CU (控制单元) 发出读命令—&gt;控制总线—&gt;主存</li>
<li>主存—&gt;数据总线 MDR—&gt;IR（存放指令）</li>
<li>CU 发出控制信号—&gt;PC 内容加 1<br>
通俗理解：PC是书的页码，存储下一条指令地址，将该地址告诉MAR（图书管理员），MAR把地址通过地址线传给内存，并找到相应地址的指令，通过数据线传给MDR，CPU从MDR读取指令到IR，存储当前要执行的指令。此时，PC+1，记住下一页的页码<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602202340752.png" alt="image.png"></li>
</ol>
</li>
</ul>
<h4 id="间址周期">间址周期</h4>
<ul>
<li><strong>任务</strong>：取操作数的<strong>有效地址</strong></li>
<li><strong>数据流向</strong>：以一次间址为例，将指令中的地址码送到 MAR 并送至地址总线，此后 CU 向存储器发出读命令，以获取有效地址并存至 MDR
<ol>
<li>Ad（IR）（或 MDR）—&gt;MAR—&gt;地址总线—&gt;主存</li>
<li>CU 发出读命令—&gt;控制总线—&gt;内存</li>
<li>主存—&gt;数据总线—&gt;MDR（存放有效地址）</li>
<li>MDR有效地址—&gt;指令的地址码字段Ad(IR)【替换原来的间接地址】</li>
</ol>
</li>
<li><strong>Ad（IR）</strong> 表示取出 IR 中存放的指令字的地址字段</li>
</ul>
<p>通俗理解：根据IR中的地址告诉MAR数据存在哪里，内存定位并取出给MDR<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602202903293.png" alt="image.png"></p>
<h4 id="执行周期">执行周期</h4>
<ul>
<li><strong>任务</strong>：取操作数，并根据 IR 中的指令字的操作码通过 ALU 操作产出执行结果</li>
<li><strong>数据流向</strong>：不同指令操作不同，无统一的数据流向</li>
<li>eg. CLA 指令（clear ACC 指令 ，ACC 清零）
<ul>
<li>执行周期操作：0→AC ，即将累加器 ACC 清零。</li>
</ul>
</li>
<li>eg. LDA X 指令（取数指令，把 X 所指内容取到 ACC ）
<ul>
<li>执行周期操作：
<ul>
<li>Ad(IR) → MAR ：将指令寄存器 IR 中的地址部分送到存储器地址寄存器 MAR 。</li>
<li>1 → R ：设置读信号</li>
<li>M(MAR) → MDR ：从存储器中，根据 MAR 中的地址读取数据到存储器数据寄存器 MDR 。</li>
<li>MDR → AC ：将 MDR 中的数据传送到累加器 ACC 。</li>
</ul>
</li>
</ul>
</li>
<li>JMP X 指令（无条件转移 ）
<ul>
<li>执行周期操作：Ad(IR) → PC ，即将指令寄存器 IR 中的地址部分送到程序计数器 PC ，改变程序执行顺序。</li>
</ul>
</li>
<li>BAN X 指令（Branch ACC Negative ，条件转移，当 ACC 为负时转移 ）
<ul>
<li>执行周期操作：$A_0\cdot Ad(IR)+\overline{A_0}\cdot(PC) → PC$ ，其中A_0可能是 ACC 的符号位（负数符号位为 1 ），根据 ACC 符号位及指令地址等情况决定是否转移，若 ACC 为负则将指令中的地址送到 PC，改变程序执行顺序 。</li>
</ul>
</li>
</ul>
<h4 id="中断周期">中断周期</h4>
<ul>
<li><strong>任务</strong>：处理中断请求<br>
<strong>保存现场与切换任务</strong></li>
<li><strong>数据流向</strong>：假设程序断点存入堆栈中，并用 SP 指示栈顶指针，而且进栈操作是先修改指针，后存入数据；出栈操作是先删除数据，后修改指针
<ol>
<li>CU 控制将 SP 减 1，SP—&gt;MAR—&gt;地址总线—&gt;主存<br>
SP-1后指向新的堆栈单元，SP新值送给MAR暂存即将访问的贮存地址</li>
<li>CU 发出写命令—&gt;控制总线—&gt;主存</li>
<li>PC—&gt;MDR—&gt;数据总线—&gt;主存（<strong>程序断点存入主存</strong>）<br>
将断点地址存入 SP 指向的单元</li>
<li>CU（<strong>中断服务程序的入口</strong>）—&gt;PC<br>
CU 将中断服务程序的入口地址送入 PC，CPU 下一条指令从该地址读取。记完断点后，执行中断程序</li>
</ol>
</li>
</ul>
<p>通俗解释：SP指向堆栈当前栈顶，先利用SP-1指向新栈顶，在堆栈腾出一个存储单元，然后将新的SP地址存到MAR，PC指向执行中断的下一条指令地址（断点地址），需要将断电地址保存到主存中堆栈中新SP指向的单元，但主存写操作必须通过MDR进行，因此先将 PC 的值传输到 MDR，再由 MDR 将数据写入主存。CU将中断服务程序的入口地址送入PC，CPU 后续从该地址开始执行中断处理逻辑<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602202937806.png" alt="image.png"></p>
<h3 id="指令的执行方案">指令的执行方案</h3>
<h4 id="单周期处理器">单周期处理器</h4>
<ul>
<li><strong>定义</strong>：
<ul>
<li>每条指令都必须在1个时钟周期内完成【CPI = 1】，指令之间<strong>串行执行</strong></li>
<li>时钟周期长度由 “<strong>最慢指令</strong>” 决定</li>
</ul>
</li>
<li><strong>特点</strong>：<strong>串行</strong>，<strong>相同执行时间</strong></li>
<li><strong>优点</strong>：设计简单，串行执行，不会出错</li>
<li><strong>缺点</strong>：效率低</li>
<li>补充：<strong>单周期CPU</strong>、<strong>基本流水线CPU</strong>、<strong>超流水线技术</strong>的CPI都是1；<strong>多周期CPU</strong>的CPI＞1；<strong>多发射流水线</strong>（超长指令字、超标量流水线）的CPI＜1</li>
</ul>
<h4 id="多周期处理器">多周期处理器</h4>
<ul>
<li><strong>定义</strong>：
<ul>
<li>指令之间<strong>串行执行</strong></li>
<li>不同指令按复杂度分配不同周期数</li>
<li>可以选用不同个数的时钟周期来完成不同指令的执行过程【CPI &gt; 1】</li>
</ul>
</li>
<li><strong>特点</strong>：串行，不同执行时间</li>
<li><strong>优点</strong>：比单周期灵活，快指令不用 “干等”，CPU 周期利用率更高。</li>
<li><strong>缺点</strong>：控制逻辑复杂（需判断每条指令该分多少周期），仍未实现指令并行。</li>
</ul>
<h4 id="流水线处理器">流水线处理器</h4>
<ul>
<li><strong>定义</strong>：
<ul>
<li>将指令执行拆分为多个阶段（如取指、译码、执行、访存、写回），每个阶段在独立单元执行。</li>
<li>力争在每个时间脉冲周期完成一条指令的执行过程【理想情况下，CPI = 1】，但实际因流水线冲突（如数据依赖）效率会降低。</li>
<li>尽量<strong>让多条指令同时运行</strong>，但<strong>各自处在不同的执行步骤中</strong></li>
</ul>
</li>
<li><strong>特点</strong>：<strong>并行</strong></li>
<li><strong>优点</strong>：大幅提升指令吞吐量</li>
<li><strong>缺点</strong>：硬件复杂（需处理指令冲突），存在 “流水线气泡”（如等待数据时阶段空闲）。</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>指令执行方式</th>
<th>时钟周期长度</th>
<th>效率特点</th>
<th>硬件复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>单周期</strong></td>
<td>串行，1 周期 / 指令</td>
<td>由最慢指令决定</td>
<td>简单但低效，快指令被拖累</td>
<td>低</td>
</tr>
<tr>
<td><strong>多周期</strong></td>
<td>串行，可变周期</td>
<td>每条指令独立配置</td>
<td>效率提升，仍无并行</td>
<td>中</td>
</tr>
<tr>
<td><strong>流水线</strong></td>
<td>并行，重叠执行</td>
<td>固定短周期</td>
<td>效率最高，需处理冲突</td>
<td>高</td>
</tr>
</tbody>
</table>
<h2 id="数据通路的功能和基本结构">数据通路的功能和基本结构</h2>
<h3 id="数据通路概述">数据通路概述</h3>
<ul>
<li><strong>定义</strong>：
<ul>
<li>数据通路是指令执行时，<strong>数据在 CPU 内部流动的路径</strong>，包括路径上的所有部件（如寄存器、ALU、总线等）</li>
<li><strong>ALU、通用寄存器、状态寄存器、异常和中断处理逻辑</strong>等都是数据通路的一部分</li>
<li>它描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里</li>
</ul>
</li>
<li><strong>功能</strong>：实现 CPU 内部的运算器与寄存器及寄存器之间的<strong>数据交换</strong></li>
<li><strong>易混淆知识点</strong>：</li>
</ul>
<ol>
<li><strong>内部总线 vs 系统总线</strong>
<ul>
<li><strong>内部总线</strong>：CPU 内部各部件（如寄存器、ALU）之间的连接线路，类似 “小区内道路”。</li>
<li><strong>系统总线</strong>：连接 CPU、内存、I/O 设备的总线，类似 “城市主干道”。</li>
</ul>
</li>
<li><strong>单总线的数据冲突案例</strong>
<ul>
<li><strong>单总线数据通路</strong>将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只允许一次操作，无法完成指令的所有操作</li>
<li>若指令需同时从内存读数据到寄存器 A，且将寄存器 B 的数据写入内存，单总线需分两步：
<ol>
<li>先完成读操作（内存→总线→寄存器 A）；</li>
<li>再完成写操作（寄存器 B→总线→内存）。</li>
</ol>
</li>
<li>多总线可同时进行这两个操作，效率翻倍。</li>
</ul>
</li>
<li><strong>控制信号的作用</strong>
<ul>
<li>每个部件有**输入控制信号（in）和输出控制信号（out）</li>
<li>例：寄存器 A 的 out=1 时，数据才能输出到总线；ALU 的 in=1 时，才能从总线接收数据。</li>
</ul>
</li>
</ol>
<h3 id="数据通路的基本结构">数据通路的基本结构</h3>
<h4 id="CPU-内部单总线方式-2">CPU 内部单总线方式</h4>
<ul>
<li><strong>定义</strong>：将所用寄存器的输入端与输出端连接到<strong>一条公共通路</strong>上</li>
<li><strong>特点</strong>：结构比较简单，数据传输存在较多的冲突现象，性能较低<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429184829.png" alt="image.png"></li>
<li>in 表示该部件的允许输入控制信号；out 表示该部件的允许输出控制信号</li>
<li>每个时钟周期只能有一次数据传输（如寄存器→总线→ALU），类似单车道同一时间只能有一辆车行驶。</li>
<li>ALU 的两个输入端不能同时接总线，需通过<strong>暂存器</strong>分两次输入数据（如先从寄存器 A→总线→暂存器，再从暂存器→ALU）。</li>
<li>ALU输入信号（in）和输出信号（out）必须<strong>在同一时钟周期内同时有效</strong>，才能完成一次完整的运算</li>
</ul>
<h4 id="CPU-内部多总线方式">CPU 内部多总线方式</h4>
<ul>
<li><strong>定义</strong>：将所用寄存器的输入端与输出端都连接到<strong>多条公共通路</strong>上，可同时进行多组数据传输</li>
<li><strong>特点</strong>：相较单总线结构，减少冲突，多条指令可并行执行部分操作（如取指和译码同时进行），<strong>效率较高</strong></li>
</ul>
<h4 id="专用数据通路方式-2">专用数据通路方式</h4>
<ul>
<li><strong>定义</strong>：根据指令类型<strong>专门设计线路</strong>，不同指令走不同路径</li>
<li><strong>优点</strong>：避免使用共享的总线，数据传输最快，<strong>性能较好</strong></li>
<li><strong>缺点</strong>：<strong>硬件总量较大</strong>，硬件成本高</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250603212507341.png" alt="image.png"><br>
若取出的指令是ADD，该加法指令指明了某个地址，另一个加法的操作数已经存储到ACC中</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>数据流向</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>Ad(IR) → MAR</code></td>
<td>将指令中的地址码送 MAR</td>
</tr>
<tr>
<td>2</td>
<td><code>M(MAR) → MDR</code></td>
<td>从主存读取操作数到 MDR</td>
</tr>
<tr>
<td>3</td>
<td><code>MDR → ALU</code></td>
<td>操作数送 ALU 的一个输入端</td>
</tr>
<tr>
<td>4</td>
<td><code>(ACC) + (MDR) → Z</code></td>
<td>ACC 与 MDR 相加，结果存入 Z</td>
</tr>
<tr>
<td>5</td>
<td><code>Z → ACC</code></td>
<td>将运算结果存入 ACC</td>
</tr>
<tr>
<td>eg. <strong>下图是一个简化了的 CPU 与主存连接结构示意图（图中省略了所有的多路选择器）。其中有一个累加寄存器（ACC）、一个状态数据寄存器和其他 4 个寄存器：主存地址寄存器（MAR）、主存数据寄存器（MDR）、程序寄存器（PC）和指令寄存器（IR），各部件及其之间的连线表示数据通路，箭头表示信息传递方向。</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>![image.png</td>
<td>400](<a target="_blank" rel="noopener" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250603213415467.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250603213415467.png</a>)</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>请写出图中 a、b、c、d 4 个寄存器的名称</strong><br>
a：MDR   b：IR   c：MAR   d：PC</li>
<li><strong>简述图中取指令的数据通路</strong><br>
(PC)→MAR;<br>
M(MAR)→MDR<br>
(MDR)→IR<br>
(PC)+1→PC<br>
OP(IR)→微操作信号发生器</li>
<li><strong>简述数据在运算器和主存之间进行存 / 取访问的数据通路</strong><br>
存/取的数据放到ACC中<br>
设数据地址已放到MAR<br>
取：<br>
M(MAR) → MDR<br>
(MDR) → ALU → ACC<br>
存：<br>
(ACC) → MDR<br>
(MDR) → M(MAR)</li>
<li><strong>简述完成指令 LDA X 的数据通路（X 为主存地址，LDA 的功能为 (X)→ACC）</strong><br>
X → MAR<br>
M(MAR) → MDR<br>
(MDR) → ALU → ACC</li>
<li><strong>简述完成指令 ADD Y 的数据通路（Y 为主存地址，ADD 的功能为 (ACC)+(Y)→ACC）</strong><br>
Y → MAR<br>
M(MAR) → MDR<br>
(MDR) → ALU,(ACC) → ALU<br>
ALU  → ACC【只有寄存器加括号，ALU是算数部件，不是寄存器不加()】<br>
和<br>
Y → MAR<br>
M(MAR) → MDR<br>
(MDR) → ALU<br>
ALU + (ACC) → ACC一样吗</li>
<li><strong>简述完成指令 STA Z 的数据通路（Z 为主存地址，STA 的功能为 (ACC)→Z）</strong><br>
Z → MAR<br>
(ACC) → MDR<br>
(MDR) → M(MAR)</li>
</ol>
<h3 id="数据通路的操作举例">数据通路的操作举例</h3>
<p>以 CPU 内部单总线数据通路为例：<br>
注意：</p>
<ol>
<li>需要注明in，out有效</li>
<li>CU发送读写控制信号不要忘</li>
<li>ALU的in，out必须<strong>同时有效</strong>，而CPU 内部总线同一时刻只能传送一个输入信号，需暂存器中转</li>
</ol>
<h4 id="寄存器之间数据传送">寄存器之间数据传送</h4>
<p><strong>目标</strong>：将程序计数器（PC）的值传送到内存地址寄存器（MAR），用于指定下一次访存的地址。</p>
<ul>
<li>(PC) -&gt; Bus             【PCout 有效，PC 内容送至总线】</li>
<li>Bus -&gt; MAR            【MARin 有效，总线内容送 MAR】</li>
</ul>
<h4 id="主存与-CPU-之间的数据传送">主存与 CPU 之间的数据传送</h4>
<p><strong>目标</strong>：从主存读取指令到指令寄存器（IR）。</p>
<ul>
<li>(PC) -&gt; Bus -&gt; MAR     【PCout 和 MARin 有效，MAR 保存要访问的指令地址（PC 的值）】</li>
<li>1 -&gt; R                            【CU 发Read 信号通过控制总线发送到主存】</li>
<li>M (MAR) -&gt; MDR         【MDRin 有效，<strong>读取指令内容</strong>】</li>
<li>MDR -&gt; Bus -&gt; IR        【MDRout 和 IRin 有效，IR 存储当前待执行的指令（如<code>ADD A, B</code>）】</li>
</ul>
<h4 id="执行算术或逻辑运算">执行算术或逻辑运算</h4>
<p><strong>目标</strong>：执行加法指令<code>ADD A, B</code>，即将寄存器 <code>ACC</code> 的值与内存中变量 <code>B</code> 的值相加，并将结果存回 <code>ACC</code></p>
<ul>
<li>Ad (IR) -&gt; Bus -&gt; MAR                 【MDRout 和 MARin 有效或者AdIRout和MARin有效，IR中的地址码字段（即B的地址）通过总线传输的MAR】</li>
<li>1 -&gt; R                                            【CU 发读命令，指示主存读取 <code>MAR</code> 中指定地址的数据】</li>
<li>M (MAR) -&gt; 数据线 -&gt; MDR         【MDRin 有效，主存将地址指定处的数据通过数据线传输到 <code>MDR</code>】</li>
<li>MDR -&gt; Bus -&gt; Y                          【MDRout 和 Yin 有效，<code>MDR</code> 中的值（<code>5</code>）通过总线传输到暂存寄存器 <code>Y</code>】</li>
<li>(ACC) + (Y) -&gt; Z                            【ACCout 和 ALUin 有效，CU 向 ALU 发送加命令，完成 <code>ACC + B</code> 的运算】</li>
<li>Z -&gt; ACC                                       【Zout 和 ACCin 有效，结果 -&gt; ACC】</li>
</ul>
<p>eg. <code>ADD (R0), R1</code> 基于单总线结构的三个阶段（取指、间址、执行）展开：</p>
<ul>
<li><strong>指令功能</strong>：<code>((R0)) + (R1) → (R0)</code><br>
含义：以寄存器 <code>R0</code> 的内容为<strong>主存地址</strong>，从主存中读取该地址的数据（被加数），与寄存器 <code>R1</code> 的内容（加数）相加，结果写回 <code>R0</code> 指向的主存地址。</li>
<li><strong>指令周期</strong>：包含 <strong>取指周期</strong>（获取指令）、<strong>间址周期</strong>（获取主存中的被加数）、<strong>执行周期</strong>（完成加法并写回结果）。<br>
<strong>取指</strong>：从主存读指令到 IR，PC 指向下一条指令。<br>
<strong>间址</strong>：从主存读被加数到 Y，地址来自 R0。<br>
<strong>执行</strong>：R1+Y→Z，结果写回主存（地址仍为 R0 指向的位置）。</li>
</ul>
<p>阶段 1：<strong>取指周期</strong>（获取指令本身）<br>
<strong>目标</strong>：从主存中读取 <code>ADD (R0), R1</code> 指令，存入指令寄存器（IR）</p>
<table>
<thead>
<tr>
<th>时序</th>
<th>微操作（数据流向）</th>
<th>有效控制信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>(PC) → MAR</code></td>
<td><code>PCout</code>, <code>MARin</code></td>
</tr>
<tr>
<td>2</td>
<td><code>M(MAR) → MDR</code></td>
<td><code>MemR</code>, <code>MARout</code>, <code>MDRinE</code></td>
</tr>
<tr>
<td>3</td>
<td><code>(MDR) → IR</code></td>
<td><code>MDRout</code>, <code>IRin</code></td>
</tr>
<tr>
<td>4</td>
<td>指令译码</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td><code>(PC)+1 → PC</code></td>
<td>-</td>
</tr>
<tr>
<td>阶段 2：间址周期（获取主存中的被加数）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>目标</strong>：以 <code>R0</code> 的内容为地址，从主存中读取<strong>被加数</strong>，存入暂存寄存器 <code>Y</code>。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>时序</th>
<th>微操作（数据流向）</th>
<th>有效控制信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>(R0) → MAR</code></td>
<td><code>R0out</code>, <code>MARin</code></td>
</tr>
<tr>
<td>2</td>
<td><code>M(MAR) → MDR</code></td>
<td><code>MemR</code>, <code>MARout</code>, <code>MDRinE</code></td>
</tr>
<tr>
<td>3</td>
<td><code>(MDR) → Y</code></td>
<td><code>MDRout</code>, <code>Yin</code></td>
</tr>
<tr>
<td>阶段 3：执行周期（完成加法并写回结果）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>目标</strong>：<code>R1</code>（加数）与 <code>Y</code>（被加数）相加，结果写回 <code>R0</code> 指向的主存地址。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>时序</th>
<th>微操作（数据流向）</th>
<th>有效控制信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>(R1) + (Y) → Z</code></td>
<td><code>R1out</code>, <code>ALUin</code>, <code>CU发ADD控制信号</code></td>
</tr>
<tr>
<td>2</td>
<td><code>(Z) → MDR</code></td>
<td><code>Zout</code>, <code>MDRin</code></td>
</tr>
<tr>
<td>3</td>
<td><code>(MDR) → M(MAR)</code></td>
<td><code>MemW</code>, <code>MDRoutE</code>, <code>MARout</code></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>间址周期的作用</strong>：
<ul>
<li><code>ADD (R0), R1</code> 中 <code>(R0)</code> 表示 “以 R0 内容为地址”，因此需要<strong>额外访存</strong>（间址周期）获取主存中的被加数，这是 “间址周期” 存在的原因。</li>
</ul>
</li>
<li><strong>暂存寄存器 <code>Y</code> 的必要性</strong>：
<ul>
<li>单总线结构同一时刻只能传一个数据，因此被加数需先存在 <code>Y</code> 中，等待与 <code>R1</code> 相加。</li>
</ul>
</li>
<li><strong>控制信号的含义</strong>：
<ul>
<li><code>MemR</code>/<code>MemW</code>：主存读 / 写控制；</li>
<li><code>R0out</code>/<code>R1out</code>：寄存器 R0/R1 输出使能；</li>
<li><code>ALUin</code>/<code>Zout</code>：ALU 输入 / 输出使能；</li>
<li>控制信号需<strong>按序激活</strong>，确保数据流向正确。</li>
</ul>
</li>
</ol>
<h2 id="控制器的功能和工作原理">控制器的功能和工作原理</h2>
<h3 id="硬布线控制器">硬布线控制器</h3>
<ul>
<li>根据指令要求、当前时序及内外部状态，按<strong>时间顺序</strong>生成并发送微操作控制信号，协调 CPU 各部件动作。</li>
<li>由<strong>组合逻辑门电路和触发器</strong>构成，又称 “<strong>组合逻辑控制器</strong>”，通过硬件电路直接产生控制信号。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429191754.png" alt="image.png|400"></li>
</ul>
<h4 id="CU-的输入信号来源">CU 的输入信号来源</h4>
<ol>
<li><strong>指令译码信息</strong>：指令经译码器解析后的结果。</li>
<li><strong>时序信号</strong>：时序系统产生的机器周期信号和节拍信号（时钟周期）。</li>
<li><strong>反馈信号</strong>：执行单元（如 ALU）产生的标志位（如进位、零标志）。</li>
</ol>
<p><strong>微操作控制信号</strong>的形成主要与<font color="#c00000">指令译码信号和时钟信号</font>有关</p>
<h4 id="硬布线控制器的时序系统及微操作">硬布线控制器的时序系统及微操作</h4>
<ol>
<li><strong>时钟周期</strong>：最小时序单位，由时钟信号驱动节拍发生器，每个节拍对应一个时钟周期。</li>
<li><strong>机器周期</strong>：指令执行的基准时间，通常包含若干时钟周期。</li>
<li><strong>指令周期</strong>：CPU 取出并执行一条指令的总时间，由多个机器周期组成。</li>
<li><strong>微操作命令分析</strong>：控制单元按指令需求生成操作序列，如 “取指令”“算术运算” 等。</li>
</ol>
<h4 id="CPU-的控制方式">CPU 的控制方式</h4>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>同步控制</strong></td>
<td><strong>统一时钟驱动</strong>，以<strong>最长</strong>微操作序列为基准，所有指令按<strong>固定机器周期</strong>执行。</td>
<td>优点：<strong>控制电路简单</strong>；缺点：<strong>速度慢</strong>。</td>
</tr>
<tr>
<td><strong>异步控制</strong></td>
<td>无统一时钟，各部件按<strong>自身速度</strong>工作，通过<strong>应答</strong>信号协调。</td>
<td>优点：<strong>速度快</strong>；缺点：<strong>控制电路复杂</strong>。</td>
</tr>
<tr>
<td><strong>联合控制</strong></td>
<td><strong>多数</strong>操作<strong>同步</strong>控制，少数复杂操作异步控制，<strong>折中</strong>两者特性。</td>
<td>平衡速度与电路复杂度。</td>
</tr>
</tbody>
</table>
<h5 id="同步控制方式">同步控制方式</h5>
<ul>
<li>系统有一个统一的时钟，所有的控制信号都来源于这个统一的时钟信号</li>
<li>通常以最长的微操作序列和最繁琐的微操作作为标准</li>
<li>采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令</li>
<li><strong>优点：控制电路简单</strong></li>
<li><strong>缺点：运行速度慢</strong></li>
</ul>
<h5 id="异步控制方式">异步控制方式</h5>
<ul>
<li>不存在基准时标信号，各部件按照自身固有速度工作，通过应答方式进行联络</li>
<li><strong>优点：运行速度快</strong></li>
<li><strong>缺点：控制电路较为复杂</strong></li>
</ul>
<h5 id="联合控制方式">联合控制方式</h5>
<ul>
<li>介于同步、异步之间的一种折中</li>
<li>对大部分采用同步控制，小部分采用异步控制</li>
</ul>
<h4 id="设计步骤">设计步骤</h4>
<ol>
<li><strong>分析微操作序列</strong>：<br>
明确在取值、间址、执行、中断这四个阶段中，各类指令在不同时刻会涉及的微操作。<br>
比如<strong>取值</strong>阶段主要是从内存读取指令，<strong>执行</strong>阶段则依据指令类型进行算术运算、逻辑运算等具体操作 。<br>
这一步是为了梳理清楚指令执行过程中各个环节的具体动作，为后续设计奠定基础。</li>
<li><strong>选择 CPU 控制方式</strong>：<br>
需要确定采用<strong>定长</strong>机器周期还是<strong>不定长</strong>机器周期，以及每个机器周期安排<strong>几个节拍</strong>。<br>
若采用同步控制方式（定长机器周期 ），就像设定了一个固定的节奏，每个机器周期内的节拍数量固定，例如这里假设一个机器周期内安排 3 个节拍。这种方式能让整个系统的时序较为规整，但可能无法很好地适应不同复杂程度指令的执行需求；<br>
而不定长机器周期则更灵活，可根据指令实际情况调整机器周期时长。</li>
<li><strong>安排微操作时序</strong>：<br>
思考如何在给定的节拍数量（如 3 个节拍）内，合理分配并完成一个机器周期内的所有微操作。<br>
要考虑微操作的先后顺序、能否并行等因素，确保各操作有条不紊地进行，充分利用每个节拍的时间，实现高效的指令执行流程。</li>
<li><strong>电路设计</strong>：<br>
确定每个微操作命令对应的逻辑表达式，然后通过具体的电路来实现这些逻辑。<br>
这是将前面分析规划的内容转化为实际硬件电路的关键步骤，通过逻辑门电路等硬件组件搭建出能够准确产生和发送微操作控制信号的电路，从而使控制器能够按照设计要求工作。</li>
</ol>
<h4 id="安排微操作时序的原则">安排微操作时序的原则</h4>
<ol>
<li><strong>顺序固定</strong>：微操作先后顺序不可随意更改（如先取指令再译码）。</li>
<li><strong>并行执行</strong>：不同部件的微操作可在<strong>同一节拍</strong>内并行完成（如寄存器读写与 ALU 运算）。</li>
<li><strong>时间优化</strong>：<strong>短时微操作</strong>可在同一节拍内按顺序执行，充分利用时钟周期。</li>
</ol>
<h5 id="安排微操作时序-取指周期">安排微操作时序 - 取指周期</h5>
<ul>
<li><strong>原则</strong>：
<ul>
<li>微操作先后顺序不得随意更改。</li>
<li>被控对象不同的微操作，尽量安排在一个节拍内完成。</li>
<li>占用时间较短的微操作，尽量安排在一个节拍内完成，并允许有先后顺序。</li>
</ul>
</li>
<li><strong>微操作</strong>：
<ul>
<li>T0：(1)PC → MAR ；(2)1 → R （存储器空闲即可）</li>
<li>T1：(3)M (MAR) → MDR （在 (1) 之后）；(6)(PC) + 1 → PC （在 (1) 之后）</li>
<li>T2：(4)MDR → IR （在 (3) 之后）；(5)OP (IR) → ID （在 (4) 之后）</li>
</ul>
</li>
<li><strong>说明</strong>：M (MAR) → MDR 从主存存取数据，用时较长，需一个时钟周期保证完成；MDR → IR 是 CPU 内部寄存器数据传送，速度快，可在一个时钟周期内紧接着完成OP (IR) → ID ，即可一次同时发出两个微命令。</li>
</ul>
<h5 id="安排微操作时序-间址周期">安排微操作时序 - 间址周期</h5>
<ul>
<li><strong>原则</strong>：同取指周期原则（微操作先后顺序不得随意更改；被控对象不同的微操作尽量安排在一个节拍内完成；占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序 ）</li>
<li><strong>微操作</strong>：
<ul>
<li>T0：(1)Ad(IR) → MAR ；(2)1 → R</li>
<li>T1：(3)M (MAR) → MDR</li>
<li>T2：(4)MDR → Ad(IR)</li>
</ul>
</li>
</ul>
<h5 id="安排微操作时序-执行周期">安排微操作时序 - 执行周期</h5>
<ul>
<li><strong>非访存指令</strong>：
<ul>
<li><strong>CLA（clear，ACC 清零 ）</strong>：T0、T1、T2：0 → AC</li>
<li><strong>COM（complement，ACC 取反 ）</strong>：T0、T1、T2：$\overline{AC}$ → AC</li>
<li><strong>SHR（shift，算术右移 ）</strong>：T0、T1、T2：L (AC) → R (AC) ，AC₀ → AC₀</li>
<li><strong>CSL（cyclic shift，循环左移 ）</strong>：T0、T1、T2：R (AC) → L (AC) ，AC₀ → ACₙ</li>
<li><strong>STP（stop，停机 ）</strong>：T0、T1、T2：0 → G</li>
</ul>
</li>
<li><strong>访存指令</strong>：
<ul>
<li><strong>ADD X（加法指令，隐含 ACC ）</strong>：T0：Ad (IR) → MAR ，1 → R ；T1：M (MAR) → MDR ；T2：(AC) + (MDR) → AC</li>
<li><strong>STA X（存数指令，隐含 ACC ）</strong>：T0：Ad (IR) → MAR ，1 → W ；T1：AC → MDR ；T2：MDR → M (MAR)</li>
<li><strong>LDA X（取数指令，隐含 ACC ）</strong>：T0：Ad (IR) → MAR ，1 → R ；T1：M (MAR) → MDR ；T2：MDR → AC</li>
</ul>
</li>
<li><strong>转移指令</strong>：
<ul>
<li><strong>JMP X（无条件转移 ）</strong>：T0、T1、T2：Ad (IR) → PC</li>
<li><strong>BAN X（Branch ACC Negative，条件转移 ）</strong>：T0、T1、T2：$A_0\cdot Ad (IR)+\overline{A_0}\cdot(PC) → PC$</li>
</ul>
</li>
</ul>
<h3 id="微程序控制器">微程序控制器</h3>
<ol>
<li><strong>存储逻辑实现</strong>：将微操作信号编码为 “微指令”，每条机器指令对应一段微程序（每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令），存储在控制存储器（也叫微程序存储器，存放微程序）中。<br>
采用存储逻辑实现，即把<strong>微操作信号代码化</strong></li>
<li>微程序控制器属于控制器类别，属于CPU的一部分</li>
<li><strong>指令执行流程</strong>：<br>
机器指令 → 微程序（控制存储器）→ 微指令 → 微操作命令（控制 CPU 部件）。
<ul>
<li><strong>机器指令</strong>（如 “加法运算”）是 “做番茄炒蛋” 的高级菜谱；</li>
<li><strong>微程序</strong>是将高级菜谱拆解为 “打蛋→切番茄→倒油→下锅” 等具体步骤；</li>
<li><strong>微指令</strong>是每个步骤的详细操作（如 “打蛋” 对应 “拿起鸡蛋→敲开→倒入碗中”）；</li>
<li><strong>微操作</strong>是最基础的动作（如 “敲开鸡蛋” 是不可再分的硬件操作）。</li>
</ul>
</li>
</ol>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>微操作</strong>：执行部件收到微命令后所进行的操作【CPU 中<strong>最基础的动作</strong>，如 “将数据从寄存器 A 传至寄存器 B”“算术逻辑单元（ALU）执行加法”，<strong>不可再分解</strong>】</li>
<li><strong>微命令</strong>：控制硬件执行微操作的 “指令”，是<strong>控制信号的最小单位</strong>。例如，“寄存器 A 输出使能” 就是一个微命令【需要发出什么控制信号】
<ul>
<li><strong>相容性</strong>微命令：可同时生效，如 “ALU 执行加法” 和 “结果存入寄存器” 可同时触发</li>
<li><strong>互斥性</strong>微命令：不能同时出现，如 “存储器读” 和 “存储器写” 必须互斥。</li>
</ul>
</li>
</ul>
<p>硬布线控制器中也有微命令和微操作的概念</p>
<ul>
<li><strong>微指令</strong>：<strong>一条微指令包含一组微命令</strong>，用于完成一步完整的硬件操作<br>
例如，“从内存取指令” 的微指令可能包含 “PC 寄存器输出地址”“存储器读使能”“指令存入 IR 寄存器” 等微命令。
<ul>
<li><strong>操作控制字段</strong>【微操作码字段】：编码具体的微命令（如 “加法”“读内存”）</li>
<li><strong>顺序控制字段</strong>【微地址码字段】：指定下一条微指令的地址（类似 “程序计数器”，控制执行流程）</li>
</ul>
</li>
<li><strong>微周期</strong>：读取并执行一条微指令的时间（1 个时钟周期）</li>
<li><strong>微地址</strong>：存放微指令的控制存储器的单元地址</li>
<li><strong>主存</strong>：用于存放程序和数据，在 CPU 外部，用 <strong>RAM</strong> 实现</li>
<li><strong>控制存储器【CM】</strong>： 核心部件，用于存放微程序，在 CPU 内部，用 <strong>ROM</strong> 存储微程序</li>
<li><strong>程序</strong>：是指令的有序集合，用于完成特定的功能</li>
<li><strong>微程序</strong>：<br>
是微指令的有序集合，一条指令的功能由一段微程序实现
<ul>
<li>一条机器指令（如加法指令 “ADD A,B”）需要分解为多个微操作步骤，每个步骤对应一条微指令，这些微指令按顺序组成 “微程序”。例如：
<ol>
<li>取指令 → 2. 解析操作码 → 3. 从内存取操作数 A → 4. 从内存取操作数 B → 5. ALU 执行加法 → 6. 存储结果。</li>
</ol>
</li>
<li>像程序一样存进控制存储器（CM），通过 “读取微指令→执行微操作” 的方式控制 CPU 动作，属于 “存储逻辑控制”（而非硬布线的 “硬件直接连线控制”）。</li>
</ul>
</li>
<li>一般来说，一条机器指令对应一个微程序</li>
</ul>
<p>关系：</p>
<ol>
<li><strong>一条机器指令</strong> 对应 <strong>一个微程序</strong></li>
<li><strong>一个微程序</strong> 对应 <strong>若干条微指令</strong></li>
<li><strong>一个微指令</strong> 会产生 <strong>若干条微命令</strong></li>
<li><strong>一个微命令</strong> 对应 <strong>一个微操作</strong></li>
</ol>
<h4 id="寄存器分类">寄存器分类</h4>
<ul>
<li><strong>地址寄存器</strong>【MAR】：存放主存的读 / 写地址</li>
<li><strong>微指令地址寄存器</strong>【uPC 或 CMAR】：存放待执行的微指令在控制存储器中的微地址</li>
<li><strong>指令寄存器</strong>【IR】：存放从主存中读出的指令</li>
<li><strong>微指令寄存器</strong>【uIR 或 CMDR】：存放从控制存储器中读出的微指令</li>
</ul>
<h4 id="基本组成">基本组成</h4>
<table>
<thead>
<tr>
<th>部件名称</th>
<th>功能通俗解释</th>
<th>类比举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>指令寄存器（IR）</strong></td>
<td>存放从主存取出的机器指令（如 “加法指令”）。</td>
<td></td>
</tr>
<tr>
<td><strong>微地址形成部件</strong></td>
<td>根据机器指令生成对应微程序的 “菜谱索引”（入口地址），如 “加法指令” 对应 “加法菜谱” 的第一页。</td>
<td>菜谱的 “目录索引”，根据菜名找对应步骤。</td>
</tr>
<tr>
<td><strong>微地址寄存器/微指令计数器（uPC或CMAR）</strong></td>
<td>记录下一条微指令的 “菜谱页码”（地址）。</td>
<td><strong>“下一条去哪”</strong>（预存，执行当前时准备好）</td>
</tr>
<tr>
<td><strong>控制存储器（CM）</strong></td>
<td>存放所有微程序的 “硬盘”，用 ROM 实现（内容固化）。</td>
<td>厨房里的 “菜谱大全”，存所有菜的做法。</td>
</tr>
<tr>
<td><strong>微指令寄存器（uIR或CMDR）</strong></td>
<td>临时存放当前微指令，拆解出 “要做什么”（操作控制字段）和 “下一步去哪”（顺序控制字段）。</td>
<td><strong>“当前干啥 + 下一条去哪”</strong>（显式写在当前微指令里，让 CMAR 直接用）</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>控制存储器（CM）</strong>：核心部件，存所有机器指令对应的微程序，控制存储器可用 ROM 构成</li>
<li><strong>微指令寄存器</strong>：存放从 CM 中取出的微指令，位数与微指令字长相等</li>
<li><strong>微地址形成部件</strong>【起始和转移地址形成部件】：根据<font color="#c00000">机器指令操作码</font>生成微程序入口地址，或根据执行结果（如标志位）决定微指令跳转逻辑。</li>
<li><strong>微地址寄存器（uIR）</strong>：暂存当前微指令，拆分出操作控制信号和下一条微地址<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250618182546692.png" alt="image.png"></li>
</ul>
<h4 id="工作过程">工作过程</h4>
<p>通过 “<strong>取微指令→解析→执行→循环</strong>” 的流程，将<strong>机器指令</strong>拆解为<strong>微操作序列</strong><br>
1. <strong>取指微程序的公共操作</strong></p>
<ul>
<li><strong>初始启动</strong>：机器通电后，自动将 “取指微程序” 的入口地址（通常为控制存储器 CM 的 0 号单元）送入微地址寄存器（CMAR），从 CM 中读取首条微指令到微指令寄存器（CMDR）。</li>
<li><strong>核心任务</strong>：执行取指微程序，从主存中取出机器指令，存入指令寄存器（IR）。</li>
<li><strong>类比</strong>：相当于计算机的 “开机引导程序”，先准备好要执行的指令。</li>
</ul>
<p>2. <strong>生成目标微程序入口地址</strong></p>
<ul>
<li><strong>关键动作</strong>：根据 IR 中机器指令的操作码字段，通过微地址形成部件生成对应微程序的入口地址，送入 CMAR。</li>
<li><strong>逻辑示例</strong>：若机器指令是 “加法指令”，操作码经硬件逻辑转换为 “加法微程序” 在 CM 中的起始地址。</li>
</ul>
<p>3. <strong>逐条执行微指令</strong></p>
<ul>
<li><strong>执行流程</strong>：从 CM 中按地址依次读取微指令，解析操作控制字段的微命令，驱动 CPU 部件（如 ALU、寄存器）执行对应操作。</li>
<li><strong>示例</strong>：加法微程序可能包含 “取操作数 A”“取操作数 B”“ALU 加法”“存结果” 等微指令，每条微指令控制一个或多个微操作并行执行。</li>
</ul>
<p>4. <strong>循环回到取指阶段</strong></p>
<ul>
<li><strong>结束与重启</strong>：当一条机器指令的微程序执行完毕后，自动回到取指微程序的入口地址（CM 的 0 号单元），重复步骤 1，等待下一条机器指令。</li>
<li><strong>循环逻辑</strong>：形成 “取指→译码→执行→再取指” 的闭环，保证计算机持续工作。</li>
</ul>
<h4 id="微程序控制器的工作原理">微程序控制器的工作原理</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250618212654581.png" alt="image.png"></p>
<ul>
<li>
<p><strong>取指周期微程序</strong>：是公用的，不管执行什么机器指令，都要先经过取指周期。若指令系统有 n 条机器指令 ，加上公用的取指周期微程序，从微程序段角度看，CM 中微程序段个数至少是 n + 1 个 。也可以从逻辑角度，把取指周期和执行周期等看作一条指令对应的整体微程序 ，微程序的个数只有 n 个（即n 条机器指令对应 n 个微程序）</p>
</li>
<li>
<p><strong>间址周期微程序</strong>：用于处理间接寻址相关操作，早期一些 CPU 可不提供，就无此微程序段。</p>
</li>
<li>
<p><strong>中断周期微程序</strong>：处理中断事务，部分 CPU 可不包含。</p>
</li>
<li>
<p><strong>执行周期微程序</strong>：不同机器指令（如 LDA、STA 指令 ）有各自对应的执行周期微程序，完成指令具体功能。</p>
</li>
<li>
<p>物理上，取指周期、执行周期等微程序段看似分开，但逻辑上一条指令对应一个完整微程序 。</p>
</li>
</ul>
<h4 id="微指令的编码方式【控制方式】">微指令的编码方式【控制方式】</h4>
<p><strong>目的</strong>：用<strong>最短的指令字长</strong>表示最多的微命令，同时<strong>减少译码延迟</strong></p>
<h5 id="直接编码方式">直接编码方式</h5>
<ul>
<li><strong>核心逻辑</strong>：微指令的每一位直接对应一个微命令，<strong>无需译码器</strong>，1 表示激活，0 表示不激活。</li>
<li><strong>示例</strong>：若有 100 个微命令（如 “存储器读”“ALU 加法” 等），则微指令的操作控制字段需 100 位，每位独立控制一个硬件动作。
<ul>
<li>第 1 位 = 1 → 激活 “存储器读”；</li>
<li>第 2 位 = 1 → 激活 “ALU 加法”。</li>
</ul>
</li>
<li><strong>优缺点</strong>：
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>并行</strong>性极强：所有微命令可同时激活（如同时执行 “读存储器” 和 “ALU 运算”）。</li>
<li>执行速度快：无需译码时间，直接按位控制硬件。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>指令字长极长：100 个微命令需 100 位字段，控制存储器（CM）容量需求大幅增加（如 CM 存储单元字长必须为 100 位）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429202112.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="字段直接编码方式">字段直接编码方式</h5>
<ul>
<li><strong>核心逻辑</strong>：将<strong>互斥</strong>微命令分组到<strong>同一字段</strong>，每组通过译码器生成控制信号（n 位字段最多表示 2ⁿ-1 个互斥命令）。<br>
类似 “分组开关”，同一组内的开关（微命令）不能同时按下（互斥），不同组可并行操作。</li>
<li><strong>分段原则</strong>：
<ol>
<li><strong>互斥性微命令同段，相容性微命令不同段</strong>（如 “读” 与 “写” 互斥，同段；“取指令” 与 “送地址” 相容，不同段）。</li>
<li><strong>每段信息位不宜过多</strong>（减少译码电路复杂度和时间）。</li>
<li><strong>每段留一个 “不操作” 状态</strong>（如 3 位段可表示<code>7</code>个互斥命令 +<code>000</code>不操作，共<code>8</code>种状态，需 3 位）。</li>
</ol>
</li>
<li><strong>优缺点</strong>：
<ul>
<li><strong>优点</strong>：
<ul>
<li>指令字长显著缩短，减少 CM 容量需求。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>需等待译码器工作，引入延迟（如字段分组后需先译码再执行）；</li>
<li>同一字段内微命令无法并行（如 “存储器读” 和 “存储器写” 不能同时激活）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429202435.png" alt="image.png"><br>
eg. <strong>某计算机控制器采用微程序控制，操作控制字段用字段直接编码法，共 33 个微命令，构成 5 个互斥类，分别含 7、3、12、5、6 个微命令。求操作控制字段至少多少位？</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><strong>每互斥类需表示的状态数</strong>：
<ul>
<li>第 1 类（7 个命令）：需<code>7+1=8</code>种状态（含不操作）→ 3 位（<code>2³=8</code>）。</li>
<li>第 2 类（3 个命令）：需<code>3+1=4</code>种状态 → 2 位（<code>2²=4</code>）。</li>
<li>第 3 类（12 个命令）：需<code>12+1=13</code>种状态 → 4 位（<code>2⁴=16≥13</code>）。</li>
<li>第 4 类（5 个命令）：需<code>5+1=6</code>种状态 → 3 位（<code>2³=8≥6</code>）。</li>
<li>第 5 类（6 个命令）：需<code>6+1=7</code>种状态 → 3 位（<code>2³=8≥7</code>）。</li>
</ul>
</li>
<li><strong>总位数</strong>：<code>3+2+4+3+3=15</code>位。</li>
</ol>
<p><strong>对比</strong>：直接编码需 33 位（每位对应一个命令），字段直接编码大幅压缩字长（15 位 vs 33 位）。</p>
<h5 id="字段间接编码方式">字段间接编码方式</h5>
<ul>
<li>
<p><strong>核心逻辑</strong>：一个字段的微命令需依赖另一字段的编码才能生效，类似 “二级密码”，需两个条件同时满足才能执行操作。例如：</p>
<ul>
<li>字段 A 编码为 “寄存器操作”，字段 B 编码为 “寄存器 A”；</li>
<li>仅当字段 A 和字段 B 同时生效，才能确定 “对寄存器 A 执行操作”。</li>
</ul>
</li>
<li>
<p><strong>优缺点</strong>：</p>
<ul>
<li><strong>优点</strong>：进一步压缩字长（如通过字段组合减少总位数）。</li>
<li><strong>缺点</strong>：微命令需分步解析，<strong>并行性</strong>大幅下降（必须等前一字段译码完成才能处理后一字段）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429202952.png" alt=""><br>
示例：</li>
<li>字段 X（2 位）：表示 “操作类型”（00 = 无操作，01 = 寄存器操作，10 = 存储器操作）；</li>
<li>字段 Y（2 位）：仅当字段 X=01 时，字段 Y 表示 “寄存器编号”（00 = 寄存器 A，01 = 寄存器 B）。<br>
通过字段组合，用 4 位表示原本需要更多位的命令。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码方式</strong></th>
<th><strong>字长</strong></th>
<th><strong>执行速度</strong></th>
<th><strong>并行性</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>直接</strong>编码</td>
<td>最长</td>
<td>最快</td>
<td>最高（全并行）</td>
<td>对<strong>速度</strong>要求极高的简单控制</td>
</tr>
<tr>
<td><strong>字段直</strong>接编码</td>
<td>中等</td>
<td>中等（需译码）</td>
<td>中等（字段内互斥）</td>
<td><strong>通用微程序控制器</strong></td>
</tr>
<tr>
<td><strong>字段间</strong>接编码</td>
<td>最短</td>
<td>最慢</td>
<td>最低</td>
<td>对<strong>存储容量</strong>敏感的场景</td>
</tr>
</tbody>
</table>
<h4 id="微指令的格式">微指令的格式</h4>
<p>微指令格式决定了控制器的 “控制粒度” 和 “执行效率”</p>
<table>
<thead>
<tr>
<th>水平型</th>
<th>垂直型</th>
</tr>
</thead>
<tbody>
<tr>
<td>并行操作能力强、效率高、灵活性强</td>
<td>相反</td>
</tr>
<tr>
<td>执行一条指令的时间短</td>
<td>相反</td>
</tr>
<tr>
<td>微指令字较长但微程序短</td>
<td>相反</td>
</tr>
<tr>
<td>用户难以掌握</td>
<td>与指令相似，相对容易掌握</td>
</tr>
</tbody>
</table>
<h5 id="水平型微指令">水平型微指令</h5>
<ul>
<li><strong>核心特性</strong>：<strong>一条指令可定义多个并行微操作</strong>，直接控制硬件部件同时工作。
<ul>
<li>例：同时执行 “从寄存器 A 取数”“ALU 加法”“结果存入寄存器 B” 三个操作。</li>
</ul>
</li>
<li><strong>编码方式</strong>：<strong>直接编码、字段直接编码、字段间接编码均属于水平型。</strong></li>
<li><strong>优缺点</strong>：
<ul>
<li><strong>优点</strong>：
<ul>
<li>并行性强，一条微指令完成多个操作，<strong>执行速度快</strong>。</li>
<li><strong>微程序短</strong>（因单条指令功能强），节省控制存储器空间。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>指令字长较长</strong>（需包含所有并行操作的编码）。</li>
<li><strong>编写难度高</strong>，需精确协调多个微操作的并行逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用场景</strong>：对<strong>执行速度要求极高</strong>的场景，如高性能处理器的核心控制。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429203656.png" alt="image.png"></li>
</ul>
<h5 id="垂直型微指令">垂直型微指令</h5>
<ul>
<li><strong>核心特性</strong>：<strong>一条指令仅能定义一个微命令</strong>，类似机器指令的 “顺序执行” 模式
<ul>
<li>例：先执行 “从寄存器 A 取数”，再执行 “ALU 加法”，需两条微指令。</li>
</ul>
</li>
<li><strong>指令结构</strong>：<strong>通过微操作码字段指定功能</strong>，类似机器指令的 “操作码 + 操作数” 格式。
<ul>
<li>例：完成 “取数 + 加法” 需两条微指令：<br>
① 操作码=取数，操作数=寄存器A<br>
② 操作码=加法，操作数=寄存器B</li>
</ul>
</li>
<li><strong>优缺点</strong>：
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>指令字长短</strong>，格式规整，编写和调试简单。</li>
<li>对设计者要求低，适合初学者或简单控制逻辑。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>微程序长</strong>（需多条指令完成复杂操作），<strong>执行速度慢</strong>。</li>
<li><strong>工作效率低</strong>，无法利用硬件并行性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用场景</strong>：早期微型计算机、控制逻辑简单的嵌入式系统。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429203930.png" alt="image.png"></li>
</ul>
<h5 id="混合型微指令">混合型微指令</h5>
<ul>
<li><strong>核心特性</strong>：在垂直型指令格式中嵌入少量并行操作字段，实现 “关键操作并行 + 简单操作顺序” 的混合控制</li>
<li><strong>优势</strong>：
<ul>
<li><strong>指令字长较短</strong>，保持编写便利性。</li>
<li><strong>微程序长度适中</strong>，执行速度比纯垂直型快。</li>
</ul>
</li>
<li><strong>应用场景</strong>：通用计算机控制器，兼顾开发效率与性能</li>
</ul>
<h4 id="微指令的地址形成方式">微指令的地址形成方式</h4>
<p>微指令地址决定了微程序的执行顺序，常见方式如下：<br>
1. <strong>下地址字段直接指定（断定方式）</strong></p>
<ul>
<li><strong>原理</strong>：微指令含 “下地址” 字段，执行后直接加载到微地址寄存器（CMAR），又称为<strong>断定方式</strong>。例如，微指令格式为<code>[操作控制][下地址]</code>，<code>下地址</code>直接赋值给 CMAR。<br>
通过微指令中指定一个专门字段来控制产生后继微指令地址</li>
<li><strong>应用</strong>：条件分支（如<code>if ZF=1 → 地址A，else → 地址B</code>）、复杂跳转（中断处理入口）。</li>
<li><strong>优点</strong>：跳转灵活，支持任意地址；<strong>缺点</strong>：微指令字长增加（需地址字段）。</li>
</ul>
<p>2. <strong>操作码映射生成</strong></p>
<ul>
<li>机器指令存入 IR 后，操作码经 “微地址形成部件” 转换为对应微程序的入口地址。
<ul>
<li><strong>示例</strong>：加法指令操作码 “001” 对应微程序入口地址 “1000”，减法操作码 “010” 对应 “2000”。</li>
<li><strong>特点</strong>：实现 “机器指令→微程序” 的映射，是微程序控制器的核心机制。</li>
</ul>
</li>
<li><strong>应用</strong>：指令解码（每条机器指令对应唯一微程序入口）、指令集扩展（新增指令只需更新映射）。</li>
<li><strong>优点</strong>：模块化，解耦机器指令与微程序；<strong>缺点</strong>：依赖固定映射，灵活性有限。</li>
</ul>
<p>3. <strong>增量计数器法（顺序执行）</strong></p>
<ul>
<li><strong>原理</strong>：CMAR 类似 PC，执行一条微指令后自动加 1（<code>CMAR += 1</code>）。如地址<code>1000</code>→<code>1001</code>→<code>1010</code>，无需地址字段。</li>
<li><strong>应用</strong>：顺序执行微程序（如取指流程：取指令→译码→执行，线性无分支）。</li>
<li><strong>优点</strong>：节省字长（无地址字段），执行速度快（仅加法逻辑）；<strong>缺点</strong>：仅支持顺序，分支需结合其他方式。</li>
</ul>
<p>4. <strong>分支转移（条件跳转）</strong></p>
<ul>
<li><strong>原理</strong>：根据标志位（CF/ZF/SF）或硬件状态（中断请求）选择微地址。例如，<code>if CF=1 → 地址X，else → 地址Y</code>，通过多路选择器实现。</li>
<li><strong>应用</strong>：算术逻辑分支（如比较指令根据结果跳转）、异常处理（除法溢出跳转到错误处理）。</li>
<li><strong>优点</strong>：支持复杂逻辑（循环、分支）；<strong>缺点</strong>：硬件复杂度增加（标志检测电路）。</li>
</ul>
<p>5. <strong>测试网络直接生成</strong></p>
<ul>
<li><strong>原理</strong>：专用硬件网络（组合逻辑）直接输出微地址，无需计算。例如，中断发生时，测试网络立即生成<code>8000</code>（中断处理入口）。</li>
<li><strong>应用</strong>：紧急事件（中断、缺页），需纳秒级响应。</li>
<li><strong>优点</strong>：响应极快；<strong>缺点</strong>：硬件专用性强，扩展性差。</li>
</ul>
<p>6. <strong>由硬件产生微程序入口地址</strong></p>
<ul>
<li><strong>第一条微程序指令地址</strong> 由 <strong>专门硬件</strong> 产生（用专门的硬件记录取值周期微程序首地址）</li>
<li><strong>中断周期</strong>由<strong>硬件</strong>产生<strong>中断周期微程序首地址</strong>（用专门的硬件记录）</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>字长</th>
<th>灵活性</th>
<th>速度</th>
<th>典型场景</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>下地址直接指定（<strong>断定方式</strong>）</td>
<td>高</td>
<td>高</td>
<td>中</td>
<td>条件分支、复杂跳转</td>
<td>每步贴指示牌</td>
</tr>
<tr>
<td>操作码映射</td>
<td>低</td>
<td>中</td>
<td>中</td>
<td>指令解码、指令集扩展</td>
<td>不同任务走不同入口</td>
</tr>
<tr>
<td><strong>增量计数器</strong></td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>顺序执行（如取指）</td>
<td>排队</td>
</tr>
<tr>
<td>分支转移</td>
<td>中</td>
<td>高</td>
<td>中</td>
<td>算术分支、异常处理</td>
<td>岔路口选路</td>
</tr>
<tr>
<td>测试网络直接生成</td>
<td>低</td>
<td>低</td>
<td>极高</td>
<td>中断、硬件异常处理</td>
<td>绿色通道</td>
</tr>
<tr>
<td>eg. <strong>某计算机采用微程序控制器，32 条指令，取指微程序（公共部分） 2 条，每条指令执行微程序 4 条，断定方式下求微指令总数及下地址字段位数。</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>微指令总数</strong>：<br>
取指微程序（2 条） + 32 条指令 ×4 条 / 指令 = <strong>130 条</strong>。</li>
<li><strong>下地址字段位数</strong>：<br>
130 条需唯一地址，<code>2⁷=128 &lt; 130</code>，<code>2⁸=256 ≥ 130</code>，故<strong>8 位</strong>。</li>
</ol>
<h4 id="微程序控制单元的设计">微程序控制单元的设计</h4>
<p>从指令拆解到微码生成的全流程：<br>
<strong>核心目标</strong>：将机器指令（如加法、跳转）分解为最基本的硬件操作步骤，形成有序的微操作序列。<br>
拆动作→排时间→设计格式→写代码<br>
1. <strong>分析微操作序列</strong>（如取指、执行的原子动作</p>
<ul>
<li><strong>目标</strong>：将指令执行过程（取指、译码、执行等）分解为最小硬件操作（微操作），明确各阶段的操作顺序。</li>
<li><strong>示例</strong>：取指阶段包含<code>PC→MAR</code>、<code>1→R</code>、<code>MDR→IR</code>等微操作，执行阶段根据指令类型（如加法、跳转）有不同操作。</li>
</ul>
<p>2. <strong>微操作与节拍安排</strong>（分配节拍，加入控制流微操作）</p>
<ul>
<li><strong>2.1 机器指令微操作</strong>：<br>
参照硬布线控制器，为每个机器周期（如取指、执行）分配微操作，确保时序正确（如取指周期分 3 个节拍，每个节拍执行 1-2 个微操作）。</li>
<li><strong>2.2 微程序特有微操作</strong>：
<ul>
<li><strong>取指周期</strong>：<br>
每条微指令结束之后都需要进行：
<ul>
<li><code>Ad(CMDR)→CMAR</code>：微指令地址字段送微地址寄存器（CMAR），控制下条微指令读取。</li>
<li><code>OP(IR)→CMAR</code>：取出指令后，根据指令类型（如 “加法”）直接跳到对应微程序的开头生成微程序入口地址<br>
机器指令操作码映射微程序入口<br>
机器指令取指阶段固定、自动<br>
微程序取指阶段内部流程固定（如顺序 / 跳转逻辑），但入口依赖机器指令、自动</li>
</ul>
</li>
<li><strong>执行周期</strong>：<br>
取指完成后，按指令类型（如加法）的微程序执行
<ul>
<li><code>Ad(CMDR)→CMAR</code>：按当前微指令地址字段跳转（支持条件分支或顺序执行）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3. <strong>确定微指令格式</strong>（操作控制 + 地址字段，计算位数）</p>
<ul>
<li><strong>3.1 操作控制字段</strong>：<br>
根据微操作数量选择编码方式（直接 / 字段编码），计算位数。例如，20 个互斥微命令用字段编码，分 3 组（7+7+6），每组 3 位，共 9 位。</li>
<li><strong>3.2 顺序控制字段</strong>：<br>
由控制存储器（CM）容量决定（如 256 单元需 8 位地址）。</li>
<li><strong>3.3 微指令字长</strong>：<br>
字长 = 操作控制字段位数 + 顺序控制字段位数（如 9+8=17 位）。</li>
</ul>
<p>4. <strong>编写微指令码点</strong>（将操作和地址编码存入 CM）</p>
<ul>
<li><strong>编码规则</strong>：操作控制字段<code>1</code>表示激活微操作，<code>0</code>表示不激活；顺序控制字段填入下条微指令地址（二进制）。</li>
<li><strong>示例</strong>：激活 “ALU 加法”（位 3）和 “存结果”（位 5），下地址 15（<code>00001111</code>），码点为<code>...1010... 00001111</code>。</li>
</ul>
<h4 id="微程序设计分类">微程序设计分类</h4>
<ul>
<li>
<p><strong>静态</strong>：微程序固化在 <strong>ROM</strong> 中，不可修改，适用于指令集稳定的场景（如传统 CPU）。</p>
<ul>
<li><strong>优势</strong>：可靠性高，成本低。</li>
</ul>
</li>
<li>
<p><strong>动态</strong>：微程序存于 <strong>EPROM</strong>，可动态修改，支持指令集扩展或仿真（如虚拟机模拟不同 CPU 指令集）。</p>
<ul>
<li><strong>应用</strong>：高端处理器的微码更新（如修复硬件漏洞）。</li>
</ul>
</li>
<li>
<p><strong>毫微程序设计（分层控制）</strong></p>
<ol>
<li><strong>微程序 vs 毫微程序</strong>：
<ul>
<li>微程序：用微指令 “翻译” 机器指令（如机器指令 “加法”→ 分解为取数、运算、存结果等微操作）。</li>
<li>毫微程序：用更底层的 “毫微指令” 翻译微指令，形成 “两层控制结构”，类似 “翻译的翻译”。</li>
</ul>
</li>
<li><strong>类比理解</strong>：
<ul>
<li>机器指令（如 “做蛋炒饭”）→ 微程序（分解为 “打蛋→炒饭→加盐”3 步微操作）→ 毫微程序（每步再细分：“打蛋”→“取鸡蛋→敲开→搅匀”3 条毫微指令）。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>优势</strong>：
<ul>
<li><strong>简化设计</strong>：上层微程序专注逻辑分解，下层毫微程序专注硬件控制，分工明确，类似 “项目经理（微程序）+ 执行团队（毫微程序）”。</li>
<li><strong>提高效率</strong>：毫微指令可并行执行（如 “取鸡蛋” 和 “拿锅” 同时做），提升硬件利用率，类似 “流水线分工”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：
<ul>
<li>复杂 CISC 架构处理器（如 x86），通过分层控制简化微程序复杂度，同时优化执行速度。</li>
</ul>
</li>
<li>毫微指令与微指令的关系好比微指令与机器指令的关系</li>
</ul>
</li>
</ul>
<h3 id="硬布线-VS-微程序">硬布线 VS 微程序</h3>
<table>
<thead>
<tr>
<th></th>
<th>微程序控制器</th>
<th>硬布线控制器</th>
</tr>
</thead>
<tbody>
<tr>
<td>工作原理</td>
<td>把硬件控制步骤（微操作）写成 “微程序” 存到控制存储器（CM），执行时像 “查字典” 读取微指令，解析后控制硬件。</td>
<td>用门电路（与非门、触发器等）搭建成组合逻辑电路，根据指令码、状态信号直接生成控制信号，像 “按开关直接通电”。</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>规整性</td>
<td>较规整</td>
<td>烦琐、不规整</td>
</tr>
<tr>
<td>应用场合</td>
<td>CISC CPU</td>
<td>RISC CPU</td>
</tr>
<tr>
<td>易扩充性</td>
<td>易扩充修改</td>
<td>困难</td>
</tr>
</tbody>
</table>
<h2 id="异常和中断机制">异常和中断机制</h2>
<p>异常和中断在本质上均为计算机系统中处理意外事件的机制，但二者存在显著差异，核心区别体现在<strong>触发场景</strong>和<strong>检测方式</strong>上：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>异常（内中断）</th>
<th>中断（外中断）</th>
</tr>
</thead>
<tbody>
<tr>
<td>触发关联</td>
<td>与<strong>特定指令的执行过程直接相关</strong>（同步事件），如 “缺页” 是指令访问内存时触发</td>
<td><font color="#c00000">与任何指令均无关联</font>（异步事件），不影响指令完成</td>
</tr>
<tr>
<td>检测方式</td>
<td>由<strong>CPU 内部自行检测</strong>，<strong>无需外部信号</strong></td>
<td>需通过<strong>中断请求线</strong>接收外部设备的信号，获取中断源信息</td>
</tr>
</tbody>
</table>
<h3 id="异常（内中断）">异常（内中断）</h3>
<p>异常是由<strong>CPU 内部产生的意外事件</strong>，属于与当前执行指令相关的<strong>同步事件</strong>（即事件的发生与指令执行同步）。其核心特性包括：</p>
<ul>
<li>触发时机：CPU 执行某条指令时，在内部检测到（与该指令直接相关）；</li>
<li>检测机制：每个指令周期末尾，CPU 会先检查是否有外中断信号，再处理内部异常；</li>
<li>本质：是 CPU 内部因硬件或软件问题引发的 “意外”，需特殊处理以保证系统正常运行。</li>
</ul>
<h4 id="分类">分类</h4>
<p>根据异常的触发源头，可分为<strong>硬故障中断</strong>和<strong>程序性异常（软件中断）</strong>：</p>
<ul>
<li><strong>硬故障中断</strong>：由计算机硬件（硬连线）出现异常引发的事件，与硬件物理状态直接相关
<ul>
<li>存储器校验错（内存数据读写时校验位不匹配）、总线错误（数据在总线传输中出错）等；</li>
<li>包括<strong>终止异常</strong>和<strong>外中断</strong>（注意：外中断本质是中断，此处因硬件关联被硬故障中断包含）。</li>
</ul>
</li>
<li><strong>程序性异常</strong>【<strong>软件中断</strong>】：CPU 在执行指令过程中，因软件逻辑或指令本身的问题引发的异常，是 “软件层面” 的意外；
<ul>
<li>整除 0（运算逻辑错误）、溢出（计算结果超出数据类型范围）、断点（调试时的预设停止点）、单步跟踪（调试时逐行执行）、非法指令（CPU 不识别的操作码）、栈溢出（栈空间不足）、地址越界（访问超出允许范围的内存地址）、缺页（所需内存页不在物理内存中）等；</li>
<li>包括<strong>故障异常</strong>和<strong>自陷异常</strong></li>
</ul>
</li>
</ul>
<p>根据异常发生的具体原因及处理后的返回逻辑，异常可进一步分为<strong>故障（Fault）</strong>、<strong>自陷（Trap）</strong>、<strong>终止（Abort）</strong> 三类，核心差异体现在 “何时检测”“能否恢复”“返回哪里”：</p>
<h5 id="故障（Fault）">故障（Fault）</h5>
<ul>
<li>概念：在引起故障的指令<strong>启动后、执行结束前</strong>被检测到的异常（即指令未完成时发现问题）；</li>
<li>典型举例：
<ul>
<li><strong>指令译码时出现 “非法操作码”</strong>（CPU 无法识别该指令，执行前发现）；</li>
<li><strong>取数据时发生 “缺段” 或 “缺页”</strong>（所需内存段 / 页未加载，执行中发现）；</li>
<li><strong>除数为零</strong>（运算开始后发现除数无效）；</li>
<li><strong>地址越界</strong>（访问内存时发现地址超出允许范围）；</li>
</ul>
</li>
<li>关键特性（返回方式）：
<ul>
<li><strong>可恢复的故障</strong>：如 “缺段”“缺页”，异常处理程序会加载所需的段 / 页到内存，处理完成后<strong>回到发生故障的指令重新执行</strong>（断点为该指令）；</li>
<li><strong>不可恢复的故障</strong>：如 “非法操作码”“除数为 0”，因无法通过处理程序修复（指令本身无效或逻辑错误），必须<strong>终止当前进程</strong>，无法回到原断点。</li>
</ul>
</li>
</ul>
<h5 id="自陷（Trap，陷阱-陷入）">自陷（Trap，陷阱 / 陷入）</h5>
<ul>
<li>概念：预先安排的 “异常事件”，如同程序中预设的 “陷阱”，是<strong>主动触发</strong>的异常（非意外）；</li>
<li>典型举例：
<ul>
<li>x86 架构中，调试时的 “断点设置”（程序员预设某行代码执行时暂停）和单步跟踪（每执行一条指令就暂停，便于调试）；</li>
<li><strong>系统调用</strong>（用户程序主动请求操作系统服务，如读取文件，通过自陷指令触发）；</li>
<li><strong>条件自陷指令</strong>（满足特定条件时触发的自陷，如某变量超过阈值）；</li>
</ul>
</li>
<li>关键特性（返回方式）：自陷是 “预期内” 的事件，处理程序完成后（如系统调用执行完服务），会回到<strong>自陷指令的下一条指令</strong>继续执行（因自陷指令已执行完毕）。</li>
</ul>
<h5 id="终止（Abort）">终止（Abort）</h5>
<ul>
<li>概念：执行指令过程中发生<strong>严重硬件故障</strong>，导致计算机无法继续运行的异常，是 “致命性” 问题；</li>
<li>典型举例：<strong>控制器出错</strong>（CPU 内部控制逻辑故障）、<strong>存储器校验错</strong>（内存硬件损坏导致无法修复）等；</li>
<li>关键特性：
<ul>
<li>非特定指令触发：<strong>随机发生</strong>（与某条指令无直接关联）；</li>
<li>处理方式：必须终止当前程序执行，通常需要调用中断服务程序重启系统或进入安全状态，<strong>无法返回原程序</strong>（因硬件已无法正常工作）。</li>
</ul>
</li>
</ul>
<h3 id="中断（外中断）">中断（外中断）</h3>
<p>中断（外中断）是由<strong>CPU 外部设备</strong>触发的事件，其核心特性如下：</p>
<ul>
<li><strong>触发源</strong>：来自 <strong>CPU 外部</strong>（如 I/O 设备、时钟等），与当前正在执行的指令<strong>无直接关联</strong>，属于<strong>异步事件</strong>（事件发生时机不确定，与指令执行不同步）。</li>
<li><strong>请求方式</strong>：外部 I/O 设备通过<strong>特定的中断请求信号线</strong>向 CPU 发送请求，告知需要处理的事件。</li>
<li><strong>检测时机</strong>：CPU 在<strong>每执行完一条指令后</strong>，会检查中断请求信号线是否有请求；若有，则进入中断响应阶段。</li>
<li><strong>核心作用</strong>：实现 CPU 与外部设备的高效交互（无需 CPU 持续轮询设备状态），提升系统资源利用率。</li>
</ul>
<h4 id="中断的分类">中断的分类</h4>
<p>根据 CPU 是否可以屏蔽中断请求，中断可分为<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断</strong>：<br>
（1）可屏蔽中断</p>
<ul>
<li><strong>概念</strong>：通过<strong>可屏蔽中断请求线（INTR）</strong> 向 CPU 发送的中断请求。</li>
<li><strong>特点</strong>：CPU 可以通过设置中断控制器中的<strong>屏蔽字</strong>来决定是否响应这类中断。被屏蔽的中断请求不会被 CPU 处理，直到屏蔽解除。</li>
<li><strong>举例</strong>：大多数 <strong>I/O</strong> 设备中断（如键盘输入、打印机完成打印、磁盘读写完成等），这些事件通常不紧急，可暂时延迟处理。</li>
</ul>
<p>（2）不可屏蔽中断</p>
<ul>
<li><strong>概念</strong>：通过<strong>不可屏蔽中断请求线（NMI）</strong> 向 CPU 发送的中断请求。</li>
<li><strong>特点</strong>：CPU<strong>必须立即响应</strong>，无法通过软件屏蔽（因涉及系统致命性问题）。</li>
<li><strong>举例</strong>：通常是紧急的硬件故障，如<strong>电源掉电、内存校验错误</strong>等，若不及时处理会导致系统崩溃。</li>
</ul>
<table>
<thead>
<tr>
<th>中断类型</th>
<th>产生原因</th>
<th>特点</th>
<th>典型例子</th>
<th>断点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>故障</strong></td>
<td><strong>指令执行时</strong>出现可恢复运算异常</td>
<td>CPU 可恢复，重执行故障指令</td>
<td><strong>溢出</strong>、非法指令、<strong>缺页</strong>、访问越权</td>
<td>故障指令的地址</td>
</tr>
<tr>
<td><strong>终止</strong></td>
<td><strong>硬件 / 软件</strong>严重不可恢复错误</td>
<td>系统终止，无法继续运行</td>
<td><strong>主存存储数据校验出错</strong>、CPU 核心部件故障、硬件电路损坏</td>
<td>随便</td>
</tr>
<tr>
<td><strong>自陷</strong></td>
<td>程序<strong>主动</strong>触发，预先安排的事件</td>
<td>用于实现程序特定功能或调试</td>
<td>单步跟踪、断点、系统调用（执行访管指令）</td>
<td>自限制令的下条指令地址</td>
</tr>
<tr>
<td><strong>I/O 中断</strong></td>
<td>I/O 设备请求服务（如数据传输完成、设备就绪）</td>
<td>协调 CPU 与 I/O 设备数据交互</td>
<td>硬盘读写完成通知 CPU、打印机准备好接收任务</td>
<td></td>
</tr>
<tr>
<td><strong>外部中断</strong></td>
<td>外部设备（键盘、鼠标等）发出的中断请求</td>
<td>响应外部事件</td>
<td>键盘按键、鼠标移动产生的中断</td>
<td>被中断指令的下一条指令的地址</td>
</tr>
<tr>
<td><strong>机器校验中断</strong></td>
<td><strong>硬件</strong>自身校验出错（如<strong>内存奇偶校验、硬件自检错误</strong>）</td>
<td>检测硬件自身状态</td>
<td>内存奇偶校验发现错误、硬件开机自检不通过</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="异常和中断响应过程">异常和中断响应过程</h3>
<ul>
<li>从 CPU 检测到异常（内中断）或中断（外中断）事件，到调出相应的处理程序，整个过程称为<strong>异常和中断响应</strong></li>
<li>响应过程不可被打断，整个中断处理过程是<strong>软 / 硬件协同</strong>实现的</li>
<li>异常和中断事件都是由<strong>硬件检测</strong>实现的</li>
</ul>
<h4 id="关中断">关中断</h4>
<ul>
<li>在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即<strong>关中断</strong></li>
<li>设置<strong>中断允许触发器</strong>（IF）实现【IF = 1 代表开中断，表示允许响应中断】</li>
</ul>
<h4 id="保存断点和程序状态">保存断点和程序状态</h4>
<ul>
<li><strong>目的</strong>：确保异常或中断处理完成后，能正确返回到被打断的程序继续执行。</li>
<li><strong>保存内容</strong>：
<ul>
<li><strong>断点</strong>：被打断程序的下一条指令地址（即当前程序计数器 PC 的值），用于处理完成后恢复执行位置。</li>
<li><strong>程序状态字（PSW）</strong>：记录 CPU 的状态信息（如标志位、中断屏蔽状态等），需在返回时恢复，保证原程序执行环境不变。</li>
</ul>
</li>
<li><strong>保存位置</strong>：通常将断点和 PSW 压入<strong>系统栈</strong>中，栈的特性支持异常 / 中断的嵌套（即处理一个中断时又发生新的中断，可依次入栈保存状态）。</li>
</ul>
<h4 id="识别异常和中断并转到相应的处理程序">识别异常和中断并转到相应的处理程序</h4>
<p>识别的目的是确定事件类型，找到对应的处理程序入口地址。主要有<strong>软件识别</strong>和<strong>硬件识别（向量中断）</strong> 两种方式：</p>
<ul>
<li><strong>软件识别</strong>：
<ul>
<li>CPU 检测到异常或中断后，会设置一个<strong>异常状态寄存器</strong>，记录事件的具体原因（如 “缺页”“键盘中断” 等）。</li>
<li>操作系统执行一个<strong>统一的查询程序</strong>，按优先级顺序读取异常状态寄存器，确定事件类型后，跳转到对应的内核处理程序。</li>
<li><strong>适用场景</strong>：<strong>异常和部分中断</strong>（尤其是原因复杂、类型较多的情况）。</li>
</ul>
</li>
<li><strong>硬件识别</strong>【<strong>向量中断</strong>】：
<ul>
<li><strong>核心概念</strong>：
<ul>
<li><strong>中断向量</strong>：每个异常或中断处理程序的首地址（入口地址）。</li>
<li><strong>中断向量表</strong>：所有中断向量集中存储的区域（通常在内存固定位置），相当于 “处理程序地址目录”。</li>
<li><strong>中断类型号</strong>：每个异常或中断被分配一个唯一编号，作为索引指向中断向量表中的对应入口。</li>
</ul>
</li>
<li><strong>原理</strong>：
<ul>
<li>事件发生时，硬件自动根据事件类型生成中断类型号。</li>
<li>CPU 通过中断类型号，直接在中断向量表中找到对应的中断向量（处理程序地址），快速跳转到处理程序。</li>
</ul>
</li>
<li><strong>特点</strong>：识别速度快（无需软件查询），效率高，是现代计算机常用的方式。</li>
<li><strong>适用场景</strong>：大多数中断（如 I/O 设备中断），因类型明确且需要快速响应。</li>
</ul>
</li>
</ul>
<h2 id="指令流水线">指令流水线</h2>
<h3 id="流水线的基本概念">流水线的基本概念</h3>
<h4 id="如何提高处理机的并行性">如何提高处理机的并行性</h4>
<ul>
<li>**时间上的并行技术（流水线技术）：
<ul>
<li>将一个任务拆分成几个不同的子阶段</li>
<li>每个阶段在不同的功能部件上并行执行，即流水线技术</li>
</ul>
</li>
<li><strong>空间上的并行技术（超标量技术）</strong>：<br>
在处理器中设置多个功能部件（如多个 ALU），同时执行多条指令，提升单位时间处理能力。</li>
</ul>
<h4 id="指令流水线的定义">指令流水线的定义</h4>
<ul>
<li>将指令执行过程的各阶段（如取指、译码、取数、执行、写回）视为独立 “流水段”，各段依次衔接形成流水线。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501220002.png" alt="image.png"></li>
<li><strong>不能缩短单条指令的执行时间</strong>，但对于整个程序来说，执行效率得到大幅提升</li>
</ul>
<p>eg. 单条指令执行需 5 个阶段，每阶段 1 周期，总耗时 5 周期</p>
<ul>
<li>流水线中第 1 条指令 5 周期完成后，后续每条指令每 1 周期完成 1 条，N 条指令总耗时为 5 + (N-1)×1 周期。</li>
</ul>
<h4 id="指令集应具备的特点">指令集应具备的特点</h4>
<ol>
<li><strong>指令长度一致</strong>：简化取指阶段的硬件设计，避免因指令长度不同导致流水线停顿。</li>
<li><strong>格式规整</strong>：源寄存器位置固定，便于在译码阶段提前获取操作数，减少等待时间。</li>
<li><strong>Load/Store 架构</strong>：将数据访存操作（Load/Store）与运算操作分离，使地址计算和运算步骤在统一周期内完成，优化流水线时序。</li>
<li><strong>数据对齐存储</strong>：确保数据在内存中按字节对齐，减少访存次数（如一次访存获取完整数据），避免流水线因等待数据而阻塞。</li>
</ol>
<h4 id="流水线的表示方法">流水线的表示方法</h4>
<ul>
<li>采用时空图描述流水线的执行情况<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501220833.png" alt="image.png"></li>
</ul>
<p>超标量流水线时间计算 <strong>核心公式</strong><br>
$\boldsymbol{总时间 = T_{首条} + \left( \left\lceil \dfrac{N}{n} \right\rceil - 1 \right) \times T}$</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{首条}$</td>
<td>第一条指令的执行时间 = 所有流水段执行时间之和（$T_1 + T_2 + … + T_m$，m为段数）</td>
</tr>
<tr>
<td>n</td>
<td>超标量度（每周期发射 / 完成的指令数，如度为 4 则每 T 处理 4 条）</td>
</tr>
<tr>
<td>N</td>
<td>总指令数</td>
</tr>
<tr>
<td>$\left\lceil x \right\rceil$</td>
<td>向上取整</td>
</tr>
<tr>
<td>T</td>
<td>流水线周期（T=$T_{max}$，各段时间的最大值）</td>
</tr>
</tbody>
</table>
<h4 id="流水线的性能指标">流水线的性能指标</h4>
<h5 id="流水线的吞吐率（TP）-总指令n-总时间Tk">流水线的吞吐率（TP）[总指令n/总时间Tk]</h5>
<ul>
<li><strong>定义</strong>：<strong>单位时间</strong>内完成的指令数或任务数。</li>
<li><strong>公式</strong>：
<ul>
<li>设流水线有 k 段，处理 n 条指令总时间为 $T_k = （k + n-1) \times \Delta t$（$\Delta t$为最长段耗时），则吞吐率：$TP = \frac{n}{T_k} = \frac{n}{(k + n - 1) \times \Delta t}$</li>
<li><strong>最大吞吐率</strong>：当 n→∞时，$TP_{max} = \frac{1}{\Delta t}$，即每周期完成 1 条指令。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501221430.png" alt="image.png"></li>
</ul>
</li>
<li><strong>注意</strong>：
<ul>
<li>m 段流水线的 CPU 吞吐能力 = m 个并行部件的 CPU 吞吐能力</li>
<li>m 段流水线在第 m 个时钟周期后，每个时钟周期都可完成一条指令</li>
<li>m 个并行部件在 m 个时钟周期后能完成全部的 m 条指令，等价于平均每个时钟周期完成一条指令</li>
</ul>
</li>
</ul>
<h5 id="流水线的加速比（S）-顺序时间-总时间">流水线的加速比（S）[顺序时间/总时间]</h5>
<ul>
<li><strong>定义</strong>：流水线比 “顺序执行” 快多少倍。</li>
<li><strong>公式</strong>：
<ul>
<li>顺序执行 n 条指令时间 $T_0 = n \times k \times \Delta t$，流水线时间 $T_k = (k + n-1) \times \Delta t$，则加速比：$S = \frac{T_0}{T_k} = \frac{n \times k}{k + n - 1}$</li>
<li><strong>最大加速比</strong>：当 n→∞时，$S_{max} = k$，即流水线段数越多，理论加速比越高。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501222028.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h5 id="流水线的效率（E）-面积比">流水线的效率（E）[面积比]</h5>
<ul>
<li><strong>定义</strong>：流水线各段的平均利用率，时空图中有效面积与总面积的比值，越接近 100% 越好。</li>
<li><strong>公式</strong>：$E = \frac{T_0}{k \times T_k} = \frac{n}{k + n - 1}$</li>
<li><strong>直观理解</strong>：流水线效率随指令数增加而趋近于 1（满负荷），但初期因流水线未填满，效率较低。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501223026.png" alt="image.png"><br>
理想情况：各个阶段的花费时间相同，每个阶段结束后能立即进入下一个阶段。<br>
实际受影响因素影响，很难达到</li>
</ul>
<h3 id="流水线的基本实现">流水线的基本实现</h3>
<h4 id="流水线的数据通路">流水线的数据通路</h4>
<ul>
<li><strong>数据通路</strong>：数据在功能部件之间传送的路径
<ul>
<li>包括数据通路上流经的部件（如 PC，ALU，通用寄存器，状态寄存器，异常和中断处理逻辑）</li>
</ul>
</li>
<li><strong>数据通路由控制部件控制</strong>，控制部件根据每条指令功能的不同生成对数据通路的控制信号
<ul>
<li><strong>数据通路不包含生成控制信号的控制部件</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501223439.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h4 id="流水线的控制信号">流水线的控制信号</h4>
<table>
<thead>
<tr>
<th>控制信号</th>
<th>生效位置</th>
<th>来 源</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BranchTaken</td>
<td>IF</td>
<td>EX</td>
<td>分支<strong>跳转</strong>信号，为 1 表示跳转，由 EX 段的 Branch 信号与 equal 标志进行逻辑与生成</td>
</tr>
<tr>
<td>RegDst</td>
<td>ID</td>
<td>ID</td>
<td>写入<strong>目的寄存器</strong>选择，为 1 时目的寄存器为 rd 寄存器，为 0 时为 rt 寄存器</td>
</tr>
<tr>
<td>RegWrite</td>
<td>ID</td>
<td>WB</td>
<td>控制寄存器堆<strong>写操作</strong>，为 1 时数据需要写回寄存器堆中的指定寄存器</td>
</tr>
<tr>
<td>AluSrc</td>
<td>EX</td>
<td>EX</td>
<td>ALU 的<strong>第二输入</strong>选择控制，为 0 时输入寄存器 rt，为 1 时输入扩展后的立即数</td>
</tr>
<tr>
<td>AluOp</td>
<td>EX</td>
<td>EX</td>
<td>控制 ALU 进行不同<strong>运算</strong>，具体取值和位宽与 ALU 的设计有关</td>
</tr>
<tr>
<td>MemWrite</td>
<td>MEM</td>
<td>EX</td>
<td>控制<strong>写不写内存</strong>，访问内存时，1 表示往内存写数据（比如保存变量），0 表示从内存读数据（比如取变量值）。</td>
</tr>
<tr>
<td>MemToReg</td>
<td>WB</td>
<td>WB</td>
<td>选<strong>写回的数据来源</strong>，结果是从内存来的（比如加载指令读的内存数据）还是 ALU 运算来的（比如加法结果）？1 表示用内存数据，0 表示用 ALU 结果。</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>流水寄存器保存的信息</strong></p>
<ul>
<li>后面流水段要用到的<strong>所有数据信息</strong>
<ul>
<li>包括 PC+4,、指令、立即数、目的寄存器、ALU 运算结果、标志信息等</li>
<li>它们是前面阶段在数据通路中执行的结果</li>
</ul>
</li>
<li>后面传递过来的后面各流水段要用到的<strong>所有控制信号</strong></li>
</ul>
</li>
<li>
<p>流水线控制信号的设计逻辑：</p>
<ul>
<li>PC 和流水段寄存器 <strong>无写使能信号</strong>（PC 每时钟必更新、流水段寄存器每时钟必写入，硬件时序直接驱动）</li>
<li>前两个流水段是 <strong>公共段</strong>（指令功能固定，无需动态控制信号）</li>
<li><strong>控制信号</strong>：仅作用于功能部件（如ALU、MUX），控制它们的操作。</li>
<li><strong>时钟信号</strong>：作用于所有状态元件（包括PC、流水段寄存器、通用寄存器、存储器等），是全局同步的，确保处理器各部件协调工作。</li>
</ul>
</li>
</ul>
<h4 id="流水线的执行过程">流水线的执行过程</h4>
<ul>
<li><strong>取指（IF）</strong>：从<strong>指令寄存器或 Cache</strong> 中取指令</li>
<li><strong>译码/读寄存器（ID）</strong>：操作控制器对指令进行<strong>译码</strong>，同时从<strong>寄存器</strong>堆中读取操作数</li>
<li><strong>执行/计算地址（EX）</strong>：加减法计算</li>
<li><strong>访存（MEM）</strong>：对<strong>存储器</strong>进行读写操作</li>
<li><strong>写回（WB）</strong>：将指令执行结果写回<strong>寄存器</strong></li>
</ul>
<p>所有的指令都有这5个周期，即使有的指令某几个阶段不执行<br>
耗时取最大的<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250801203452374.png" alt="image.png"><br>
流水线每个功能段部件后面都要有一个<strong>缓冲寄存器</strong>，或称为<strong>锁存器</strong>，其作用是保存本流水段的执行结果，提供给下一流水段使用</p>
<table>
<thead>
<tr>
<th>英文术语</th>
<th>中文翻译</th>
<th>核心功能（通俗理解）</th>
<th>关联阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC（Program Counter）</td>
<td>程序计数器</td>
<td>存放下一条要执行的<strong>指令地址</strong>，是 “指令执行顺序” 的 “指挥棒”（类似 “原料清单的页码”）。</td>
<td>IF 阶段（取指的 “地址源”）</td>
</tr>
<tr>
<td>Instruction Cache</td>
<td>指令缓存</td>
<td>高速缓存<strong>指令</strong>（因为从主存取指令慢，缓存常用指令加速），是 “指令的临时仓库”。</td>
<td>IF 阶段（取指的 “数据源”）</td>
</tr>
<tr>
<td>Inst. Register（Instruction Register）</td>
<td>指令寄存器</td>
<td>临时存储<strong>当前正在处理的指令</strong>，供译码阶段解析（类似 “临时放说明书的架子”）。</td>
<td>IF→ID 阶段（指令的 “中转站”）</td>
</tr>
<tr>
<td>Registers（Register File）</td>
<td>寄存器堆</td>
<td>CPU 内部的<strong>高速存储单元</strong>，存 “操作数” 和 “运算结果”（类似 “车间的零件库”）。</td>
<td>ID 阶段（读操作数）、WB 阶段（写结果）</td>
</tr>
<tr>
<td>Imm（Immediate）</td>
<td>立即数</td>
<td>指令中<strong>直接包含的常数</strong>（比如<code>addi $t0, $t1, 5</code>中的<code>5</code>），无需从寄存器 / 内存读取。</td>
<td>ID 阶段（与寄存器操作数配合）</td>
</tr>
<tr>
<td>ALU（Arithmetic Logic Unit）</td>
<td>算术逻辑单元</td>
<td>执行<strong>算术运算</strong>（加减乘除）和<strong>逻辑运算</strong>（与或非）的 “核心运算器”（类似 “车间的机床”）。</td>
<td>EX 阶段（运算的 “执行器”）</td>
</tr>
<tr>
<td>Data Cache</td>
<td>数据缓存</td>
<td>高速缓存<strong>数据</strong>（因为从主存读写数据慢，缓存常用数据加速），是 “数据的临时仓库”。</td>
<td>M 阶段（访存的 “数据源 / 目标”）</td>
</tr>
</tbody>
</table>
<h3 id="流水线的冒险与处理">流水线的冒险与处理</h3>
<p><strong>流水线冒险</strong>：在流水线中会有一种情况，在下一个时钟周期中下一条指令不能执行，这种情况被叫做流水线冒险<br>
根据导致冒险的原因不同分为：结构冒险、数据冒险和控制冒险</p>
<ul>
<li><strong>数据冒险</strong>：后面指令用到前面指令结果时，前面指令结果还没产生
<ul>
<li><strong>解决</strong>：
<ul>
<li><strong>停顿 / 插 NOP</strong>：暂停流水线，直至能正确读取寄存器操作数（等待前指令结果写回）；</li>
<li><strong>编译指令重排</strong>【可部分解决】：编译器调整指令顺序，让不依赖前指令结果的指令先执行，减少数据等待的 stall 周期。</li>
<li><strong>寄存器堆读写设计</strong>【可部分解决】：通过 <strong>时序拆分</strong> 规避冲突：规定寄存器堆 <strong>前半时钟周期写数据、后半时钟周期读数据</strong>；若同一时钟内，前指令写入的数据正好是后指令读取的数据，因读写时序错开，天然无冒险。</li>
<li><strong>数据转发（旁路技术）</strong>【可部分解决】：构建专用数据通路，直接传递中间结果：
<ul>
<li>若依赖数据是 <strong>ALU 运算结果</strong>（如加法结果）：可从 ALU 输出端得到的中间结果直接转发至下条指令的 ALU 输入端，无需等待写回寄存器，快速解决 RAW 冲突；</li>
<li>若依赖数据是 <strong>Load 指令从内存（DM）读出的内容</strong>（Load - use 冒险）：因内存读需 “访存阶段” 完成，转发无法提前获取结果，需 <strong>阻塞 1 个时钟周期或插 NOP</strong>，这类场景是转发的 “例外”。<br>
注：Load 指令的数据在<strong>访存阶段</strong>产生，后续指令在<strong>执行阶段</strong>就需该数据，转发技术无法捕获访存阶段的结果，故至少阻塞 1 周期。</li>
</ul>
</li>
</ul>
</li>
<li><strong>乱序</strong>执行的流水线中存在三种数据相关：
<ul>
<li>RAW（写后读）：先往盒里放材料（写），再拿出来用（读），但没放好就想拿 —— 比如先装胚，再拿胚抹奶油，胚没装完就拿。</li>
<li>WAW（写后写）：两次往同一个盒里放材料，第一次还没放完，第二次就想放 —— 比如先往盒里装原味胚，还没装完，又想装巧克力胚，盒子里就乱了。</li>
<li>WAR（读后写）：先拿材料用，再往盒里放新的，还没拿完就放新的 —— 比如先拿盒里的胚用，还没拿完，就往盒里装新胚，拿的还是旧的。</li>
</ul>
</li>
<li><strong>按序</strong>执行的流水线中，只可能出现 <strong>RAW</strong> 冲突</li>
</ul>
</li>
<li><strong>控制冒险</strong>：也叫分支冒险，决策依赖于一条指令的结果，而其他指令正在执行中，如分支跳转指令需等 ALU 给出结果后才知道跳转地址。【只要不是<strong>顺序执行指令</strong>，都会引发控制冒险】
<ul>
<li><strong>解决</strong>：
<ul>
<li>分支预测（静态：默认不转移；动态：按历史调整）</li>
<li>延迟槽（分支后插无关指令，避免断流）
<ul>
<li>硬件上阻塞（stall）分支指令后三条指令的执行</li>
<li>软件上插入三条NOP指令</li>
</ul>
</li>
<li>提前算目标 PC（减少停顿周期）</li>
</ul>
</li>
</ul>
</li>
<li><strong>结构冒险</strong>：<font color="#c00000">硬件资源</font><strong>（如存储器、ALU、寄存器）</strong> 冲突，同一个部件同时被不同指令所使用【<strong>烤箱又要烤胚又要热奶油</strong>】
<ul>
<li><strong>解决</strong>：
<ul>
<li>一个部件的每条指令只能使用一次，且固定部件的使用阶段（如：ALU总在第三阶段被用）</li>
<li>设置多个独立的部件来避免硬件资源冲突
<ul>
<li>将指令Cache和数据Cache分开</li>
<li>将寄存器读口和写口独立开来</li>
</ul>
</li>
<li>产生空泡，使读写错开进行<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250815033212387.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="结构冒险">结构冒险</h4>
<ul>
<li><strong>定义</strong>：多条指令<strong>同时需要同一硬件资源</strong>（如总线、寄存器端口），导致 “资源竞争”<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501224958.png" alt="image.png"><br>
<strong>解决方法</strong>：</li>
<li>前一指令访存时，使后一条指令（以及其后续指令）<strong>暂停一个时钟周期</strong></li>
<li><strong>设置多个独立的部件</strong>：
<ul>
<li>寄存器访存冲突：将寄存器的读口和写口独立开来</li>
<li>访存冲突：单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行（<strong>分离结构的 Cache</strong>）</li>
</ul>
</li>
</ul>
<h4 id="数据冒险">数据冒险</h4>
<ul>
<li>
<p><strong>定义</strong>：后一条指令需要<strong>前一条指令的结果</strong>，但前一条指令的结果还没生成（比如没写回寄存器）</p>
</li>
<li>
<p><strong>乱序</strong>执行的流水线中存在三种数据相关：</p>
<ul>
<li><strong>写后读 RAW</strong>：当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据</li>
<li><strong>读后写 WAR</strong>：当前指令读出数据后，下一条指令才能写入寄存器</li>
<li><strong>写后写 WAW</strong>：当前指令写入寄存器后，下一条指令才能写入寄存器</li>
</ul>
</li>
<li>
<p><strong>按序</strong>执行的流水线中，只可能出现 <strong>RAW</strong> 冲突<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502153843.png" alt="image.png"><br>
<strong>解决方法</strong>：</p>
</li>
<li>
<p><strong>延迟执行相关指令</strong>：把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直至数据相关问题消失后再继续执行，可分为<strong>硬件阻塞（stall）</strong> 和<strong>软件插入空操作 nop</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502154533.png" alt="image.png"></p>
</li>
<li>
<p><strong>转发（旁路）技术</strong>：设置相关转发通路，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而将数据通路中生成的中间数据<strong>直接转发到 ALU 的输入端</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502154556.png" alt="image.png"></p>
</li>
<li>
<p><strong>load-use 数据冒险处理</strong>：load 指令与紧邻的运算类指令存在数据相关问题，可以使用<strong>延迟+转发</strong>技术解决，最好是在<strong>程序编译时进行优化</strong>，通过调整指令顺序避免出现该现象<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502154939.png" alt="image.png"></p>
</li>
</ul>
<h4 id="控制冒险">控制冒险</h4>
<ul>
<li><strong>定义</strong>：分支指令（如<code>if...else</code>）的<strong>跳转目标不确定</strong>，导致流水线 “提前取错指令”（比如分支不满足时，已经取了分支满足的指令）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502155758.png" alt="image.png"><br>
<strong>解决办法</strong></li>
<li><strong>对转移指令进行分支预测</strong>：
<ul>
<li><strong>静态预测</strong>：默认不跳转或跳转，则按序继续执行分支指令的后续指令</li>
<li><strong>动态预测</strong>：根据程序执行的历史情况，进行动态调整，有效提高预测准确率</li>
</ul>
</li>
<li>同时<strong>预取</strong> “分支满足” 和 “分支不满足” 的指令，预测正确后直接执行对应路。</li>
<li><strong>加快和提前形成条件码</strong></li>
<li><strong>提高转移方向的猜准率</strong></li>
</ul>
<table>
<thead>
<tr>
<th>冒险类型</th>
<th>冲突原因</th>
<th>典型场景</th>
<th>解决思路</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构冒险</td>
<td>硬件资源不够用</td>
<td>抢总线、抢寄存器端口</td>
<td>加资源（复制）或让指令等</td>
</tr>
<tr>
<td>数据冒险</td>
<td>数据依赖未满足</td>
<td>后指令需要前指令结果</td>
<td>等、转发、编译优化</td>
</tr>
<tr>
<td>控制冒险</td>
<td>分支目标不确定</td>
<td>if/else 导致取指错误</td>
<td>延迟槽、预测、预取双路指令</td>
</tr>
</tbody>
</table>
<h3 id="流水线的分类">流水线的分类</h3>
<ul>
<li><strong>级别分类</strong>：看 “并行的粒度”—— 是 “单个机器零件内部”（部件级）、“一条生产线”（处理机级），还是 “多个工厂接力”（处理机间级）。</li>
<li><strong>功能分类</strong>：看 “流水线会啥活”—— 是 “只会包饺子”（单功能），还是 “既能包饺子又能做面条”（多功能）。</li>
<li><strong>连接方式</strong>：看 “同一时间干几件事”—— 是 “同一时间只干一件事”（静态），还是 “同一时间干多件事”（动态）。</li>
<li><strong>反馈信号</strong>：看 “流水线是不是直的”—— 是 “单行道”（线性），还是 “环形路”（非线性）</li>
</ul>
<h4 id="按流水线使用级别分类（谁在并行？——-部件-单-CPU-多-CPU）">按<strong>流水线使用级别</strong>分类（谁在并行？—— 部件 / 单 CPU / 多 CPU）</h4>
<table>
<thead>
<tr>
<th>分类</th>
<th>定义</th>
<th>例子 / 类比</th>
<th>核心区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>部件功能级流水线</td>
<td>把<strong>单个硬件部件</strong>（如 ALU）拆成更小的子模块，让子模块<strong>并行处理同一指令的子操作</strong>。</td>
<td>比如加法指令需要 “求阶差→对阶→尾数相加→规格化”4 步，每步由独立子电路并行完成。  <br>类比：包饺子时，剁馅、和面、擀皮、包馅四个工位同时做<strong>同一份饺子</strong>的不同步骤。</td>
<td>属于 <strong>“指令内并行”</strong>（一个指令拆成子操作并行）。</td>
</tr>
<tr>
<td>处理机级流水线</td>
<td>把<strong>一条指令的执行过程</strong>拆成多个阶段（如 IF/ID/EX/M/WB），让<strong>不同指令的不同阶段</strong>并行。</td>
<td>经典 5 阶段指令流水线：指令 1 在 WB，指令 2 在 M，指令 3 在 EX…  <br>类比：工厂流水线，5 个工人分别负责 “取料→切割→组装→质检→包装”，同时处理 5 个产品的不同工序。</td>
<td>属于 <strong>“指令间并行”</strong>（多条指令的不同阶段并行）。</td>
</tr>
<tr>
<td>处理机间流水线</td>
<td>多个 ** 处理器（多核 / 多 CPU）** 协作，每个处理器负责指令的一个阶段，接力完成指令。</td>
<td>比如 CPU1 负责取指，CPU2 负责译码，CPU3 负责执行… 指令在多个处理器间传递。  <br>类比：接力赛，4 个队员分别跑 “起跑→加速→冲刺→交接棒”，共同完成一场比赛。</td>
<td>属于 <strong>“处理器间并行”</strong>（多个 CPU 分工协作）。</td>
</tr>
</tbody>
</table>
<h4 id="按能完成的功能分类（流水线会啥技能？——-单一技能-多项技能）">按<strong>能完成的功能</strong>分类（流水线会啥技能？—— 单一技能 / 多项技能）</h4>
<table>
<thead>
<tr>
<th>分类</th>
<th>定义</th>
<th>例子 / 类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>单功能流水线</td>
<td>只能完成<strong>一种固定操作</strong>（如加法、乘法），不能切换功能。</td>
<td>专门的 “加法流水线”，只能连续做加法运算；  <br>类比：只能包饺子的生产线，不能改包包子。</td>
</tr>
<tr>
<td>多功能流水线</td>
<td>可以<strong>动态切换功能</strong>，同时支持多种操作（如加法、乘法、逻辑运算）。</td>
<td>CPU 的 ALU 流水线，既可以做加法，也可以做乘法；  <br>类比：既能包饺子又能做面条的生产线，随时切换模式。</td>
</tr>
</tbody>
</table>
<h4 id="按连接方式分类（同一时间能做几件事？——-专一-花心）">按<strong>连接方式</strong>分类（同一时间能做几件事？—— 专一 / 花心）</h4>
<table>
<thead>
<tr>
<th>分类</th>
<th>定义</th>
<th>例子 / 类比</th>
<th>与 “功能分类” 的区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态流水线</td>
<td>同一时间<strong>只能执行一种功能</strong>（即使支持多种功能，也只能选一种）。</td>
<td>多功能流水线在某一时刻只能选 “加法” 或 “乘法”，不能同时做两种；  <br>类比：厨房同一时间只能用烤箱烤面包，不能同时用烤箱烤面包 + 用锅炒菜。</td>
<td>强调 <strong>“同一时间的专一性”</strong>，与 “是否支持多种功能” 无关（多功能静态流水线也只能同一时间做一件事）。</td>
</tr>
<tr>
<td>动态流水线</td>
<td>同一时间<strong>可以执行多种功能</strong>（不同子模块并行处理不同操作）。</td>
<td>同一时刻，加法子模块做加法，乘法子模块做乘法；  <br>类比：厨房同时用烤箱烤面包 + 用锅炒菜，多任务并行。</td>
<td>强调 <strong>“同一时间的多任务”</strong>，需要硬件支持多个子模块独立工作。</td>
</tr>
</tbody>
</table>
<h4 id="按是否有反馈信号分类（“流水线是直的还是绕的？”——-单行线-环路）">按<strong>是否有反馈信号</strong>分类（“流水线是直的还是绕的？”—— 单行线 / 环路）</h4>
<table>
<thead>
<tr>
<th>分类</th>
<th>定义</th>
<th>例子 / 类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性流水线</td>
<td>指令从 “起点”（IF）到 “终点”（WB）<strong>单向流动</strong>，无反馈或循环。</td>
<td>经典 5 阶段指令流水线：指令执行完就 “流走”，不会回头；  <br>类比：单行道，车从起点开到终点，不调头。</td>
</tr>
<tr>
<td>非线性流水线</td>
<td>存在<strong>反馈或循环路径</strong>，指令可能多次经过同一功能段（如乘法用多次加法实现）。</td>
<td>乘法流水线：用 “加法 + 移位” 循环多次完成乘法；  <br>类比：环形赛道，赛车需要绕圈跑多圈才能完成比赛。</td>
</tr>
</tbody>
</table>
<h3 id="流水线多发技术">流水线多发技术</h3>
<p><strong>突破 “单指令 / 单周期” 限制</strong>的核心手段，通过 <strong>空间并行（多部件）</strong> 或 <strong>时间并行（细分阶段）</strong> 提升性能</p>
<h4 id="超标量流水线技术">超标量流水线技术</h4>
<ul>
<li><strong>定义</strong>：每个时钟周期<strong>同时发射多条独立指令</strong>（比如同时发射<code>add</code>和<code>sub</code>），硬件层面动态识别指令间的并行性，自动调度执行，也称<strong>动态多发射技术</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502160930.png" alt="image.png"></li>
<li>每个时钟周期内可<strong>并发多条独立指令</strong></li>
<li>并不影响流水线功能段的处理时间</li>
<li>需要<strong>多个功能部件</strong>（如 2 个 ALU、2 个 Load/Store 单元），用 “硬件资源” 换 “指令吞吐量”</li>
<li>不能调整指令的<strong>执行顺序</strong>：【注意，乱序发射时硬件会调整指令顺序，优先执行无依赖的指令（比如<code>add</code>和<code>sub</code>不冲突，就同时执行）】</li>
<li><strong>编译优化辅助</strong>：编译器把 “可能并行的指令” 排在一起，降低硬件调度压力</li>
</ul>
<h4 id="超长指令字技术">超长指令字技术</h4>
<ul>
<li><strong>定义</strong>：<font color="#c00000">编译阶段</font>把 “多条能并行的指令” 打包成<strong>一条超长指令</strong>（比如包含<code>add</code>、<code>sub</code>、<code>load</code>三个操作），硬件只需按指令顺序执行这些子操作，也称<strong>静态多发射技术</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502161143.png" alt="image.png"></li>
<li>需要<strong>多个处理部件</strong></li>
</ul>
<h4 id="超流水线技术">超流水线技术</h4>
<ul>
<li><strong>定义</strong>：把<strong>原有流水线的每个阶段再细分</strong>（比如把 EX 阶段拆成 EX1、EX2），让时钟周期更短，指令 “流动更快”。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502161507.png" alt="image.png"></li>
<li>在<strong>一个时钟周期</strong>内<strong>再分段</strong>（3段）</li>
<li>在一个时钟周期内<strong>一个功能部件使用多次</strong>（3次）</li>
<li><strong>不能调整</strong>指令的<strong>执行顺序</strong></li>
<li>图中流水线速度时原来速度的3倍</li>
<li>靠编译程序解决优化问题</li>
<li>流水线功能段越多，时钟周期越短，<strong>指令吞吐率越高</strong></li>
<li>通过<strong>提高流水线主频</strong>的方式来提升流水线性能的</li>
<li>流水线级数越多，用于<strong>流水线寄存器的开销越大</strong></li>
</ul>
<p><strong>高级流水线技术</strong> 分为 <strong>超流水线技术</strong> 和 <strong>多发射流水线</strong>，核心是突破 “单周期 1 条指令” 的限制，降低 CPI（或提高 IPC）。</p>
<ul>
<li><strong>超流水线</strong>技术
<ul>
<li><strong>核心</strong>：将流水线 <strong>细分为更多阶段</strong>（如 5 段拆为 10 段），压缩单阶段执行时间。</li>
<li><strong>效果</strong>：每个时钟周期可启动 <strong>多条指令</strong>（通过高频阶段切换提升吞吐），使 <strong>CPI 趋近于 1 甚至更低</strong></li>
</ul>
</li>
<li><strong>多发射流水线</strong>
<ul>
<li><strong>核心</strong>：<strong>同时发射多条指令</strong>，并行进入多条子流水线执行（硬件需多个独立执行部件）。</li>
<li><strong>分类</strong>
<ul>
<li><strong>静态多发射</strong>
<ul>
<li>调度方式：<strong>编译器静态调度</strong>【注：若认为 “静态多发射无需硬件要求” 则错误。因其属于多发射流水线，前提是硬件需配备多个独立执行部件以支持指令并行执行。】</li>
<li>依赖条件：软件提前打包多操作指令</li>
<li>代表 / 特点：<strong>超长指令字</strong>（VLIW）处理器</li>
</ul>
</li>
<li><strong>动态多发射</strong>
<ul>
<li>调度方式：<strong>硬件动态调度</strong></li>
<li>依赖条件：支持<strong>乱序</strong>执行、<strong>寄存器重命名</strong></li>
<li>代表 / 特点：<strong>超标量处理器</strong>（如 x86 架构）</li>
<li>细分类型
<ul>
<li>按序发射・按序完成
<ul>
<li>调度方式：发射和完成顺序均严格</li>
<li>依赖条件：调度简单，并行度低</li>
<li>代表 / 特点：早期实验架构</li>
</ul>
</li>
<li>按序发射・无序完成
<ul>
<li>调度方式：发射顺序不变，完成乱序</li>
<li>依赖条件：平衡复杂度与并行度</li>
<li>代表 / 特点：主流超标量处理器（如 Intel Core）</li>
</ul>
</li>
<li>无序发射・无序完成
<ul>
<li>调度方式：发射和完成均乱序</li>
<li>依赖条件：硬件最复杂，并行度最高</li>
<li>代表 / 特点：高端服务器 CPU（如 AMD Zen）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>因多指令并行，<strong>CPI 可 &lt; 1</strong>（如 1 周期执行 2 条指令，CPI=0.5），故定义 <strong>IPC（Instructions Per Cycle，即 1/CPI）</strong> 衡量并行效率。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>技术类型</th>
<th>核心思想</th>
<th>发射方式</th>
<th>并行性来源</th>
<th>硬件复杂度</th>
<th>性能提升关键</th>
<th>类比场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>超标量</strong></td>
<td>同一周期发多条独立指令</td>
<td>动态发射</td>
<td>硬件动态调度</td>
<td>高（多部件）</td>
<td>空间换时间（多 ALU 等）</td>
<td>双开生产线，同时做 2 种产品</td>
</tr>
<tr>
<td><strong>超长指令字</strong></td>
<td>编译时打包并行指令</td>
<td>静态发射</td>
<td>编译器静态分析</td>
<td>低（硬件简单）</td>
<td>编译优化能力</td>
<td>菜谱写清 “同时切菜 + 洗菜 + 备料”</td>
</tr>
<tr>
<td><strong>超流水线</strong></td>
<td>细分阶段，提高主频</td>
<td>单指令发射</td>
<td>时间并行（更细粒度）</td>
<td>中（寄存器多）</td>
<td>缩短时钟周期</td>
<td>把工序拆细，加快生产节奏</td>
</tr>
</tbody>
</table>
<h3 id="五段式指令流水线">五段式指令流水线</h3>
<p>在理想状态下，每个阶段耗时一个时钟周期，意味着每经过一个时钟周期，处理器就能执行一条新指令。然而实际情况中，数据相关性、分支预测错误等问题会影响流水线性能。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250822194529418.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>IF（取指）</th>
<th>ID（译码）</th>
<th>EX（执行）</th>
<th>MEM（访存）</th>
<th>WB（写回）</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算类（如 add）</td>
<td>取指令至锁存器</td>
<td>解析操作，读源寄存器</td>
<td>ALU 执行运算，存结果</td>
<td>空闲</td>
<td>结果写回目标寄存器</td>
</tr>
<tr>
<td>LOAD（读内存）</td>
<td>取指令至锁存器</td>
<td>解析 LOAD，算有效地址（EA）</td>
<td>补算 EA</td>
<td>按 EA 读内存，存数据</td>
<td>数据写回目标寄存器</td>
</tr>
<tr>
<td>STORE（写内存）</td>
<td>取指令至锁存器</td>
<td>解析 STORE，读数据 / 地址寄存器</td>
<td>算 EA，存待写数据</td>
<td>按 EA 写内存</td>
<td>空闲（或更状态）</td>
</tr>
<tr>
<td>条件转移</td>
<td>取指令至锁存器</td>
<td>解析分支，读判据寄存器</td>
<td>判分支条件，算目标 PC</td>
<td>写目标 PC 到程序计数器</td>
<td>空闲</td>
</tr>
<tr>
<td>无条件转移</td>
<td>取指令至锁存器</td>
<td>解析转移，读目标地址</td>
<td>算目标 PC，写回程序计数器</td>
<td>空闲</td>
<td>空闲</td>
</tr>
<tr>
<td>eg.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>load Rd,996(Rs)</code>          功能：((Rs)+996)→Rd   ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>store Rs,996(Rd)</code>        功能：Rs→((Rd)+996)   ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm。将要存的数放到B</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>beq Rs, Rt, #偏移量</code>    若(Rs) == (Rt)，则 PC = PC + 指令字长 + 偏移量×指令字长（跳转）；否则 PC = PC + 指令字长（顺序执行）。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>bne Rs, Rt, #偏移量</code>     若(Rs) != (Rt)，则PC = PC + 指令字长 + 偏移量×指令字长（跳转）；否则 PC = PC + 指令字长（顺序执行）。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>jmp #偏移量</code>                     功能：(PC)+指令字长+(偏移量x指令字长)→PC</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>eg.</p>
<ul>
<li><strong>流水线规则</strong>：按序发射、按序完成，无转发技术，<strong>同一寄存器的读、写不能同时钟周期</strong></li>
<li><strong>指令序列</strong>：
<ul>
<li><code>I1: LOAD R1, [a]</code>（读内存→写 R1）</li>
<li><code>I2: LOAD R2, [b]</code>（读内存→写 R2）</li>
<li><code>I3: ADD R1, R2</code>（读 R1、R2→算和→写 R1）</li>
<li><code>I4: STORE R2, [x]</code>（读 R2→写内存）</li>
</ul>
</li>
</ul>
<p>I3 的 ID 段阻塞原因：因为I3与I1和I2都存在数据相关，需等到I1和I2将结果写回寄存器后，I3才能读寄存器内容，所以I3的ID段被阻塞。<br>
I4 的 IF 段阻塞原因：I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容</p>
<h2 id="多处理器的基本概念">多处理器的基本概念</h2>
<h3 id="SISD、SIMD、SIMD、MIMD-的基本概念">SISD、SIMD、SIMD、MIMD 的基本概念</h3>
<ul>
<li>基于<strong>指令流的数量和数据流的数量</strong>，将计算机体系结构分为 SISD，SIMD，MISD 和 MIMD</li>
<li>常规的<strong>单处理机</strong>属于 <strong>SSID</strong>，常规的<strong>多处理机</strong>属于 <strong>MIMD</strong></li>
</ul>
<h4 id="单指令流单数据流结构-SISD">单指令流单数据流结构 (SISD)</h4>
<ul>
<li><strong>串行</strong>计算机结构</li>
<li>通常<strong>只包含一个处理器和一个存储器</strong></li>
<li>有些使用<strong>流水线</strong>的方式，所以有时会设置多个功能部件，并采用多模块交叉方式组织存储器</li>
<li><strong>通俗理解</strong>：就像家里炒菜的「单个厨师」—— 先洗锅（1 步）、再倒油（2 步）、再炒鸡蛋（3 步），一步一步按顺序来，全程只炒「一盘菜」。</li>
</ul>
<h4 id="单指令流多数据流结构（SIMD）">单指令流多数据流结构（SIMD）</h4>
<ul>
<li>一个指令流<strong>同时对多个数据流进行处理</strong>，称为<strong>数据级并行技术</strong></li>
<li>由<strong>一个指令控制部件、多个处理单元组成</strong></li>
<li>每个处理单元虽然执行的都是同一条指令, 但每个单元都有自己的地址寄存器，就有了不同的数据地址</li>
<li>一个顺序应用程序被编译之后, 可能按照 SISD 组织并运行于串行硬件上，也可能按 SIMD 组织并运行于并行硬件上</li>
<li><strong>for 循环效率高</strong>，但 switch 或 case 时效率低</li>
<li><strong>向量处理器</strong>也是 SIMD 的变体，是一种实现了直接操作一维数组（向量）指令集的 CPU<br>
分<strong>向量流水处理机</strong>和<strong>阵列处理机</strong>两类</li>
<li><strong>通俗理解</strong>：烤面包时，一个烤箱按 “180 度烤 10 分钟” 的同一步骤，同时烤 12 个面包。</li>
</ul>
<h4 id="多指令流单数据流结构（MISD）">多指令流单数据流结构（MISD）</h4>
<ul>
<li>同时执行多条指令，处理同一个数据</li>
<li>实际上不存在这样的计算机</li>
<li><strong>通俗理解</strong>：就像「五个厨师围着一盘菜干活」—— 一个厨师切菜、一个厨师加盐、一个厨师翻炒、一个厨师调火、一个厨师准备盛盘，同时对这一盘菜做不同步骤。但这根本不现实：菜还没切，怎么翻炒？盐还没加，怎么盛盘？</li>
</ul>
<h4 id="多指令流多数据流结构（MIMD）">多指令流多数据流结构（MIMD）</h4>
<ul>
<li><strong>同时执行多条指令，处理多个不同的数据</strong></li>
<li>分为多计算机系统和多处理器系统
<ul>
<li><strong>多计算机系统</strong>：
<ul>
<li>每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间</li>
<li>不能通过存取指令来访问不同节点的私有存储器</li>
<li>而要通过消息传递进行数据传送，也称为<strong>消息传递 MIMD</strong></li>
<li><strong>通俗理解</strong>：相当于每个厨师有自己的食材柜，要传数据得靠 “发消息”（比如厨师 A 要借酱油，得打电话让厨师 B 送过来）</li>
</ul>
</li>
<li><strong>多处理器系统</strong>：
<ul>
<li>共享存储多处理器（SMP）系统的简称</li>
<li>它具有共享的单一地址空间，通过访存指令来访问系统中的所有存储器，也称<strong>共享存储 MIMD</strong></li>
<li><strong>通俗理解</strong>：相当于所有厨师共用一个食材架，要数据直接拿（不用发消息，效率更高）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>通俗理解</strong>：就像「餐厅里的多个厨师各做各的」—— 厨师 A 按 “炒番茄炒蛋” 的步骤（指令）处理鸡蛋和番茄（数据），厨师 B 按 “炖红烧肉” 的步骤（指令）处理五花肉（数据），厨师 C 按 “做沙拉” 的步骤（指令）处理蔬菜（数据），大家同时干活，互不干扰。</li>
</ul>
<h4 id="联系与区别">联系与区别</h4>
<ul>
<li><strong>SISD</strong>：一个人干一件事，按步骤来
<ul>
<li><strong>1个处理机+1个主存储器</strong></li>
<li>各指令序列只能并发，<strong>不能并行</strong>，每条指令处理一两个数据</li>
<li>不是 数据集并行技术</li>
<li>若采用指令流水线，需设置多个功能部件，采用多模块交叉存储</li>
<li>eg.标量流水线处理机</li>
</ul>
</li>
<li><strong>SIMD</strong>：一个步骤干多件相同的事，批量高效
<ul>
<li><strong>1个指令控制部件（CU）+多个处理单元/执行单元（如ALU）+多个局部存储器+1个主存储器</strong></li>
<li>各指令序列只能并发，<strong>不能并行</strong>，但每条指令可同时处理多个具有<strong>相同特征的</strong>数据</li>
<li><strong>数据级并行</strong></li>
<li>每个执行单元有各自的寄存器组、局部存储器、地址寄存器</li>
<li>不同执行单元执行同一条指令，处理不同的数据</li>
<li>eg.并行处理机、阵列处理机、向量处理机</li>
</ul>
</li>
<li><strong>MISD</strong>：多条指令并行处理同一个数据。实际不存在</li>
<li><strong>MIMD</strong>：多个人干多件不同的事，并行度最高，现在的多任务电脑全靠它
<ul>
<li>指令 + 数据都并行</li>
<li>按<strong>地址空间的访问方式</strong>划分
<ul>
<li><strong>多处理机</strong>：有<strong>共享</strong>的单一地址空间
<ul>
<li>各处理器之间，可以通过LOAD/STORE指令，访问同一个主存储器，可通过主存相互传送数据</li>
<li>一台计算机内，包含<strong>多个处理器+1个主存储器</strong></li>
<li>多个处理器<strong>共享</strong>单一的物理地址空间</li>
</ul>
</li>
<li><strong>多计算机</strong>：有多个私有地址空间
<ul>
<li>各计算机之间，不能通过LOAD/STORE指令直接访问对方的存储器，只能通过“<strong>消息传递</strong>”相互传送数据</li>
<li>由多台计算机组成，因此拥有<strong>多个处理器+多个主存储器</strong></li>
<li>每台计算机拥有各自的私有存储器，物理地址空间相互独立</li>
</ul>
</li>
</ul>
</li>
<li>按<strong>存储访问时间是否一致</strong>划分
<ul>
<li><strong>一致性</strong>内存访问 (UMA) 结构：处理器对所有存储单元的访问时间一致</li>
<li><strong>非一致性</strong>内存访问 (NUMA) 结构：处理器对不同的存储单元的访问时间可能不一致</li>
</ul>
</li>
<li>按<strong>处理单元的位置及其互联方式</strong>划分
<ul>
<li><strong>多核芯片</strong>：在一个 CPU 芯片中包含多个处理单元，称为<strong>片级多处理器</strong></li>
<li><strong>对称多处理器</strong>：指将多个相同类型的 CPU 通过总线互连，属于 <strong>UMA 结构多处理器</strong></li>
</ul>
</li>
<li><strong>硬件多线程</strong>：在线程阻塞时处理器可切换到另一线程的实现</li>
</ul>
</li>
<li><strong>向量处理机</strong>（<strong>SIMD思想的进阶应用</strong>）
<ul>
<li>一条指令的处理对象是“向量”</li>
<li>擅长对<strong>向量型数据并行计算、浮点数运算</strong>，常被用于<strong>超级计算机</strong>中，处理科学研究中巨大运算量</li>
<li><strong>多个处理单元+多组“向量寄存器&quot;</strong></li>
<li>主存储器应采用“多个端口同时读取”的交叉多模块存储器</li>
<li><strong>主存储器大小</strong>限定了机器的解题规模，因此要有大容量的、集中式的主存储器</li>
</ul>
</li>
</ul>
<h3 id="多核处理器">多核处理器</h3>
<ul>
<li>
<p>将<strong>多个处理单元集成到单个 CPU</strong> 中，每个处理单元称为一个<strong>核（core）</strong></p>
</li>
<li>
<p><strong>多核处理机 = 多处理机系统 = 共享内存多处理机</strong></p>
</li>
<li>
<p>多个处理器共享一个主存储器</p>
</li>
<li>
<p>多个处理器共享单一的地址空间，都可以通过LOAD、STORE指令访问共享的主存储器</p>
</li>
<li>
<p>每个核可以<strong>有自己的 Cache，也可以共享一个 Cache</strong></p>
</li>
<li>
<p>所有核一般都是对称的，并且共享主存，因此<strong>多核属于共享存储的对称多处理器</strong></p>
</li>
<li>
<p>在多核计算机系统中，若要充分发挥硬件的性能，必须采用<strong>多线程执行</strong>，使每个核在<strong>同一时刻都有线程在执行</strong>，这是真正的并行执行</p>
</li>
<li>
<p><strong>通俗理解</strong>：以前 CPU 是 “一个厨房一个厨师”（单核），现在是 “一个厨房塞多个厨师”（多核）—— 比如 4 核 CPU 就是 4 个厨师挤在同一个 CPU 里，每个厨师（核）都能独立干活。</p>
</li>
<li>
<p><strong>关键细节</strong>：</p>
<ol>
<li><strong>每个厨师有 “专属小食材柜”</strong>：每个核可以有自己的 Cache（高速缓存，像厨师手边的小抽屉，放常用的盐、油），也能和其他厨师共用一个 “大食材柜”（共享 Cache，比如厨房中间的调料台）。</li>
<li><strong>所有厨师共用 “大仓库”</strong>：不管有多少核，都共享电脑的主存（相当于餐厅的食材仓库），要拿不常用的食材（比如面粉），都去同一个仓库取。</li>
<li><strong>必须 “多线程” 才不浪费</strong>：要是只让一个厨师忙（单线程，比如只开一个游戏），其他厨师闲着，多核就白买了！得让每个厨师都有活干（多线程，比如同时开游戏、微信、浏览器），才能真正 “并行干活”（比如厨师 A 炒游戏的 “数据菜”，厨师 B 切微信的 “消息菜”）。</li>
</ol>
</li>
</ul>
<h3 id="共享内存处理器（SMP）">共享内存处理器（SMP）</h3>
<ul>
<li><strong>定义</strong>：具有共享的<strong>单一物理地址空间</strong>的多处理器</li>
<li>处理器通过存储器中的共享变量相互通信，所有处理器都能通过存取指令访存任何存储器的位置</li>
<li>即使这些系统共享同一个物理地址空间，它们仍然可以在自己的虚拟地址空间中单独地运行程序</li>
<li><strong>通俗理解</strong>：不管有多少个处理器（厨师），大家都用 “同一个物理地址的食材架”（共享主存）—— 比如 3 个处理器要拿 “番茄”，不用问对方 “你家番茄在哪”，直接去 “主存第 123 号位置” 拿，地址都一样。</li>
<li><strong>怎么干活</strong>：厨师们靠 “共享食材架上的纸条”（共享变量）沟通 —— 比如厨师 A 炒完菜，在食材架贴张纸条 “红烧肉好了”，厨师 B 看到纸条就知道 “该盛盘了”，不用喊来喊去。</li>
<li>单一地址空间的多处理器分类
<ul>
<li><strong>统一存储访问（UMA）多处理器</strong>：
<ul>
<li>根据处理器与共享存储器之间的连接方式分为基于<strong>总线</strong>、基于<strong>交叉开关网络</strong>和基于<strong>多级交换网络</strong>连不管有多少个处理器（厨师），大家都用 “同一个物理地址的食材架”（共享主存）—— 比如 3 个处理器要拿 “番茄”，不用问对方 “你家番茄在哪”，直接去 “主存第 123 号位置” 拿，地址都一样。接等几种处理器</li>
<li>每个处理器对所有存储单元的<strong>访问时间都是大致相同</strong>的</li>
<li><strong>通俗理解</strong>：厨房中间放一个超大食材架，不管厨师 A 站左边、厨师 B 站右边，伸手拿食材的时间都差不多（比如都要 1 秒）。</li>
</ul>
</li>
<li><strong>非统一存储访问（NUMA）多处理器</strong>：
<ul>
<li>某些存储器的访存速度较快，具体取决于哪个处理器退出访问请求及访问哪个字【由于主存被分割给了不同的处理器】
<ul>
<li><strong>通俗理解</strong>：厨房被分成 3 块区域，每个厨师旁边都有一个 “小食材架”（本地内存），厨师 A 拿自己旁边的鸡蛋只要 0.5 秒；但要拿厨师 B 旁边的牛肉，得走过去，要 2 秒 —— 访存速度取决于 “哪个厨师去拿” 和 “拿哪个区域的食材”。</li>
</ul>
</li>
<li>处理器中<strong>不带高速缓存</strong>时，被称为 <strong>NC-NUMA</strong>
<ul>
<li><strong>通俗理解</strong>：厨师没带 “随身小抽屉”（没有 Cache），要拿食材必须去区域小食材架或大仓库，慢得很。</li>
</ul>
</li>
<li>处理器中带有<strong>一致性高速缓存</strong>时，被称为 <strong>CC-NUMA</strong>（某些访问请求要比其他的快）
<ul>
<li><strong>通俗理解</strong>：厨师带了 “随身小抽屉”（有 Cache），常用的食材放抽屉里，不用总跑大仓库；而且抽屉里的食材和其他厨师的抽屉 “同步”（比如厨师 A 抽屉里的盐用完了，会自动从大仓库补，不会和厨师 B 的盐不一样），所以大部分时候拿食材都快。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="硬件多线程">硬件多线程</h3>
<ul>
<li>引入硬件多线程的<strong>目的</strong>：<strong>为了减少开销</strong></li>
<li>硬件多线程中必须为<strong>每个线程提供单独的通用寄存器组、单独的程序计数器</strong>等</li>
<li>线程的激活只<strong>需要激活选中的寄存器</strong>，从而省略了与存储器数据交换的环节，节省了开销</li>
<li><strong>通俗理解</strong>：硬件多线程让 <strong>CPU 同时 “假装” 运行多个线程</strong>（比如游戏、微信、浏览器同时跑），但 CPU 物理核心有限。为了让 CPU 不闲着，给每个线程配独立 “工具包”（通用寄存器、程序计数器），切换时只需 “换工具包”，不用把数据存到内存（省时间）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502171515.png" alt="image.png"></li>
</ul>
<h4 id="细粒度多线程">细粒度多线程</h4>
<ul>
<li>多个线程之间<strong>轮流交叉执行指令</strong>，多个线程之间的指令是互不相关的</li>
<li>可以<strong>乱序并行</strong>执行</li>
<li>该方式下，处理器能在每个时钟周期切换线程</li>
<li>实现<strong>指令级并行</strong></li>
<li><strong>通俗理解</strong>：厨房（CPU）里，厨师 A 炒 1 分钟菜，立刻换厨师 B 炒 1 分钟，再换厨师 C… 哪怕 A 的菜还没炒完，也强行换班</li>
<li><strong>核心特点</strong>：
<ul>
<li><strong>切换频率高</strong>：每个时钟周期（比如 1 纳秒）就换线程，像 “轮班制”；</li>
<li><strong>切换代价低</strong>：只需要换 “工具包”（寄存器），不用清理灶台（流水线）；</li>
<li><strong>指令执行</strong>：多个线程的指令<strong>轮流交叉执行</strong>（示例图 a：i 周期跑 A，i+1 跑 B，i+2 又跑 A），让 CPU 一直忙。</li>
</ul>
</li>
</ul>
<h4 id="粗粒度多线程">粗粒度多线程</h4>
<ul>
<li>
<p><strong>连续几个时钟周期</strong>都执行<strong>同一线程</strong>的指令序列</p>
</li>
<li>
<p>仅在<strong>一个线程出现较大开销的阻塞</strong>时，才切换线程；如 Cache 缺失</p>
</li>
<li>
<p>当发生流水线阻塞的时候，必须清除被阻塞的流水线</p>
</li>
<li>
<p>新线程的指令开始执行前需要重载流水线，<strong>开销较上一种较大</strong></p>
</li>
<li>
<p>实现<strong>指令级并行</strong></p>
</li>
<li>
<p><strong>通俗理解</strong>：：厨师 A 在厨房炒红烧肉，突然发现没酱油了（Cache 缺失，大阻塞），才让厨师 B 进来炒青菜。换班时得把 A 的锅碗瓢盆全清走（重载流水线），特别麻烦，所以尽量不换。</p>
</li>
<li>
<p><strong>核心特点</strong>：</p>
<ul>
<li><strong>切换频率低</strong>：只有线程<strong>卡壳（如 Cache miss、长延迟操作）</strong> 时才换；</li>
<li><strong>切换代价高</strong>：要清空流水线、重新加载新线程的指令，像 “大扫除后再开工”；</li>
<li><strong>指令执行</strong>：同一线程连续跑多个周期（示例图 b：A 跑 i、i+1 周期，直到 i+1 发现 Cache miss 才换 B）。</li>
</ul>
</li>
</ul>
<h4 id="同时多线程（SMT）">同时多线程（SMT）</h4>
<ul>
<li>
<p>又叫做<strong>超线程技术 HT</strong></p>
</li>
<li>
<p>在实现指令级并行的同时，实现<strong>线程级并行</strong></p>
</li>
<li>
<p><strong>通俗理解</strong>：：厨房有两个灶台、两个炒锅、两个切菜板… 厨师 A 用灶台 1 炒鸡蛋，同时厨师 B 用灶台 2 煎牛排，甚至厨师 C 还能用电饭煲焖饭，<strong>同一时间多个线程一起干活</strong></p>
</li>
<li>
<p><strong>核心特点</strong>：</p>
<ul>
<li><strong>并行发射</strong>：同一时钟周期内，<strong>多个线程的指令同时发射</strong>（示例图 c：i 周期，A 的 j、j+1 和 B 的 k、k+1 同时执行）；</li>
<li><strong>硬件利用满</strong>：CPU 里的多个功能部件（如 ALU、乘法器）被不同线程同时占用，既让单个线程内的指令并行（指令级并行），又让多个线程同时跑（线程级并行）；</li>
<li><strong>切换？不需要</strong>：因为本来就同时跑，不用切换，直接 “边等边干”。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>硬件多线程维度</strong></th>
<th>细粒度多线程</th>
<th>粗粒度多线程</th>
<th>同时多线程（SMT）</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令发射</td>
<td>轮流发射各线程指令（每时钟周期发射一个线程）</td>
<td>连续多周期发射同一线程指令，流水线阻塞时切换线程</td>
<td>单时钟周期内同时发射多线程指令</td>
</tr>
<tr>
<td>线程切换频率</td>
<td>每时钟周期切换一次</td>
<td>仅流水线阻塞时切换</td>
<td>NULL</td>
</tr>
<tr>
<td>线程切换代价</td>
<td>低</td>
<td>高（需重载流水线）</td>
<td>NULL</td>
</tr>
<tr>
<td>并行性</td>
<td><strong>指令级并行</strong>，线程间不并行</td>
<td><strong>指令级并行</strong>，线程间不并行</td>
<td><strong>指令级 + 线程级并行</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>细粒度：<strong>高频轮班，不让 CPU 闲</strong>；</li>
<li>粗粒度：<strong>卡壳才换，换一次超麻烦</strong>；</li>
<li>SMT同时多线程/超线程技术：<strong>多线程同干，硬件榨干性能</strong>。</li>
<li>它们的物理资源（ALU、Cache、访存端口）<strong>共享</strong>（多线程同时占用）；每个线程的通用寄存器组、PC<strong>独立</strong></li>
<li>都属于单个物理CPU</li>
<li>补充：双核CPU：在<strong>同一块 CPU 芯片中，集成两个独立的 “处理核心（物理核）”</strong>。每个核心都像一个迷你 CPU，能独立执行指令、运算数据，相当于 “把两个 CPU 打包进一个芯片里”。<br>
特点：并行干活；共享物理内存；每个核心有自己的<strong>寄存器组、程序计数器（PC）、L1 Cache</strong>；缓存一致性</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th>双核 CPU（物理双核）</th>
<th>超线程（SMT，逻辑双核）</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>真・两个物理核心</td>
<td>一个物理核心<strong>模拟</strong>两个逻辑核心</td>
</tr>
<tr>
<td>资源独立性</td>
<td>每个核心独立 ALU、寄存器等</td>
<td>共享物理核心的 ALU、Cache 等资源</td>
</tr>
<tr>
<td>多任务冲突</td>
<td>物理核独立，冲突少</td>
<td>逻辑核共享资源，高负载时易 “抢资源”</td>
</tr>
</tbody>
</table>
<h2 id="错题">错题</h2>
<ol>
<li>
<p><strong>条件转移指令执行时所依据的条件来自()<br>
A.指令寄存器   B.标志寄存器   C.程序计数器   D.地址寄存器</strong><br>
B</p>
</li>
<li>
<p><strong>指令（ ）从主存储器中读出。<br>
A. 总是根据程序计数器<br>
B. 有时根据程序计数器，有时根据转移指令<br>
C. 根据地址寄存器<br>
D. 有时根据程序计数器，有时根据地址寄存器</strong><br>
程序计数器（PC）的作用是存放下一条要执行指令在主存中的地址 。在指令执行过程中，正常顺序执行时，PC 自动递增指向下一条指令地址；遇到转移类指令（如跳转指令）时，会将转移目标地址送入 PC 。但不管哪种情况，最终都是依据 PC 中存储的地址从主存储器中读出指令，所以指令总是根据程序计数器从主存储器中读出，A 正确<br>
地址寄存器主要用于在数据传输过程中暂存地址，和指令从主存读出的依据关系不大 。</p>
</li>
<li>
<p><strong>程序计数器（PC）可以使用字节地址或字地址，其位数取决于（ ）。 I. 存储器的容量 II. 机器字长 III. 指令字长 A. I B. I 和 III C. II 和 III D. I、II 和 III</strong><br>
当 PC 使用字节地址时，其位数取决于存储器的容量，因为要能表示存储器中所有字节单元的地址；当使用字地址时，指令需按边界对齐存放，PC 位数 = 存储器地址的位数 - log2(指令字长的字节数)，所以和指令字长有关。而机器字长与 PC 位数并无直接决定关系 。所以 PC 位数取决于存储器的容量和指令字长，选 B。</p>
</li>
<li>
<p><strong>下列关于程序计数器（PC）的叙述中，错误的是（ ）。<br>
A. 机器指令中不能显式地使用 PC<br>
B. 指令顺序执行时，PC 值总是自动加 1<br>
C. 调用指令执行后，PC 值一定是被调用过程的入口地址<br>
D. 无条件转移指令执行后，PC 值一定是转移目标地址</strong><br>
<strong>A 选项</strong>：机器指令中一般不会直接显式使用 PC，该选项正确。<br>
<strong>B 选项</strong>：指令顺序执行时，PC 值加的不一定是 1。若指令按字节编址，且指令长度为n字节，那么 PC 要加n；若按字编址，PC 增量也不是简单加 1 ，所以该选项错误。<br>
<strong>C 选项</strong>：调用指令执行后，通常会将被调用过程的入口地址送入 PC，使程序转向被调用过程执行，该选项正确。<br>
<strong>D 选项</strong>：无条件转移指令执行后，会将转移目标地址送入 PC，从而使程序跳转到目标地址执行，该选项正确。</p>
</li>
<li>
<p><strong>指令译码是指对()进行译码<br>
A.整条指令   B.指令的操作码字段   C.指令的地址码字段   D.指令的地址</strong><br>
B</p>
</li>
<li>
<p><strong>间址周期结束后，CPU内寄存器 MDR中的内容为()<br>
A.指令   B.操作数地址   C.操作数   D.无法确定</strong><br>
B   间址周期是为了获取操作数的有效地址。在间接寻址方式中，指令中的地址字段给出的是操作数地址的地址 ，需要通过访存来得到真正的操作数地址。</p>
</li>
<li>
<p><strong>某计算机的主存储器空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是（ ）<br>
A. 30, 30 B. 30, 32 C. 32, 30 D. 32, 32</strong><br>
主存容量 4GB，按字节编址，4GB=2^32字节，地址空间为2^32个字节单元。但指令按字边界对齐存放，指令字长 32 位即 4 字节，所以地址只需表示到字单元，字单元数量为2^32÷4=2^30 ，因此 PC 宽度至少 30 位。IR位数等于指令字长。选B</p>
</li>
<li>
<p><strong>下列关于指令执行的叙述中，错误的是（ ）。<br>
A. 指令周期的第一个操作是取指令<br>
B. 为了进行取指操作，控制器需要得到相应的指令<br>
C. 取指操作是控制器自动进行的<br>
D. 指令执行时有些操作是相同或相似的</strong><br>
控制器是依据程序计数器（PC）提供的地址去取指令，而不是先得到相应指令才进行取指操作，逻辑错误，B错误。</p>
</li>
<li>
<p><strong>下列关于 CPU 时钟信号的叙述中，错误的是（ ）。<br>
A. 处理器总是每来一个时钟信号就开始执行一条新的指令<br>
B. 边沿触发指状态单元总在时钟上升沿或下降沿开始改变状态<br>
C. 时钟周期以相邻状态单元之间最长组合逻辑延迟为基准确定<br>
D. 每个时钟周期称为一个节拍，机器的主频就是时钟周期的倒数</strong><br>
A 选项：处理器执行指令的过程包括取指、译码、执行等阶段，并不是每来一个时钟信号就开始执行一条新指令，一条指令的执行可能跨越多个时钟周期，该选项错误。<br>
B 选项：边沿触发的状态单元确实在时钟上升沿或下降沿改变状态，该选项正确。<br>
C 选项：为保证电路正常工作，时钟周期要以相邻状态单元之间最长组合逻辑延迟为基准确定，该选项正确。<br>
D 选项：时钟周期也叫节拍，主频是时钟周期的倒数，该选项正确。</p>
</li>
<li>
<p><strong>下列关于多周期 CPU 的说法中，合理的是（ ）。<br>
A. 执行各条指令的时钟周期数相同，各时钟周期的长度均匀<br>
B. 执行各条指令的时钟周期数相同，各时钟周期的长度可变<br>
C. 执行各条指令的时钟周期数可变，各时钟周期的长度均匀<br>
D. 执行各条指令的时钟周期数可变，各时钟周期的长度可变</strong><br>
多周期 CPU 把指令的执行分为多个阶段来实现，每个阶段在一个时钟周期内完成，时钟周期以最复杂的阶段所花的时间为准，阶段的划分原则是：将一条指令的执行过程尽量分成大致相等的若干阶段。不同的指令(根据指令的复杂程度)所含的时钟周期数可以不同。</p>
</li>
<li>
<p><strong>下列有关数据通路的叙述中，错误的是（ ）。<br>
A. 数据通路由若干组合逻辑元件和时序逻辑元件连接而成<br>
B. 数据通路的功能由控制部件送出的控制信号决定<br>
C. ALU 属于操作元件，包含在数据通路中<br>
D. 通用寄存器属于状态元件，但不包含在数据通路中<br>
A 选项</strong>：数据通路是由组合逻辑元件（如 ALU 等）和时序逻辑元件（如寄存器等）连接组成的，用于实现数据的传输和处理，该选项正确。<br>
<strong>B 选项</strong>：控制部件发出的控制信号决定数据通路中各个部件的操作和数据流动方向等，从而决定数据通路的功能，该选项正确。<br>
<strong>C 选项</strong>：算术逻辑单元（ALU）用于进行算术和逻辑运算，是数据通路中的操作元件，该选项正确。<br>
<strong>D 选项</strong>：通用寄存器用于暂存数据，是状态元件，并且包含在数据通路中，用于数据的暂存和传输等操作，该选项错误。</p>
</li>
<li>
<p><strong>数据通路是由操作元件和状态元件通过总线或分散方式连接而成的进行数据存储、处理和传送的路径，下列部件中属于状态元件的是（ ）。</strong><br>
<strong>I. 算术逻辑部件 II. 译码器 III. 移位寄存器 IV. 存储器数据寄存器</strong><br>
<strong>A. I、III B. II、III、V C. III、IV D. I、IV</strong><br>
<strong>状态元件特点</strong>：状态元件用于存储数据，具有记忆功能，能够保存当前的状态信息 。<br>
<strong>I. 算术逻辑部件（ALU）</strong>：主要功能是进行算术运算和逻辑运算，属于操作元件，用于对数据进行处理，而非存储数据，所以 I 不属于状态元件。<br>
<strong>II. 译码器</strong>：功能是对输入的代码进行翻译，得到对应的控制信号或操作信号，属于操作元件，不是用于存储数据的，所以 II 不属于状态元件。<br>
<strong>III. 移位寄存器</strong>：可以存储数据，并且能够对存储的数据进行移位操作，具有存储数据的功能，属于状态元件。<br>
<strong>IV. 存储器数据寄存器（MDR）</strong> ：用于暂存从存储器中读出的数据或者准备写入存储器的数据，起到数据存储的作用，属于状态元件。</p>
</li>
<li>
<p><strong>下列关于采用单总线方式的 CPU 的说法中，正确的是（ ）。</strong><br>
<strong>A. ALU 的两个输入端及输出端都可与总线相连</strong><br>
<strong>B. ALU 的两个输入端可以与总线相连，但输出端需通过暂存器与总线相连</strong><br>
<strong>C. ALU 的一个输入端可以与总线相连，其输出端也可与总线相连</strong><br>
<strong>D. ALU 只能有一个输入端可以与总线相连，另一输入端需通过暂存器与总线相连</strong><br>
在单总线结构的 CPU 中，为避免数据冲突，同一时刻总线上只能有一路数据传输。ALU 进行运算时，若两个输入端都直接连总线，会导致数据冲突。通常一个输入端与总线相连获取数据，另一个输入端通过暂存器获取经总线暂存的数据 ，所以 D 正确</p>
</li>
<li>
<p><strong>CPU 内部若多个部件共享一条总线，则每个部件与总线之间需设置一个常用的器件，CPU 控制该器件的状态，实现某个部件与总线的连接或断开。该器件是（ ）。</strong><br>
<strong>A. 触发器</strong><br>
<strong>B. 多路选择器</strong><br>
<strong>C. 三态门</strong><br>
<strong>D. 与非门</strong><br>
C。三态门可视为一种控制开关，由控制端决定信号线的通断，能输出到内部总线的部件均通过个三态门与内部总线相连，用于控制该部件与内部总线之问数据通路的连接与断开。</p>
</li>
<li>
<p><strong>CPU 内部电路通常采用总线连接方式，总线上信号流动的原则是（ ）。</strong><br>
<strong>I. 每个时刻只有一个器件发送信息</strong><br>
<strong>II. 每个时刻有一个或多个器件发出信息</strong><br>
<strong>III. 每个时刻只有一个器件接收信息</strong><br>
<strong>IV. 每个时刻有一个或多个器件接收信息</strong><br>
<strong>A. I、III</strong><br>
<strong>B. I、IV</strong><br>
<strong>C. II、III</strong><br>
<strong>D. II、IV</strong><br>
在单总线结构中，同一时刻只能有一个器件向总线发送信息，否则信号会冲突；但可以有一个或多个器件接收总线上的信息 ，所以 I、IV 正确，答案为 B。</p>
</li>
<li>
<p><strong>下列关于单周期数据通路和多周期数据通路的说法中，正确的是（ ）。<br>
A. 单周期 CPU 的 CPI 总比多周期 CPU 的 CPI 大<br>
B. 单周期 CPU 的时钟周期通常比多周期 CPU 的时钟周期短<br>
C. 在一条指令执行过程中，单周期 CPU 中的每个控制信号取值一直不变，而多周期 CPU 中的控制信号可能发生改变<br>
D. 在一条指令执行过程中，单周期数据通路和多周期数据通路中的每个部件都可使用多次<br>
A 选项</strong>：CPI（执行一条指令所需的时钟周期数），单周期 CPU 中一条指令在一个时钟周期内完成，CPI = 1 ；多周期 CPU 中一条指令由多个时钟周期完成，CPI ＞ 1 ，所以单周期 CPU 的 CPI 比多周期 CPU 的 CPI 小 ，A 错误。<br>
<strong>B 选项</strong>：单周期 CPU 中，时钟周期要满足最复杂指令的执行时间，通常较长；多周期 CPU 中不同指令阶段可采用不同时长时钟周期，整体时钟周期相对较短，B 错误。<br>
<strong>C 选项</strong>：单周期 CPU 在一个时钟周期内完成指令执行，控制信号在指令执行期间无需改变；多周期 CPU 指令分多个阶段执行，不同阶段可能需要不同控制信号，控制信号会发生改变 ，C 正确。<br>
<strong>D 选项</strong>：单周期数据通路中，每个部件在一个时钟周期内按固定顺序使用一次；多周期数据通路中，部件可在不同周期按需多次使用 ，D 错误。</p>
</li>
<li>
<p><strong>采用 CPU 内部总线的数据通路与不采用 CPU 内部总线的数据通路相比，（ ）。</strong><br>
<strong>A. 前者性能较高</strong><br>
<strong>B. 后者的数据冲突问题较严重</strong><br>
<strong>C. 前者的硬件量大，实现难度高</strong><br>
<strong>D. 以上说法都不对</strong><br>
D。采用 CPU 内部总线的数据通路，结构相对简单、硬件量小，但存在数据冲突等问题，性能不一定高；不采用内部总线的数据通路，硬件量大、实现复杂，数据冲突问题相对不突出。A、B、C 说法均错误，所以选 D。</p>
</li>
<li>
<p><strong>【2016 统考真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是（ ）。</strong><br>
<strong>A. 可以采用单总线结构数据通路</strong><br>
<strong>B. 处理器时钟频率较低</strong><br>
<strong>C. 在指令执行过程中控制信号不变</strong><br>
<strong>D. 每条指令的 CPI 为 1</strong><br>
单周期处理器中，所有指令在一个时钟周期内完成，CPI = 1 ，可采用单总线结构数据通路，指令执行过程控制信号不变。为保证最复杂指令能在一个时钟周期内完成，时钟周期较长，对应的时钟频率较高，B 说法错误。</p>
</li>
<li>
<p><strong>【2021 统考真题】下列关于数据通路的叙述中，错误的是（ ）。</strong><br>
<strong>A. 数据通路包含 ALU 等组合逻辑（操作）元件</strong><br>
<strong>B. 数据通路包含寄存器等时序逻辑（状态）元件</strong><br>
<strong>C. 数据通路不包含用于异常事件检测及响应的电路</strong><br>
<strong>D. 数据通路中的数据流动路径由控制信号进行控制</strong><br>
数据通路包含 ALU 等组合逻辑元件、寄存器等时序逻辑元件 ，数据流动路径由控制信号控制。同时，数据通路也包含用于异常事件检测及响应的电路，C 说法错误</p>
</li>
<li>
<p><strong>取指令操作（ ）。</strong><br>
<strong>A. 受到上一条指令的操作码控制</strong><br>
<strong>B. 受到当前指令的操作码控制</strong><br>
<strong>C. 受到下一条指令的操作码控制</strong><br>
<strong>D. 是控制器固有的功能，不需要在操作码控制下进行</strong><br>
D。取指令是控制器公共流程（如 PC 取指、更新），与指令操作码无关（操作码用于执行阶段译码），属于固有功能，无需操作码控制。</p>
</li>
<li>
<p><strong>在组合逻辑控制器中，微操作控制信号的形成主要与（ ）信号有关。</strong><br>
<strong>A. 指令操作码和地址码</strong><br>
<strong>B. 指令译码信号和时钟</strong><br>
<strong>C. 操作码和条件码</strong><br>
<strong>D. 状态信息和条件</strong><br>
B。组合逻辑（硬布线）通过指令译码（解析操作码，生成译码信号）和时钟节拍（时序控制）生成控制信号，地址码（A）用于寻址，条件码（C、D）非核心，故 B 正确。</p>
</li>
<li>
<p><strong>在微程序控制器中，形成微程序入口地址的是（ ）。</strong><br>
<strong>A. 机器指令的地址码字段</strong><br>
<strong>B. 微指令的微地址码字段</strong><br>
<strong>C. 机器指令的操作码字段</strong><br>
<strong>D. 微指令的微操作码字段</strong><br>
C。微程序入口由机器指令操作码（OP）映射（如<code>OP(IR)→CMAR</code>）<br>
地址码（A）用于<strong>数据寻址</strong><br>
微地址码（B）是微指令内的下地址，控制微程序内部跳转<br>
微操作码（D）对应微命令，控制硬件操作（如激活寄存器传输、运算单元，通过编码生成控制信号）</p>
</li>
<li>
<p><strong>下列不属于微指令结构设计所追求目标的是（ ）。</strong><br>
A. 提高微程序的执行速度<br>
B. 提供微程序设计的灵活性<br>
C. 缩短微指令的长度<br>
D. 增大控制存储器的容量<br>
D。微指令设计追求速度、灵活、短字长（减少 CM 容量），而非增大 CM 容量。</p>
</li>
<li>
<p><strong>下列关于微指令的说法中，错误的是（ ）。</strong><br>
<strong>I. 字段直接编码方式可用较少的二进制位数表示较多的微操作命令。若有两组互斥的微命令，每组微命令的个数分别为 4 和 9，则分别只需要 2 位和 4 位即可</strong><br>
<strong>II. 直接编码方式不用进行译码操作，微指令字段中的每一位都代表一个微命令</strong><br>
<strong>III. 垂直型微指令用较长的微程序结构换取较短的微指令结构，所以在执行效率和灵活性两方面都高于水平型微指令</strong><br>
<strong>IV. 在字段间接编码方式中，某个字段的译码输出需要依靠另外某个字段的输出</strong><br>
<strong>A. II</strong><br>
<strong>B. I、II</strong><br>
<strong>C. I、III</strong><br>
<strong>D. II、III、IV</strong></p>
<ul>
<li><strong>I 错误</strong>：字段直接编码中，4 个微命令需 3 位（含不操作，2³≥5），而非 2 位。</li>
<li><strong>II 正确</strong>：直接编码每位代表微命令，无需译码。</li>
<li><strong>III 错误</strong>：垂直型微指令执行效率（微程序长、速度慢）和灵活性（功能单一，不如水平型灵活）均低于水平型。</li>
<li><strong>IV 正确</strong>：字段间接编码中，字段译码依赖另一字段。</li>
</ul>
</li>
<li>
<p><strong>微程序控制存储器属于（ ）的一部分。</strong><br>
<strong>A. 主存</strong><br>
<strong>B. 外存</strong><br>
<strong>C. CPU</strong><br>
<strong>D. 缓存</strong><br>
C。微程序控制存储器用于存放微程序，而微程序控制器是 CPU 的重要组成部分 ，所以微程序控制存储器属于 CPU。主存主要用于存放正在运行的程序和数据；外存用于长期存储大量数据；缓存是为了解决 CPU 和主存速度不匹配问题，用于暂存 CPU 近期可能会频繁访问的数据和指令。</p>
</li>
<li>
<p><strong>下列说法中，正确的是（ ）。</strong><br>
<strong>A. 采用微程序控制器是为了提高速度</strong><br>
<strong>B. 控制存储器由高速 RAM 电路组成</strong><br>
<strong>C. 微指令计数器决定指令执行顺序</strong><br>
<strong>D. 一条微指令存放在控制器的一个控制存储器单元中</strong></p>
<ul>
<li><strong>A 错</strong>：微程序控制器简化设计，非提速（硬布线更快）。</li>
<li><strong>B 错</strong>：控存用 ROM（非易失，固化微程序），非 RAM（易失）。</li>
<li><strong>C 错</strong>：μPC 控制微指令顺序（微程序内），指令顺序由 PC（机器指令）控制。</li>
<li><strong>D 对</strong>：控存每个单元存一条微指令，与主存单元存机器指令类似。</li>
</ul>
</li>
<li>
<p><strong>在微程序控制器中，控制部件向执行部件发出的某个控制信号称为（ ）。</strong><br>
<strong>A. 微程序</strong><br>
<strong>B. 微指令</strong><br>
<strong>C. 微操作</strong><br>
<strong>D. 微命令</strong><br>
微命令是控制部件发出的单个控制信号（D 对）；微程序是微指令序列（A 错），微指令包含多微命令（B 错），微操作是执行部件动作（C 错）。</p>
</li>
<li>
<p><strong>垂直型微指令的特点是（ ）。</strong><br>
<strong>A. 控制信号经过编码产生</strong><br>
<strong>B. 强调并行控制功能</strong><br>
<strong>C. 采用微操作码</strong><br>
<strong>D. 微指令格式垂直表示</strong></p>
<ul>
<li><strong>A 错</strong>：编码产生控制信号是字段编码特性，非垂直型微指令特点（垂直型多直接给出信号）。</li>
<li><strong>B 错</strong>：并行控制是<strong>水平型</strong>微指令特点（多字段并行操作），垂直型并行性差。</li>
<li><strong>C 对</strong>：垂直型微指令类似机器指令，每条含<strong>微操作码</strong>（对应单一基本操作，功能简单，微程序长）。</li>
<li><strong>D 错</strong>：“格式垂直表示” 表述无意义，垂直型核心是<strong>功能单一（微操作码对应基本操作）</strong>。</li>
</ul>
</li>
<li>
<p><strong>下列说法中，正确的是（ ）。</strong><br>
<strong>I. 微程序控制方式和硬布线方式相比较，前者可以使指令的执行速度更快</strong><br>
<strong>II. 若采用微程序控制方式，则可用 μPC 取代 PC</strong><br>
<strong>III. 控制存储器可以用 ROM 实现</strong><br>
<strong>IV. 指令周期也称 CPU 时钟周期</strong><br>
<strong>A. I、III</strong><br>
<strong>B. II、III</strong><br>
<strong>C. 只有 III</strong><br>
<strong>D. I、III、IV</strong></p>
<ul>
<li><strong>I 错</strong>：硬布线速度更快（无控存访问延迟），微程序控制慢。</li>
<li><strong>II 错</strong>：μPC 控微指令，PC 控机器指令，功能不同，不可取代。微程序控制方式中需要用到PC</li>
<li><strong>III 对</strong>：控存（如 ROM）存储微程序，常见实现。</li>
<li><strong>IV 错</strong>：指令周期≠CPU 时钟周期（前者含多个后者）。</li>
</ul>
</li>
<li>
<p><strong>下图是某微程序控制器的基本结构，μPC 是一个 8 位寄存器，μIR 是一个 32 位寄存器，一条机器指令平均由 4 条不同的微指令组成（不含取指部分），则下列描述中错误的是（ ）。</strong><br>
<strong>A. 微指令地址用增量法</strong><br>
<strong>B. 条件码来自标志寄存器</strong><br>
<strong>C. 最多 64 条机器指令</strong><br>
<strong>D. 控存容量 1KB</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250630211321102.png" alt="image.png|400"></p>
<ul>
<li><strong>A 对</strong>：微指令地址的产生方法有增量（计数）法、断定（下址字段）法，途中有μPC+1，是增量法生成微地址。</li>
<li><strong>B 对</strong>：条件码用于转移，通常来自标志寄存器（运算状态）</li>
<li><strong>C 错</strong>：μPC 8 位，能够指向256 微指令地址，其中包含若干取指微指令，因此机器指令的条数小于256/4=64</li>
<li><strong>D 对</strong>：容量=单元数×每条微指令位数=2^8×32bit=1024B=1KB，控存容量计算正确。</li>
</ul>
</li>
<li>
<p><strong>【2014 统考真题】某计算机采用微程序控制器，共有 32 条指令，公共的取指令微程序包含 2 条微指令，各指令对应的微程序平均由 4 条微指令组成，采用断定法（后继地址字段法）确定下条微指令地址，则微指令中后继地址字段的位数至少是（ ）。</strong><br>
<strong>A. 5</strong><br>
<strong>B. 6</strong><br>
<strong>C. 8</strong><br>
<strong>D. 9</strong><br>
先算总微指令数，32 条指令对应微指令数为 32×4 = 128 条，再加上公共取指令微程序的 2 条，共 128 + 2 = 130 条。要表示这些微指令地址，需满足 2^n≥130（n 为地址字段位数），2^7 = 128 不够，2^8 = 256 满足，所以 n 至少为 8。</p>
</li>
<li>
<p><strong>【2017 统考真题】下列关于主存储器（MM）和控制存储器（CS）的叙述，错误的是（ ）。</strong><br>
<strong>A. MM 在 CPU 外，CS 在 CPU 内</strong><br>
<strong>B. MM 按地址访问，CS 按内容访问</strong><br>
<strong>C. MM 存储指令和数据，CS 存储微指令</strong><br>
<strong>D. MM 用 RAM 和 ROM 实现，CS 用 ROM 实现</strong><br>
主存储器（MM）在 CPU 外部，按地址访问，存储指令和数据，可由 RAM 和 ROM 实现；控制存储器（CS）在 CPU 内部，按地址访问（并非按内容访问 ），用于存储微指令，常用 ROM 实现。所以 B 选项错误，按照内容的是相联存储器。</p>
</li>
<li>
<p><strong>【2019 统考真题】下列有关处理器时钟信号的叙述中，错误的是（ ）。</strong><br>
<strong>A. 时钟信号由机器脉冲源发出的脉冲信号经整形和分频后形成</strong><br>
<strong>B. 时钟信号的宽度称为时钟周期，时钟周期的倒数为机器主频</strong><br>
<strong>C. 时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定</strong><br>
<strong>D. 处理器总是在每来一个时钟信号时就开始执行一条新的指令</strong><br>
时钟信号由机器脉冲源发出的脉冲信号经整形和分频后得到，时钟信号宽度即时钟周期，其倒数是机器主频，时钟周期依据相邻状态单元间组合逻辑电路的最大延迟确定。而处理器执行新指令并非每来一个时钟信号就开始，要根据指令周期等情况，比如指令流水线中，不同阶段在不同时钟周期执行，所以 D 选项错误。</p>
</li>
<li>
<p><strong>【2019 统考真题】某指令的功能为 R [r2]←R [r1]+M [R [r0]]，其两个源操作数分别采用寄存器、寄存器间接寻址方式。对于下列给定部件，该指令在取数及执行过程中需要用到的是（ ）。</strong><br>
<strong>I. 通用寄存器组（GPRs）</strong><br>
<strong>II. 算术逻辑单元（ALU）</strong><br>
<strong>III. 存储器（Memory）</strong><br>
<strong>IV. 指令译码器（ID）</strong><br>
<strong>A. 仅 I、II  B. 仅 I、II、III  C. 仅 II、III、IV  D. 仅 I、III、IV</strong><br>
该指令的两个源操作数分别采用寄存器、寄存器间接寻址方式，取数阶段需用到通用寄存器组（GPRs）和存储器（Memory）；执行阶段，源操作数相加需用到算术逻辑单元（ALU）。按照将指令执行分为取值、译码、间址、取数、执行的流程，指令译码器（IV）在译码阶段已完成使命，取数及执行阶段不再用到。所以该指令在取数及执行过程中用到的是 I、II、III。</p>
</li>
<li>
<p><strong>【2021 统考真题】下列寄存器中，汇编语言程序员可见的是（ ）。</strong><br>
<strong>I. 指令寄存器</strong><br>
<strong>II. 微指令寄存器</strong><br>
<strong>III. 基址寄存器</strong><br>
<strong>IV. 标志 / 状态寄存器</strong></p>
<ul>
<li><strong>解析</strong>：指令寄存器用于存放当前指令，对汇编语言程序员透明；微指令寄存器存放微指令，也对其透明；基址寄存器可用于地址计算等，汇编语言程序员可见；标志 / 状态寄存器记录运算状态，汇编语言程序员可使用。所以 III、IV 对汇编语言程序员可见。</li>
<li><strong>答案</strong>：D</li>
</ul>
</li>
<li>
<p><strong>【2021 统考真题】通常情况下，将汇编语言程序中实现特定功能的指令序列定义成一条伪指令（pseudo - instruction）。在下列选项中，CPU 能理解并直接执行的是（ ）。</strong><br>
<strong>I. 伪指令</strong><br>
<strong>II. 微指令</strong><br>
<strong>III. 机器指令</strong><br>
<strong>IV. 汇编指令</strong><br>
A. 仅 I、IV  B. 仅 II、III  C. 仅 III、IV  D. 仅 I、III、IV<br>
B。高级语言程序、汇编语言程序需经翻译生成机器语言程序才能被 CPU 执行。机器指令能被 CPU 理解并直接执行。<br>
微指令是 CPU 控制单元用于实现机器指令的更底层指令，在微程序控制的 CPU 中，一条机器指令对应一个微程序（微指令有序序列），用来控制 CPU 实现机器指令的过程，微指令也能被 CPU 理解并直接执行。<br>
伪指令是汇编语言中为方便编程设置的指令，需经汇编程序处理，不能被 CPU 直接执行；汇编指令也需汇编成机器指令后才能被 CPU 执行。</p>
</li>
<li>
<p><strong>指令执行结果出现异常而引起的中断是（ ）。</strong><br>
<strong>A. I/O 中断  B. 机器校验中断  C. 故障  D. 外部中断</strong><br>
C。故障中断是指在指令执行过程中，因指令执行结果出现异常情况（如运算溢出、除数为零等）而引发的中断。I/O 中断是与输入输出设备相关操作引起的；机器校验中断更多是硬件本身校验出错（如内存奇偶校验错等硬件层面）；外部中断是由外部设备（如键盘、鼠标等）产生的非指令执行异常相关的中断请求。</p>
</li>
<li>
<p><strong>访问主存时发生的校验错误属于（ ）。</strong><br>
<strong>A. 故障  B. 自陷  C. 终止  D. 外中断</strong><br>
C。访问主存时发生校验错误属于终止中断。终止中断通常是由于出现严重的、不可恢复的错误导致，主存校验错误属于硬件层面较为严重的错误情况。故障中断虽然也是错误相关，但一般是指令执行过程中的异常；自陷是程序主动触发（如系统调用等）；外中断是外部设备（非主存相关硬件错误）引发的。</p>
</li>
<li>
<p><strong>下列给出的事件中，无须异常处理程序进行处理的是（ ）。</strong><br>
<strong>A. 缺页故障  B. Cache 缺失  C. 地址越界  D. 除数为 0</strong><br>
B。缺页故障需操作系统的缺页处理程序将页面从外存调入主存，需异常处理。Cache 缺失由硬件自动从主存读取，无需软件层面异常处理程序干预。地址越界属非法访问内存，需操作系统异常处理机制介入。除数为 0 是运算异常，需异常处理程序处理。</p>
</li>
<li>
<p><strong>下列关于异常 / 中断机制与进程上下文切换机制的叙述中，错误的是（ ）。</strong><br>
<strong>A. 进程上下文切换和异常 / 中断响应两者都会产生异常控制流。</strong><br>
<strong>B. 进程上下文切换后，CPU 执行的是另一个进程的代码。</strong><br>
<strong>C. 响应异常 / 中断请求后，CPU 执行的是内核程序的代码。</strong><br>
<strong>D. 进程上下文切换和异常 / 中断响应处理都通过执行内核程序实现。</strong><br>
D。解析：进程上下文切换由内核程序实现（正确），但异常 / 中断响应的<strong>触发是硬件机制</strong>（如 CPU 的异常检测模块），并非完全通过内核程序实现（硬件先检测，再转交内核处理）。因此 D 中 “都通过执行内核程序实现” 表述错误。A（均产生异常控制流，正确，见补充知识）、B（切换后执行另一进程代码，正确）、C（异常处理在内核态，正确）均无误。<br>
补充知识：进程上下文切换虽为系统正常调度机制，但从<strong>进程执行的局部视角</strong>，其<strong>控制流的突变（被内核强制中断和转移）</strong> 符合异常控制流的核心特征（非程序自身逻辑驱动的执行流改变，响应系统事件）。因此，进程上下文切换会产生异常控制流。</p>
</li>
<li>
<p><strong>异常或中断处理结束后，返回到被中断原程序继续执行的指令地址称为 “断点”，下列关于 “断点” 的说法中，错误的是（ ）。</strong><br>
<strong>A. “陷阱” 类异常的断点为陷阱指令下一条指令的地址</strong><br>
<strong>B. “故障” 类异常的断点为当前发生异常的指令的地址</strong><br>
<strong>C. 外部中断的断点总是当前刚执行完的指令的地址</strong><br>
<strong>D. “终止” 类异常的断点可以是当前指令或下一条指令的地址</strong><br>
<strong>C</strong>。解析：外部中断检测在<strong>一条指令执行完后、取下一条指令前</strong>，故响应后返回<strong>下一条指令地址</strong>（而非 “刚执行完的指令”）。A（陷阱后执行下一条，正确）、B（故障需重执行当前指令，断点为当前地址，正确）、D（终止类不返回，断点无意义，描述合理，正确）。C 错误。</p>
</li>
<li>
<p><strong>下列关于流水 CPU 基本概念的描述中，正确的是（ ）。</strong><br>
<strong>A. 流水 CPU 是以空间并行性为原理构造的处理器</strong><br>
<strong>B. 流水 CPU 一定是 RISC 机器</strong><br>
<strong>C. 流水 CPU 一定是多媒体 CPU</strong><br>
<strong>D. 流水 CPU 是一种非常经济而实用的时间并行技术</strong><br>
<strong>D</strong>。解析：流水线通过 “时间重叠” 让指令阶段并行（时间并行），非空间并行（A 错）；CISC 架构（如 x86）也可实现流水线（B 错）；流水线是执行效率优化，与多媒体指令集无关（C 错）；流水线复用硬件，成本低且高效，属时间并行技术（D 对）。</p>
</li>
<li>
<p><strong>流水 CPU 是由一系列称为 “段” 的处理电路组成的。一个 m 段流水线稳定时的 CPU 的吞吐能力，与 m 个并行部件的 CPU 的吞吐能力相比，( )。</strong><br>
<strong>A. 具有同等水平的吞吐能力</strong><br>
<strong>B. 不具备同等水平的吞吐能力</strong><br>
<strong>C. 吞吐能力大于前者的吞吐能力</strong><br>
<strong>D. 吞吐能力小于前者的吞吐能力</strong><br>
<strong>A</strong>。解析：流水线稳定后，<strong>每个时钟周期完成 1 条指令</strong>；m 个并行部件（空间并行）理想下也可<strong>每个时钟周期完成 1 条指令</strong>（并行部件同步，效率与时间并行等价），故吞吐能力相当（A 对）。</p>
</li>
<li>
<p><strong>设指令由取指、分析、执行 3 个子部件完成，并且每个子部件的时间均为 Δt，若采用度为 4 的超标量流水线处理机，连续执行 20 条指令，只需（ ）。</strong><br>
<strong>A. 3Δt B. 5Δt C. 7Δt D. 9Δt</strong><br>
<strong>C</strong>。解析：超标量度 4（每周期发 4 条），首 3Δt 建流水线，剩余 16 条需 4Δt，总 3+4=7Δt。<br>
相当于度为1，执行5条指令<br>
若执行21条指令：度为 4 的超标量流水线每周期可发射 4 条指令。前 3Δt 为流水线建立时间（首 4 条指令完成），剩余 21-4=17 条，需 5 个周期（4×4=16 条，最后 1 条需 1 个周期），总 3+5=8Δt。</p>
</li>
<li>
<p><strong>设指令流水线把一条指令分为取指、分析、执行 3 部分，3 部分执行时间不等长，且 3 部分的时间分别是 t₍取指₎=2ns，t₍分析₎=2ns，t₍执行₎=1ns，则 100 条指令全部执行完毕需（ ）。</strong><br>
<strong>A. 163ns B. 183ns C. 193ns D. 203ns</strong><br>
<strong>C</strong>。解析：流水线周期 T=2ns，总时间 = 5 + (100-1)×2 -1=193ns（首条 5ns，后续 99 条每周期 2ns，执行段少 1ns 补差）。</p>
</li>
<li>
<p><strong>下列关于流水段寄存器的叙述中，正确的是（ ）。</strong><br>
<strong>A. 指令译码得到的控制信号需通过流水段寄存器传递到下一个流水段</strong><br>
<strong>B. 每个流水段之间的流水段寄存器位数一定相同</strong><br>
<strong>C. 每个流水段之间的流水段寄存器存放的信息一定相同</strong><br>
<strong>D. 用户程序可以通过指令指定访问哪个流水段寄存器</strong><br>
<strong>A</strong>。解析：流水段寄存器用于暂存当前段数据 / 控制信号，译码控制信号需经其传至下一段（A 对）；不同段寄存器<strong>位数（B，如取指存指令、执行存运算结果，位数可不同）、存放信息（C，取指存指令 vs 分析存操作数，信息不同）</strong> 均不一定相同；流水段寄存器是硬件内部结构，<strong>用户无法访问（D 错）</strong>。</p>
</li>
<li>
<p><strong>下列关于流水线数据通路的描述中，错误的是（ ）。</strong><br>
<strong>A. 每个流水段由执行指令子功能的功能部件和流水段寄存器组成</strong><br>
<strong>B. 控制信号仅作用在功能部件上，时钟信号仅作用在流水段寄存器上</strong><br>
<strong>C. 在没有阻塞的情况下，PC 的值在每个时钟周期都会改变</strong><br>
<strong>D. 取指令阶段和指令译码阶段不需要控制信号的控制</strong><br>
A正确，流水段标准结构为 “功能部件（如取指单元）+ 流水段寄存器（暂存段间数据）”；B错，控制信号决定<strong>数据流向</strong>和<strong>操作类型</strong>，仅作用在功能部件上是对的，时钟信号是全局同步的，作用域所有状态元件（PC、寄存器、存储器等）；C对，PC自增。补充 PC 和流水段寄存器无写使能信号（因为PC每个时钟周期必然更新，流水段寄存器每个时钟周期必然锁存当前段数据，传递到下一段，所以无需写使能，即硬件逻辑强制每时钟写入）；D对，因为<strong>取指、译码</strong>的操作对 <strong>所有指令都相同</strong>，所以前两个流水段无需控制信号。</p>
</li>
<li>
<p><strong>下列关于结构冒险的叙述中，正确的是（ ）。</strong><br>
<strong>Ⅰ. 结构冒险是指同时有多条指令使用同一个资源</strong><br>
<strong>Ⅱ. 避免结构冒险的基本做法是使每个指令在相同流水段中使用相同的部件</strong><br>
<strong>Ⅲ. 重复设置功能部件可以避免结构冒险</strong><br>
A. Ⅰ、Ⅱ、Ⅳ B. Ⅰ、Ⅱ、Ⅲ C. Ⅰ、Ⅲ、Ⅳ D. Ⅰ、Ⅱ、Ⅲ 和 Ⅳ<br>
Ⅰ 符合结构冒险 “多指令同时争用同一硬件资源” 的定义；Ⅱ 对应教材结论 “一个部件每条指令只能使用一次，且只能在特定阶段使用（即指令在相同流水段用相同部件），可避免部分结构冒险”；Ⅲ“重复设置功能部件”、Ⅳ“分离指令 / 数据 Cache” 均属于 “通过设置多个独立部件规避硬件冲突” 的策略，选 D。</p>
</li>
<li>
<p><strong>指令流水线中出现数据相关时流水线将受阻，（ ）可解决数据相关问题。</strong><br>
<strong>A. 增加硬件资源</strong> <strong>B. 采用旁路技术</strong> <strong>C. 采用分支预测技术</strong> <strong>D. 以上都可以</strong><br>
<strong>B</strong>。解析：A 错误，<strong>结构冒险</strong>（硬件不足）；B 正确，旁路技术通过硬件直接传递运算结果，打破数据依赖的时间差（如解决 RAW 冒险）；C 错误，<strong>控制冒险</strong>（分支跳转的流程不确定）D 错误</p>
</li>
<li>
<p><strong>下列关于数据冒险和转发技术的叙述中，正确的是（ ）。</strong><br>
<strong>Ⅰ. 并非所有数据冒险都能通过转发技术解决</strong><br>
<strong>Ⅱ. 五段流水线中 load-use 数据冒险会引起至少一个时钟周期的阻塞</strong><br>
<strong>Ⅲ. 前面的分支指令和后面的 ALU 运算指令之间肯定不会发生数据冒险</strong><br>
A. Ⅰ、Ⅱ B. Ⅰ、Ⅲ C. Ⅱ、Ⅲ D. Ⅰ、Ⅱ、Ⅲ<br>
<strong>A</strong>。解析：Ⅰ 正确，因为转发技术无法解决所有数据冒险，例如 load-use 冒险中，数据来自内存读取，转发无法提前获取；Ⅱ 正确，五段流水线中，load 指令需在访存阶段才能得到数据，而后续指令在执行阶段就需要该数据，因此至少会阻塞 1 个时钟周期；Ⅲ 错误，若分支指令写入某个寄存器，后续 ALU 指令读取该寄存器时，可能因数据未写回而发生数据冒险，并非 “肯定不会”。注：如果是按序发射，是对的</p>
</li>
<li>
<p><strong>下列关于数据冒险的叙述中，正确的是（ ）。</strong><br>
<strong>Ⅰ. 数据冒险是指后面指令用到的数据还未来得及由前面的指令产生</strong><br>
<strong>Ⅱ. 在发生数据冒险的指令之间插入空操作指令能避免数据冒险</strong><br>
<strong>Ⅲ. 采用转发（旁路）技术可以解决一部分数据冒险现象</strong><br>
<strong>Ⅳ. 通过编译器调整指令顺序可解决部分数据冒险</strong><br>
A. Ⅰ、Ⅱ、Ⅳ B. Ⅰ、Ⅱ、Ⅲ C. Ⅰ、Ⅲ、Ⅳ D. Ⅰ、Ⅱ、Ⅲ 和 Ⅳ<br>
<strong>C</strong>。解析：Ⅰ 正确，符合数据冒险 “数据依赖未满足” 的定义；Ⅱ 错误，插入空操作只是让流水线停顿等待数据，并未 “避免” 冒险本身，数据依赖仍然存在；Ⅲ 正确，转发技术可直接传递 ALU 运算结果，解决部分数据冒险（如 RAW 中运算结果的依赖）；Ⅳ 正确，编译器通过调整指令顺序，让无关指令填充等待周期，可减少部分数据冒险的影响。</p>
</li>
<li>
<p><strong>下列指令序列中，指令 I1 和 I3、I2 和 I3 之间发生数据相关。假定采用 “取指、译码 / 取数、执行、访存、写回” 五段流水线方式，那么在采用转发技术时，需要在指令 I3 之前加入（ ）条空操作指令才能使这段程序不发生数据冒险。</strong><br>
<strong>I1: add r1, r0, r0 # (r1)←(r0)+(r0)</strong><br>
<strong>I2: load r3, [2(r2)] # (r3)←M[(r2)+2]</strong><br>
<strong>I3: add r5, r3, r1 # (r5)←(r3)+(r1)</strong><br>
A. 3 B. 2 C. 0 D. 1<br>
<strong>D</strong>。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250824184401869.png" alt="image.png|300"></p>
</li>
<li>
<p><strong>下面关于控制冒险的描述中，错误的是（ ）。</strong><br>
<strong>Ⅰ. 无条件转移指令不会发生控制冒险</strong><br>
<strong>Ⅱ. 在分支指令加入若干空操作可以避免控制冒险</strong><br>
<strong>Ⅲ. 采用转发（旁路）技术，可以解决部分控制冒险</strong><br>
<strong>Ⅳ. 中断或异常也会引起控制冒险</strong><br>
<strong>Ⅴ. 流水线的段数与控制冒险引发的开销无关</strong><br>
A. Ⅰ、Ⅳ 、V B. Ⅲ、Ⅴ C. Ⅰ、Ⅲ、Ⅳ D. Ⅰ、Ⅲ、V<br>
<strong>D</strong>。解析：Ⅰ 错误，若无条件转移指令的目标地址在执行阶段才确定，仍会引发控制冒险，只要不是顺序执行指令，都会引发控制冒险；Ⅱ 正确，加入空操作可让流水线等待分支结果，减少控制冒险影响；Ⅲ 错误，转发技术用于解决数据冒险，与控制冒险无关；Ⅳ 正确，中断或异常会改变程序流向，引发控制冒险；Ⅴ 错误，流水线段数越多，分支结果确定前取出的错误指令越多，开销越大，因此与段数相关。综上，错误的是 Ⅰ、Ⅲ、Ⅴ。</p>
</li>
<li>
<p><strong>【2013 统考真题】某 CPU 主频为 1.03GHz，采用 4 级指令流水线，每个流水段的执行需要 1 个时钟周期。假定 CPU 执行了 100 条指令，在其执行过程中，没有发生任何流水线阻塞，此时流水线的吞吐率为（ ）。</strong><br>
A. 0.25×10⁹条指令 / 秒 B. 0.97×10⁹条指令 / 秒 C. 1.0×10⁹条指令 / 秒 D. 1.03×10⁹条指令 / 秒<br>
<strong>C</strong> t=(m+k−1)⋅Δt=103×(1/1.03×10⁹)=10⁻⁷秒，吞吐率 = 100÷10⁻⁷=1.0×10⁹条 / 秒</p>
</li>
<li>
<p><strong>【2017 统考真题】下列关于指令流水线数据通路的叙述中，错误的是（ ）。</strong><br>
<strong>A. 包含生成控制信号的控制部件</strong><br>
<strong>B. 包含算术逻辑运算部件（ALU）</strong><br>
<strong>C. 包含通用寄存器组和取指部件</strong><br>
<strong>D. 由组合逻辑电路和时序逻辑电路组合而成</strong><br>
<strong>A</strong>。解析：数据通路是<strong>数据传输 / 运算的硬件路径</strong>（如寄存器、ALU、取指部件），<strong>控制部件是独立模块（生成控制信号指挥数据通路）</strong>，故数据通路不包含控制部件；B、C、D 均符合数据通路的组成（ALU 是运算核心，寄存器组 / 取指部件是数据载体，组合逻辑 + 时序逻辑是硬件实现基础）。</p>
</li>
<li>
<p><strong>【2023 统考真题】在采用 “取指、译码 / 取数、执行、访存、写回”5 段流水线的 RISC 处理器中，执行如下指令序列（第一列为指令序号），其中 s0、s1、s2、s3 和 t2 表示寄存器编号。</strong><br>
<strong>I1 add s2, s1, s0  // R[s2]←R[s1]+R[s0]</strong><br>
<strong>I2 load s3, 0(s2)  // R[s3]←M[R[s2]+0]</strong><br>
<strong>I3 beq t2, s3, L1  // if R[t2]=R[s3] jump to L1</strong><br>
<strong>I4 addi t2, t2, 20  // R[t2]←R[t2]+20</strong><br>
<strong>若采用转发（旁路）技术处理数据冒险，采用硬件阻塞方式处理控制冒险，则在指令 I1～I4 的执行过程中，发生流水线阻塞的指令有（ ）。</strong><br>
<strong>A. 仅 I3 B. 仅 I2、I4 C. 仅 I3、I4 D. 仅 I2、I3、I4</strong><br>
<strong>C</strong>。解析：I1 的 s2 在 EX 阶段产生，可通过转发（Ex/Mem 寄存器）供给 I2 的 EX 阶段（计算访存地址），I2 无阻塞；I2 是 load 指令，s3 在 MEM 阶段产生，I3 的 EX 阶段需比较 s3，转发无法提前获取 MEM 阶段数据（load - use 冒险），I3 需阻塞；I3 是分支指令，在 MEM 阶段才确定是否跳转，I4 已提前取指，因<strong>控制冒险</strong>需阻塞；故仅 I3、I4 阻塞，I2 因转发无阻塞。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
<th>五段流水线阶段细节</th>
</tr>
</thead>
<tbody>
<tr>
<td>I1</td>
<td><code>add s2, s1, s0</code></td>
<td>IF（取指）→ ID（译码 + 读 s0/s1）→ EX（计算 s1+s0）→ MEM（跳过）→ WR（写回 s2）</td>
</tr>
<tr>
<td>I2</td>
<td><code>load s3, 0(s2)</code></td>
<td>IF（取指）→ ID（译码 + 读 s2）→ EX（计算 s2+0）→ MEM（访存 M (s2+0)）→ WR（写回 s3）</td>
</tr>
<tr>
<td>I3</td>
<td><code>beq t2, s3, L1</code></td>
<td>IF（取指）→ ID（译码 + 读 t2/s3）→ EX（计算 t2-s3）→ MEM（判 ZF 改 PC）→ WR（跳过）</td>
</tr>
<tr>
<td>I4</td>
<td><code>addi t2, t2, 20</code></td>
<td>IF（取指）→ ID（译码 + 读 t2）→ EX（计算 t2+20）→ MEM（跳过）→ WR（写回 t2）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>周期</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>I1</td>
<td>取指</td>
<td>译码（读 s0、s1）</td>
<td>执行（算 s1+s0）</td>
<td>访存（跳过）</td>
<td>写回（写 s2）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>I2</td>
<td>-</td>
<td>取指</td>
<td>译码（读 s2）</td>
<td>执行（算 s2+0）</td>
<td>访存（读 M (s2+0)）</td>
<td>写回（写 s3）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td></td>
<td></td>
<td>取指（阻塞气泡）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>I3</td>
<td></td>
<td></td>
<td></td>
<td>取指</td>
<td>译码（读 t2、s3）</td>
<td>执行（算 t2-s3）</td>
<td>访存（改 PC 到 L1）</td>
<td>写回（跳过）</td>
<td></td>
</tr>
<tr>
<td>I4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>取指（红标，原提前取指需阻塞）</td>
<td>译码（读 t2，阻塞后）</td>
<td>执行（算 t2+20）</td>
<td>访存（跳过）</td>
<td>写回（写 t2）</td>
</tr>
<tr>
<td>因为I3的访存阶段可能会修改PC的值，而I4的取指阶段读取PC的值，可能造成控制冒险</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol start="57">
<li>
<p><strong>下列关于超线程（HT）技术的描述中，正确的是（ ）。</strong><br>
<strong>A. 超线程技术可以让四核的 Intel Core i7 处理器变成八核</strong><br>
<strong>B. 超线程是一项硬件技术，能使系统性能大幅提升，与操作系统和应用软件无关</strong><br>
<strong>C. 含有超线程技术的 CPU 需要芯片组的支持才能发挥技术优势</strong><br>
<strong>D. 超线程模拟出的每个 CPU 核都具有独立的资源，各自工作互不干扰</strong><br>
<strong>C</strong>。解析：A 错误，超线程是 “单物理核模拟多逻辑核”（如四核变八核是逻辑核，物理核仍为 4），并非真正物理核数量翻倍；B 错误，超线程性能依赖操作系统（线程调度）和应用软件（多线程优化），并非与软件无关；C 正确，超线程需芯片组、操作系统、软件协同（如芯片组调度资源），才能充分发挥优势；D 错误，超线程的逻辑核<strong>共享物理资源</strong>（如 ALU、Cache），遇资源竞争会阻塞，并非 “独立资源、互不干扰”。</p>
</li>
<li>
<p><strong>双核 CPU 和超线程 CPU 的共同点是（ ）。</strong><br>
<strong>A. 都有两个内核 B. 都能同时执行两个运算 C. 都包含两个 CPU D. 都不会出现争抢资源的现象</strong><br>
<strong>B</strong>。解析：A 错误（超线程是 “逻辑双核”，物理核数为 1）；C 错误（均为单 CPU，双核是单 CPU 内集成两物理核，超线程是单 CPU 模拟两逻辑核）；D 错误（超线程共享物理资源、双核也可能共享 Cache，均会争抢资源）；B 正确（双核两物理核同时运算，超线程单物理核内两逻辑线程并行运算，均实现 “同时执行两个运算”）。</p>
</li>
<li>
<p><strong>下列有关多核 CPU 和单核 CPU 的描述中，错误的是（ ）。</strong><br>
<strong>A. 双核的频率为 2.4GHZ，那么其中每个核心的频率也是 2.4GHZ</strong><br>
<strong>B. 同等性能下，采用双核 CPU 可以降低计算机系统的功耗和体积</strong><br>
<strong>C. 多核 CPU 共用一组内存，数据共享</strong><br>
<strong>D. 所有程序在多核 CPU 上运行速度都快</strong><br>
<strong>D</strong>。解析：A 正确（多核同频设计下，各核心频率一致）；B 正确（多核通过并行替代高频单核，降低功耗与体积）；C 正确（多核属共享内存架构，共用主存并通过缓存一致性共享数据）；D 错误（单线程程序无法利用多核并行，甚至因缓存竞争等开销无法提速，仅多线程程序能发挥多核优势）。</p>
</li>
<li>
<p><strong>下列关于多核 CPU 的描述中，正确的是（ ）。</strong><br>
<strong>A. 各核心完全对称，拥有各自的 Cache</strong><br>
<strong>B. 任何程序都可以同时在多个核心上运行</strong><br>
<strong>C. 一颗 CPU 中集成了多个完整的执行内核，可同时进行多个运算</strong><br>
<strong>D. 只有使用了多核 CPU 的计算机，才支持多任务操作系统</strong><br>
<strong>C</strong>。解析：A 错误，多核核心可不对称（如大小核），且 Cache 可独可共享；B 错误，单线程程序无法多核心并行；C 正确，多核集成多个独立执行内核（含运算、控制单元），支持并行运算；D 错误，单核 CPU 通过分时复用也支持多任务（宏观并行、微观串行）。</p>
</li>
<li>
<p><strong>下列关于多处理器的说法中，正确的是（ ）。</strong><br>
<strong>Ⅰ. 通常采用偶数路 CPU，如 2 路、4 路、6 路等</strong><br>
<strong>Ⅱ. NUMA 构架比 UMA 构架的运算扩展性要强</strong><br>
<strong>Ⅲ. UMA 构架需要解决的重要问题是 Cache 一致性</strong><br>
<strong>A. Ⅰ B. Ⅰ 和 Ⅱ C. Ⅰ 和 Ⅲ D. Ⅰ、Ⅱ 和 Ⅲ</strong><br>
<strong>D</strong>。解析：Ⅰ 正确，SMP（对称多处理器）常用偶数路 CPU 均衡调度；Ⅱ 正确，UMA 共享内存易冲突，NUMA 分区内存支持更灵活扩展；Ⅲ 正确，UMA 多 CPU 共享内存，Cache 副本需通过协议保障一致性；故三者均对。</p>
</li>
<li>
<p><strong>下列关于多核处理器的说法中，不正确的是（ ）。</strong><br>
<strong>A. 多核处理器并不能使单线程程序的执行速度加快</strong><br>
<strong>B. 多核处理器在 Flynn 分类法中属于 MIMD 系统</strong><br>
<strong>C. 多核处理器实际上就是在一个 CPU 上集成了多个控制核心</strong><br>
<strong>D. 多核处理器通常比单核处理器的能耗更高</strong><br>
<strong>C</strong>。解析：A 正确，单线程程序仅占一个核心，多核无法并行加速；B 正确，多核多核心同时执行不同指令、处理不同数据，符合 MIMD；C 错误，多核集成的是 “运算核心”（含运算、存储等完整单元），而非 “控制核心”；D 正确，多核同时运行任务，总能耗通常更高。</p>
</li>
</ol>
<div class="main-hero-waves-area"><div class="waves-area"><svg class="waves-svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 1440 140" preserveAspectRatio="none"><path class="parallax" d="M 0 44 C 355 167 415 0 725 44 L 725 44 L 0 44 Z"></path><use class="parallax" xlink:href="#wave1" x="48" y="3"></use><use class="parallax" xlink:href="#wave1" x="48" y="5"></use><use class="parallax" xlink:href="#wave1" x="48" y="7"></use><use class="parallax" xlink:href="#wave1" x="48" y="9"></use></svg></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://labi.com">Lorinda</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://labi.com/post/d64a2c5e.html">http://labi.com/post/d64a2c5e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://labi.com" target="_blank">蜡笔梦工厂</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPU%E5%8A%9F%E8%83%BD%E7%BB%84%E6%88%90%EF%BC%88%E6%8E%A7%E5%88%B6%E5%99%A8-%E8%BF%90%E7%AE%97%E5%99%A8%EF%BC%89/">CPU功能组成（控制器/运算器）</a><a class="post-meta__tags" href="/tags/%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E8%8A%82%E6%8B%8D-%E5%91%A8%E6%9C%9F%EF%BC%89/">时序系统（节拍/周期）</a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6/">微程序控制与硬布线控制</a><a class="post-meta__tags" href="/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%EF%BC%88%E6%97%B6%E7%A9%BA%E5%9B%BE-%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%EF%BC%89/">流水线技术（时空图/冲突处理）</a></div><div class="post-share"><div class="social-share" data-image="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第 4 章 文件管理：存储与访问机制</div></div><div class="info-2"><div class="info-item-1">介绍文件的逻辑与物理结构，讲解目录管理（按名存取）、索引节点功能及外存空闲空间分配策略，实现文件的安全存储与高效共享。</div></div></div></a><a class="pagination-related" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第 5 章 输入输出管理：设备协同与优化</div></div><div class="info-2"><div class="info-item-1">详解I/O设备分类与控制方式（程序直接控制/DMA/通道），分析磁盘结构与调度策略，介绍SPOOLing等I/O优化技术，保障设备与CPU、内存的高效协同。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155535.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info-name">Lorinda</div><div class="author-info-description">欢迎来到Lorinda的个人博客\^o^/</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">112</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://lr0513.github.io/"><i class="fab fa-github"></i><span>你回来了~</span><i class="faa-passing animated" style="padding-left:20px;display:inline-block;vertical-align:middle;"><svg class="icon" style="height:28px;width:28px;fill:currentColor;position:relative;top:5px"><use xlink:href="#icon-hexolabixiaoxin1"></use></svg></i></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div><div id="welcome-info"></div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"><div id="newYear-main"><div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">CPU 的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">CPU 的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">CPU 的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">CPU 寄存器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%AF%E8%A7%81%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">用户可见的寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">用户不可见的寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-ALU-PSW-ACC-GPRs-%E6%9A%82-%E7%A7%BB-%E8%AE%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">运算器基本结构(ALU,PSW,ACC,GPRs,暂,移,计)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">组成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-PC-IR-ID-MAR-MDR"><span class="toc-number">1.2.4.</span> <span class="toc-text">控制器基本结构(PC,IR,ID,MAR,MDR)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%88%90-2"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">组成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">数据通路基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">专用数据通路方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU-%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">CPU 内部单总线方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%B8%B8%E6%B7%B7%E6%B7%86%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">CPU 常混淆点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">指令周期相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">易混淆知识点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">不同指令的指令周期举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">指令周期的数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">取指周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">间址周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">执行周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.4.</span> <span class="toc-text">中断周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">2.4.</span> <span class="toc-text">指令的执行方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">单周期处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">多周期处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">流水线处理器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">数据通路的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">数据通路概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">数据通路的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">CPU 内部单总线方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E5%86%85%E9%83%A8%E5%A4%9A%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">CPU 内部多总线方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%96%B9%E5%BC%8F-2"><span class="toc-number">3.2.3.</span> <span class="toc-text">专用数据通路方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">数据通路的操作举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">寄存器之间数据传送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E4%B8%8E-CPU-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">主存与 CPU 之间的数据传送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%9C%AF%E6%88%96%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.3.</span> <span class="toc-text">执行算术或逻辑运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">控制器的功能和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">硬布线控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CU-%E7%9A%84%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E6%9D%A5%E6%BA%90"><span class="toc-number">4.1.1.</span> <span class="toc-text">CU 的输入信号来源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%BE%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.</span> <span class="toc-text">硬布线控制器的时序系统及微操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">CPU 的控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">同步控制方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">异步控制方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">联合控制方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.1.4.</span> <span class="toc-text">设计步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.5.</span> <span class="toc-text">安排微操作时序的原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F-%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">安排微操作时序 - 取指周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F-%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">安排微操作时序 - 间址周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F-%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">安排微操作时序 - 执行周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text">寄存器分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">4.2.3.</span> <span class="toc-text">基本组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.4.</span> <span class="toc-text">工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.5.</span> <span class="toc-text">微程序控制器的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E3%80%90%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E3%80%91"><span class="toc-number">4.2.6.</span> <span class="toc-text">微指令的编码方式【控制方式】</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">直接编码方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">字段直接编码方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.6.3.</span> <span class="toc-text">字段间接编码方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.7.</span> <span class="toc-text">微指令的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.7.1.</span> <span class="toc-text">水平型微指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.7.2.</span> <span class="toc-text">垂直型微指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.7.3.</span> <span class="toc-text">混合型微指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.8.</span> <span class="toc-text">微指令的地址形成方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.2.9.</span> <span class="toc-text">微程序控制单元的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.10.</span> <span class="toc-text">微程序设计分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF-VS-%E5%BE%AE%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">硬布线 VS 微程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">异常和中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%EF%BC%88%E5%86%85%E4%B8%AD%E6%96%AD%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">异常（内中断）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%EF%BC%88Fault%EF%BC%89"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">故障（Fault）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E9%99%B7%EF%BC%88Trap%EF%BC%8C%E9%99%B7%E9%98%B1-%E9%99%B7%E5%85%A5%EF%BC%89"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">自陷（Trap，陷阱 &#x2F; 陷入）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%EF%BC%88Abort%EF%BC%89"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">终止（Abort）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%EF%BC%88%E5%A4%96%E4%B8%AD%E6%96%AD%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">中断（外中断）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">中断的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">异常和中断响应过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="toc-number">5.3.1.</span> <span class="toc-text">关中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E6%96%AD%E7%82%B9%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">保存断点和程序状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E5%B9%B6%E8%BD%AC%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">识别异常和中断并转到相应的处理程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">6.</span> <span class="toc-text">指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">流水线的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="toc-number">6.1.1.</span> <span class="toc-text">如何提高处理机的并行性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.2.</span> <span class="toc-text">指令流水线的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E5%BA%94%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.1.3.</span> <span class="toc-text">指令集应具备的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.4.</span> <span class="toc-text">流水线的表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.5.</span> <span class="toc-text">流水线的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%9E%E5%90%90%E7%8E%87%EF%BC%88TP%EF%BC%89-%E6%80%BB%E6%8C%87%E4%BB%A4n-%E6%80%BB%E6%97%B6%E9%97%B4Tk"><span class="toc-number">6.1.5.1.</span> <span class="toc-text">流水线的吞吐率（TP）[总指令n&#x2F;总时间Tk]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%8A%A0%E9%80%9F%E6%AF%94%EF%BC%88S%EF%BC%89-%E9%A1%BA%E5%BA%8F%E6%97%B6%E9%97%B4-%E6%80%BB%E6%97%B6%E9%97%B4"><span class="toc-number">6.1.5.2.</span> <span class="toc-text">流水线的加速比（S）[顺序时间&#x2F;总时间]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88E%EF%BC%89-%E9%9D%A2%E7%A7%AF%E6%AF%94"><span class="toc-number">6.1.5.3.</span> <span class="toc-text">流水线的效率（E）[面积比]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">流水线的基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-number">6.2.1.</span> <span class="toc-text">流水线的数据通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.2.2.</span> <span class="toc-text">流水线的控制信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.3.</span> <span class="toc-text">流水线的执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">流水线的冒险与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9"><span class="toc-number">6.3.1.</span> <span class="toc-text">结构冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">6.3.2.</span> <span class="toc-text">数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">6.3.3.</span> <span class="toc-text">控制冒险</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">流水线的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BD%BF%E7%94%A8%E7%BA%A7%E5%88%AB%E5%88%86%E7%B1%BB%EF%BC%88%E8%B0%81%E5%9C%A8%E5%B9%B6%E8%A1%8C%EF%BC%9F%E2%80%94%E2%80%94-%E9%83%A8%E4%BB%B6-%E5%8D%95-CPU-%E5%A4%9A-CPU%EF%BC%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">按流水线使用级别分类（谁在并行？—— 部件 &#x2F; 单 CPU &#x2F; 多 CPU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%83%BD%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB%EF%BC%88%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%9A%E5%95%A5%E6%8A%80%E8%83%BD%EF%BC%9F%E2%80%94%E2%80%94-%E5%8D%95%E4%B8%80%E6%8A%80%E8%83%BD-%E5%A4%9A%E9%A1%B9%E6%8A%80%E8%83%BD%EF%BC%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">按能完成的功能分类（流水线会啥技能？—— 单一技能 &#x2F; 多项技能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E8%83%BD%E5%81%9A%E5%87%A0%E4%BB%B6%E4%BA%8B%EF%BC%9F%E2%80%94%E2%80%94-%E4%B8%93%E4%B8%80-%E8%8A%B1%E5%BF%83%EF%BC%89"><span class="toc-number">6.4.3.</span> <span class="toc-text">按连接方式分类（同一时间能做几件事？—— 专一 &#x2F; 花心）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%8D%E9%A6%88%E4%BF%A1%E5%8F%B7%E5%88%86%E7%B1%BB%EF%BC%88%E2%80%9C%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%98%AF%E7%9B%B4%E7%9A%84%E8%BF%98%E6%98%AF%E7%BB%95%E7%9A%84%EF%BC%9F%E2%80%9D%E2%80%94%E2%80%94-%E5%8D%95%E8%A1%8C%E7%BA%BF-%E7%8E%AF%E8%B7%AF%EF%BC%89"><span class="toc-number">6.4.4.</span> <span class="toc-text">按是否有反馈信号分类（“流水线是直的还是绕的？”—— 单行线 &#x2F; 环路）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.</span> <span class="toc-text">流水线多发技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.1.</span> <span class="toc-text">超标量流水线技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.2.</span> <span class="toc-text">超长指令字技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.3.</span> <span class="toc-text">超流水线技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E6%AE%B5%E5%BC%8F%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">6.6.</span> <span class="toc-text">五段式指令流水线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.</span> <span class="toc-text">多处理器的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SISD%E3%80%81SIMD%E3%80%81SIMD%E3%80%81MIMD-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">SISD、SIMD、SIMD、MIMD 的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%8C%87%E4%BB%A4%E6%B5%81%E5%8D%95%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%93%E6%9E%84-SISD"><span class="toc-number">7.1.1.</span> <span class="toc-text">单指令流单数据流结构 (SISD)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%8C%87%E4%BB%A4%E6%B5%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%93%E6%9E%84%EF%BC%88SIMD%EF%BC%89"><span class="toc-number">7.1.2.</span> <span class="toc-text">单指令流多数据流结构（SIMD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%8C%87%E4%BB%A4%E6%B5%81%E5%8D%95%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%93%E6%9E%84%EF%BC%88MISD%EF%BC%89"><span class="toc-number">7.1.3.</span> <span class="toc-text">多指令流单数据流结构（MISD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%8C%87%E4%BB%A4%E6%B5%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%93%E6%9E%84%EF%BC%88MIMD%EF%BC%89"><span class="toc-number">7.1.4.</span> <span class="toc-text">多指令流多数据流结构（MIMD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.5.</span> <span class="toc-text">联系与区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">多核处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88SMP%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">共享内存处理器（SMP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.4.</span> <span class="toc-text">硬件多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E7%B2%92%E5%BA%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">细粒度多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%97%E7%B2%92%E5%BA%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.4.2.</span> <span class="toc-text">粗粒度多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88SMT%EF%BC%89"><span class="toc-number">7.4.3.</span> <span class="toc-text">同时多线程（SMT）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">错题</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：Linux环境与自动化部署"></a><div class="content"><a class="title" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署">瑞吉外卖：Linux环境与自动化部署</a><time datetime="2025-09-02T02:04:00.000Z" title="发表于 2025-09-02 10:04:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：性能优化与架构升级"></a><div class="content"><a class="title" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级">瑞吉外卖：性能优化与架构升级</a><time datetime="2025-09-02T02:03:00.000Z" title="发表于 2025-09-02 10:03:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：移动端交互与用户端实现"></a><div class="content"><a class="title" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现">瑞吉外卖：移动端交互与用户端实现</a><time datetime="2025-09-02T02:02:00.000Z" title="发表于 2025-09-02 10:02:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：核心业务功能开发"></a><div class="content"><a class="title" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发">瑞吉外卖：核心业务功能开发</a><time datetime="2025-09-02T02:01:00.000Z" title="发表于 2025-09-02 10:01:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：项目概述与整体架构"></a><div class="content"><a class="title" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构">瑞吉外卖：项目概述与整体架构</a><time datetime="2025-09-02T02:00:00.000Z" title="发表于 2025-09-02 10:00:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ce4585c2.html" title="前端实现：界面与交互逻辑"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端实现：界面与交互逻辑"></a><div class="content"><a class="title" href="/post/ce4585c2.html" title="前端实现：界面与交互逻辑">前端实现：界面与交互逻辑</a><time datetime="2025-08-30T03:03:00.000Z" title="发表于 2025-08-30 11:03:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d67b0a8b.html" title="核心功能开发：业务流程实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="核心功能开发：业务流程实现"></a><div class="content"><a class="title" href="/post/d67b0a8b.html" title="核心功能开发：业务流程实现">核心功能开发：业务流程实现</a><time datetime="2025-08-30T03:02:00.000Z" title="发表于 2025-08-30 11:02:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b85186f.html" title="基础开发：环境搭建与核心配置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础开发：环境搭建与核心配置"></a><div class="content"><a class="title" href="/post/b85186f.html" title="基础开发：环境搭建与核心配置">基础开发：环境搭建与核心配置</a><time datetime="2025-08-30T03:01:00.000Z" title="发表于 2025-08-30 11:01:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/25e0fe54.html" title="项目概述：架构与需求分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目概述：架构与需求分析"></a><div class="content"><a class="title" href="/post/25e0fe54.html" title="项目概述：架构与需求分析">项目概述：架构与需求分析</a><time datetime="2025-08-30T03:00:00.000Z" title="发表于 2025-08-30 11:00:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/g86c4e7a.html" title="第 7 章 计算机系统结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 7 章 计算机系统结构"></a><div class="content"><a class="title" href="/post/g86c4e7a.html" title="第 7 章 计算机系统结构">第 7 章 计算机系统结构</a><time datetime="2025-08-28T21:20:00.000Z" title="发表于 2025-08-29 05:20:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f75b3d6f.html" title="第 6 章 输入输出系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 6 章 输入输出系统"></a><div class="content"><a class="title" href="/post/f75b3d6f.html" title="第 6 章 输入输出系统">第 6 章 输入输出系统</a><time datetime="2025-08-28T21:19:00.000Z" title="发表于 2025-08-29 05:19:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 5 章 输入输出管理：设备协同与优化"></a><div class="content"><a class="title" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化">第 5 章 输入输出管理：设备协同与优化</a><time datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d64a2c5e.html" title="第 5 章 中央处理器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 5 章 中央处理器"></a><div class="content"><a class="title" href="/post/d64a2c5e.html" title="第 5 章 中央处理器">第 5 章 中央处理器</a><time datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 4 章 文件管理：存储与访问机制"></a><div class="content"><a class="title" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制">第 4 章 文件管理：存储与访问机制</a><time datetime="2025-08-28T21:17:00.000Z" title="发表于 2025-08-29 05:17:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b93e5f6d.html" title="第 4 章 指令系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 4 章 指令系统"></a><div class="content"><a class="title" href="/post/b93e5f6d.html" title="第 4 章 指令系统">第 4 章 指令系统</a><time datetime="2025-08-28T21:17:00.000Z" title="发表于 2025-08-29 05:17:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ce20e5e9.html" title="第 3 章 内存管理：地址映射与虚拟内存"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 3 章 内存管理：地址映射与虚拟内存"></a><div class="content"><a class="title" href="/post/ce20e5e9.html" title="第 3 章 内存管理：地址映射与虚拟内存">第 3 章 内存管理：地址映射与虚拟内存</a><time datetime="2025-08-28T21:16:00.000Z" title="发表于 2025-08-29 05:16:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a81d4c7b.html" title="第 3 章 存储系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 3 章 存储系统"></a><div class="content"><a class="title" href="/post/a81d4c7b.html" title="第 3 章 存储系统">第 3 章 存储系统</a><time datetime="2025-08-28T21:16:00.000Z" title="发表于 2025-08-29 05:16:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/833e46bb.html" title="第 2 章 进程与线程：并发管理核心"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 2 章 进程与线程：并发管理核心"></a><div class="content"><a class="title" href="/post/833e46bb.html" title="第 2 章 进程与线程：并发管理核心">第 2 章 进程与线程：并发管理核心</a><time datetime="2025-08-28T21:15:00.000Z" title="发表于 2025-08-29 05:15:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e72f3b9c.html" title="第 2 章 数据的表示与计算"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 2 章 数据的表示与计算"></a><div class="content"><a class="title" href="/post/e72f3b9c.html" title="第 2 章 数据的表示与计算">第 2 章 数据的表示与计算</a><time datetime="2025-08-28T21:15:00.000Z" title="发表于 2025-08-29 05:15:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b328aa63.html" title="第 1 章 操作系统概述：计算机系统基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 1 章 操作系统概述：计算机系统基础"></a><div class="content"><a class="title" href="/post/b328aa63.html" title="第 1 章 操作系统概述：计算机系统基础">第 1 章 操作系统概述：计算机系统基础</a><time datetime="2025-08-28T21:14:00.000Z" title="发表于 2025-08-29 05:14:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c45d1e8a.html" title="第 1 章 计算机系统概述"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 1 章 计算机系统概述"></a><div class="content"><a class="title" href="/post/c45d1e8a.html" title="第 1 章 计算机系统概述">第 1 章 计算机系统概述</a><time datetime="2025-08-28T21:14:00.000Z" title="发表于 2025-08-29 05:14:00">2025-08-29</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：Linux环境与自动化部署"/></a><div class="content"><a class="title" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署">瑞吉外卖：Linux环境与自动化部署</a><time datetime="2025-09-02T02:04:00.000Z" title="发表于 2025-09-02 10:04:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：性能优化与架构升级"/></a><div class="content"><a class="title" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级">瑞吉外卖：性能优化与架构升级</a><time datetime="2025-09-02T02:03:00.000Z" title="发表于 2025-09-02 10:03:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：移动端交互与用户端实现"/></a><div class="content"><a class="title" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现">瑞吉外卖：移动端交互与用户端实现</a><time datetime="2025-09-02T02:02:00.000Z" title="发表于 2025-09-02 10:02:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：核心业务功能开发"/></a><div class="content"><a class="title" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发">瑞吉外卖：核心业务功能开发</a><time datetime="2025-09-02T02:01:00.000Z" title="发表于 2025-09-02 10:01:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：项目概述与整体架构"/></a><div class="content"><a class="title" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构">瑞吉外卖：项目概述与整体架构</a><time datetime="2025-09-02T02:00:00.000Z" title="发表于 2025-09-02 10:00:00">2025-09-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> By Lorinda</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="日间和夜间模式切换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="to_comment" type="button" title="前往评论" onclick="FixedCommentBtn();"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-three-beta.vercel.app/',
      region: 'ap-beijing',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-three-beta.vercel.app/',
      region: 'ap-beijing',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async src="//at.alicdn.com/t/c/font_4860073_9duzoqyl2cn.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="/js/pagination-jump.js"></script><script async src="/js/fps.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async data-pjax src="/js/music.js"></script><script defer src="/js/lunar.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script> let backimg =["url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/d42bcc24810cda2c22eaed769b79a93.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/2f5e89ae13329dd89bdcdbfc68c5fde.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/48b137c38cc79ad960ecf2a9a12fc20.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/4474312751631fedb37381e37cdb9c0.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/be978bd80f41d2781455513ba1676a2.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a01223e0819746191dd135670a2d7da.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/af380cb8a5ed3f047e66dbfe731f488.jpg)"];let index = Math.floor(Math.random() * backimg.length);;document.getElementById("web_bg").style.backgroundImage = backimg[index]</script><script type="text/javascript" src="/js/rightmenu.js"></script><script src="/js/history.js"></script><script src="/js/historyroll.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script defer src="/js/day.js"></script><script async src="/js/title.js"></script><script defer src="/js/random.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="/js/sun_moon.js" async></script><script>
  document.addEventListener('copy', function(e) {
    const selection = window.getSelection().toString()
    if (selection.length > 30) {
      const notice = document.createElement('div')
      notice.className = 'copy-notification'
      notice.textContent = '内容已复制到剪贴板'

      document.body.appendChild(notice)
      setTimeout(() => notice.classList.add('show'), 10)

      setTimeout(() => {
        notice.classList.remove('show')
        setTimeout(() => notice.remove(), 300)
      }, 2000)
    }
  })
</script>
<div class="aplayer no-destroy" data-id="7338633309" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script async data-pjax src="/js/newYear.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-nest.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-show-text.min.js" data-mobile="false" data-text="Ha,Ha,Ha" data-fontsize="15px" data-random="false" async="async"></script><script>(() => {
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "cbe39e5f-e68f-4a07-b9cd-3ebbb6aa9ae8";
  (function () {
    d = document;
    s = d.createElement("script");
    s.src = "https://client.crisp.chat/l.js";
    s.async = 1;
    d.getElementsByTagName("head")[0].appendChild(s);
  })();
  $crisp.push(["safe", true])

  const isChatBtn = true
  const isChatHideShow = false

  if (isChatBtn) {
    const open = () => {
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])
    }

    const close = () => $crisp.push(["do", "chat:hide"])

    close()

    $crisp.push(["on", "chat:closed", close])

    window.chatBtnFn = () => $crisp.is("chat:visible") ? close() : open()

  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => $crisp.push(["do", "chat:hide"]),
      show: () => $crisp.push(["do", "chat:show"])
    }
  }
})()</script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementsByClassName('recent-posts')[0];
      var item_html = '<div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155818.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">系统基础</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术栈/&quot;);" href="javascript:void(0);">技术栈</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">技术工具</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程语言/&quot;);" href="javascript:void(0);">编程语言</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">语言入门</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/4e357962b00044466380f6850a120ec.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/大数据技术/&quot;);" href="javascript:void(0);">大数据技术</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">数技核心</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155709.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/瑞吉外卖项目/&quot;);" href="javascript:void(0);">瑞吉外卖项目</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">计基要点</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160015.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机基础/&quot;);" href="javascript:void(0);">计算机基础</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">瑞吉实践</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160113.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/苍穹外卖项目/&quot;);" href="javascript:void(0);">苍穹外卖项目</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">苍穹实践</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155951.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr">专业课程</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机基础/专业课/&quot;);" href="javascript:void(0);">专业课</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementsByClassName('recent-posts')[0] && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '9aac1b5db191491a8993c445d664de8f';
  var gaud_map_key = '3cc01a5a19f500daa0e9e680ef0f6db2';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '120.780172,40.624088';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt="">第 7 章 计算机系统结构</a><div class="blog-slider__text">阐述计算机系统结构的基本概念，分析并行处理技术的实现方式，详解存储层次的优化策略，介绍系统性能的评价指标与方法。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt="">第 6 章 输入输出系统</a><div class="blog-slider__text">介绍I/O设备的分类与特性，详解程序查询、中断与DMA三种控制方式，分析中断系统的处理机制，理解设备与主机的信息交换过程。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt="">第 5 章 中央处理器</a><div class="blog-slider__text">详解CPU的功能组成与工作原理，分析时序系统的作用，对比微程序与硬布线控制方式，介绍流水线技术的性能优化机制。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-deployment.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-deployment.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：Linux环境与自动化部署</a><div class="blog-slider__text">详解瑞吉外卖部署流程，包括Linux环境配置、Git版本管理、自动化脚本与项目发布实践。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-deployment.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt="">第 4 章 指令系统</a><div class="blog-slider__text">详解指令的基本格式与寻址方式，对比CISC与RISC体系结构特点，分析指令的执行流程，理解指令系统对硬件的适配关系。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/ce4585c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/ce4585c2.html&quot;);" href="javascript:void(0);" alt="">前端实现：界面与交互逻辑</a><div class="blog-slider__text">详解苍穹外卖前端开发实现，包括Vue组件架构设计、核心页面（登录、首页、订单页）开发，接口交互封装与状态管理，确保前端界面与后端服务高效协同。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/ce4585c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-optimization.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-optimization.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：性能优化与架构升级</a><div class="blog-slider__text">详解瑞吉外卖优化方案，包括Redis缓存应用、数据库读写分离、系统架构升级等性能提升手段。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-optimization.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt="">第 3 章 存储系统</a><div class="blog-slider__text">分析存储系统的层次结构设计，详解主存储器的组成与工作流程，阐述Cache的映射方式与替换策略，介绍存储器性能优化方法。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/d67b0a8b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/d67b0a8b.html&quot;);" href="javascript:void(0);" alt="">核心功能开发：业务流程实现</a><div class="blog-slider__text">聚焦苍穹外卖核心业务功能开发，详解用户管理、菜品管理、订单全流程及购物车交互逻辑，结合数据统计功能实现业务闭环，覆盖项目核心场景。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/d67b0a8b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt="">第 2 章 数据的表示与计算</a><div class="blog-slider__text">详解数制转换规则，阐述定点数与浮点数的表示方法，分析补码运算机制，介绍ALU的功能与实现，掌握数据在计算机中的处理方式。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b85186f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b85186f.html&quot;);" href="javascript:void(0);" alt="">基础开发：环境搭建与核心配置</a><div class="blog-slider__text">详解苍穹外卖项目基础开发流程，包括本地开发环境搭建、数据库表结构设计与初始化，核心配置（跨域、日志等）及基础工具类实现，构建项目开发基石。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b85186f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-business.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-business.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：核心业务功能开发</a><div class="blog-slider__text">详解瑞吉外卖后端核心业务实现，包括员工管理、菜品分类、订单流程等功能的接口与逻辑开发。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-business.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-mobile.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-mobile.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：移动端交互与用户端实现</a><div class="blog-slider__text">详解瑞吉外卖移动端用户端开发，包括手机验证码登录、地址簿管理、菜品 / 套餐展示、购物车增删改查、用户订单创建与再来一单功能，及前后端接口交互逻辑。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-mobile.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt="">Redis</a><div class="blog-slider__text">Redis 作为内存 NoSQL 数据库的定位，支持 String/Hash 等多数据结构，具备 RDB/AOF 持久化与主从高可用，核心用于缓存、分布式锁，性能高效。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt="">第 1 章 计算机系统概述</a><div class="blog-slider__text">介绍计算机系统的硬件与软件组成，详解五大功能部件及总线工作机制，阐述指令集体系结构的核心作用，建立计算机系统的整体认知。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/25e0fe54.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/25e0fe54.html&quot;);" href="javascript:void(0);" alt="">项目概述：架构与需求分析</a><div class="blog-slider__text">全面解析苍穹外卖项目的整体规划，包括项目背景、核心需求、技术栈选型依据，详解系统架构设计与开发规范，为项目开发提供整体指导。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/25e0fe54.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt="">王道计组pdf</a><div class="blog-slider__text">计算机组成原理</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt="">第 2 章 进程与线程：并发管理核心</a><div class="blog-slider__text">讲解进程与线程的定义、状态转换及控制逻辑，分析进程调度策略，阐述进程同步互斥（PV 操作）与死锁的处理机制，是操作系统并发管理的核心。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt="">第 4 章 文件管理：存储与访问机制</a><div class="blog-slider__text">介绍文件的逻辑与物理结构，讲解目录管理（按名存取）、索引节点功能及外存空闲空间分配策略，实现文件的安全存储与高效共享。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt="">第 5 章 输入输出管理：设备协同与优化</a><div class="blog-slider__text">详解I/O设备分类与控制方式（程序直接控制/DMA/通道），分析磁盘结构与调度策略，介绍SPOOLing等I/O优化技术，保障设备与CPU、内存的高效协同。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt="">第 3 章 内存管理：地址映射与虚拟内存</a><div class="blog-slider__text">覆盖内存分配方式（连续/分页/分段）与地址转换机制，详解虚拟内存技术、请求分页流程及页面置换策略，解决多道程序下内存利用率与地址映射问题。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt="">第 1 章 操作系统概述：计算机系统基础</a><div class="blog-slider__text">阐述操作系统的定义与核心功能，详解四大特征（并发 / 共享 / 虚拟 / 异步）、处理器运行模式及系统结构分类，介绍 OS 引导流程，奠定操作系统认知基础。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt="">数据结构</a><div class="blog-slider__text">数据结构的核心是高效组织数据，区分逻辑结构（线性 / 非线性）与物理结构（顺序 / 链式），覆盖数组、树、图等核心类型，为优化算法效率、支撑工程应用奠定基础。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-overview.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-overview.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：项目概述与整体架构</a><div class="blog-slider__text">全面解析瑞吉外卖项目背景、技术选型、整体架构设计及核心业务流程，建立项目全局认知。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-overview.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt="">java基础</a><div class="blog-slider__text">Java基础</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>