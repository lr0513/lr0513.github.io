<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第 4 章 指令系统 | 蜡笔梦工厂</title><meta name="author" content="Lorinda"><meta name="copyright" content="Lorinda"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="详解指令的基本格式与寻址方式，对比CISC与RISC体系结构特点，分析指令的执行流程，理解指令系统对硬件的适配关系。">
<meta property="og:type" content="article">
<meta property="og:title" content="第 4 章 指令系统">
<meta property="og:url" content="http://labi.com/post/b93e5f6d.html">
<meta property="og:site_name" content="蜡笔梦工厂">
<meta property="og:description" content="详解指令的基本格式与寻址方式，对比CISC与RISC体系结构特点，分析指令的执行流程，理解指令系统对硬件的适配关系。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png">
<meta property="article:published_time" content="2025-08-28T21:17:00.000Z">
<meta property="article:modified_time" content="2025-08-28T22:28:49.694Z">
<meta property="article:author" content="Lorinda">
<meta property="article:tag" content="指令格式（操作码&#x2F;地址码）">
<meta property="article:tag" content="寻址方式（立即数&#x2F;直接&#x2F;间接寻址）">
<meta property="article:tag" content="指令集设计（CISC&#x2F;RISC）">
<meta property="article:tag" content="指令执行周期">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png"><link rel="shortcut icon" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155552.png"><link rel="canonical" href="http://labi.com/post/b93e5f6d.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?bf06f078fafddfd82b474ce179303666";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":{"enable":true},"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第 4 章 指令系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2264842_b004iy0kk2b.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/loading.css"><link rel="stylesheet" href="/css/about.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160015.png"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg" style="background-image: url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/af380cb8a5ed3f047e66dbfe731f488.jpg);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155535.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">112</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-hexoa-homezhuyefangzijia"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-hexoa-homezhuyefangzijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-hexoshouhuiban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoshouhuiban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexohuanjiaowenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexofenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexobiaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoguidang"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoicon_liebiao"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoyinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexotubiaozhizuomoban"></use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-hexopengyou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexopengyou"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-hexowode"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexowode"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155552.png" alt="Logo"><span class="site-name">蜡笔梦工厂</span></a><a class="nav-page-title" href="/"><span class="site-name">第 4 章 指令系统</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-hexoa-homezhuyefangzijia"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-hexoa-homezhuyefangzijia"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-hexoshouhuiban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoshouhuiban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexohuanjiaowenzhang"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexofenlei"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexobiaoqian"></use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoguidang"></use></svg><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoicon_liebiao"></use></svg><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexoyinle"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexotubiaozhizuomoban"></use></svg><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-hexopengyou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexopengyou"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-hexowode"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-hexowode"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div></nav><div id="post-info"><h1 class="post-title">第 4 章 指令系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-28T21:17:00.000Z" title="发表于 2025-08-29 05:17:00">2025-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-28T22:28:49.694Z" title="更新于 2025-08-29 06:28:49">2025-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">26.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div class="series-navigation"><h4 class="series-title">计算机组成原理核心知识系列</h4><ol class="series-list"><li class="series-item"><a class="series-link" href="/post/c45d1e8a.html"><span class="series-icon">•</span><span class="series-text"> 🎯 计算机系统概述</span></a></li><li class="series-item"><a class="series-link" href="/post/e72f3b9c.html"><span class="series-icon">•</span><span class="series-text"> 🔢 数据的表示与计算</span></a></li><li class="series-item"><a class="series-link" href="/post/a81d4c7b.html"><span class="series-icon">•</span><span class="series-text"> 💾 存储系统</span></a></li><li class="series-item series-current"><a class="series-link" href="/post/b93e5f6d.html"><span class="series-icon">•</span><span class="series-text"> 📝 指令系统</span></a><span class="series-current-tag">← 当前位置 🛸</span></li><li class="series-item"><a class="series-link" href="/post/d64a2c5e.html"><span class="series-icon">•</span><span class="series-text"> ⚙️ 中央处理器</span></a></li><li class="series-item"><a class="series-link" href="/post/f75b3d6f.html"><span class="series-icon">•</span><span class="series-text"> 🔌 输入输出系统</span></a></li><li class="series-item"><a class="series-link" href="/post/g86c4e7a.html"><span class="series-icon">•</span><span class="series-text"> 🏗️ 计算机系统结构</span></a></li></ol></div><h2 id="指令系统">指令系统</h2>
<h3 id="指令集体系结构">指令集体系结构</h3>
<ul>
<li>
<p><strong>指令【机器指令】</strong>：指示计算机执行某种操作的命令，是计算机运行的<strong>最小功能单位</strong><br>
操作码OP【一个】+指令码A【几个】</p>
</li>
<li>
<p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码</p>
</li>
<li>
<p>一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令</p>
</li>
<li>
<p><strong>指令集</strong>：一台计算机能执行的<strong>机器指令</strong>的集合称为该机的<strong>指令系统</strong>，也称为<strong>指令集</strong><br>
由于冯诺依曼架构，指令与数据共存于主存，按顺序执行，默认每执行一条指令后 PC +1 ；分支 / 调用指令可显式修改 PC 值。<br>
所以机器指令需要显式或隐式的表示：</p>
<ul>
<li>操作码（+ , - , * , / ,移位等）</li>
<li>源操作数/地址：指定参与运算数据位置</li>
<li>结果地址：指定运算结果存放处</li>
<li>下一条指令地址：多由 PC 隐式管理，显式跳转指令可指定新地址<br>
操作码必显式；地址字段依指令类型显式编码。<br>
PC 自动递增；部分指令有默认寄存器；堆栈操作隐含栈顶地址。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424203342250.png" alt="image.png"></li>
</ul>
</li>
<li>
<p>指令系统是<strong>指令集体系结构（ISA)</strong> 中最核心的部分</p>
</li>
<li>
<p>ISA 规定的内容主要包括：</p>
<ul>
<li><strong>指令格式</strong>，<strong>指令寻址方式</strong>，<strong>操作类型</strong>，以及每种<strong>操作对应的操作数</strong>的相应规定</li>
<li><strong>操作数的类型</strong>，<strong>操作数寻址方式</strong>，以及是按<strong>大端方式</strong>还是按<strong>小端方式</strong>存放</li>
<li>程序可访问的<strong>寄存器编号、个数和位数</strong>，<strong>存储空间的大小和编址方式</strong></li>
<li>指令执行过程的<strong>控制方式</strong>等，包括<strong>程序计数器</strong>、<strong>条件码定义</strong>等</li>
</ul>
</li>
</ul>
<p>1A-32系统（如 Intel x86 架构的 32 位系统）中，指令的 <strong>地址码（Address Field）</strong> 的位数可以 <strong>没有、1 位 或 2 位</strong>，这主要取决于 <strong>指令的寻址方式</strong> 和 <strong>操作数的来源</strong>。</p>
<h3 id="指令格式">指令格式</h3>
<h4 id="基本指令结构">基本指令结构</h4>
<ul>
<li>一条指令通常要包括操作码字段和地址码字段</li>
<li><strong>操作码</strong>：指出该指令应执行什么操作以及具有何种功能【用户要干什么】|<br>
长度取决于指令系统中的指令条数<br>
eg.操作码占7位，则该机器最多包含2^7=128条指令。</li>
<li><strong>地址码</strong>：用来描述该指令的操作对象，或者直接给出操作数，或者指出操作数的<mark>存储器地址</mark>或<mark>寄存器地址</mark>(即寄存器名)。【对谁操作】<br>
提供地址码的方式：
<ul>
<li>显地址方式：指令中明显指明地址（直接或间接给出）</li>
<li>隐地址方式：地址隐含约定，不出现在指令中<br>
使用隐地址可以减少指令中的地址数，简化地址结构</li>
</ul>
</li>
<li>指令的地址由程序计数器给出<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240422215027.png" alt="image.png"></li>
</ul>
<h4 id="指令的分类">指令的分类</h4>
<ol>
<li>按指令长度分类<br>
指令字长指一条指令包含的二进制位数，由 <strong>操作码长度、地址码长度、地址码个数</strong> 共同决定</li>
</ol>
<p>半字长、单字长、双字长指令指的是指令长度是机器字长的多少倍<br>
指令字长会影响取指令所需时间。eg.机器字长=存储字长=16bit，则取一条双字长指令需要两次访存</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>定义</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>单字长指令</strong></td>
<td>指令长度 = 机器字长（如 32 位机器中指令占 32 位）</td>
<td>1 次访存即可完整取出指令，效率高。</td>
</tr>
<tr>
<td><strong>双字长指令</strong></td>
<td>指令长度 = 2 个机器字长（如 32 位机器中指令占 64 位）</td>
<td>需 2 次访存，耗时较长，用于复杂操作（如长立即数或大范围地址）。</td>
</tr>
<tr>
<td><strong>半字长指令</strong></td>
<td>指令长度 = 半个机器字长（如 32 位机器中指令占 16 位）</td>
<td>节省存储空间，但需对齐处理（主存按字节编址时需补足为完整字长）。</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>按是否定长分类
<ul>
<li><strong>定长指令字结构</strong>：所有指令的长度都是相等的，执行速度快，控制简单</li>
<li><strong>变长指令字结构</strong>：指令的长度随功能而异<br>
主存一般按字节编制，所以<strong>指令字长多为字节的整数倍</strong></li>
</ul>
</li>
</ol>
<h4 id="具体指令结构">具体指令结构</h4>
<ul>
<li>下图指令字长 32 位：
<ul>
<li>【操作码 (OP) 8 位】+【地址码 (A) 共 4 个，每个 6 位】</li>
</ul>
</li>
<li>指令访问内存的过程：
<ul>
<li>首先 000000 这个位置上存放着操作指令</li>
<li>$A_1$，$A_2$ 上存着两串数</li>
<li>他们在 000000 指令的执行下，要进行加法操作，将结果填入到 $A_3$ 中</li>
<li>$A_3$ 中的数据就是 $A_1$ + $A_2$ 的和</li>
<li>最后再去 $A_4$ 读取出指令，开始下一轮工作</li>
</ul>
</li>
<li>内存中既有操作码，又有地址码，这样把他们放在一起并不好可以优化他们
<ul>
<li>把操作码放一起，地址码放一块</li>
<li>通过程序计数器使操作码 +1 顺序执行</li>
</ul>
</li>
<li>优化后的好处：
<ul>
<li>将操作码放一块，我们可以让程序执行完一步就自动执行下一句指令</li>
<li>这样我们的指令就不用存放下一条指令的位置了</li>
<li>这样访存的次数少了一次，速度也会快点</li>
<li>如无例外（如跳转指令），执行完就直接下一条继续，也就是顺序执行</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240422220641.png" alt="image.png"></p>
<h4 id="指令地址码">指令地址码</h4>
<h5 id="零地址指令">零地址指令</h5>
<p>只给出操作码 OP，没有显示地址，操作数来源隐含。<br>
访存次数：1 次（仅取指令）。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423175431.png" alt="image.png"></p>
<ol>
<li>不需要操作数的指令：<strong>空操作</strong>指令，<strong>停机</strong>指令，<strong>关中断</strong>指令<br>
<code>NOP</code>（空操作）：无操作数，地址码为 0 位。</li>
<li>堆栈计算机，两个操作数来自<strong>堆栈</strong>的<font color="#ff0000">栈顶和次栈顶单元</font>【基于后缀表达式】<br>
<code>RET</code>（从子程序返回）：操作数隐含在栈顶，无需显式地址码<br>
堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。<br>
若是<strong>软堆栈</strong>(堆栈区由<strong>内存</strong>实现)，则对于双目运算需要访问<strong>4次</strong>内存：取指令、取源数 取源数2、存结果。<br>
若是<strong>硬堆栈</strong>(堆栈区由<strong>寄存器</strong>实现)，则只需在取指令时访问<strong>1次</strong>内存。</li>
</ol>
<h5 id="一地址指令">一地址指令</h5>
<p>含 1 个地址码，操作数可能是<strong>寄存器、立即数或隐含位置</strong>。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423180024.png" alt="image.png"></p>
<ol>
<li>只有目的操作数的<strong>单操作数</strong>指令：
<ul>
<li>OP ($A_1$) -&gt; $A_1$<br>
注：$A_1$指某个主存地址，$(A_1)$指$A_1$所指向的地址中的内容</li>
<li>eg.自增、自减、取反、求补</li>
<li>若地址码字段均为主存地址，完成一条指令需要 3 次访存（取指 -&gt; 读 $A_1$ -&gt; 写 $A_1$）<br>
如 <code>INC [A1]</code>：3 次（取指令 → 读 <code>A1</code> → 写 <code>A1</code>）</li>
</ul>
</li>
<li><strong>隐含</strong>约定目的地址的<strong>双操作数</strong>指令
<ul>
<li>(ACC) OP ($A_1$) -&gt; ACC</li>
<li>另一个操作数由 ACC（累加器）提供</li>
<li>完成一条指令需要 2 次访存（取指 -&gt; 读 $A_1$）<br>
<code>ADD ACC, [A1]</code>：2 次（取指令 → 读 <code>A1</code>，结果存 <code>ACC</code>【存回ACC不需要访存】）。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INC [0x1000]   ; 内存地址 0x1000 的值加 1</span><br><span class="line">ADD ACC, [0x2000] ; ACC = ACC + [0x2000]</span><br></pre></td></tr></table></figure>
<h5 id="二地址指令">二地址指令</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423175953.png" alt="image.png"></p>
<ul>
<li>($A_1$) OP ($A_2$) -&gt; $A_1$</li>
<li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li>
<li>完成一条指令需要 4 次访存（取指 -&gt; 读 $A_1$ -&gt; 读 $A_2$ -&gt; 写 $A_1$）</li>
</ul>
<h5 id="三地址指令">三地址指令</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423175606.png" alt="image.png"></p>
<ul>
<li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li>
<li>($A_1$) OP ($A_2$) -&gt; $A_3$</li>
<li>完成一条指令需要 4 次访存（取指 -&gt; 读 $A_1$ -&gt; 读 $A_2$ -&gt; 写 $A_3$）</li>
</ul>
<h5 id="四地址指令">四地址指令</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423180042.png" alt="image.png"></p>
<ul>
<li>($A_1$) OP ($A_2$) -&gt; $A_3$，$A_4$ =下一条将要执行指令的地址</li>
<li>正常情况下：取指令之后 PC + 1，指向下一条指令</li>
<li>四地址指令：执行指令后，将 PC 的值修改为 $A_4$ 所指地址</li>
<li>完成一条指令需要 4 次访存（取指 -&gt; 读 $A_1$ -&gt; 读 $A_2$ -&gt; 写 $A_3$）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>格式</strong></th>
<th><strong>访存次数</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>二地址指令</strong></td>
<td><code>OP A1, A2</code></td>
<td>4 次</td>
<td>算术运算（如 <code>ADD A1, A2</code> → <code>A1 = A1 + A2</code>）</td>
</tr>
<tr>
<td><strong>三地址指令</strong></td>
<td><code>OP A1, A2, A3</code></td>
<td>4 次</td>
<td>结果存独立地址（如 <code>A3 = A1 + A2</code>）</td>
</tr>
<tr>
<td><strong>四地址指令</strong></td>
<td><code>OP A1, A2, A3, A4</code></td>
<td>4 次</td>
<td>跳转指令（如 <code>A4</code> 指定下一条指令地址）</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>访存过程</strong>：
<ul>
<li><strong>二地址</strong>：取指令 → 读 <code>A1</code> → 读 <code>A2</code> → 写 <code>A1</code>。</li>
<li><strong>四地址</strong>：执行后直接跳转至 <code>A4</code>，无需 <code>PC+1</code>。<br>
正常情况下，取指令后PC+1，指向下一条指令</li>
</ul>
</li>
</ul>
<p><strong>地址码位数的影响</strong>：</p>
<ul>
<li><strong>直接寻址范围</strong>：$\text{寻址范围} = 2^{\text{地址码位数}}$
<ul>
<li>若地址码为 <code>n</code> 位，可寻址 <code>2^n</code> 个存储单元。</li>
</ul>
</li>
<li><strong>指令总长固定时的权衡</strong>：
<ul>
<li>地址码数量↑ =&gt; 单个地址码位数↓ =&gt; 寻址能力↓。</li>
<li>例如：32 位定长指令中，二地址指令每个地址占 12 位（寻址 4KB），三地址指令每个地址占 8 位（寻址 256B）。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>术语</strong></th>
<th><strong>定义</strong></th>
<th><strong>示例/说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>指令字长</strong></td>
<td>一条指令的总位数（如 x86 指令可为 1~15 字节）</td>
<td><strong>变长</strong>设计提高灵活性。</td>
</tr>
<tr>
<td><strong>机器字长</strong></td>
<td>CPU 一次整数运算处理的位数（如 64 位 CPU）</td>
<td>字长不变。决定<strong>寄存器大小和 ALU 宽度</strong>。</td>
</tr>
<tr>
<td><strong>存储字长</strong></td>
<td>一个存储单元的位数（如 64 位内存条的存储字长为 64 位）</td>
<td>与 <strong>MDR</strong>（内存数据寄存器）位数一致。</td>
</tr>
<tr>
<td><strong>机器指令</strong></td>
<td>CPU 直接执行的二进制编码（如 <code>B8 01 00 00 00</code> 表示 <code>MOV EAX, 1</code>）。</td>
<td>硬件与软件的接口。</td>
</tr>
<tr>
<td><strong>汇编指令</strong></td>
<td>机器指令的助记符形式（如 <code>MOV EAX, 1</code>）</td>
<td>与机器指令一一对应，依赖具体架构。</td>
</tr>
<tr>
<td><strong>机器</strong>指令和<strong>汇编</strong>指令都是机器级指令</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="指令操作码">指令操作码</h4>
<h5 id="定长操作码">定长操作码</h5>
<ul>
<li>在指令字的最高部分分配固定的若干位（定长）表示操作码</li>
<li>一般取 n 位操作码字段的指令系统最大能表示 $2^n$ 条指令</li>
<li>优点：简化计算机硬件的设计，提高指令译码和识别速度</li>
<li>缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限</li>
</ul>
<h5 id="可变长度操作码">可变长度操作码</h5>
<ul>
<li>全部指令的<strong>操作码字段的位数不固定</strong>，且分散地放在指令字的不同位置上</li>
<li>最常见的变长操作码方法是<strong>扩展操作码</strong>，使<strong>操作码的长度随地址码的减少而增加</strong>，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地<strong>缩短指令字长</strong><br>
目的：<strong>保持指令长度不变而增加指令的数量</strong></li>
<li>优点：在指令字长有限的前提下扔保持比较丰富的指令种类</li>
<li>缺点：增加了指令译码和分析的难度，使控制器的设计复杂化</li>
</ul>
<h6 id="扩展操作码计算">扩展操作码计算</h6>
<p>核心设计原则：</p>
<ol>
<li><strong>禁止短码作为长码前缀</strong>：短操作码不能与长操作码的前缀相同，避免解码冲突。</li>
<li><strong>操作码唯一性</strong>：各指令的操作码必须互不重复。</li>
<li><strong>分层扩展机制</strong>：通过保留特定编码（如全 <code>1</code>）触发下一级扩展，逐级释放操作码空间。</li>
<li><strong>频率优化</strong>：高频指令分配短操作码（如三地址指令），低频指令分配长操作码（如零地址指令）<br>
<strong>指令字长固定为 16 位</strong>，划分为 <strong>4 位操作码（OP）</strong> 和 **3 个 4 位地址字段（A₁、<br>
A₂、A₃）</li>
</ol>
<table>
<thead>
<tr>
<th><strong>指令类型</strong></th>
<th><strong>操作码字段</strong></th>
<th><strong>地址字段</strong></th>
<th><strong>指令数量</strong></th>
<th><strong>保留扩展码</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>三地址指令</td>
<td>OP（4 位）</td>
<td>A1,A2​, A3​</td>
<td>15 条</td>
<td>OP = <code>1111</code></td>
</tr>
<tr>
<td>二地址指令</td>
<td>OP + A1​（8 位）</td>
<td>A2​, A3​</td>
<td>15 条</td>
<td>OP + A1​ = <code>1111 1111</code></td>
</tr>
<tr>
<td>一地址指令</td>
<td>OP + A1​ + A2​（12 位）</td>
<td>A3​</td>
<td>15 条</td>
<td>OP + A1 + A2 = <code>1111 1111 1111</code></td>
</tr>
<tr>
<td>零地址指令</td>
<td>OP + A1​ + A2​ + A3​（16 位）</td>
<td>无</td>
<td>16 条</td>
<td>无</td>
</tr>
</tbody>
</table>
<ol>
<li>三地址指令<br>
操作码字段：OP（4 位）<br>
可用编码：0000 ~ 1110（共 15 条）<br>
保留编码：1111 用于扩展至二地址指令。</li>
<li>二地址指令<br>
触发条件：OP = 1111<br>
操作码字段：A₁（4 位）<br>
可用编码：0000 ~ 1110（共 15 条）<br>
保留编码：1111 用于扩展至一地址指令。</li>
<li>一地址指令<br>
触发条件：OP + A₁ = 1111 1111<br>
操作码字段：A₂（4 位）<br>
可用编码：0000 ~ 1110（共 15 条）<br>
保留编码：1111 用于扩展至零地址指令。</li>
<li>零地址指令<br>
触发条件：OP + A₁ + A₂ = 1111 1111 1111<br>
操作码字段：A₃（4 位）<br>
可用编码：0000 ~ 1111（共 16 条），无保留码。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423182012.png" alt="image.png"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424193133113.png" alt="image.png|400"></li>
</ol>
<ul>
<li>拓展操作码<strong>不一定只能有一条</strong>，也就是说不一定只有 1111 作拓展操作码</li>
<li>地址长度为 n，上一层留出 m 条指令，下一层可扩展出 $m×2^n$ 条指令</li>
</ul>
<p>eg.<br>
<strong>假设指令字长为 16 位，操作数的地址码为 6 位，指令有零地址、一地址、二地址 3 种格式。</strong><br>
<strong>1）设操作码固定，若零地址指令有 M 种，一地址指令有 N 种，则二地址指令最多有几种？</strong><br>
<strong>2）采用扩展操作码技术，二地址指令最多有几种？</strong><br>
<strong>3）采用扩展操作码技术，若二地址指令有 P 条，零地址指令有 Q 条，则一地址指令最多有几种？</strong></p>
<ol>
<li>一个操作码，两个地址码，所以操作码占4位，因为操作码的位数反映了机器允许的指令条数，最多包含2^4=16条。二地址指令数 = 总指令数 - 零地址指令 - 一地址指令 = <code>16 - M - N</code>。</li>
<li>
<ul>
<li>前 4 位操作码需保留 <code>1111</code> 用于扩展。2^4-1=15种</li>
</ul>
</li>
<li>二地址指令操作码 4 位，可有 $2^4$ 种编码。 二地址指令有 $p$ 条，则留出 $2^4 - p$ 种编码用于 一地址指令的扩展。 一地址指令操作码字段可有 $2^6×(2^4 - p)$ 种 编码，假设留出 $n$ 种用于零地址的扩展，则 $2^6×n = Q$ $\Rightarrow n = Q / 2^6 \Rightarrow$ 一地址最多有 $(2^4 - p)×2^6 - Q / 2^6$ 种。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424195604061.png" alt="image.png"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424203306695.png" alt="image.png"></p>
<h2 id="指令的寻址方式">指令的寻址方式</h2>
<h3 id="指令寻址">指令寻址</h3>
<ul>
<li>确定<strong>下一条</strong>要执行的指令的存放地址</li>
<li>由<strong>程序计数器</strong> PC 指明
<ul>
<li>程序计数器是指让程序执行完一步就自动执行下一句指令的<strong>物理硬件</strong></li>
<li>若机器按字寻址，PC 给出下一条指令字的访存地址 (指令在内存中的地址)，因此 <strong>PC 的位数取决于存储器的字数</strong></li>
<li>若机器按字寻址，指令寄存器 IR 用于接收取得的指令，因此 <strong>IR 的位数取决于指令字长</strong>|<br>
每一条指令的执行都需要“取指令”，“执行指令”两个阶段</li>
</ul>
</li>
</ul>
<h4 id="种类">种类</h4>
<ol>
<li><strong>顺序寻址</strong>：通过程序计数器 PC + 1，自动形成下一条指令的地址
<ul>
<li>“1” 理解为指令字长，实际加的值会因指令长度、编址方式而不同</li>
<li>现代计算机通常是按字节编址的，若指今字长为 16 位则 PC 自增为(PC)+2；若指令字长为 32 位，则 PC 自增为(PC)+4.</li>
</ul>
</li>
<li><strong>跳跃寻址</strong>：通过转移类指令（如相对寻址）实现，可用来实现程序的条件或无条件转移
<ul>
<li><strong>跳跃</strong>：指下条指令的地址不由 PC 自动给出，而由本条指令给出下条指令地址的计算方式</li>
<li>跳跃的方式分为<strong>绝对转移</strong>【地址码直接指出转移目标地址】和<strong>相对转移</strong>【地址码指出转移目的地址相对于当前 PC 值的偏移量】</li>
<li>跳跃的结果是当前指令修改 PC 值，下一条指令仍然通过 PC 给出，<strong>CPU 总是根据 PC 的内容去主存取指令</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425203000698.png" alt="image.png"></li>
</ul>
</li>
</ol>
<h3 id="数据寻址">数据寻址</h3>
<ul>
<li>确定<strong>本条指令</strong>的地址码指明的真实地址</li>
<li>表示的是<strong>操作数的地址</strong></li>
</ul>
<h4 id="地址码的组成">地址码的组成</h4>
<ul>
<li>地址码 = 寻址特征 + 形式地址
<ul>
<li><strong>寻址特征</strong>：指明属于那种寻址方式（其位数决定了寻址方式的种类）</li>
<li><strong>形式地址 A</strong>：不代表操作数的真实地址，需要根据寻址特征的要求转换为对应存储器的地址</li>
<li><strong>有效地址 EA</strong>：通过寻址方式和形式地址计算出操作数在存储器中的真实地址<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426162040.png" alt="image.png"></li>
</ul>
</li>
<li><strong>A</strong> 既可以是寄存器编号，又可以是内存地址，<strong>(A)</strong> 表示地址为 A 的数值</li>
<li><strong>EA=A</strong> 表示形式地址 A 就是真实地址 EA</li>
<li><strong>EA=(A)</strong> 表示形式地址 A 的内容就是真实地址 EA<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425203654408.png" alt="image.png"></li>
</ul>
<h4 id="常见的数据寻址方式">常见的数据寻址方式</h4>
<p>数据存放在存储器，寄存器<br>
指令在代码段</p>
<p>MOV 目标， 源<br>
DST目标操作数：通用寄存器、段寄存器、存储单元、立即数<br>
SRC源操作数：通用寄存器、段寄存器、存储单元<br>
MOV指令中的源和目的操作数中至少要有一个是寄存器。</p>
<p><strong>访问主存空间的：</strong></p>
<h5 id="隐含寻址">隐含寻址</h5>
<ul>
<li><strong>定义</strong>：不直接给出操作数的地址，而是在指令中就隐含操作数的地址</li>
<li><strong>寻址过程</strong>：
<ul>
<li>形式地址 A 取出对应的一个操作数</li>
<li>另一个操作数通过隐含寻址方式的指令设置，隐含在 ACC 中</li>
</ul>
</li>
<li><strong>有效地址</strong>：由程序指定<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204734489.png" alt="image.png"></li>
<li><strong>优点</strong>：有利于缩短指令字长</li>
<li><strong>缺点</strong>：需增加存储操作数或隐含地址的硬件</li>
</ul>
<h5 id="立即寻址【操作数在指令中】">立即寻址【操作数在指令中】</h5>
<p>MOV AL,07H<br>
MOV AL,’A’<br>
MOV AX,1A2BH</p>
<ul>
<li><strong>定义</strong>：把我们实际要操作的数，<strong>直接存放</strong>在形式地址中</li>
<li><strong>寻址过程</strong>：
<ul>
<li>寻址特征为 <strong>#</strong>，代表立即寻址的意思</li>
<li>形式地址写的是操作数 3 的<strong>补码</strong>（011）</li>
</ul>
</li>
<li><strong>有效地址</strong>： A 就是操作数，也称<strong>立即数</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425205022682.png" alt="image.png"></li>
<li><strong>优点</strong>：指令在执行阶段<strong>不访存</strong>，指令执行速度最快</li>
<li><strong>缺点</strong>：A 的位数限制了立即数的范围</li>
</ul>
<p>注：</p>
<ol>
<li>立即数只能做源操作数。MOV 3,AL ×</li>
<li>源、目的操作数的<strong>字长必须一致</strong>。MOV AH（8位），3064H（16位） ×</li>
<li>汇编程序在进行汇编时，会将不同进制的立即数一律汇编为等值的二进制数，负数则用其<strong>补码</strong>形式表示。<br>
MOV BL,‘A’ ;指令执行后(BL)=41H，指令等同于MOV BL,41H</li>
</ol>
<h5 id="直接寻址-地址">直接寻址 <code>[地址]</code></h5>
<ul>
<li><strong>定义</strong>：指令的地址码直接给出操作数所在的存储单元地址</li>
<li><strong>寻址过程</strong>：根据这个有效位置去内存中寻找操作数</li>
<li><strong>有效地址</strong>：EA = A<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204856174.png" alt="image.png"></li>
<li><strong>优点</strong>：简单，不需要专门计算操作数的地址，指令在执行阶段仅需<strong>访存 1 次</strong></li>
<li><strong>缺点</strong>：形式地址 A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改<br>
注：</li>
</ul>
<ol>
<li>默认段是DS</li>
<li></li>
</ol>
<h5 id="间接寻址">间接寻址</h5>
<ul>
<li><strong>定义</strong>：A为操作数地址的地址</li>
<li><strong>寻址过程</strong>：去该主存单元取操作数的地址，再去找操作数</li>
<li><strong>有效地址</strong>：EA = (A)<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204339483.png" alt="image.png"></li>
<li><strong>优点</strong>：可<strong>扩大寻址范围</strong>【EA 的位数大于 A 的位数】，多次间接寻址便于<strong>编制程序</strong>【方便完成子程序的返回】</li>
<li><strong>缺点</strong>：指令在执行阶段要多次访存（<strong>1 次间址 2 次访存</strong>），<strong>执行速度较慢</strong></li>
</ul>
<p><strong>访问寄存器的：</strong></p>
<h5 id="寄存器寻址【操作数在寄存器中】">寄存器寻址【操作数在寄存器中】</h5>
<ul>
<li><strong>定义</strong>：地址字段给出的是<strong>操作数所在寄存器的编号</strong></li>
<li><strong>寻址过程</strong>：访问该寄存器，取出操作数</li>
<li><strong>有效地址</strong>：EA = $R_i$<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204613673.png" alt="image.png|400"></li>
<li><strong>优点</strong>：指令在执行阶段<strong>不用访存</strong>，只访问寄存器，执行速度快，指令字长较短【寄存器数量远小于内存单元数，地址码位数较少】</li>
<li><strong>缺点</strong>：寄存器价格昂贵，CPU 的寄存器数量有限</li>
<li>注：
<ol>
<li>两个操作数不能同为<strong>段寄存器</strong>（如 <code>MOV ES, DS</code> ）。</li>
<li><strong>目的</strong>操作数不能是代码<strong>段寄存器</strong>（如<code>CS</code> ），但可作为<strong>源</strong>操作数。</li>
<li>两个操作数不能同时为存储单元 <code>eg.mov [0x1345] [0x1321]</code></li>
<li>立即数不能作为⽬的操作数，如mov 110H,AX</li>
<li><strong>立即数</strong>不能直接传给<strong>段寄存器</strong>，如mov DS,110H // 翻译成机器码很长</li>
<li>不允许 存储器-&gt;存储器</li>
<li>必须采用<strong>同样长度</strong>的寄存器</li>
</ol>
</li>
</ul>
<h5 id="寄存器间接寻址">寄存器间接寻址</h5>
<ul>
<li><strong>定义</strong>：地址字段给出的是操作数所在的寄存器的地址</li>
<li><strong>寻址过程</strong>：根据该地址去寄存器中找到操作数的有效地址</li>
<li><strong>有效地址</strong>：EA = $(R_i)$<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204700981.png" alt="image.png"></li>
<li><strong>优点</strong>：相比间接寻址，既扩大了寻址范围，又减少了访存次数（执行阶段仅访存 1 次）</li>
<li><strong>缺点</strong>：相比寄存器访存，执行阶段需要访存（操作数在主存中）</li>
</ul>
<p>注：</p>
<ol>
<li>源和目的操作数不能同时为存储器操作数（如 <code>MOV [BX], [SI]</code>）</li>
<li>不允许使用 <strong>AX、CX、DX、SP 存放 EA</strong> ，例如 <code>MOV AX,[CX]</code> 是错误指令<br>
<strong>源</strong>操作数不能是AX、CX、DX、SP</li>
<li>立即数和存储器寻址方式同时使用时应明示数据类型 ，如 <code>MOV [BX],20H</code> 写法错误，应明确数据类型（如字节型 <code>BYTE PTR [BX],20H</code> 、字型 <code>WORD PTR [BX],20H</code> 等 ）</li>
<li>有【】间接，无【】寄存器寻址</li>
<li>可以用于间接寻址的寄存器有基址寄存器BX、BP 和变址寄存器 SI、DI。</li>
<li>$PA（物理地址） = \begin{cases} (DS) \ (SS) \ \vdots \end{cases} \times 16 + \begin{cases} (SI) \ (DI) \ (BX) \ (BP) \end{cases}$<br>
$PA=SS×10H+BP$<br>
有效地址EA由寄存器(BX，BP，SI，DI)间接给出：<br>
当EA=(BX)/(SI)/(DI)时：PA=(DS)x16+EA<br>
当EA=(BP)时：PA=(SS)x16+EA</li>
<li><strong>MOV BL, [1200H]</strong><br>
这是存储器寻址指令。默认使用数据段寄存器 <code>DS</code> ，根据 <code>DS</code> 中的段地址和偏移地址 <code>1200H</code> 计算出物理地址，然后从该物理地址对应的内存单元中取出 8 位数据，传送到寄存器 <code>BL</code> 中 。假设 <code>DS = 3000H</code> ，物理地址就是 <code>3000H×16 + 1200H = 31200H</code> ，从 <code>31200H</code> 地址单元取数据给 <code>BL</code><br>
<strong>MOV BL, ES:[1200H]</strong><br>
与上一条类似，但明确指定使用附加段寄存器 <code>ES</code> 。根据 <code>ES</code> 中的段地址和偏移地址 <code>1200H</code> 计算物理地址，再从对应内存单元取 8 位数据传至 <code>BL</code> 。比如 <code>ES = 4000H</code> ，物理地址就是 <code>4000H×16 + 1200H = 41200H</code> ，从这里取数据给 <code>BL</code> 。<br>
<strong>MOV AX, [SI]</strong><br>
已知 <code>SI = 1200H</code> ，这是寄存器间接寻址。使用默认的数据段寄存器 <code>DS</code> ，结合 <code>DS</code> 的段地址和 <code>SI</code> 中的偏移地址 <code>1200H</code> 算出物理地址，从该地址对应内存单元取出 16 位数据传至 <code>AX</code> 。<br>
<strong>MOV AX,[BX]</strong>：源操作数在数据段，EA（有效地址，偏移量） = BX，PA = DS×16 + EA 。表示从数据段中，以 BX 寄存器的值为有效地址，计算出物理地址后，将对应存储单元的内容传送给 AX 寄存器。<br>
<strong>MOV [BP],DI</strong>：目的操作数在堆栈段，EA = BP，PA = SS×16 + EA 。即将 DI 寄存器中的内容传送到堆栈段中，以 BP 寄存器的值为有效地址对应的存储单元。</li>
<li></li>
</ol>
<table>
<thead>
<tr>
<th><strong>寄存器</strong></th>
<th><strong>主要限制</strong></th>
<th><strong>错误用法</strong></th>
<th><strong>正确用法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AX</code>/<code>CX</code>/<code>DX</code></td>
<td>不能用于基址/变址寻址</td>
<td><code>MOV [AX + SI], BX</code></td>
<td><code>MOV [BX + SI], AX</code></td>
</tr>
<tr>
<td><code>SP</code></td>
<td>不能用于基址寻址或通用计算</td>
<td><code>LEA SP, [BX+DI]</code></td>
<td><code>LEA BP, [BX+DI]</code></td>
</tr>
<tr>
<td>所有通用寄存器</td>
<td>不能替换字符串指令的隐式寄存器</td>
<td><code>STOSB DX</code></td>
<td><code>STOSB</code>（隐式用 AX）</td>
</tr>
<tr>
<td><strong>偏移寻址：</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="基址寻址">基址寻址</h5>
<ul>
<li><strong>定义</strong>：CPU 中基址寄存器（BR）的内容【首地址】 + 形式地址 A【偏移量】 = 操作数的有效地址<br>
以程序的其实存放地址作为起点</li>
<li><strong>寻址过程</strong>：程序运行前，CPU 将 BR 的值修改为程序的起始地址（存放在操作系统 PCB 中 ）</li>
<li><strong>有效地址</strong>：EA = (BR) + A</li>
<li><strong>基址寄存器</strong>：
<ul>
<li>可采用专用寄存器，可指定某个通用寄存器</li>
<li><strong>面向操作系统</strong>，内容由操作系统或管理程序确定，用于解决程序逻辑空间与存储器物理空间的无关性</li>
<li>程序执行过程中，<strong>基址寄存器内容不变</strong>（作为基地址），<strong>形式地址可变</strong>（作为偏移量）</li>
<li>采用<strong>通用寄存器时</strong>，可由用户决定哪个寄存器，但其内容仍由<strong>操作系统</strong>确定【不可修改】
<ul>
<li>若系统有 N 个通用寄存器可用作基址寄存器，则需 log₂​N 位二进制编码唯一标识每个寄存器。
<ul>
<li><strong>8个通用寄存器</strong>（如x86的EAX、EBX等）：需 <strong>3位</strong>（23=823=8）。</li>
<li><strong>16个通用寄存器</strong>（如ARM的R0~R15）：需 <strong>4位</strong>（24=1624=16）</li>
</ul>
</li>
<li>**指令格式的各部分占位：
<ul>
<li><strong>操作码位数</strong>：由指令条数决定，取 ⌈log⁡2(指令数)⌉。</li>
</ul>
</li>
<li><strong>寻址方式位数</strong>：由支持的寻址方式数量决定，取 ⌈log⁡2(寻址方式数)⌉。</li>
<li><strong>寄存器编号位数</strong>：由通用寄存器数量决定，如 16 个寄存器需 log⁡2(16)=4位。</li>
<li><strong>剩余位数</strong>：用于地址码或偏移量。</li>
<li><strong>计算地址/偏移量范围</strong>：</li>
<li><strong>直接寻址</strong>：地址码位数为 n，范围为 $0∼2^n−1$（无符号）【注：内存地址是无符号数】</li>
<li><strong>补码偏移量</strong>：位数为 m，范围为 $−2^{m−1}∼+2^{m−1}-1$。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426183205.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>可以扩大寻址范围（基址寄存器的位数大于 A 的位数）</li>
<li>用户不必考虑自己的程序存于主存的具体位置，<strong>有利于多道程序设计</strong></li>
<li>可用于<strong>编制浮动程序</strong></li>
</ul>
</li>
<li><strong>缺点</strong>：偏移量（A）的位数较短</li>
</ul>
<h5 id="变址寻址">变址寻址</h5>
<ul>
<li>
<p><strong>定义</strong>：变址寄存器（IX）的内容【偏移量】 + 形式地址 A【首地址】= 操作数的有效地址<br>
由程序员自己决定从哪里作为起点<br>
其中IX可为变址寄存器(专用)，也可用通用寄存器作为变址寄存器</p>
</li>
<li>
<p><strong>有效地址</strong>：EA = (IX) + A</p>
</li>
<li>
<p><strong>变址寄存器</strong>：</p>
<ul>
<li><strong>面向用户</strong>，程序执行过程中，内容可由<strong>用户</strong>改变（作为偏移量）【可以修改】</li>
<li>形式地址 A 不变（作为基地址）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426183710.png" alt="image.png|400"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250426190946841.png" alt="image.png"></li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>可以<strong>扩大寻址范围</strong>（变址寄存器的位数大于 A 的位数）</li>
<li>在<strong>数组处理</strong>过程中，可设定 A 为数组的首地址，不断改变 IX 的内容，便可很容易形成数组中任意一个数据的地址，适合<strong>编制循环程序</strong></li>
<li>偏移量的位数足以表示<strong>整个存储空间</strong></li>
</ul>
</li>
<li>
<p><strong>基址寻址 VS 变址寻址</strong></p>
<ul>
<li><strong>变址寻址</strong>适合处理<strong>数据串、数组</strong>。在处理数组时，可通过<strong>修改</strong>变址寄存器的值，以顺序或跳跃方式访问数组元素，提高程序处理数组数据的灵活性和效率<br>
变址寄存器内容由用户程序根据需要设定，在程序执行过程中可<strong>灵活改变</strong> ，常用于实现<strong>循环</strong>访问数据结构，可简化程序设计</li>
<li><strong>基址寻址</strong>适用于<strong>多用户的计算机系统</strong>，把每个用户的基地址存于基址寄存器，便于将用户的逻辑地址转换为物理地址，实现程序的重定位 ；也适用于程序中数据区位置相对固定，但偏移量可变的情况<br>
基址寄存器内容由操作系统或管理程序设置，一般在程序执行过程中<strong>保持不变</strong>，形式地址 A 是用户编程时确定的<strong>相对地址</strong> ，便于实现程序的<strong>动态重定位</strong></li>
</ul>
</li>
</ul>
<h5 id="基址变址寻址">基址变址寻址</h5>
<ul>
<li>32位有效地址的组成
<ul>
<li>基址寄存器 + 变址寄存器×比例+位移量<br>
$\begin{cases} EAX \ EBX \ ECX \ EDX \ EBP \ ESP \ ESI \ EDI \end{cases} + \begin{cases} EAX \ EBX \ ECX \ EDX \ EBP \ ESI \ EDI \end{cases} \times \begin{cases} 1 \ 2 \ 4 \ 8 \end{cases} + \begin{cases} 8位位移量 \ 32位位移量 \end{cases}$</li>
</ul>
</li>
<li>16位有效地址的组成
<ul>
<li>基址寄存器 + 变址寄存器+位移量<br>
$\begin{cases} BX \ BP \end{cases} + \begin{cases} SI \ DI \end{cases} + \begin{cases} 8位位移量 \ 16位位移量 \end{cases}$ 组合成多种存储器寻址方式<br>
当基址寄存器为BX时：PA=(DS)x16+EA<br>
当基址寄存器为BP时：PA=(SS)x16+EA<br>
有效地址EA：基址寄存器(BX，BP) + 变址寄存器(SI，DI)</li>
</ul>
</li>
</ul>
<p>基址寄存器：存放在基址寄存器中的内容，常用来指向数据段中数组或字符串的<strong>首地址</strong><br>
变址寄存器：存放在变址寄存器中的内容，常用来访问数组中的某个元素或字符串中的<strong>某个字符</strong><br>
偏移地址：存放在指令中的一个8位、16或32位的数，但它不是立即数，而是一个地址</p>
<ol>
<li><code>MOV [BX + DI], AX</code>：此指令中目的操作数在数据段。 EA = (BX) + (DI) ，PA = (DS)×16 + EA</li>
<li><code>MOV DX, [BX][SI]</code>：该指令里源操作数在数据段。EA = (BX) + (SI) ， PA = (DS)×16 + EA</li>
<li><code>MOV [BP][DI], BX</code>：这条指令中目的操作数在堆栈段。即 EA = (BP) + (DI) ， PA = (SS)×16 + EA<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250427200202792.png" alt="image.png"><br>
DS是数据段寄存器，SS是堆栈段寄存器，有BP/EBP（栈帧基址）的默认段寄存器是SS【数据存于堆栈段】，其他都是DS【数据存于数据段】</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250426191153246.png" alt="image.png"></p>
<h5 id="带比例变址寻址">带比例变址寻址</h5>
<p>比例因子只能是1，2，4，8</p>
<h5 id="相对寻址">相对寻址</h5>
<ul>
<li><strong>定义</strong>：PC 的内容 + 形式地址 A【相对偏移量】 = 操作数的有效地址<br>
以PC所指地址作为起点</li>
<li><strong>有效地址</strong>：EA = (PC) + A【补码表示，可正可负】</li>
<li>A 是相对于 PC 所指地址（下一条指令地址）的偏移量，可正可负，<strong>补码表示</strong></li>
<li>A 的位数决定操作数的寻址范围<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426185023.png" alt="image.png"></li>
<li><strong>优点</strong>：
<ul>
<li>操作数的地址不是固定的，随 PC 值的变化而变化，与指令地址之间总是相差一个固定的偏移量，因此<strong>便于程序浮动</strong>（一段代码在程序内部的浮动）</li>
<li>广泛应用于<strong>转移指令</strong></li>
</ul>
</li>
</ul>
<p><strong>其他寻址：</strong></p>
<h5 id="堆栈寻址">堆栈寻址</h5>
<ul>
<li><strong>定义</strong>：操作数存放在堆栈中，隐含使用<strong>堆栈指针（SP）</strong> 作为<strong>操作数地址</strong><br>
用SS段寄存器记录其段地址，用SP段寄存器记录其段地址，用SP始终指向堆栈的顶部。
<ul>
<li>入栈push：SP/ESP👇🏼高→低【从高地址向低地址存数据】
<ul>
<li><strong>先减后压</strong>【<strong>先减指针，再存数据</strong>（向低地址增长）】</li>
<li>SP = SP - 2 或 ESP = ESP - 4</li>
<li>SS : [SP] ← src 或 SS : [ESP] ← src<br>
src可以是16/32位立即数、16/32位内部寄存器、段寄存器、16/32位存储器操作数</li>
<li><strong>操作单位</strong>：
<ul>
<li>16 位模式：以 <strong>字（2 字节）</strong> 为单位，SP 减 2。</li>
<li>32/64 位模式：以 <strong>双字（4 字节）</strong> 为单位，ESP 减 4。</li>
</ul>
</li>
<li>PUSH EAX</li>
<li>PUSH DWORD PTR [EBX]</li>
<li>SS=2004H，ESP=1000H，EBX=12345678H，执行 PUSH EBX 指令后，ESP的内容为OFFCH，内存分布（小端方式）：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250504190607408.png" alt="image.png"></li>
</ul>
</li>
<li>出栈pop：SP/ESP🖕🏼低→高
<ul>
<li><strong>先弹后加</strong>【<strong>先取数据，再加指针</strong>（向高地址收缩）】</li>
<li>操作单位：
<ul>
<li>16 位模式：SP 加 2。</li>
<li>32/64 位模式：ESP 加 4。</li>
</ul>
</li>
<li>执行的操作：
<ul>
<li>dest←SS:[SP] 或 dest ← SS:[ESP]</li>
<li>SP=(SP)+2 或 ESP=(ESP)+4<br>
dest可以是16位/32位内部寄存器、段寄存器、16位或32位存储器操作数。</li>
</ul>
</li>
<li>以字或双字为单位操作
<ul>
<li>出栈字数据时，ESP加2</li>
<li>出栈双字数据时，ESP加4</li>
</ul>
</li>
<li>POP EAX;R[EAX]←SS:M[R[ESP]</li>
<li>POP DWORD PTR [EBX]; DS:M[R[EBX]←SS:M[R[ESP]<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250504192744048.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>PUSH EBP:<br>
R[ESP]←R[ESP]-4,M[R[ESP]]←R[EBP]<br>
POP EBP<br>
R[EBP]←M[R[ESP]],R[ESP]←R[ESP]+4</p>
<ul>
<li><strong>堆栈</strong>：
<ul>
<li>存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）“原则管理的存储区</li>
<li>该存储区中被读 / 写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）</li>
<li>硬件自动完成 SP 的加减操作</li>
<li><strong>硬堆栈</strong>：<strong>寄存器</strong>堆栈，速度快，成本较高，不需要访存，不适合做大容量堆栈</li>
<li><strong>软堆栈</strong>：从<strong>主存</strong>中划出一段区域，执行阶段访存 1 次</li>
<li>堆栈可用于<strong>函数调用</strong>时保存当前函数的相关信息</li>
</ul>
</li>
<li><strong>有效地址</strong>：入栈 / 出栈时 EA 的确定方式不同<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250426193739470.png" alt="image.png"></li>
<li>堆栈操作的应用
<ul>
<li>子程序调用和返回
<ul>
<li><strong>CALL 指令</strong>：将返回地址压入堆栈，再跳转到子程序。</li>
<li><strong>RET 指令</strong>：从堆栈弹出返回地址，跳回主程序。</li>
</ul>
</li>
</ul>
</li>
<li>中断处理
<ul>
<li><strong>INT 指令</strong>：压入标志寄存器、CS 和 IP，转入中断服务程序。</li>
<li><strong>IRET 指令</strong>：弹出 IP、CS 和标志寄存器，恢复原程序。</li>
</ul>
</li>
<li>参数传递与寄存器保护
<ul>
<li><strong>传递参数</strong>：通过堆栈向子程序传递参数。</li>
<li><strong>保护现场</strong>：在子程序开头压入需保护的寄存器，结尾弹出。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 子程序入口</span><br><span class="line">push ebp          ; 保护 EBP</span><br><span class="line">push eax          ; 保护 EAX</span><br><span class="line">; 子程序内容</span><br><span class="line">pop eax           ; 恢复 EAX</span><br><span class="line">pop ebp           ; 恢复 EBP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<ul>
<li>随机访问堆栈数据
<ul>
<li><strong>通过 EBP 访问参数</strong>：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ebp, esp        ; EBP 指向当前栈顶</span><br><span class="line">mov eax, [ebp + 8]  ; 访问栈中第 3 个双字参数（假设 32 位模式）</span><br></pre></td></tr></table></figure>
<ul>
<li>注：
<ul>
<li><strong>入栈与出栈必须成对</strong>，避免栈指针错位</li>
</ul>
</li>
</ul>
<h4 id="对比">对比</h4>
<ul>
<li>速度方面：<strong>立即寻址 &gt; 寄存器寻址 &gt; 直接寻址 &gt; 寄存器间接寻址 &gt; 间接寻址</strong></li>
</ul>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>有效地址</th>
<th>例子</th>
<th>访存次数（指令执行期间）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>隐含</strong>寻址</td>
<td>程序指定</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td><strong>立即</strong>寻址</td>
<td>A 即是操作数</td>
<td><code>MOV AX, 100</code></td>
<td>0</td>
</tr>
<tr>
<td><strong>直接</strong>寻址</td>
<td>EA = A</td>
<td><code>MOV AX, [2000H]</code></td>
<td>1</td>
</tr>
<tr>
<td><strong>一次间接</strong>寻址</td>
<td>EA = (A)</td>
<td><code>MOV AX, [[3000H]]</code></td>
<td>2</td>
</tr>
<tr>
<td><strong>寄存器</strong>寻址</td>
<td>EA = Ri​</td>
<td><code>ADD AX, BX</code></td>
<td>0</td>
</tr>
<tr>
<td><strong>寄存器间接一次</strong>寻址</td>
<td>EA = (Ri​)</td>
<td><code>MOV AX, [BX]</code></td>
<td>1</td>
</tr>
<tr>
<td>转移指令 - <strong>相对</strong>寻址</td>
<td>EA = (PC) + A</td>
<td>PC为基准跳转</td>
<td>1</td>
</tr>
<tr>
<td>多道程序 - <strong>基址</strong>寻址</td>
<td>EA = (BR) + A</td>
<td>BR做起点偏移</td>
<td>1</td>
</tr>
<tr>
<td><strong>循环</strong>程序、<strong>数组</strong>问题 - <strong>变址</strong>寻址</td>
<td>EA = (IX) + A</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td><strong>堆栈</strong>寻址</td>
<td>入栈 / 出栈时 EA 的确定方式不同，硬堆栈不访存，软堆栈访存 1 次</td>
<td>硬：寄；软：内</td>
<td></td>
</tr>
<tr>
<td><strong>立即寻址</strong>：操作数获取便捷，通常用于给寄存器赋初值。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>直接寻址</strong>：相对于立即寻址，<strong>缩短了指令长度</strong>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>间接寻址</strong>：<strong>扩大了寻址范围</strong>，便于编制程序，易于完成<strong>子程序返回</strong>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>寄存器寻址</strong>的<strong>指令字较短</strong>，指令<strong>执行速度较快</strong>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>寄存器间接寻址</strong> <strong>扩大了寻址范围</strong>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>基址寻址</strong> <strong>扩大了操作数寻址范围</strong>，适用于<strong>多道程序设计</strong>，常用于为程序或数据分配存储空间。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>变址寻址</strong>主要用于处理<strong>数组</strong>问题，适合编制<strong>循环</strong>程序。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>相对寻址</strong>用于控制程序的执行<strong>顺序、转移</strong>等。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。即：</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>基址寻址</strong>：(BR)+A</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BR基址寄存器的内容由操作系统控制，程序员可操作偏移地址A。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>变址寻址</strong>：(IX)+A</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>偏移地址A不变，程序员可操作的是变址寄存器IX。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425211646242.png" alt="image.png"></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="（MOV）操作数限制总结">（MOV）操作数限制总结</h5>
<p><strong>1. 段寄存器（CS/DS/ES/SS/FS/GS）的限制</strong></p>
<ul>
<li><strong>两个段寄存器不能直接传送</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV ES, DS   ;  错误：不能 MOV 段寄存器 → 段寄存器</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>立即数不能直接传给段寄存器</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS, 1000H   ;  错误：不能 MOV 立即数 → 段寄存器</span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong>（需通过通用寄存器中转）：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, 1000H</span><br><span class="line">MOV DS, AX      ;  正确</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AX、CX、DX、SP 不能作为目标操作数</strong>（但可作为源操作数）</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV CS, AX   ;  错误：CS 不可修改</span><br><span class="line">MOV AX, CS   ;  正确：CS 可作为源</span><br></pre></td></tr></table></figure>
<p><strong>2. 立即数的限制</strong></p>
<ul>
<li><strong>立即数不能作为目标操作数</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV 110H, AX   ;  错误：立即数不能是目标</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>立即数不能直接传给存储器操作数（需指定数据类型）</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV [BX], 9      ;  错误：未指明字节/字/双字</span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong>（使用 <code>BYTE PTR</code>/<code>WORD PTR</code> 等）：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV BYTE PTR [BX], 9   ;  字节传送</span><br><span class="line">MOV WORD PTR [BX], 9   ;  字传送</span><br></pre></td></tr></table></figure>
<p><strong>3. 存储器操作数的限制</strong></p>
<ul>
<li><strong>两个操作数不能同时为存储器操作数（不能同时带 <code>[ ]</code>）</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV [2000H], [BX]   ;  错误：不能 内存 → 内存</span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong>（通过寄存器中转）：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [BX]</span><br><span class="line">MOV [2000H], AX   ;  正确</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>存储器操作数类型必须明确</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD [SI], 20H        ;  错误：未指明字节/字</span><br><span class="line">MOV [1200H], 23H     ;  错误：未指明数据类型</span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD BYTE PTR [SI], 20H   ;  字节操作</span><br><span class="line">MOV WORD PTR [1200H], 23H ;  字操作</span><br></pre></td></tr></table></figure>
<p><strong>4. 寄存器组合的限制</strong></p>
<ul>
<li><strong>基址/变址寄存器组合无效</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [SI+DI]        ;  错误：不能两个变址寄存器（SI+DI）</span><br><span class="line">MOV AX, [BX+BP]        ;  错误：不能两个基址寄存器（BX+BP）</span><br><span class="line">MOV AX, [BX+BP+100H]   ;  错误：BX 和 BP 冲突</span><br></pre></td></tr></table></figure>
<p><strong>合法组合</strong>（基址 + 变址）：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [BX+SI]        ;  正确：BX（基址） + SI（变址）</span><br><span class="line">MOV AX, [BP+DI+10H]    ;  正确：BP（基址） + DI（变址）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ESP 不能用于基址变址寻址</strong>（ESP能否作为基址）</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DX, [ESP+EDI+2000H]   ;  错误：ESP 不能参与变址</span><br><span class="line">MOV EAX, [EBX + ESP*2]   ;  错误：ESP 不能作为变址寄存器</span><br><span class="line">MOV ECX, [ESP + ESI]     ;  错误：ESP 不能与变址寄存器组合</span><br></pre></td></tr></table></figure>
<p><strong>可用 <code>ESI</code>/<code>EDI</code> 代替 <code>ESP</code></strong>：</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, [EBX + ESI*2]   ;正确：ESI 是合法变址寄存器</span><br></pre></td></tr></table></figure>
<p><strong>如果必须用 <code>ESP</code>，先将其值复制到通用寄存器</strong>：</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EDX, ESP             ; 将 ESP 的值暂存到 EDX</span><br><span class="line">MOV EAX, [EBX + EDX*1]   ;间接使用</span><br></pre></td></tr></table></figure>
<p><strong>5. 数据类型一致性</strong></p>
<ul>
<li><strong>操作数类型不匹配</strong></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL, 1000H      ;  错误：1000H（16位）→ AL（8位）</span><br><span class="line">MOV AX, BL         ;  错误：BL（8位）→ AX（16位）</span><br><span class="line">MOV [SI], 35H      ;  错误：未指明字节/字</span><br><span class="line">MOV AL, 512        ;  错误：512 超出 8 位范围（AL 最大 255）</span><br><span class="line">MOV AH, BX         ;  错误：AH（8位）← BX（16位）</span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AL, 10H        ;  8 位立即数 → AL</span><br><span class="line">MOV AX, BX         ;  16 位寄存器 → 寄存器</span><br><span class="line">MOV WORD PTR [SI], 35H  ;  字操作</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>单次 MOV 只能涉及一个内存操作数</strong>（寄存器 ↔ 内存，不能内存 ↔ 内存）。</li>
<li><strong>段寄存器操作需通过通用寄存器中转</strong>。</li>
</ol>
<p>说明程序功能，寻址方式，判断对错并改正</p>
<ul>
<li><strong>MOV [2000H], BX</strong><br>
将 <code>BX</code> 的值存入内存地址 <code>2000H</code>，直接寻址，√</li>
<li><strong>MOV ESI, BL</strong><br>
将 <code>BL</code>（8 位）的值存入 <code>ESI</code>（32 位），寄存器寻址，×（操作数大小不匹配）</li>
<li><strong>MOV [EAX], 2000H</strong><br>
将立即数 <code>2000H</code> 存入 <code>[EAX]</code> 指向的内存，寄存器间接寻址，×（未指定操作数大小）</li>
<li><em><em>MOV CX, [ESP+EDI</em> 6]</em>*<br>
从 <code>[ESP + EDI*6]</code> 读取 16 位数据到 <code>CX</code>，基址变址寻址，×（比例因子只能是 1/2/4/8）</li>
<li><strong>MOV ECX, SS:[405000H]</strong><br>
从 <code>SS</code> 段地址 <code>405000H</code> 读取 32 位数据到 <code>ECX</code>，直接寻址，√</li>
<li><strong>MOV [EBX+ESP+ARY], EAX</strong><br>
将 <code>EAX</code> 存入 <code>[EBX + ESP + ARY]</code> 指向的内存，基址变址寻址，×（<code>ESP</code> 不能作为变址寄存器）</li>
<li><strong>MOV BL, [EBP+10H]</strong><br>
从 <code>[EBP + 10H]</code> 读取 8 位数据到 <code>BL</code>，基址寻址，√（默认段为 <code>SS</code>）</li>
<li><strong>MOV DX, [ESP+EDI+2000H]</strong><br>
从 <code>[ESP + EDI + 2000H]</code> 读取 16 位数据到 <code>DX</code>，基址变址寻址，×（<code>ESP</code> 不能作为基址与变址同时出现）</li>
<li><strong>MOV [EBP+ESI+20H], EBX</strong><br>
将 <code>EBX</code> 存入 <code>[EBP + ESI + 20H]</code> 指向的内存，基址变址寻址，√</li>
<li><strong>MOV AL, ES:[2000H]</strong><br>
从 <code>ES</code> 段地址 <code>2000H</code> 读取 8 位数据到 <code>AL</code>，直接寻址，√</li>
<li><em><em>MOV [EBX+ESI</em> 4-4], EDX</em>*<br>
将 <code>EDX</code> 存入 <code>[EBX + ESI*4 - 4]</code> 指向的内存，基址变址寻址，√</li>
<li><em><em>MOV AX,[ESI</em> 2+80H]</em>*<br>
从 <code>[ESI*2 + 80H]</code> 读取 16 位数据到 <code>AX</code>，变址寻址，√<br>
改正：<em><em>MOV AX, [EBX + ESI</em> 2 + 80H]</em>* 添加基址寄存器 EBX</li>
</ul>
<ol>
<li>直接寻址示例
<ul>
<li><strong>指令</strong>：MOV BX,[1234H]</li>
<li><strong>执行条件</strong>：(DS)=2000H，内存单元 21234H 的值为 5213H</li>
<li><strong>计算过程</strong>：直接地址 1234H 紧跟指令操作码后，物理地址 = DS 的值 + 偏移量 1234H = 2000H* 16 + 1234H = 21234H 。</li>
<li><strong>执行效果</strong>：取单元 21234H 的值 5213H，按 “高高低低” 原则存入寄存器 BX，执行后 BX 的值为 5213H 。</li>
</ul>
</li>
<li>寄存器间接寻址示例
<ul>
<li><strong>指令</strong>：MOV BX,[DI]</li>
<li><strong>执行条件</strong>：(DS)=1000H，(DI)=2345H，存储单元 12345H 的内容是 4354H</li>
<li><strong>计算过程</strong>：根据寄存器间接寻址规则，操作数物理地址 PA=(DS)* 16+DI = 1000H* 16 + 2345H = 12345H 。</li>
<li><strong>执行效果</strong>：把物理地址 12345H 开始的一个字的值（4354H）传送给 BX 。</li>
</ul>
</li>
<li>寄存器相对寻址示例
<ul>
<li><strong>指令</strong>：MOV BX,[SI+100H]</li>
<li><strong>执行条件</strong>：(DS)=1000H，(SI)=2345H，内存单元 12445H 的内容为 2715H</li>
<li><strong>计算过程</strong>：源操作数有效地址 EA=(SI)+100H = 2345H + 100H = 2445H ；物理地址 PA=(DS)* 16+EA = 1000H* 16 + 2445H = 12445H 。</li>
<li><strong>执行效果</strong>：把物理地址 12445H 开始的一个字的值（2715H）传送给 BX 。</li>
</ul>
</li>
<li>基址加变址寻址示例
<ul>
<li><strong>指令</strong>：MOV BX,[BX+SI]</li>
<li><strong>执行条件</strong>：(DS)=1000H，(BX)=2100H，(SI)=0011H，内存单元 12111H 的内容为 1234H</li>
<li><strong>计算过程</strong>：源操作数有效地址 EA=(BX)+(SI)=2100H + 0011H = 2111H ；物理地址 PA=(DS)* 16+EA = 1000H* 16 + 2111H = 12111H 。</li>
<li><strong>执行效果</strong>：把物理地址 12111H 开始的一个字的值（1234H）传送给 BX 。</li>
</ul>
</li>
</ol>
<h2 id="程序的机器级代码表示">程序的机器级代码表示</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250427192020070.png" alt="image.png"></p>
<h3 id="指令操作类型">指令操作类型</h3>
<h5 id="数据传送类">数据传送类</h5>
<ul>
<li>进行 <strong>CPU 和主存</strong>之间的数据传送</li>
<li><strong>LOAD</strong>：把存储器中的数据放到寄存器中【存储器→寄存器】</li>
<li><strong>STORE</strong>：把寄存器中的数据放到存储器中【寄存器→存储器】</li>
</ul>
<h5 id="运算类">运算类</h5>
<ul>
<li><strong>算术</strong>：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>英文</th>
<th>汇编指令</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>加</td>
<td>add</td>
<td>add d,s</td>
<td>计算 d + s，结果存入 d</td>
</tr>
<tr>
<td>减</td>
<td>subtract</td>
<td>sub d,s</td>
<td>计算 d - s，结果存入 d</td>
</tr>
<tr>
<td>乘</td>
<td>multiply</td>
<td>mul d,s  <br>imul d,s</td>
<td>无符号数 d * s，乘积存入 d  <br>有符号数 d * s，乘积存入 d</td>
</tr>
<tr>
<td>除</td>
<td>divide</td>
<td>div s  <br>idiv s</td>
<td>无符号数除法 edx:eax /s，商存入 eax，余数存入 edx  <br>有符号数除法 edx:eax /s，商存入 eax，余数存入 edx</td>
</tr>
<tr>
<td>取负数</td>
<td>negative</td>
<td>neg d</td>
<td>将 d 取负数，结果存入 d</td>
</tr>
<tr>
<td>自增 ++</td>
<td>increase</td>
<td>inc d</td>
<td>将 d++，结果存入 d</td>
</tr>
<tr>
<td>自减 –</td>
<td>decrease</td>
<td>dec d</td>
<td>将 d–，结果存入 d</td>
</tr>
<tr>
<td><code>edx:eax</code>组合起来表示一个 64 位的数据，其中<code>edx</code>存放高 32 位，<code>eax</code>存放低 32 位 。在除法运算中（如<code>div</code>和<code>idiv</code>指令），被除数是<code>edx:eax</code>表示的 64 位数，除以源操作数<code>s</code>后，商存到<code>eax</code>，余数存到<code>edx</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>逻辑</strong>：与、或、非、异或、位操作、位测试、位清除、位求反</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>英文</th>
<th>汇编指令</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>与</td>
<td>and</td>
<td>and d,s</td>
<td>将 d、s 逐位相与，结果放回 d</td>
</tr>
<tr>
<td>或</td>
<td>or</td>
<td>or d,s</td>
<td>将 d、s 逐位相或，结果放回 d</td>
</tr>
<tr>
<td>非</td>
<td>not</td>
<td>not d</td>
<td>将 d 逐位取反，结果放回 d</td>
</tr>
<tr>
<td>异或</td>
<td>exclusive or</td>
<td>xor d,s</td>
<td>将 d、s 逐位异或，结果放回 d</td>
</tr>
<tr>
<td>左移</td>
<td>shift left</td>
<td>shl d,s</td>
<td>将 d 逻辑左移 s 位，结果放回 d（通常 s 是常量）</td>
</tr>
<tr>
<td>右移</td>
<td>shift right</td>
<td>shr d,s</td>
<td>将 d 逻辑右移 s 位，结果放回 d（通常 s 是常量）</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>移位操作</strong>：算术移位、逻辑移位、循环移位（带进位和不带进位）</li>
</ul>
<h5 id="程序控制类">程序控制类</h5>
<ul>
<li>改变<strong>程序执行的顺序</strong></li>
<li><strong>无条件</strong>转移 JMP</li>
<li><strong>条件</strong>转移 JZ：结果<strong>为0</strong>；JO：结果<strong>溢出</strong>；JC：结果有<strong>进位</strong></li>
<li>调用 CALL、返回 RETURN、陷阱 Trap</li>
<li><strong>调用指令和转移指令的区别</strong>：前者必须保存下一条指令的地址，当子程序执行结束时，根据返回地址返回到主程序继续执行，后者不需要返回</li>
<li>转移指令，子程序调用与返回指令用于解决变动程序中<strong>指令执行次序</strong>的需求，而不是数据调用次序的需求</li>
<li>其他指令：
<ul>
<li>用于实现分支结构、循环结构的指令：cmp、test、jmp、jxxx</li>
<li>用于实现函数调用的指令：push、pop、call、ret</li>
<li>用于实现数据转移的指令：mov</li>
</ul>
</li>
</ul>
<h5 id="输入输出类">输入输出类</h5>
<ul>
<li>进行 CPU 和 I/O 设备之间的数据传送</li>
<li>传送控制命令和状态信息</li>
</ul>
<h3 id="寄存器组织">寄存器组织</h3>
<p>寄存器是 CPU 内部的高速存储单元，用于临时存放 <strong>操作数、操作数地址、中间结果</strong> 等数据。<br>
IA-32 架构的寄存器分为 <strong>通用寄存器</strong>、<strong>专用寄存器</strong> 和 <strong>段寄存器</strong> 三类。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424211310351.png" alt="image.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424213209986.png" alt="image.png"><br>
32位寄存器：E开头<br>
专用寄存器：EIP、EFLAGS<br>
16位寄存器：最后一位是X、P、S、I【性癖沙漏】<br>
8位寄存器：ABCD+H、L<br>
段寄存器：CDEFG+S，S+S</p>
<h4 id="通用寄存器">通用寄存器</h4>
<p>通用寄存器主要用于<strong>整数运算、地址操作和数据暂存</strong>，包括 <strong>8 个 32 位寄存器</strong>，其低 16 位和 8 位可独立使用：</p>
<table>
<thead>
<tr>
<th><strong>32 位寄存器</strong></th>
<th><strong>16 位寄存器</strong></th>
<th><strong>8 位寄存器</strong></th>
<th><strong>主要用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>EAX</td>
<td>AX</td>
<td>AH/AL</td>
<td><strong>累加器</strong>，存放运算结果或函数返回值</td>
</tr>
<tr>
<td>EBX</td>
<td>BX</td>
<td>BH/BL</td>
<td><strong>基址寄存器</strong>，用于<strong>内存寻址</strong></td>
</tr>
<tr>
<td>ECX</td>
<td>CX</td>
<td>CH/CL</td>
<td><strong>计数器</strong>，用于<strong>循环控制</strong></td>
</tr>
<tr>
<td>EDX</td>
<td>DX</td>
<td>DH/DL</td>
<td><strong>数据寄存器</strong>，<strong>辅助运算</strong>或 <strong>I/O 操作</strong></td>
</tr>
<tr>
<td>ESI</td>
<td>SI</td>
<td>-</td>
<td><strong>源变址寄存器</strong>，用于<strong>字符串/数组</strong>操作</td>
</tr>
<tr>
<td>EDI</td>
<td>DI</td>
<td>-</td>
<td><strong>目的变址寄存器</strong>，用于<strong>字符串/数组操作</strong></td>
</tr>
<tr>
<td>EBP</td>
<td>BP</td>
<td>-</td>
<td><strong>基址指针</strong>，指向<strong>栈帧基地址</strong></td>
</tr>
<tr>
<td>ESP</td>
<td>SP</td>
<td>-</td>
<td><strong>栈指针</strong>，指向<strong>栈顶位置</strong></td>
</tr>
<tr>
<td>32 位寄存器、16 位寄存器和 8 位寄存器属于同一组相关寄存器，只是数据存储宽度不同。16 位寄存器是 32 位寄存器的低 16 位 ，例如 <code>EAX</code> 是 32 位，<code>AX</code> 是其低 16 位；8 位寄存器是 16 位寄存器进一步拆分的结果，比如 <code>AX</code> 又可拆分为高 8 位的 <code>AH</code> 和低 8 位的 <code>AL</code> 。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>前四个用于存放操作数，后四个用于存放变址值/指针</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>用途优先级</strong>：</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据首选存储于<strong>内存</strong>，再 <strong>EAX</strong>，接着考虑 <strong>EDX</strong> 等<strong>通用寄存器</strong>，最后考虑其他寄存器。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="专用寄存器">专用寄存器</h4>
<h4 id="指令指针寄存器-EIP">指令指针寄存器 (EIP)</h4>
<ul>
<li><strong>功能</strong>：存放下一条要执行指令的 <strong>有效地址（偏移地址）</strong>。</li>
<li><strong>特性</strong>：
<ul>
<li><strong>不可直接修改</strong>，由 <strong>控制转移指令（如 JMP、CALL）</strong> 或<strong>中断/异常</strong>自动更新。</li>
<li>在<strong>实模式</strong>下为 16 位（IP），<strong>保护模式</strong>下为 32 位（EIP）。
<ul>
<li>实模式：
<ul>
<li>操作系统与用户/程序拥有同等的权利，也就是说操作系统可以做的，普通用户也可以自己做。</li>
<li>所使用的地址都是真实的物理地址</li>
</ul>
</li>
<li>保护模式：
<ul>
<li>通过分段和分页机制实现虚拟地址到物理地址的映射。</li>
<li>32 位处理器可访问 4GB 内存，支持虚拟内存，段大小可动态分配，分页提高内存管理灵活性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="标志寄存器-EFLAGS">标志寄存器 (EFLAGS)</h5>
<ul>
<li><strong>功能</strong>：反映指令<strong>执行结果</strong>或<strong>控制 CPU 操作模式</strong>。
<ul>
<li><strong>状态标志</strong>：记录算术/逻辑运算结果特征。</li>
<li><strong>控制标志</strong>：控制 CPU 行为（如中断、方向）。</li>
<li><strong>系统标志</strong>：操作系统级控制（如虚拟化、权限）。</li>
<li>关注的不是整体数据，而是每一位的含义</li>
</ul>
</li>
</ul>
<h6 id="状态标志位">状态标志位</h6>
<ol>
<li><strong>高级语言视角</strong>：在高级语言中，通过类似 “if (a&gt; b) {… } else {… }” 的语句结构进行条件判断，直接以逻辑表达式（如a &gt; b ）来决定执行不同分支的代码。</li>
<li><strong>硬件视角</strong>
<ul>
<li><strong>比较操作</strong>：通过 “cmp 指令”（如 cmp a, b ）来比较a和b，其本质是计算a - b 。</li>
<li><strong>结果存储</strong>：相减得到的结果相关信息会记录在程序状态字寄存器（PSW）中 。</li>
<li><strong>条件判断依据</strong>：依据 PSW 中的标志位进行条件判断，以决定程序是否转移。PSW 中几个关键标志位含义如下：</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>标志位</strong></th>
<th><strong>名称</strong></th>
<th><strong>触发条件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CF</td>
<td><strong>进位</strong>标志</td>
<td><strong>无符号</strong>数运算产生<strong>进位/借位</strong>时置 1</td>
</tr>
<tr>
<td>PF</td>
<td><strong>奇偶</strong>标志</td>
<td>运算结果<strong>低 8 位中 1 的个数</strong>为<strong>偶数</strong>时置 1</td>
</tr>
<tr>
<td>AF</td>
<td><strong>辅助进位</strong>标志</td>
<td>运算中<strong>低四位向高四位产生进位/借位</strong>时置 1（用于 BCD 码调整）</td>
</tr>
<tr>
<td>ZF</td>
<td><strong>零</strong>标志</td>
<td>运算<strong>结果为 0</strong> 时置 1</td>
</tr>
<tr>
<td>SF</td>
<td><strong>符号</strong>标志</td>
<td>运算结果<strong>最高位为 1</strong> 时置 1（有符号数为负数）</td>
</tr>
<tr>
<td>OF</td>
<td><strong>溢出</strong>标志</td>
<td><strong>有符号</strong>数运算结果<strong>超出范围</strong>时置 1</td>
</tr>
<tr>
<td>DF</td>
<td><strong>方向</strong>标志</td>
<td>控制字符串<strong>操作地址增减方向</strong>（0=递增，1=递减）</td>
</tr>
<tr>
<td>IF</td>
<td><strong>中断允许</strong>标志</td>
<td>控制是否响应<strong>可屏蔽中断</strong>（1=允许）</td>
</tr>
<tr>
<td>TF</td>
<td><strong>陷阱</strong>标志</td>
<td>置 1 时进入<strong>单步调试</strong>模式（每条指令后触发中断）</td>
</tr>
<tr>
<td>溢出标志OF=1【<mark>有符号</mark>】 看<mark>符号位</mark>的一列是否符合规律 +±/—+；看变形补码是否是01，10，自然丢失的不考虑。溢出的根本原因是计算机的字长有限 <strong><mark>最高位与次高位进位异或</mark></strong> 一个有进位一个没有进位,则他们的状态异或得1,则结果就有溢出</td>
<td></td>
<td></td>
</tr>
<tr>
<td>进位标志CF=1 【<mark>无符号</mark>】 <mark>最高位进位Cout和Cinsub(减法=1，加法=0)异或</mark></td>
<td></td>
<td></td>
</tr>
<tr>
<td>状态标志：6个( OF、SF、ZF、CF、AF、PF )记录指令执行结果的辅助信息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>控制标志：3个( DF、IF、TF )用来控制CPU的操作</td>
<td></td>
<td></td>
</tr>
<tr>
<td>系统标志：控操作系统或核心管理程序的操作方式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>汇编语言中，条件跳转指令有很多种，如je2表示当比较结果为 a=b 时跳转到2jg2表示当比较结果为a&gt;b时跳转到2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>无条件转移指令jmp2，就不会管PSW的各种标志位</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eg.  10010001B+01110100B=00000101B</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10010001</span><br><span class="line">+ 01110100</span><br><span class="line">──────────</span><br><span class="line">  00000101  （进位 1）</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>进位标志 CF</strong>：CF = 1，因为运算产生了进位。</li>
<li><strong>辅助进位标志 AF</strong>：AF = 0，半字节无进位。</li>
<li><strong>符号标志 SF</strong>：SF = 0，结果最高位为0，结果为正。</li>
<li><strong>零标志 ZF</strong>：ZF = 0，结果不为0。</li>
<li><strong>奇偶标志 PF</strong>：PF = 1，结果中1的个数为偶数个。</li>
<li><strong>溢出标志 OF</strong>：OF = 0，将两个操作数作为有符号数，10010001B = -6FH，01110100B = +74H，(-6FH)+(+74H)= +05H，由于不是同号相加，结果无溢出（加法OF溢出判断规则：同号相加，结果相异；OF为1，否则OF为0）。</li>
</ol>
<p>eg.01110001B - 10001011B = 11100110B</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  01110001</span><br><span class="line">- 10001011</span><br><span class="line">──────────</span><br><span class="line">  11100110  （借位 1）</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>进位标志 CF</strong>：CF = 1，因为运算产生了借位。</li>
<li><strong>辅助进位标志 AF</strong>：AF = 1，半字节产生了进位。</li>
<li><strong>符号标志 SF</strong>：SF = 1，结果最高位为1，结果为负。</li>
<li><strong>零标志 ZF</strong>：ZF = 0，结果不为0。</li>
<li><strong>奇偶标志 PF</strong>：PF = 0，结果中1的个数为奇数个。</li>
<li><strong>溢出标志 OF</strong>：OF = 1，将两个操作数作为有符号数，01110001B = +71H，10001011B = -75H，(+71H)-(-75)=-1AH ，由于是异号相减，差的符号与被减数相异（减法OF溢出判断规则：异号相减，差的符号与被减数相异，OF为1；否则OF为0），所以产生了溢出。</li>
</ol>
<h6 id="条件转移指令的比较规则">条件转移指令的比较规则</h6>
<p>①<strong>无符号整数比较（bgt）</strong>：仅依赖 <strong>CF（借位）</strong> 判断大小，ZF 用于排除相等情况</p>
<ul>
<li>
<p><strong>判断条件</strong>：A &gt; B（无符号）</p>
</li>
<li>
<p><strong>标志位逻辑</strong>：</p>
<ul>
<li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li>
<li><strong>CF=0</strong>：无借位（A ≥ B）。</li>
</ul>
</li>
<li>
<p><strong>转移条件</strong>：CF=0 且 ZF=0 → <strong>$\overline{CF + ZF} = 1$</strong></p>
</li>
<li>
<p><strong>判断条件</strong>：A ＜ B（无符号）</p>
</li>
<li>
<p><strong>标志位逻辑</strong>：</p>
<ul>
<li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li>
<li><strong>CF=1</strong>：有借位（A ≤ B）。</li>
</ul>
</li>
<li>
<p><strong>转移条件</strong>：CF=0 且 ZF=0→$CF ∧ ¬ZF$</p>
</li>
</ul>
<p>②<strong>有符号整数比较（如 bgt.s）</strong>：需结合 <strong>SF（符号）</strong> 和 <strong>OF（溢出）</strong>，确保结果符号的正确性</p>
<ul>
<li><strong>判断条件</strong>：A &gt; B（有符号）</li>
<li><strong>标志位逻辑</strong>：
<ul>
<li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li>
<li><strong>SF=OF</strong>：符号标志与溢出标志一致（结果为正且未溢出，或为负但溢出）。</li>
</ul>
</li>
<li><strong>转移条件</strong>：<strong>ZF=0 且 SF=OF</strong>（如 $\overline{SF \oplus OF} \cdot \overline{ZF} = 1$）。</li>
<li><strong>判断条件</strong>：A ＜ B（有符号）</li>
<li><strong>标志位逻辑</strong>：
<ul>
<li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li>
<li><strong>SF≠OF</strong>：符号标志与溢出标志不同，表示结果无效需反转</li>
</ul>
</li>
<li><strong>转移条件</strong>：(SF⊕OF)=1且ZF=0（如 $(SF ⊕ OF) ∧ ¬ZF$）。</li>
</ul>
<h4 id="段寄存器">段寄存器</h4>
<p>段寄存器用于 <strong>内存分段管理</strong>，与偏移地址共同构成 <strong>逻辑地址</strong>：</p>
<table>
<thead>
<tr>
<th><strong>段寄存器</strong></th>
<th><strong>名称</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CS</td>
<td><strong>代码段</strong>寄存器</td>
<td>指向<strong>当前代码段</strong>，<strong>EIP</strong> 保存<strong>段内偏移地址</strong></td>
</tr>
<tr>
<td>SS</td>
<td><strong>堆栈段</strong>寄存器</td>
<td>指向<strong>当前堆栈段</strong>，<strong>ESP</strong> 保存<strong>栈顶偏移地址</strong></td>
</tr>
<tr>
<td>DS</td>
<td><strong>数据段</strong>寄存器</td>
<td><strong>默认数据</strong>段，用于<strong>一般数据</strong>访问</td>
</tr>
<tr>
<td>ES</td>
<td><strong>附加段</strong>寄存器</td>
<td><strong>辅助数据</strong>段，常用于<strong>字符串</strong>操作的目标段</td>
</tr>
<tr>
<td>FS/GS</td>
<td><strong>附加段</strong>寄存器</td>
<td><strong>扩展数据</strong>段，<strong>操作系统或程序</strong>可自由使用</td>
</tr>
<tr>
<td><strong>逻辑地址格式</strong>：<code>段基址:偏移地址</code> → 需转换为 <strong>物理地址</strong> 访问内存。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="存储器组织">存储器组织</h4>
<h5 id="物理地址与逻辑地址">物理地址与逻辑地址</h5>
<ul>
<li><strong>物理地址</strong>：内存单元的<strong>实际地址</strong>，<strong>唯一</strong>且<strong>连续</strong>（如 IA-32 支持 4GB 空间：<code>00000000H~FFFFFFFFH</code>）。</li>
<li><strong>逻辑地址</strong>：<strong>程序员</strong>使用的地址，格式为 <code>段基址:偏移地址</code>。
<ul>
<li><strong>转换规则</strong>：物理地址 = 段基址 × 16【后面加一个0】（实模式）或通过段描述符（保护模式） + 偏移地址。</li>
<li><strong>多逻辑地址映射</strong>：同一物理地址可由不同逻辑地址表示（如 <code>1000H:2000H</code> 和 <code>2000H:1000H</code> 均指向 <code>12000H</code>）。  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425201252771.png" alt="image.png">
<ul>
<li><code>1460H × 10H + 0100H = 14600H + 0100H = 14700H</code></li>
<li><code>1380H × 10H + 0F00H = 13800H + 0F00H = 14700H</code><br>
从物理地址 <code>14700H</code> 开始的内存内容为：<br>
14700H: 43H, 14701H: 42H`（低字节在前，高字节在后）。<br>
<strong>取16位数据</strong>：</li>
</ul>
</li>
<li><strong>小端方式</strong>：低地址存低位字节 → 数据为 <code>4243H</code>。</li>
</ul>
</li>
</ul>
<h5 id="存储模型">存储模型</h5>
<p>IA-32 支持三种存储模型，用于程序访问存储器：</p>
<table>
<thead>
<tr>
<th><strong>模型</strong></th>
<th><strong>特点</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>平展模型</strong></td>
<td>单一<strong>连续</strong>地址空间（0~4GB），段寄存器指向<strong>同一基址</strong>（0）</td>
<td>现代操作系统（如 Windows）</td>
</tr>
<tr>
<td><strong>段式模型</strong></td>
<td>代码、数据、堆栈分段管理，每段最大 4GB</td>
<td>增强程序安全性与模块化</td>
</tr>
<tr>
<td><strong>实地址模型</strong></td>
<td>兼容 8086，段最大 64KB，物理地址 = 段基址 × 16 + 偏移地址</td>
<td>实模式程序或引导代码</td>
</tr>
</tbody>
</table>
<h5 id="工作模式">工作模式</h5>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>保护模式</strong></td>
<td>支持段页式存储管理、多任务与权限控制，全面发挥 32 位性能</td>
</tr>
<tr>
<td><strong>实地址模式</strong></td>
<td>兼容 8086，仅支持 1MB 内存，段最大 64KB</td>
</tr>
<tr>
<td><strong>虚拟 8086 模式</strong></td>
<td>在保护模式下运行 8086 程序，支持多任务</td>
</tr>
</tbody>
</table>
<h4 id="段选择器与段描述符">段选择器与段描述符</h4>
<ul>
<li><strong>段选择器</strong>：16 位段寄存器值，指向全局描述符表 (GDT) 或局部描述符表 (LDT) 中的条目。</li>
<li><strong>段描述符</strong>：64 位数据结构，包含段基址、段限长、访问权限等信息。
<ul>
<li><strong>基址</strong>：32 位，定义段起始物理地址。</li>
<li><strong>限长</strong>：20 位，定义段大小（单位由粒度位决定，4KB 或 1B）。</li>
<li><strong>权限</strong>：定义段的特权级（0~3）和访问类型（代码/数据/系统段）。</li>
</ul>
</li>
</ul>
<h4 id="基本段类型">基本段类型</h4>
<p>编写应用程序时，涉及三类<strong>基本段</strong>:</p>
<ul>
<li><strong>代码段</strong>  :<font color="#ff0000">CS:EIP</font>
<ul>
<li>存放<strong>指令代码</strong> 程序的指令代码<strong>必须</strong>安排在代码段</li>
<li><strong>段基地址</strong>：代码段寄存器<strong>CS</strong>指示</li>
<li><strong>偏移地址</strong>：指令指针寄存器<strong>EIP</strong>或<strong>IP</strong>保存，指向下一条要执行的指令。</li>
<li>代码段是<strong>只读</strong>的，防止程序意外修改指令</li>
<li>跳转/调用指令会修改<code>EIP</code>的值。</li>
</ul>
</li>
<li><strong>数据段</strong> :<font color="#ff0000">DS:偏移地址</font>
<ul>
<li>存放数据 程序的数据默认存放在数据段，数据也可放在其他段【保存程序的全局变量、静态数据等】</li>
<li><strong>段基地址</strong>：数据段寄存器<strong>DS</strong>指示<br>
有时也用附加段寄存器<strong>ES</strong>，段寄存器<strong>FS</strong>和<strong>GS</strong>指示，但需显式指定段前缀<br>
例如：<code>MOV EAX, ES:[EBX]</code>表示从附加段<code>ES</code>而非默认<code>DS</code>读取数据</li>
<li><strong>偏移地址</strong>：各种存储器寻址方式计算出来</li>
</ul>
</li>
<li><strong>堆栈段</strong>  : <font color="#ff0000">SS:ESP</font>
<ul>
<li>堆栈区域 程序使用的堆栈操作（如<code>PUSH</code>、<code>POP</code>、<code>CALL</code>）<strong>一定</strong>在堆栈段【存储<strong>函数调用时的返回地址、局部变量、参数</strong>等】</li>
<li><strong>段基地址</strong>：堆栈段寄存器<strong>SS</strong>指示</li>
<li><strong>偏移地址</strong>：堆栈指针寄存器<strong>ESP</strong>或<strong>SP</strong>保存</li>
<li>堆栈向<strong>低地址</strong>方向增长（如<code>PUSH EAX</code>会先<code>ESP-4</code>再写入数据）</li>
<li><code>EBP</code>通常用作栈帧基址，访问局部变量时默认基于<code>SS</code>段（如<code>[EBP-8]</code>）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>默认段寄存器</strong></th>
<th><strong>可覆盖的段寄存器</strong></th>
<th><strong>规则</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指令</td>
<td>CS</td>
<td><strong>不可覆盖</strong></td>
<td>永远从<code>CS:EIP</code>取指令</td>
</tr>
<tr>
<td>堆栈操作（PUSH/POP）</td>
<td>SS</td>
<td><strong>不可覆盖</strong></td>
<td>永远使用<code>SS:ESP</code></td>
</tr>
<tr>
<td>一般数据访问</td>
<td>DS</td>
<td>CS/ES/SS/FS/GS</td>
<td>如<code>MOV EAX, FS:[EBX]</code></td>
</tr>
<tr>
<td>以<code>EBP/ESP</code>为基址的寻址</td>
<td>SS</td>
<td>CS/ES/DS/FS/GS</td>
<td>有效地址（如<code>[EBP-如</code>MOV EAX, DS:[EBP-4]<code>4]</code>）</td>
</tr>
<tr>
<td>串操作的源操作数</td>
<td>DS</td>
<td>CS/ES/SS/FS/GS</td>
<td>必须用<code>ES:ESI</code></td>
</tr>
<tr>
<td>串操作的目的操作数</td>
<td>ES</td>
<td><strong>不可覆盖</strong></td>
<td>必须用<code>ES:EDI</code></td>
</tr>
<tr>
<td>在x86架构中，<strong>段覆盖</strong>是指<strong>显式指定一个非默认的段寄存器</strong>来访问内存数据。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>覆盖目的</strong>：临时突破默认规则，访问其他段的数据（如跨段读取或写入）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>段覆盖语法：<code>段寄存器:[偏移地址]</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1. 代码段访问</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU自动从 CS:EIP 取指令执行</span><br><span class="line">MOV EAX, [EBX]   ; 默认从 DS:[EBX] 读取数据</span><br><span class="line">MOV EAX, ES:[EBX]; 显式从 ES:[EBX] 读取</span><br><span class="line">JMP 0x1000       ; 修改 EIP，跳转到 CS:0x1000</span><br></pre></td></tr></table></figure>
<p><strong>2. 数据段覆盖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, [ESI]          ; 默认 DS:[ESI]</span><br><span class="line">MOV EAX, ES:[ESI]       ; 显式指定 ES:[ESI]</span><br><span class="line">MOV EAX, FS:[0x30]      ; 读取Windows TEB（线程环境块）</span><br></pre></td></tr></table></figure>
<p><strong>3. 堆栈操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH EAX        ; 将EAX压入 SS:ESP-4</span><br><span class="line">POP EBX         ; 从 SS:ESP 弹出数据到EBX</span><br><span class="line">CALL func       ; 将返回地址压入堆栈（SS:ESP-4）</span><br></pre></td></tr></table></figure>
<p><strong>4. 串操作（需注意段规则）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV ESI, DS:[src_addr]  ; 源地址（可省略DS）</span><br><span class="line">MOV EDI, ES:[dst_addr]  ; 目标地址（必须用ES）</span><br><span class="line">MOVSB                   ; 复制 DS:[ESI] -&gt; ES:[EDI]</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>误区</strong>：<code>CS</code>可以被显式修改（如<code>MOV CS, AX</code>）。<br>
<strong>事实</strong>：<code>CS</code>只能通过控制转移指令（如<code>JMP</code>、<code>CALL</code>）间接修改，直接写入会引发异常。</p>
</li>
<li>
<p><strong>误区</strong>：堆栈段可以用其他段寄存器覆盖。<br>
<strong>事实</strong>：堆栈操作（如<code>PUSH</code>、<code>POP</code>）强制使用<code>SS</code>，不可覆盖。</p>
</li>
<li>
<p><strong>误区</strong>：<code>EIP</code>可以像通用寄存器一样自由修改。<br>
<strong>事实</strong>：<code>EIP</code>只能通过跳转、中断等指令隐式修改，不支持<code>MOV EIP, EAX</code>这类操作。</p>
</li>
</ol>
<h4 id="常用指令">常用指令</h4>
<h5 id="数据传送指令">数据传送指令</h5>
<ul>
<li><strong>MOV</strong>：通用数据传送（如 <code>MOV EAX, [0x1000]</code>）。</li>
<li><strong>XCHG</strong>：交换两操作数值（至少一个为寄存器，如 <code>XCHG EAX, EBX</code>）。<br>
此指令不影响标准寄存器的值</li>
</ul>
<h5 id="堆栈操作指令">堆栈操作指令</h5>
<ul>
<li><strong>PUSH</strong>：将操作数压入栈顶（如 <code>PUSH EAX</code>）。</li>
<li><strong>POP</strong>：从栈顶弹出数据到目标（如 <code>POP EBX</code>）。</li>
</ul>
<h5 id="地址操作指令">地址操作指令</h5>
<ul>
<li><strong>LEA</strong>：加载有效地址到寄存器（如 <code>LEA ESI, [EBX+4]</code>）。<br>
LEA REG，SRC<br>
把源操作数SRC的地址偏移量传送至寄存器REG<br>
mov传送操作数的内容，LEA传送操作数的地址。<br>
eg.已知R[eax]=0100h，R[edx]=1000h，M[1400H]=08H，M[1100H]=02H，在平展存储模型下，说明下列指令的功能及各指令执行后eax的值。<br>
(1) <code>mov eax,[edx][eax]</code><br>
功能：R[eax]←M[R[edx]+R[eax]] ，R[eax]=02H<br>
(2) <code>mov eax,[edx+eax*4]</code><br>
功能：R[eax]←M[R[edx]+R[eax]∗4] ，R[eax]=08H<br>
(3) <code>lea eax,[edx+eax*4]</code><br>
功能：R[eax]←R[edx]+R[eax]∗4 ，R[eax]=1400H</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA BX,BUFFER;将内存单元BUFFER的偏移地址送BX</span><br><span class="line">MOV AL,[BX];取出BUFFER的第一个数据送AL</span><br><span class="line">MOV AH,[BX+1];取出BUFFER的第二个数据送AH</span><br></pre></td></tr></table></figure>
<h5 id="输入输出指令">输入输出指令</h5>
<ul>
<li><strong>IN/OUT</strong>：与 I/O 端口通信（如 <code>IN AL, 60H</code> 读取键盘输入）。<br>
<strong>输入</strong>指令：输入指令IN用于从I/O端口读数据到累加器<strong>AL、AX或EAX</strong>（没有AH）中<br>
<strong>输出</strong>指令：输出指令OUT用于把累加器<strong>AL、AX或EAX</strong>的内容写到I/O端口<br>
<strong>注意</strong> 输入输出指令中，只有累加器AL、AX或EAX才能与I/O端口进行数据传送，所以又称为累加器专用指令。<br>
IN指令：从端口输入一个字节到AL或输入一个字到AX中<br>
OUT指令：从端口输入一个字到AL或输入一个字到AX中</li>
<li>port 0~64KB</li>
<li><strong>I/O直接寻址</strong>：port为<strong>8位</strong>立即数表示的<strong>端口地址</strong>。寻址范围00H~FFH，即256个端口。</li>
<li><strong>I/O寄存器间接寻址</strong>：<strong>16位</strong>端口地址，<strong>DX</strong>为<strong>间接寄存器</strong>。寻址范围0000H~FFFH，即64个端口</li>
<li>最低的256 个端口可以用直接寻址或间接寻址</li>
<li>高于256的端口只能用间接寻址。</li>
</ul>
<p>输入指令：</p>
<table>
<thead>
<tr>
<th>指令格式</th>
<th>数据宽度</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IN AL, port</code></td>
<td>8</td>
<td>从<code>port</code>端口读 1 个字节到<code>AL</code>中</td>
</tr>
<tr>
<td><code>IN AX, port</code></td>
<td>16</td>
<td>从<code>port</code>端口读 1 个字到<code>AX</code>中</td>
</tr>
<tr>
<td><code>IN EAX, port</code></td>
<td>32</td>
<td>从<code>port</code>端口读 1 个双字到<code>EAX</code>中</td>
</tr>
<tr>
<td><code>IN AL, DX</code></td>
<td>8</td>
<td>从<code>DX</code>所指示的端口读 1 个字节到<code>AL</code>中</td>
</tr>
<tr>
<td><code>IN AX, DX</code></td>
<td>16</td>
<td>从<code>DX</code>所指示的端口读 1 个字到<code>AX</code>中</td>
</tr>
<tr>
<td><code>IN EAX, DX</code></td>
<td>32</td>
<td>从<code>DX</code>所指示的端口读 1 个双字到<code>EAX</code>中</td>
</tr>
<tr>
<td>输出指令：</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>指令格式</th>
<th>数据宽度</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OUT port, AL</code></td>
<td>8</td>
<td>将<code>AL</code>中的 1 个字节数据输出到<code>port</code>端口</td>
</tr>
<tr>
<td><code>OUT port, AX</code></td>
<td>16</td>
<td>将<code>AX</code>中的 1 个字数据输出到<code>port</code>端口</td>
</tr>
<tr>
<td><code>OUT port, EAX</code></td>
<td>32</td>
<td>将<code>EAX</code>中的 1 个双字数据输出到<code>port</code>端口</td>
</tr>
<tr>
<td><code>OUT DX, AL</code></td>
<td>8</td>
<td>将<code>AL</code>中的 1 个字节数据输出到<code>DX</code>所指示的端口</td>
</tr>
<tr>
<td><code>OUT DX, AX</code></td>
<td>16</td>
<td>将<code>AX</code>中的 1 个字数据输出到<code>DX</code>所指示的端口</td>
</tr>
<tr>
<td><code>OUT DX, EAX</code></td>
<td>32</td>
<td>将<code>EAX</code>中的 1 个双字数据输出到<code>DX</code>所指示的端口</td>
</tr>
<tr>
<td>将端口 20H 地址开始的 16 位数据取反，指令序列分别为：</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IN AX,20H</span><br><span class="line">NOT AX</span><br><span class="line">OUT 20H,AX</span><br></pre></td></tr></table></figure>
<h6 id="I-O寻址方式-VS-存储器寻址方式"><strong>I/O寻址方式 VS 存储器寻址方式</strong></h6>
<p><strong>存储器寻址方式</strong></p>
<ol>
<li>
<p><strong>立即寻址</strong></p>
<ul>
<li><strong>示例</strong>: <code>MOV DX, 03B0H</code>
<ul>
<li><code>03B0H</code> 是立即数，由指令直接给出。</li>
<li><strong>功能</strong>: 将立即数 <code>03B0H</code> 直接存入寄存器 <code>DX</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>直接寻址</strong></p>
<ul>
<li><strong>示例</strong>: <code>MOV DX, [03B0H]</code>
<ul>
<li><code>[03B0H]</code> 表示内存偏移地址 <code>03B0H</code> 处的内容。</li>
<li><strong>功能</strong>: 从内存地址 <code>DS:03B0H</code> 读取数据到 <code>DX</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>寄存器寻址</strong></p>
<ul>
<li><strong>示例</strong>: <code>MOV DX, AX</code>
<ul>
<li><code>AX</code> 是源寄存器，<code>DX</code> 是目标寄存器。</li>
<li><strong>功能</strong>: 将 <code>AX</code> 的值复制到 <code>DX</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>寄存器间接寻址</strong></p>
<ul>
<li><strong>示例</strong>: <code>MOV DX, [AX]</code>
<ul>
<li><code>[AX]</code> 表示以 <code>AX</code> 的值为内存偏移地址。</li>
<li><strong>功能</strong>: 从内存地址 <code>DS:AX</code> 读取数据到 <code>DX</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>I/O寻址方式</strong></p>
<ol>
<li>
<p><strong>直接寻址</strong></p>
<ul>
<li><strong>示例</strong>: <code>IN AL, 3FH</code>
<ul>
<li><code>3FH</code> 是端口号，作为立即数直接给出。</li>
<li><strong>功能</strong>: 从端口 <code>3FH</code> 读取数据到 <code>AL</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>寄存器间接寻址</strong></p>
<ul>
<li><strong>示例</strong>: <code>OUT DX, AL</code>
<ul>
<li><code>DX</code> 寄存器存储端口号。</li>
<li><strong>功能</strong>: 将 <code>AL</code> 的值写入 <code>DX</code> 指定的端口。</li>
<li><strong>注意</strong>: I/O 间接寻址<strong>只能用 <code>DX</code> 作为地址寄存器</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>存储器寻址</strong></th>
<th><strong>I/O寻址</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>地址范围</strong></td>
<td>访问内存单元（如 <code>DS:03B0H</code>）</td>
<td>访问I/O端口（如端口号 <code>3FH</code>）</td>
</tr>
<tr>
<td><strong>间接寻址寄存器</strong></td>
<td>任意通用寄存器（如 <code>AX</code>）</td>
<td><strong>仅限 <code>DX</code></strong></td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td>使用 <code>[ ]</code> 表示内存地址</td>
<td>无 <code>[ ]</code>，直接写端口号或寄存器</td>
</tr>
<tr>
<td><strong>关键指令详解</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1. <code>SUB</code>（减法）</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>语法</strong>: <code>SUB destination, source</code></li>
<li><strong>功能</strong>: <code>destination = destination - source</code></li>
<li><strong>示例</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB AX, BX   ; AX = AX - BX</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2. <code>CMP</code>（比较）</strong></p>
<ul>
<li><strong>语法</strong>: <code>CMP operand1, operand2</code></li>
<li><strong>功能</strong>: 计算 <code>operand1 - operand2</code>，<strong>仅影响标志位</strong>，不修改操作数。</li>
<li><strong>用途</strong>: 配合条件跳转指令（如 <code>JE</code>, <code>JNZ</code>）使用。</li>
<li><strong>示例</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP AX, 100   ; 比较 AX 和 100，设置标志位</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3. <code>INC</code>（自增）</strong></p>
<ul>
<li><strong>语法</strong>: <code>INC operand</code></li>
<li><strong>功能</strong>: <code>operand = operand + 1</code></li>
<li><strong>示例</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC CX   ; CX = CX + 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>eg.<br>
<strong>栈指针变化</strong>：</p>
<ol>
<li><strong>题目</strong>：假设当前R[esp]=3412FFB0h，下面指令连续执行后，说明每条指令执行后 esp 的内容？其中：dword-- 双字类型，32 位；word-- 字类型，16 位
<ul>
<li>push dx ；R[esp]= [填空 1]</li>
<li>push eax ；R[esp]= [填空 2]</li>
<li>push dword ptr 0f79h ；R[esp]= [填空 3]</li>
<li>pop eax ；R[esp]= [填空 4]</li>
<li>pop word ptr [bx] ；R[esp]= [填空 5]</li>
<li>pop ebx ；R[esp]= [填空 6]</li>
</ul>
</li>
<li><strong>答案</strong>：3412FFAEH；3412FFAAH；3412FFA6H；3412FFAAH；3412FFACH；3412FFBОH</li>
</ol>
<p><strong>寄存器操作</strong>：<br>
<strong>屏蔽</strong> <font color="#e36c09">AND 1111变0  </font><br>
eg.AND AX 1111 1110 0111 1111B AX第7、8位屏蔽<br>
<strong>置1</strong> <font color="#e36c09">OR 0000变1  </font><br>
eg.OR CL,0011 0000B CL中第4、5位置1<br>
<strong>取反</strong> <font color="#e36c09">XOR 0000变1  </font><br>
eg.XOR DH,1000 1000B DH中第3、7位取反</p>
<ol>
<li><strong>题目</strong>
<ul>
<li>(1) MOV AL，45H;XOR AL，31H 指令执行后，R[AL]= [填空 1]</li>
<li>(2) 已知 MOV AX，2345H 屏蔽 AX 寄存器的高 8 位，编写的指令为 [填空 2], 指令执行后，R[AX]= [填空 3]</li>
<li>(3) 已知 MOV EAX，12345678H 将 EAX 寄存器的高 16 位置 1, 编写的指令为 [填空 1]。指令执行后，R[EAX]= [填空 2]</li>
<li>(4) 已知 MOV AX，7890H 将 AH 寄存器的第 6 位和第 7 位取反其余位保持不变。编写的指令为 [填空 3]。指令执行后，R[AX]= [填空 4]</li>
</ul>
</li>
<li><strong>答案</strong>
<ul>
<li>(1) 74H<br>
45H (01000101B) XOR 31H (00110001B) = 74H (01110100B)</li>
<li>(2) AND AX,00FFH；0045H</li>
<li>(3) OR EAX,FFFF0000H；FFFF5678H</li>
<li>(4) XOR AX,C000H/XOR AH,C0H；B890H</li>
</ul>
</li>
</ol>
<p><strong>add 函数汇编代码</strong>：</p>
<ol>
<li><strong>题目</strong>：以 add 函数汇编代码为例
<ol>
<li>PUSH EBP</li>
<li>MOV EBP ESP</li>
<li>SUB ESP,40H</li>
<li>PUSH EBX</li>
<li>PUSH ESI</li>
<li>PUSH EDI</li>
<li>MOV EAX,DWORD PTR SS:[EBP+8]</li>
<li>ADD EAX,DWORD PTR SS:[EBP+0CH]</li>
<li>POP EDI</li>
<li>POP ESI</li>
<li>POP EBX</li>
<li>MOV ESP,EBP</li>
<li>POP EBP</li>
</ol>
<ul>
<li>根据要求填写指令序号
<ul>
<li>形成栈底的指令是 填空 1</li>
<li>现场保护的指令是 填空 2</li>
<li>恢复现场的指令是 填空 3</li>
<li>开辟堆栈空间的指令是 [填空 4]</li>
<li>SS:[EBP+8] 这个地址的数据是 [填空 5]</li>
<li>SS:[EBP+0CH] 这个地址的数据是 [填空 6]</li>
</ul>
</li>
</ul>
</li>
<li><strong>答案</strong>：1 2；4 5 6；9 10 11；3；7DH/125；50H/80</li>
</ol>
<ul>
<li><strong>形成栈底的指令</strong>：<code>1 2</code>
<ul>
<li><code>PUSH EBP</code> + <code>MOV EBP, ESP</code> 建立栈帧基址。</li>
</ul>
</li>
<li><strong>现场保护的指令</strong>：<code>4 5 6</code>
<ul>
<li><code>PUSH EBX/ESI/EDI</code> 保存调用者寄存器。</li>
</ul>
</li>
<li><strong>恢复现场的指令</strong>：<code>9 10 11</code>
<ul>
<li><code>POP EDI/ESI/EBX</code> 恢复寄存器。</li>
</ul>
</li>
<li><strong>开辟堆栈空间的指令</strong>：<code>3</code>
<ul>
<li><code>SUB ESP, 40H</code> 分配局部变量空间。</li>
</ul>
</li>
<li><strong><code>SS:[EBP+8]</code>的数据</strong>：<code>7DH</code>（十进制125）
<ul>
<li>假设第一个参数为125。</li>
</ul>
</li>
<li><strong><code>SS:[EBP+0CH]</code>的数据</strong>：<code>50H</code>（十进制80）
<ul>
<li>假设第二个参数为80。</li>
</ul>
</li>
</ul>
<p>eg.<strong>寄存器赋值</strong><br>
已知：<code>EAX = AABBCCDDH</code>, <code>EBX = 11223344H</code>, <code>ECX = 66778899H</code></p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>结果</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOV EAX, 5678H</code></td>
<td>EAX = <strong>00005678H</strong></td>
<td>32位寄存器赋值，立即数零扩展至32位。</td>
</tr>
<tr>
<td><code>MOV CX, 2000H</code></td>
<td>ECX = <strong>66772000H</strong></td>
<td>仅修改CX（ECX低16位），高16位不变。</td>
</tr>
<tr>
<td><code>MOV AH, 55H</code></td>
<td>EAX = <strong>AABB55DDH</strong></td>
<td>修改AH（EAX高8位），其余位不变。</td>
</tr>
<tr>
<td><code>MOV AL, 77H</code></td>
<td>EAX = <strong>AABBCC77H</strong></td>
<td>修改AL（EAX低8位），其余位不变。</td>
</tr>
<tr>
<td><code>MOV BH, AL</code></td>
<td>EBX = <strong>1122DD44H</strong></td>
<td>将AL的值（DDH）写入BH（EBX第15~8位）。</td>
</tr>
<tr>
<td>eg. <strong>内存操作与数据访问</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>(AX)=1122H,(BX)=2002H</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>地址</strong></th>
<th>2000H</th>
<th>2001H</th>
<th>2002H</th>
<th>2003H</th>
<th>2004H</th>
<th>2005H</th>
<th>2006H</th>
<th>2007H</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据</strong></td>
<td>10H</td>
<td>20H</td>
<td>30H</td>
<td>40H</td>
<td>50H</td>
<td>60H</td>
<td>70H</td>
<td>80H</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>结果</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOV BX, [2004H]</code></td>
<td>BX = <strong>6050H</strong></td>
<td>从2004H取2字节（50H,60H），小端组合。</td>
</tr>
<tr>
<td><code>MOV AX, BX</code></td>
<td>AX = <strong>2002H</strong></td>
<td>将BX的值2002H复制到AX。</td>
</tr>
<tr>
<td><code>MOV AX, [BX]</code></td>
<td>AX = <strong>4030H</strong></td>
<td>BX=2002H，取[2002H]的30H和40H。</td>
</tr>
<tr>
<td><code>MOV [AX], 2000H</code></td>
<td>AX 值不变</td>
<td>将2000H写入[AX]指向的内存（AX仍为1122H）。</td>
</tr>
<tr>
<td><code>MOV BL, 78H</code></td>
<td>BX = <strong>2078H</strong></td>
<td>修改BL（BX低8位），BH保持20H不变。</td>
</tr>
</tbody>
</table>
<h4 id="关键总结">关键总结</h4>
<ol>
<li><strong>寄存器层级</strong>：<strong>通用寄存器 &gt; 专用寄存器 &gt; 段寄存器</strong>，分工明确，支持高效运算与内存管理。</li>
<li><strong>地址转换</strong>：<strong>逻辑地址</strong>通过<strong>分段机制</strong>转换为<strong>物理地址</strong>，<strong>保护模式</strong>下需借助<strong>段描述符</strong>。</li>
<li><strong>标志位控制</strong>：EFLAGS 反映 <strong>CPU 状态</strong>，<strong>直接影响条件跳转指令</strong>（如 JZ、JC）。</li>
<li><strong>段式管理</strong>：增强程序模块化与安全性，但增加地址转换开销。</li>
</ol>
<h5 id="AT-T格式-VS-Intel格式">AT&amp;T格式 VS Intel格式</h5>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>AT&amp;T 格式</th>
<th>Intel 格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的操作数 d、源操作数 s</td>
<td><strong>op s, d</strong> <br>源操作数在左，目的操作数在右</td>
<td><strong>op d, s</strong> <br>源操作数在右，目的操作数在左</td>
</tr>
<tr>
<td>寄存器的表示</td>
<td>mov %ebx, %eax <br>寄存器名之前必须加 “%”</td>
<td>mov eax, ebx<br>直接写寄存器名即可</td>
</tr>
<tr>
<td>立即数的表示</td>
<td>mov <strong>$985</strong>, %eax<br>立即数之前必须加 $</td>
<td>mov eax, 985 <br>直接写数字即可</td>
</tr>
<tr>
<td>主存地址的表示</td>
<td>mov %eax, <strong>(af996h)</strong> <br>用 “小括号”</td>
<td>mov [af996h], eax <br>用 “中括号”</td>
</tr>
<tr>
<td>读写长度的表示</td>
<td>movb $5, (af996h) <br>movw $5, (af996h) <br>movl $5, (af996h) <br>addb $4, (af996h) <br>指令后加b、w、l 分别表示读写长度为 byte、word、dword，默认32bit</td>
<td>mov byte ptr [af996h], 5 <br>mov word ptr [af996h], 5 <br>mov dword ptr [af996h], 5 <br>add byte ptr [af996h], 4 <br>在主存地址前说明读写长度 byte、word、dword，默认32bit</td>
</tr>
<tr>
<td>主存地址偏移量的表示</td>
<td>movl -8(%ebx), %eax<br>偏移量 (基址) <br>movl 4(%ebx, %ecx, 32), %eax <br>偏移量 (基址，变址，比例因子)</td>
<td>mov eax, [ebx - 8] <br>[基址 + 偏移量] <br>mov eax, [ebx + ecx_32 + 4] <br>[基址 + 变址* 比例因子 + 偏移量]</td>
</tr>
</tbody>
</table>
<h4 id="选择语句的机器级表示">选择语句的机器级表示</h4>
<p>程序计数器PC也用IP表示</p>
<ul>
<li>jmp&lt;地址&gt;：使PC无条件转移至&lt;地址&gt;</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmp 128   &lt;地址&gt;可以用常数给出</span><br><span class="line">jmp eax   &lt;地址&gt;可以来自于寄存器</span><br><span class="line">jmp [999]   &lt;地址&gt;可以来自于主存</span><br><span class="line">jmp NEXT   &lt;地址&gt;可以用“标号”锚定，在代码中，需要在目标跳转地址处写上 `NEXT:` 来标识该位置，标号的名字可根据实际需求自行设定。</span><br><span class="line">写汇编语言代码时，一般会以函数名作为“标号”，标注该函数指令的起始地址</span><br></pre></td></tr></table></figure>
<ul>
<li>jxxx条件转移指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je &lt;地址&gt;    # jump when equal，若 a==b 则跳转</span><br><span class="line">jne &lt;地址&gt;   # jump when not equal，若 a!=b 则跳转</span><br><span class="line">jg &lt;地址&gt;    # jump when greater than，若 a&gt;b 则跳转</span><br><span class="line">jge &lt;地址&gt;   # jump when greater than or equal to，若 a&gt;=b 则跳转</span><br><span class="line">jl &lt;地址&gt;    # jump when less than，若 a&lt;b 则跳转</span><br><span class="line">jle &lt;地址&gt;   # jump when less than or equal to，若 a&lt;=b 则跳转</span><br></pre></td></tr></table></figure>
</li>
<li>cmp条件转移指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b     # 比较a和b两个数【ab可以来自寄存器/主存/常量】</span><br><span class="line"></span><br><span class="line">条件转移指令一般要和cmp指令一起使用</span><br><span class="line">cmp eax,ebx # 比较寄存器 eax 和 ebx 里的值</span><br><span class="line">jg NEXT     # 若 eax &gt; ebx，则跳转到 NEXT:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (a&gt;b) &#123;</span><br><span class="line">   c=a;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   c=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>mov eax,7</code> ：假设变量 a = 7，存入 eax</li>
<li><code>mov ebx,6</code> ：假设变量 b = 6，存入 ebx</li>
<li><code>cmp eax,ebx</code> ：比较变量 a 和 b</li>
<li><code>jg NEXT</code> ：若 a&gt;b，转移到 NEXT</li>
<li><code>mov ecx,ebx</code> ：假设用 ecx 存储变量 c，令 c = b</li>
<li><code>jmp END</code> ：无条件转移到 END</li>
<li><code>NEXT:</code></li>
<li><code>mov ecx,eax</code> ：假设用 ecx 存储变量 c，令 c = a</li>
<li><code>END:</code></li>
</ol>
<h4 id="循环语句的机器级表示">循环语句的机器级表示</h4>
<p><strong>for 循环实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">    result +=i;</span><br><span class="line">&#125; <span class="comment">//求 1+2+3+...+100</span></span><br></pre></td></tr></table></figure>
<p><strong>while 循环实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">    result +=i;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="comment">//求 1+2+3+...+100</span></span><br></pre></td></tr></table></figure>
<p><strong>汇编语言实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0    #用 eax 保存 result，初值为0</span><br><span class="line">mov edx,1    #用 edx 保存 i，初始值为1</span><br><span class="line">cmp edx,100  #比较 i和100</span><br><span class="line">jg L2        #若i&gt;100，转跳到 L2 执行</span><br><span class="line">L1:          #循环主体</span><br><span class="line">add eax,edx  #实现 result +=i</span><br><span class="line">inc edx      #inc 自增指令，实现 i++</span><br><span class="line">cmp edx,100  #i和100</span><br><span class="line">jle L1       #若 i&lt;=100，转跳到 L1 执行</span><br><span class="line">L2:          #跳出循环主体</span><br></pre></td></tr></table></figure>
<p><strong>loop指令实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">500</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">    做某些处理;</span><br><span class="line">&#125; <span class="comment">// 循环500轮</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, 500      # 用ecx作为循环计数器【注意：循环计数器固定用ecx】</span><br><span class="line">Looptop:</span><br><span class="line">    ...</span><br><span class="line">    做某些处理</span><br><span class="line">    ...</span><br><span class="line">loop Looptop       # ecx--，若ecx!=0，跳转到Looptop</span><br><span class="line"> 等价于</span><br><span class="line"> dec ecx</span><br><span class="line"> cmp ecx, 0</span><br><span class="line"> jne Looptop</span><br></pre></td></tr></table></figure>
<ul>
<li><code>loopx</code> 指令如 <code>loopnz</code>, <code>loopz</code>
<ul>
<li><code>loopnz</code> — 当 <code>ecx!=0 &amp;&amp; ZF==0</code> 时，继续循环</li>
<li><code>loopz</code> — 当 <code>ecx!=0 &amp;&amp; ZF==1</code> 时，继续循环</li>
</ul>
</li>
</ul>
<h4 id="栈帧的机器级表示">栈帧的机器级表示</h4>
<h5 id="Call和ret指令-函数调用的机器级表示">Call和ret指令(函数调用的机器级表示)</h5>
<p>函数的栈帧：保存函数大括号内定义的局部变量、保存函数调用相关的信息<br>
函数调用过程（caller 到 add）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">    push ebp            ; 保存上一层函数的栈帧基址（ebp旧值）</span><br><span class="line">    mov ebp, esp        ; 设置当前函数的栈帧基址（ebp新值）【这两条指令完成栈帧切换】</span><br><span class="line">    sub esp, <span class="number">24</span>         ; 分配局部变量空间</span><br><span class="line">    mov [ebp<span class="number">-12</span>], <span class="number">125</span>   ; 初始化局部变量</span><br><span class="line">    mov [ebp<span class="number">-8</span>], <span class="number">80</span>     ; 初始化局部变量</span><br><span class="line">    mov eax, [ebp<span class="number">-8</span>]    ; 准备参数</span><br><span class="line">    mov [esp+<span class="number">4</span>], eax    ; 将参数压栈（假设调用约定需要）</span><br><span class="line">    mov eax, [ebp<span class="number">-12</span>]   ; 其他操作</span><br><span class="line">    mov esp, eax        ; 调整栈指针</span><br><span class="line">    call add            ; 调用add函数</span><br><span class="line">    mov [ebp<span class="number">-4</span>], eax    ; 处理返回值</span><br><span class="line">    mov eax, [ebp<span class="number">-4</span>]    ; 使用返回值</span><br><span class="line">    leave               ; 恢复esp和e</span><br><span class="line">bp</span><br><span class="line">    ret                 ; 返回到上一级</span><br><span class="line"></span><br><span class="line">add:</span><br><span class="line">    push ebp            ; 保存上一层函数的栈帧基址（ebp旧值）</span><br><span class="line">    mov ebp, esp        ; 设置当前函数的栈帧基址（ebp新值）【这两条指令完成栈帧切换】</span><br><span class="line">    mov eax, [ebp+<span class="number">12</span>]   ; 获取参数<span class="number">1</span></span><br><span class="line">    mov edx, [ebp+<span class="number">8</span>]    ; 获取参数<span class="number">2</span></span><br><span class="line">    add eax, edx        ; 执行加法</span><br><span class="line">    leave               ; 恢复esp和ebp</span><br><span class="line">    ret                 ; 返回到caller</span><br></pre></td></tr></table></figure>
<p>栈帧结构<br>
±-----------------+<br>
| 返回地址（IP旧值）| &lt;—— 栈顶（call时压入）<br>
±-----------------+<br>
| caller的栈帧     |<br>
±-----------------+<br>
| add函数的栈帧    |<br>
±-----------------+<br>
| main函数的栈帧   |<br>
±-----------------+<br>
| …其他栈帧…   |<br>
±-----------------+</p>
<ul>
<li>
<p><strong>call 指令的作用</strong></p>
<ol>
<li>将 IP旧值压栈保存（保存在函数的栈帧顶部）</li>
<li>设置 IP新值，无条件转移至被调用函数的第一条指令</li>
</ol>
</li>
<li>
<p><strong>ret 指令的作用</strong><br>
从函数的栈帧顶部找到 IP 旧值，将其出栈并恢复 IP寄存器</p>
</li>
</ul>
<p>栈底（高地址）<br>
栈顶（低地址）<br>
通常以4字节为单位操作栈帧</p>
<h5 id="如何访问栈帧">如何访问栈帧</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505202835812.png" alt="image.png"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505203252548.png" alt="image.png"></p>
<p>方法一：</p>
<ul>
<li><strong>Push 指令</strong>：使栈指针（esp）先减4，然后将指定的操作数压入栈。操作数可以是立即数、寄存器或内存地址。<br>
push xxx可以是立即数/寄存器/主存地址</li>
<li><strong>Pop 指令</strong>：将栈顶元素弹出到指定的操作数，然后esp加4。操作数可以是寄存器或内存地址。<br>
pop xxx可以是寄存器/主存地址</li>
</ul>
<p>方法二：</p>
<ul>
<li>使用 <code>mov</code> 指令结合 <code>esp</code> 或 <code>ebp</code> 来访问栈帧中的数据。</li>
<li>也可利用 <code>sub</code> 或 <code>add</code> 指令修改栈指针（esp）的值，以此调整栈顶的位置。</li>
</ul>
<h5 id="如何切换栈帧">如何切换栈帧</h5>
<p>标记栈帧的范围：EBP、ESP寄存器<br>
每个函数的开头都有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp            ; 保存上一层函数的栈帧基址（ebp旧值）</span><br><span class="line">mov ebp, esp        ; 设置当前函数的栈帧基址（ebp新值）【这两条指令完成栈帧切换】</span><br></pre></td></tr></table></figure>
<p>这两条指令也可用<code>enter</code>代替</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move esp,ebp   # 让esp指向当前栈帧底部</span><br><span class="line">pop ebp        # 将esp所指元素出栈，写入寄存器ebp</span><br></pre></td></tr></table></figure>
<p>这两条指令也可用<code>leave</code>代替</p>
<h5 id="一个栈帧包含的内容">一个栈帧包含的内容</h5>
<p>每个函数的栈帧底部存储<strong>上一层函数的基址</strong>（ebp旧值）<br>
每个函数的栈帧顶部存储<strong>返回地址</strong>（当前函数的栈帧除外）<br>
通常将<strong>局部变量</strong>集中存储在<strong>栈帧底部区域</strong><br>
c语言中越靠前定义的局部变量越靠近<strong>栈顶</strong><br>
通常将<strong>调用参数</strong>集中存储在<strong>栈帧顶部区域</strong><br>
gcc编译器将每个栈帧大小设置为<strong>16B的整数倍</strong>（当前函数的栈帧除外），因此栈帧内可能出现<strong>空闲</strong>未使用的区域。<br>
访问当前函数的局部变量：[ebp-4]、[ebp-8]…<br>
访问上一层函数传过来的参数：[ebp+8]、[ebp+12].<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505211134466.png" alt="image.png"><br>
<strong>栈帧结构</strong>（栈底→栈顶）<br>
①上一层栈帧的基地址(ebp旧值);②若干个局部变量;③未使用区;④部分寄存器值;⑤若干个调用参数;⑥返回地址(IP旧值)</p>
<ol>
<li>
<p><strong>IP(返回地址)</strong></p>
<ul>
<li>一定存在。用于恢复上一层函数的栈帧。</li>
</ul>
</li>
<li>
<p><strong>上一层栈帧基址</strong></p>
<ul>
<li>每个函数开头都要执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure>
</li>
<li>一定存在。用于恢复上一层函数的栈帧。</li>
</ul>
</li>
<li>
<p><strong>若干个局部变量</strong></p>
<ul>
<li>局部变量。C语言中越靠前定义的局部变量越靠近栈顶。</li>
<li>不一定存在。有些函数可能不定义局部变量。</li>
</ul>
</li>
<li>
<p><strong>未使用的区域</strong></p>
<ul>
<li>栈帧大小为16B整数倍，因此可能产生未使用区域。</li>
<li>不一定存在。如果其他部分刚好是16B整数倍，则不会留下“零头”。</li>
</ul>
</li>
<li>
<p><strong>若干个调用参数</strong></p>
<ul>
<li>调用参数。参数列表中越靠前的参数越靠近栈顶。</li>
<li>不一定存在。有些函数调用不需要传参数。</li>
</ul>
</li>
<li>
<p><strong>IP(返回地址) 上一层栈帧基址</strong></p>
<ul>
<li>函数调用时，call指令将IP寄存器值（返回地址）压栈保存。</li>
<li>一定存在（发生调用时）。但凡调用其他函数，就必须记录返回地址。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505213804398.png" alt="image.png"></p>
<h2 id="CISC-和-RISC">CISC 和 RISC</h2>
<h3 id="复杂指令系统计算机（CISC）">复杂指令系统计算机（CISC）</h3>
<ul>
<li><strong>设计思路</strong>：一条指令完成一个复杂的基本功能</li>
<li><strong>代表</strong>：x86 架构，主要用于笔记本、台式机等</li>
<li><strong>指令系统</strong>：复杂庞大</li>
<li><strong>指令数目</strong>：一般大于 200 条</li>
<li><strong>指令字长</strong>：不固定，指令格式多，寻址方式多</li>
<li><strong>可访存指令</strong>：不加限制</li>
<li><strong>各种指令执行时间</strong>：相差较大，大多数指令需要多个时钟周期才能完成</li>
<li><strong>各种指令使用频度</strong>：相差很大</li>
<li><strong>通用寄存器数量</strong>：较少</li>
<li><strong>目标代码</strong>：难以用优化编译生成高效的目标代码程序</li>
<li><strong>控制方式</strong>：绝大多数为微程序控制</li>
<li><strong>指令流水线</strong>：可通过一定方式实现</li>
<li><strong>兼容性</strong>：可兼容很多不同的高级语言和软件</li>
</ul>
<h3 id="精简指令系统计算机（RISC）">精简指令系统计算机（RISC）</h3>
<ul>
<li><strong>设计思路</strong>：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能</li>
<li><strong>代表</strong>：ARM 架构，主要用于手机、平板等</li>
<li><strong>指令系统</strong>：简单精简</li>
<li><strong>指令数目</strong>：一般小于 100 条</li>
<li><strong>指令字长</strong>：定长，指令种类少，寻址方式种类少</li>
<li><strong>可访存指令</strong>：只有 Load / Store 指令</li>
<li><strong>各种指令执行时间</strong>：绝大多数在一个周期内完成</li>
<li><strong>各种指令使用频度</strong>：都比较常用</li>
<li><strong>通用寄存器数量</strong>：多</li>
<li><strong>目标代码</strong>：采用优化的编译程序，生成代码较为高效</li>
<li><strong>控制方式</strong>：绝大多数为组合逻辑控制，硬布线</li>
<li><strong>指令流水线</strong>：必须实现</li>
<li><strong>兼容性</strong>：较差</li>
</ul>
<p>和 CISC 相比，RISC 的优点体现在：</p>
<ul>
<li>
<p>RISC 更能充分利用 VLSI（超大规模集成电路）芯片的面积</p>
</li>
<li>
<p>RISC 更能提高运算速度</p>
</li>
<li>
<p>RISC 便于设计，可降低成本，提高可靠性</p>
</li>
<li>
<p>RISC 有利于编译程序代码优化</p>
</li>
<li>
<p>优先选取使用<mark>频率高</mark>的简单指令，<mark>指令条数少，<mark>采用</mark>等长</mark>指令</p>
</li>
<li>
<p>指令长度固定，指令格式<mark>种类</mark>较<mark>少</mark></p>
</li>
<li>
<p>以<mark>控制</mark>逻辑为主，不用或少用微码控制</p>
</li>
<li>
<p>寻址方式种类较<mark>少</mark></p>
</li>
<li>
<p>有<mark>大量</mark>通用寄存器</p>
</li>
<li>
<p>并行处理能力强</p>
</li>
<li>
<p>访存指令只有load和store两种</p>
</li>
</ul>
<p><mark>CISC</mark>是<mark>复杂</mark>指令系统，兼容性强，指令繁多，长度可变，由<mark>微程序</mark>实现。<br>
<mark>RISC</mark>是<mark>精简</mark>指令系统，指令少，使用频率接近，主要依靠<mark>硬件</mark>实现（通用寄存器，硬布线逻辑控制），<mark>寄存器多</mark>且支持==流水线</p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>CISC</th>
<th>RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计思路</td>
<td>一条指令完成一个复杂的基本功能</td>
<td>一条指令完成一个基本 “动作”，多条指令组合完成复杂基本功能</td>
</tr>
<tr>
<td>代表</td>
<td>x86 架构，用于笔记本、台式机等</td>
<td>ARM 架构，用于手机、平板等</td>
</tr>
<tr>
<td>指令系统</td>
<td>复杂，庞大</td>
<td>简单，精简</td>
</tr>
<tr>
<td>指令数目</td>
<td>一般大于 200 条</td>
<td>一般小于 100 条</td>
</tr>
<tr>
<td>指令字长</td>
<td>不固定，指令格式多，寻址方式多</td>
<td>定长，指令种类少，寻址方式种类少</td>
</tr>
<tr>
<td>可访存指令</td>
<td>不加限制</td>
<td>只有 Load/Store 指令</td>
</tr>
<tr>
<td>各种指令执行时间</td>
<td>相差较大，多数需多个时钟周期</td>
<td>绝大多数在一个周期内完成</td>
</tr>
<tr>
<td>各种指令使用频度</td>
<td>相差很大</td>
<td>都比较常用</td>
</tr>
<tr>
<td>通用寄存器数量</td>
<td>较少</td>
<td>多</td>
</tr>
<tr>
<td>目标代码</td>
<td>难以用优化编译生成高效目标代码程序</td>
<td>采用优化编译程序，生成代码较为高效</td>
</tr>
<tr>
<td>控制方式</td>
<td>绝大多数为微程序控制</td>
<td>绝大多数为组合逻辑控制（硬布线）</td>
</tr>
<tr>
<td>指令流水线</td>
<td>可以通过一定方式实现</td>
<td>必须实现</td>
</tr>
<tr>
<td>兼容性</td>
<td>可兼容很多不同的高级语言和软件</td>
<td>较差</td>
</tr>
<tr>
<td>芯片面积利用</td>
<td>难以充分利用 VLSI 芯片面积</td>
<td>更能充分利用 VLSI 芯片面积</td>
</tr>
<tr>
<td>运算速度</td>
<td>相对较慢</td>
<td>更能提高运算速度</td>
</tr>
<tr>
<td>设计成本与可靠性</td>
<td>设计相对复杂，成本较高，可靠性较难保障</td>
<td>便于设计，可降低成本，提高可靠性</td>
</tr>
<tr>
<td>编译程序优化</td>
<td>不利于编译程序代码优化</td>
<td>有利于编译程序代码优化</td>
</tr>
<tr>
<td>指令选取原则</td>
<td>/</td>
<td>优先选取使用频率高的简单指令，指令条数少</td>
</tr>
<tr>
<td>并行处理能力</td>
<td>相对较弱</td>
<td>并行处理能力强</td>
</tr>
</tbody>
</table>
<h1>错题</h1>
<ol>
<li>
<p><strong>下列关于指令集体系结构和指令系统的说法中，错误的是()。<br>
A.指令集体系结构位于计算机软/硬件的交界面上<br>
B.指令集体系结构是指低级语言程序员所看到的概念结构和功能特性<br>
C.任何程序运行前都要先转换为机器语言程序<br>
D.指令系统和机器语言是无关的</strong><br>
指令集体系结构(ISA)完整定义了软件和硬件之间的接口；低级语言（如汇编语言）程序员直接使用 ISA 提供的指令、寄存器等资源编写程序，ISA 是其编程时看到的功能特性；<strong>指令系统</strong>是机器指令的集合，<strong>机器语言</strong>是由这些指令的二进制编码构成的语言。二者直接相关：指令系统决定了机器语言的功能和格式，机器语言是指令系统的具体实现形式。D</p>
</li>
<li>
<p><strong>下列有关指令集体系结构(ISA)的叙述中，错误的是()。<br>
A.ISA 规定了执行每条指令时所包含的控制信号<br>
B.ISA 规定了指令获取操作数的方式，即寻址方式<br>
C.ISA 规定了所有指令的集合，包括指令格式和操作类型<br>
D.ISA 规定了程序可访问的寄存器个数、存储空间大小、编址方式和大端/小端方式</strong><br>
指令集体系结构(ISA)是软件和硬件之间接口的一个完整定义，包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断和异常处理及外部 IO。ISA 规定了执行每条指令时所需要的操作码、操作数、寻址方式等信息，以及指令的功能和效果。控制信号是由控制单元根据ISA 生成的，它属于微架构层面的实现细节，而不是ISA 层面的抽象定义。</p>
</li>
<li>
<p><strong>在CPU执行指令的过程中，指令的地址由()给出。<br>
A.程序计数器(PC)   B.操作系统   C.指令的地址码字段   D.程序员</strong><br>
PC 存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址。</p>
</li>
<li>
<p><strong>【2017统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条、二地址指令 107条，每个地址字段为6位，则指令字长至少应该是( )。A.24 位   B. 26 位   C.28 位   D.32 位</strong><br>
三地址指令有 29 条，所以其操作码至少为5 位。以5位进行计算，它剩余 32- 29=3种操作码给二地址。而二地址额外多了6位给操作码，因此其数量最大达 3x64 = 192。所以指令字长最少为23 位，因为计算机按字节编址，需要是8的倍数，所以指令字长至少应该是 24位。</p>
</li>
<li>
<p><strong>【2022 统考真题】下列选项中，属于指令集体系结构(ISA)规定的内容是()。<br>
I.指令字格式和指令类型     II.CPU 的时钟周期<br>
III.通用寄存器个数和位数   IV.加法器的进位方式<br>
A. 仅I、II   B.仅I、III   C.仅II、IV   D.仅I、III、IV</strong><br>
指令集体系结构处于软/硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由 ISA 规定。两个CPU 可以有不同的时钟周期，但指令集可以相同；加法器的进位方式涉及电路设计，这两项都属于计算机的硬件部分，不由ISA规定。</p>
</li>
<li>
<p><strong>指令系统中采用不同寻址方式的目的是()。<br>
A.提供扩展操作码的可能并降低指令译码难度<br>
B.可缩短指令字长，扩大寻址空间，提高编程的灵活性<br>
C.实现程序控制<br>
D.三者都正确</strong><br>
采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度。程序控制是靠转移指令而非寻址方式实现的。B</p>
</li>
<li>
<p><strong>采用直接转移的无条件转移指令的功能是将指令中的地址码送入()。<br>
A.程序计数器(PC)    B.累加器(ACC)<br>
C.指令寄存器(IR)     D.地址寄存器(MAR)</strong><br>
转移指令有条件/无条件、直接间接、相对/绝对三种属性。<br>
<strong>条件转移</strong>是指需要先判断条件是否成立，才决定是否转移<br>
<strong>无条件转移</strong>是指不用判断条件就可以转移，典型的是<strong>函数调用和返回</strong><br>
<strong>直接转移</strong>是指转移目标地址直接放在<strong>指令</strong>中，执行时直接将地址码送入<strong>PC</strong> 选A<br>
<strong>间接转移</strong>是指转移目标地址存放在<strong>寄存器或内存单元</strong>中<br>
<strong>相对转移</strong>是指转移目标地址为当前 <strong>PC值加上偏移量</strong>，偏移量一般在指令中<br>
<strong>绝对转移</strong>是指转移目标地址直接由<strong>指令或寄存器</strong>给出。</p>
</li>
<li>
<p><strong>为了缩短指令中某个地址段的位数，有效的方法是采取()。<br>
A.立即寻址   B.变址寻址   C.间接寻址   D.寄存器寻址</strong><br>
CPU 中寄存器的数量都不会太多，用很短的编码就可以指定寄存器，寄存器寻址需要的地址段位数为⌈log₂(通用寄存器个数)⌉，因此能有效地缩短地址段的位数。<br>
立即寻址，操作数直接保存在指令中，若地址段位数太小，则操作数表示的范围会很小<br>
变址寻址，EA= 变址寄存器IX的内容 + 形式地址 A，A 与主存寻址空间有关<br>
间接寻址中存放的仍然是主存地址</p>
</li>
<li>
<p><strong>设指令中的地址码为 A，变址寄存器为 X，程序计数器为 PC，则变址间址寻址方式的操作数的有效地址 EA是( )。<br>
A.((PC)+A)   B.((X)+A)   C.(X)+(A)   D.(X)+A</strong><br>
变址寻址的有效地址是(X)+A，再进行间址，即把(X)+A中取出的内容作为真实地址 EA，即 EA=((X)+A)<br>
寄存器中的内容和指令地址码相加得到的是操作数的地址码。</p>
</li>
<li>
<p><strong>某计算机的指令字长为 16 位，由低到高第 0~7位是形式地址 D，第8~9位为寻址特征位 X，第 10~15 位为操作码。<br>
当X=00 时为直接寻址；当X=01 时使用 X1 进行变址寻址;；当 X=10 时使用 X2 进行变址寻址；当 X=11 时为相对寻址。<br>
设(PC)= 1234H,(X1)=0005H,(X2)=1188H，则指令2222H的有效地址是()。A.1256H     B.0027H    C.2222H    D.11AAH</strong><br>
将指令 2222H 展开成二进制为0010 00100010 0010B，因此寻址特征位X=10，即使用 X2进行变址寻址，其有效地址为1188H+22H=11AAH。<br>
其他情况：<br>
直接寻址：若指令为0022H，D=22H，有效地址为 22H<br>
变址寻址：若指令为 0522H，X1=0005H，D=22H，有效地址为 0005H+22H=0027H<br>
相对寻址：若指令为 1122H，(PC)=1234H，D=22H，有效地址为 1234H+22H=1256H</p>
</li>
<li>
<p><strong>某计算机的主存容量为 4Mx16 位，且存储字长等于指令字长，若该机能完成 97 种操作,操作码位数固定，且有直接、间接、基址、变址、相对、立即六种寻址方式，则相对寻址的偏移量范围为()。<br>
A.(-32.+31)   B.(-64.+63)   C.(-128,+127)   D.(-256,+255)</strong><br>
操作码位数固定，且能完成97种操作，则操作码位数是⌈log₂97⌉=7位<br>
具有六种寻址方式，则寻址特征位数是⌈log₂6⌉3位:指令字长为16 位，因此地址码位数是16-3-7=6位，6 位补码的表示范围为-32~+31，即为相对寻址的偏移量范围。</p>
</li>
<li>
<p><strong>对按字寻址的机器，程序计数器和指令寄存器的位数各取决于()。<br>
A.机器字长，存储器的字数   B.存储器的字数，指令字长<br>
C.指令字长，机器字长          D.地址总线宽度，存储器的字数</strong><br>
机器按字寻址，程序计数器(PC)给出下一条指令字的访存地址(指令在内存中的地址)，因此取决于存储器的字数;指令寄存器(IR)用于接收取得的指令，因此取决于指令字长。</p>
</li>
<li>
<p><strong>假设寄存器 R中的数值为 200，主存地址为 200和 300 的地址单元中存放的内容分别是300和400，则()方式下访问到的操作数为200。<br>
A.直接寻址 200                B.寄存器间接寻址®<br>
C.存储器间接寻址(200)   D.寄存器寻址 R</strong><br>
直接寻址 200 访问的操作数是 300，选项A错误。<br>
寄存器间接寻址®的访问结果与1一样，选项 B错误。<br>
存储器间接寻址(200)表示主存地址 200 中的内容为有效地址，有效地址为 300，访问的操作数是 400，选项C错误。<br>
寄存器寻址R表示寄存器R的内容为操作数，只有选项D正确。</p>
</li>
<li>
<p><strong>假设某条指令的第一个操作数采用寄存器间接寻址方式，指令中给出的寄存器编号为8,8 号寄存器的内容为 1200H，地址为 1200H 的单元中的内容为 12FCH，地址为 12FCH的单元中的内容为 38D8H，而地址为 38D8H 的单元中的内容为 88F9H，则该操作数的有效地址为( )。<br>
A.1200H   B. 12FCH   C.38D8H   D. 88F9H</strong><br>
寄存器间接寻址中操作数的有效地址 EA=®,8号寄存器内容为 1200H,因此 EA=1200H。</p>
</li>
<li>
<p><strong>设相对寻址的转移指令占 3B，第一字节为操作码，第二、三字节为相对位移量(补码表示)，而且数据在存储器中采用以低字节为字地址的存放方式。每当 CPU 从存储器取出一字节时，即自动完成(PC)+1→PC。<br>
若 PC的当前值为 240(十进制)，要求转移到290(十进制)，则转移指令的第二、三字节的机器代码是( )<br>
若 PC 的当前值为 240(十进制)，要求转移到200(十进制)，则转移指令的第二、三字节的机器代码是( )。<br>
A. 2FH、FFH    B. D5H、00H    C. D5H、FFH    D.2FH、00H</strong><br>
PC 的当前值为 240，该指令取出后 PC 的值为 243，要求转移到 290，即相对位移量为290-243=47，转换成补码为2FH。因为数据在存储器中采用以低字节地址为字地址的存放方式，所以该转移指令的第二字节为 2FH，而由于47 是正数，只需在高位补0，所以第三字节为 00H。<br>
PC 的当前值为 240，该指令取出后 PC 的值为 243，要求转移到 200，即相对位移量为200-243=-43，转换成补码为 D5H。数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为 D5H，因为-43 是负数，所以只需在高位补 1，所以第三字节为 FFH。</p>
</li>
<li>
<p><strong>某计算机按字节编址，采用大端方式，某指令的一个操作数的机器数为 ABCD 00FFH，该操作数采用基址寻址方式，指令中形式地址(用补码表示)为FF00H，当前基址寄存器的内容为 C000 0000H，则该操作数的LSB(即FFH)存放的地址是()。<br>
A.C000 FF00H  B. C000 FF03H  C.BFFF FF00H  D. BFFF FF03H</strong><br>
C000 0000H+FF00H=C000 0000H+FFFF FF00H=BFFF FF00H<br>
<strong>大端存储</strong>：高字节在低地址，低字节在高地址，LSB地址 = 基地址 + 数据长度【这里是4字节】 - 1。<br>
按字节编址，起始地址BFFF FF00H，对应ABH（MSB），CDH则对应BFFF FF01H，所以LSB对应BFFF FF03H</p>
</li>
<li>
<p><strong>下列关于指令的功能及分类的叙述中，正确的是()。<br>
A.算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据<br>
B.移位操作指令，通常用于把指定的两个操作数左移或右移一位<br>
C.转移指令、子程序调用与返回指令，用于解决数据调用次序的需求<br>
D.特权指令，通常仅用于实现系统软件，这类指令一般不提供给用户</strong><br>
算术与逻辑运算指令用于完成对一个(如自增、取反等)或两个数据的算术运算或逻辑运算，选项A 错误。移位操作用于把一个操作数左移或右移一位或多位，选项 B错误。转移指令、子程序调用与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求，选项C 错误。</p>
</li>
<li>
<p><strong>某计算机字长为 16 位，标志寄存器中存在 ZF、SF、OF 和 CF 标志位，采用双字节字长指令字。假定 bgt(大于零转移)指令的第一个字节指明操作码和寻址方式，第二个字节为立即数Imm8，用补码表示。<br>
指令功能是：<br>
若跳转条件成立，则PC=PC+2+Imm8×2<br>
否则，PC=PC+2。<br>
则下列叙述中错误的是()。<br>
A.该计算机按字节编址<br>
B.若 bgt 指令是无符号整数的比较，则跳转条件可以是ZF+CF=0<br>
C.若 bgt 指令是有符号整数的比较，则跳转条件可以是SF⊕OF=0<br>
D.转移目标地址的范围是相对于 bgt 指令的前 127 条指令到后 128 条指令之间</strong><br>
PC 的增量是 2，每条指令占2字节，可知编址单位为字节。<br>
若 bgt 指令是无符号整数比较大于零，结果非零（ZF=0）且无借位（CF=0），即ZF+CF=0<br>
若 bgt 指令是有符号整数的比较，则跳转条件成立时，要么未发生溢出，SF=OF=0，要么发生溢出SF=OF=1，但前提是ZF 一定为0，所以正确的跳转条件是(ZF+(SF⊕OF)=0)。选C<br>
Imm8是 8 位补码立即数，范围为−128∼127，转移目标地址为PC+2+Imm8×2。<code>PC + 2</code> 是因为当前指令占 2 字节，执行完后 <code>PC</code> 会先指向 <strong>下一条指令的地址</strong>（即当前指令地址 + 2），再根据 <code>Imm8</code> 进行偏移。<strong>偏移量</strong>：<code>Imm8 × 2</code>（字节），即 <code>-256 ≤ 偏移 ≤ +254.</code> <strong>指令数范围</strong>：<code>-128 ≤ 偏移指令数 ≤ +127</code>（因为每条指令占2字节）。<br>
因此，实际指令数偏移范围为 <strong>-128 ≤ Imm8 ≤ +127</strong>，但相对于当前指令的可见范围是 <strong>前127条到后128条</strong>。</p>
</li>
<li>
<p><strong>【2011统考真题】某机器有一个标志寄存器，其中有进位/借位标志CF、零标志ZF、符号标志SF和溢出标志OF，条件转移指令bgt（无符号整数比较大于时转移）的转移条件是（ ）。<br>
A. CF + OF = 1 B. $\overline{SF}$ + ZF = 1 C. $\overline{CF + ZF}$ = 1 D. $\overline{CF + SF}$ = 1</strong></p>
</li>
<li>
<p><strong>【2014 统考真题】某计算机有 16 个通用寄存器，采用 32 位定长指令字，操作码字段(含寻址方式位)为8位，STORE指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任意一个通用寄存器，且偏移量用补码表示，则STORE指令中偏移量的取值范围是()。<br>
A.-32768-+32767   B.-32767~+32768<br>
C.-65536-+65535   D.-65535-+65536</strong><br>
采用 32 位定长指令字，其中操作码为8位，两个地址码共占用32-8=24位，而STORE指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址，机器中共有16 个通用寄存器，因此寻址一个寄存器需要 log16=4位，源操作数中的寄存器直接寻址用掉4 位，而目的操作数采用基址寻址也要指定一个寄存器，同样用掉4位，则留给偏移量的位数为24-4-4=16位，而偏移量用补码表示，因此 16 位补码的表示范围为-32768~+32767。</p>
</li>
<li>
<p><strong>【2018 统考真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器的初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器的内容自动加 1。若某次循环所取元素的地址为 2100H，则进入该次循环时变址寄存器的内容是()。<br>
A.25   B. 32   C.64   D. 100</strong><br>
<strong>变址寻址公式</strong>：有效地址 <code>EA = 基地址 + 变址值 × sizeof(double)</code><br>
每次循环：变址寄存器的值自动加1（元素索引递增）<br>
某次循环的EA：2100H<br>
根据变址寻址的公式 EA=(IX)+A，有(IX)=2100H-2000H=100H=256，sizeof(double)：8字节（双精度浮点数占8字节），因此数组的下标为256/8=32。</p>
</li>
<li>
<p><strong>【2020 统考真题】某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对4种寻址方式。在单地址指令中，直接寻址方式的可寻址范围是()<br>
A.0-255   B. 0-1023   C.-128-127   D.-512-511</strong><br>
48 条指令需要6位操作码字段，4种寻址方式需要2位寻址特征位，还剩16-6-2=8位作为地址码，所以直接寻址范围为0~255。注意，主存地址不能为负（内存地址是无符号数）</p>
</li>
<li>
<p><strong>【2023 统考真题】某运算类指令中有一个地址码为通用寄存器编号，对应通用寄存器中存放的是操作数或操作数的地址，CPU区分两者的依据是()<br>
A.操作数的寻址方式   B.操作数的编码方式<br>
C.通用寄存器的编号   D.通用寄存器的内容</strong><br>
指令结构：操作码 + 寻址方式字段 + 地址码（通用寄存器编号）。<br>
寄存器直接寻址：<br>
寻址方式字段标记为“寄存器直接寻址”。<br>
通用寄存器内容：直接作为操作数。<br>
寄存器间接寻址：<br>
寻址方式字段标记为“寄存器间接寻址”。<br>
通用寄存器内容：作为操作数的内存地址。<br>
CPU通过寻址方式字段（即操作数的寻址方式）确定寄存器内容是操作数还是地址。</p>
</li>
<li>
<p><strong>假设 R|ax]=7FE6H,R[bx]=FFE8H，执行指令“sub bx,ax”后，寄存器的内存和各标志的变化为( )。<br>
A. R[ax]=8002H，OF=0，SF=1，CF=1，ZF=0<br>
B. R[bx]=8002H，OF=0，SF=1，CF=0，ZF=0<br>
C. R[ax]=8002H，OF=1，SF=1，CF=0，ZF=0<br>
D. R[bx]=8002H，OF=1，SF=1，CF=0，ZF=0</strong><br>
<code>sub bx, ax</code>是<code>bx - ax</code><br>
7FE6H = 0111 1111 1110 0110B（[-B]补就是[B]补连同符号位一起取反+1）<br>
FFE8H = 1111 1111 1110 1000B<br>
$\begin{align*} &amp;1111 1111 1110 1000\ +&amp;1000 0000 0001 1010\ \hline &amp;1000 0000 0000 0010 \end{align*}$<br>
= 8002H，该结果存放在目标操作数<code>bx</code>中，所以R[bx]=8002H 。<br>
溢出OF=最高位⊕次高位进位=1⊕1=0<br>
进位CF=最高位进位Cout⊕Cin(减法=1，加法=0)=1⊕1=0<br>
B</p>
</li>
<li>
<p><strong>某计算机的数据采用小端方式存储，减法指令“sub ax,imm”的功能为(ax)-imm→ax,imm 表示立即数，该指令对应的十六进机器码为 2dxxxx(从左到右以字节为单位由低地址到高地址)，其中xxxx 对应 imm 的机器码，若imm=-3,(ax)=7，则该指令对应的机器码和执行后 OF 标志位的值分别为( )。<br>
A.2DFFFDH,0   B.2DFFFDH,1<br>
C.2DFDFFH,0   D.2DFDFFH,1</strong><br>
对于 16 位有符号数，其表示范围是<code>-32768</code>到<code>32767</code> ，计算结果 10 在这个范围内<br>
-3的补码=1111 1111 1111 1101=FFFD<br>
2DFDFF，C</p>
</li>
<li>
<p><strong>假设R[eax]=080480B4H，R[ebx]=00000011H，M[080480F8H]=000000B0H，执行指令 “<code>imul eax, [eax+ebx*4], -16</code>” 后，寄存器或存储单元的内容变为（ ）。<br>
A. R[eax]=00000B00H    B. M[080480F8H]=00000B00H<br>
C. R[eax]=FFFFF500H   D. M[080480F8H]=FFFFF500H</strong><br>
000000B0H×(-16)，即$(2^7 + 2^5 + 2^4)\times(-2^4)= - 2^{11}-2^9 - 2^8$ 。 计算结果为负数，求其补码： 原码：1000 0000 0000 0000 1011 0000 0000，补码即1111 1111 1111  1111  1111 0101 0000 0000 = FFFF F500H，C。</p>
</li>
<li>
<p><strong>程序P中有两个变量i和j，被分别分配在寄存器<code>eax</code>和<code>edx</code>中，P中语句 “<code>if(i &lt; j)&#123;...&#125;</code>” 对应的指令序列如下（左边为指令地址，中间为机器代码，右边为汇编指令），其中<code>jle</code>指令的偏移量为0d：</strong><br>
<strong>804846a 39 c2 cmp dword ptr [edx],eax</strong><br>
<strong>804846c 7e 0d jle xxxxxxxx</strong><br>
<strong>若执行到804846aH处的<code>cmp</code>指令时，i=105，j=100，则<code>jle</code>指令执行后将转到（ ）处的指令执行。</strong><br>
<strong>A. 8048461H</strong>    <strong>B. 804846eH</strong>    <strong>C. 8048479H</strong>    <strong>D. 804847bH</strong><br>
因为<code>jle</code>指令是 “小于或等于则跳转”，而这里i≥j不满足跳转条件，所以不会发生跳转，程序将顺序执行下一条指令。<br>
<code>jle</code>指令的地址是804846cH，偏移量为0dH（十六进制），顺序执行下一条指令的地址应该是<code>jle</code>指令地址加上偏移量。<br>
804846cH+0dH=8048479H</p>
</li>
<li>
<p><strong>子程序调用指令的完整功能是（ ）。<br>
A. 改变堆栈指针 SP 的值    B. 改变程序计数器 PC 的值<br>
C. 改变程序计数器 PC 的值和堆栈指针 SP 的值  D. 改变地址寄存器的值</strong><br>
C</p>
</li>
<li>
<p><strong>下列有关调用指令（转子指令）的叙述中，错误的是（ ）。<br>
A. 与高级语言源程序中的过程调用相对应，一次过程调用对应一条调用指令<br>
B. 指令执行时必须保留返回地址，调用指令随后一条指令的地址是返回地址<br>
C. 嵌套调用时返回地址通常保存在栈中，非嵌套调用时可保存在特定寄存器中<br>
D. 指令执行时将无条件转移到目标地址处，转移目标地址无须在指令中明显给出</strong><br>
A 选项：在高级语言中，过程调用这一操作在机器语言层面，通常由一条调用指令来实现 ，该项叙述正确。<br>
B 选项：调用指令执行时，为了能在子程序执行完后回到主程序的正确位置，需要保留返回地址，这个返回地址就是调用指令后面一条指令的地址，该项叙述正确。<br>
C 选项：对于嵌套调用，由于嵌套层次不确定，使用栈这种 “先进后出” 的数据结构来保存返回地址很合适；非嵌套调用时，返回地址的保存相对简单，可放在特定寄存器中 ，该项叙述正确。<br>
D 选项：调用指令执行时，虽然是转移到目标地址（子程序入口），但转移目标地址一般是在指令中明确给出的，或者通过某种寻址方式能确定目标地址，该项说无须在指令中明显给出是错误的。</p>
</li>
<li>
<p><strong>假设 P 为调用过程，Q 为被调用过程，程序在 32 位 x86 处理器上执行，以下是 C 语言程序中过程调用所涉及的操作：<br>
① 过程 Q 保存 P 的现场，并为非静态局部变量分配空间<br>
② 过程 P 将实参存放到 Q 能访问到的地方<br>
③ 过程 P 将返回地址存放到特定处，并转跳到 Q 执行<br>
④ 过程 Q 取出返回地址，并转跳回到过程 P 执行<br>
⑤ 过程 Q 恢复 P 的现场，并释放局部变量所占空间<br>
⑥ 执行过程 Q 的函数体<br>
过程调用的正确执行步骤是（ ）。<br>
A. ②→③→④→①→⑤→⑥<br>
B. ②→③→①→④→⑥→⑤<br>
C. ②→③→①→⑥→⑤→④<br>
D. ②→③→①→⑤→⑥→④</strong><br>
C</p>
</li>
<li>
<p><strong>下列关于 RISC 和 CISC 的说法中，不正确的是（ ）。<br>
A. RISC 指令格式种类少，寻址方式少，指令长度固定，更容易用硬布线电路实现<br>
B. CISC 指令功能强大，寻址方式多，便于汇编程序员编程<br>
C. CISC 指令格式种类多，所以更有利于编译优化<br>
D. RISC 多数指令能够在一个时钟周期内完成，特别适合流水线工作</strong><br>
C，CISC难以编译优化</p>
</li>
<li></li>
</ol>
<div class="main-hero-waves-area"><div class="waves-area"><svg class="waves-svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 1440 140" preserveAspectRatio="none"><path class="parallax" d="M 0 44 C 355 167 415 0 725 44 L 725 44 L 0 44 Z"></path><use class="parallax" xlink:href="#wave1" x="48" y="3"></use><use class="parallax" xlink:href="#wave1" x="48" y="5"></use><use class="parallax" xlink:href="#wave1" x="48" y="7"></use><use class="parallax" xlink:href="#wave1" x="48" y="9"></use></svg></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://labi.com">Lorinda</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://labi.com/post/b93e5f6d.html">http://labi.com/post/b93e5f6d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://labi.com" target="_blank">蜡笔梦工厂</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%93%8D%E4%BD%9C%E7%A0%81-%E5%9C%B0%E5%9D%80%E7%A0%81%EF%BC%89/">指令格式（操作码/地址码）</a><a class="post-meta__tags" href="/tags/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%88%E7%AB%8B%E5%8D%B3%E6%95%B0-%E7%9B%B4%E6%8E%A5-%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%89/">寻址方式（立即数/直接/间接寻址）</a><a class="post-meta__tags" href="/tags/%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%BE%E8%AE%A1%EF%BC%88CISC-RISC%EF%BC%89/">指令集设计（CISC/RISC）</a><a class="post-meta__tags" href="/tags/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F/">指令执行周期</a></div><div class="post-share"><div class="social-share" data-image="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/ce20e5e9.html" title="第 3 章 内存管理：地址映射与虚拟内存"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第 3 章 内存管理：地址映射与虚拟内存</div></div><div class="info-2"><div class="info-item-1">覆盖内存分配方式（连续/分页/分段）与地址转换机制，详解虚拟内存技术、请求分页流程及页面置换策略，解决多道程序下内存利用率与地址映射问题。</div></div></div></a><a class="pagination-related" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第 4 章 文件管理：存储与访问机制</div></div><div class="info-2"><div class="info-item-1">介绍文件的逻辑与物理结构，讲解目录管理（按名存取）、索引节点功能及外存空闲空间分配策略，实现文件的安全存储与高效共享。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155535.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info-name">Lorinda</div><div class="author-info-description">欢迎来到Lorinda的个人博客\^o^/</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">112</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://lr0513.github.io/"><i class="fab fa-github"></i><span>你回来了~</span><i class="faa-passing animated" style="padding-left:20px;display:inline-block;vertical-align:middle;"><svg class="icon" style="height:28px;width:28px;fill:currentColor;position:relative;top:5px"><use xlink:href="#icon-hexolabixiaoxin1"></use></svg></i></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div><div id="welcome-info"></div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"><div id="newYear-main"><div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">指令集体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本指令结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">指令的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">具体指令结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E7%A0%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">指令地址码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">零地址指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">一地址指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">二地址指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">三地址指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">四地址指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.2.5.</span> <span class="toc-text">指令操作码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">定长操作码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">可变长度操作码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">扩展操作码计算</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">指令的寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">指令寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.</span> <span class="toc-text">数据寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A0%81%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">地址码的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">常见的数据寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">隐含寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E3%80%90%E6%93%8D%E4%BD%9C%E6%95%B0%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E3%80%91"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">立即寻址【操作数在指令中】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-%E5%9C%B0%E5%9D%80"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">直接寻址 [地址]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">间接寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E3%80%90%E6%93%8D%E4%BD%9C%E6%95%B0%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E3%80%91"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">寄存器寻址【操作数在寄存器中】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">寄存器间接寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.7.</span> <span class="toc-text">基址寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.8.</span> <span class="toc-text">变址寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.9.</span> <span class="toc-text">基址变址寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.10.</span> <span class="toc-text">带比例变址寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.11.</span> <span class="toc-text">相对寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.12.</span> <span class="toc-text">堆栈寻址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">2.2.3.</span> <span class="toc-text">对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%88MOV%EF%BC%89%E6%93%8D%E4%BD%9C%E6%95%B0%E9%99%90%E5%88%B6%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">（MOV）操作数限制总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text">程序的机器级代码表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">指令操作类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E7%B1%BB"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">数据传送类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%B1%BB"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">运算类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%B1%BB"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">程序控制类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B1%BB"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">输入输出类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E7%BB%87"><span class="toc-number">3.2.</span> <span class="toc-text">寄存器组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">专用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8-EIP"><span class="toc-number">3.2.3.</span> <span class="toc-text">指令指针寄存器 (EIP)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8-EFLAGS"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">标志寄存器 (EFLAGS)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">3.2.3.1.1.</span> <span class="toc-text">状态标志位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="toc-number">3.2.3.1.2.</span> <span class="toc-text">条件转移指令的比较规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87"><span class="toc-number">3.2.5.</span> <span class="toc-text">存储器组织</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B8%8E%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">物理地址与逻辑地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">存储模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">工作模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8E%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.2.6.</span> <span class="toc-text">段选择器与段描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.7.</span> <span class="toc-text">基本段类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.8.</span> <span class="toc-text">常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.8.1.</span> <span class="toc-text">数据传送指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.8.2.</span> <span class="toc-text">堆栈操作指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.8.3.</span> <span class="toc-text">地址操作指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.8.4.</span> <span class="toc-text">输入输出指令</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#I-O%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-VS-%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.8.4.1.</span> <span class="toc-text">I&#x2F;O寻址方式 VS 存储器寻址方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.9.</span> <span class="toc-text">关键总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AT-T%E6%A0%BC%E5%BC%8F-VS-Intel%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.9.1.</span> <span class="toc-text">AT&amp;T格式 VS Intel格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.10.</span> <span class="toc-text">选择语句的机器级表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.11.</span> <span class="toc-text">循环语句的机器级表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.12.</span> <span class="toc-text">栈帧的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Call%E5%92%8Cret%E6%8C%87%E4%BB%A4-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.12.1.</span> <span class="toc-text">Call和ret指令(函数调用的机器级表示)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E6%A0%88%E5%B8%A7"><span class="toc-number">3.2.12.2.</span> <span class="toc-text">如何访问栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E6%A0%88%E5%B8%A7"><span class="toc-number">3.2.12.3.</span> <span class="toc-text">如何切换栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%A0%88%E5%B8%A7%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">3.2.12.4.</span> <span class="toc-text">一个栈帧包含的内容</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CISC-%E5%92%8C-RISC"><span class="toc-number">4.</span> <span class="toc-text">CISC 和 RISC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88CISC%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">复杂指令系统计算机（CISC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88RISC%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">精简指令系统计算机（RISC）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">错题</span></a></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：Linux环境与自动化部署"></a><div class="content"><a class="title" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署">瑞吉外卖：Linux环境与自动化部署</a><time datetime="2025-09-02T02:04:00.000Z" title="发表于 2025-09-02 10:04:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：性能优化与架构升级"></a><div class="content"><a class="title" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级">瑞吉外卖：性能优化与架构升级</a><time datetime="2025-09-02T02:03:00.000Z" title="发表于 2025-09-02 10:03:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：移动端交互与用户端实现"></a><div class="content"><a class="title" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现">瑞吉外卖：移动端交互与用户端实现</a><time datetime="2025-09-02T02:02:00.000Z" title="发表于 2025-09-02 10:02:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：核心业务功能开发"></a><div class="content"><a class="title" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发">瑞吉外卖：核心业务功能开发</a><time datetime="2025-09-02T02:01:00.000Z" title="发表于 2025-09-02 10:01:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：项目概述与整体架构"></a><div class="content"><a class="title" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构">瑞吉外卖：项目概述与整体架构</a><time datetime="2025-09-02T02:00:00.000Z" title="发表于 2025-09-02 10:00:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ce4585c2.html" title="前端实现：界面与交互逻辑"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端实现：界面与交互逻辑"></a><div class="content"><a class="title" href="/post/ce4585c2.html" title="前端实现：界面与交互逻辑">前端实现：界面与交互逻辑</a><time datetime="2025-08-30T03:03:00.000Z" title="发表于 2025-08-30 11:03:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d67b0a8b.html" title="核心功能开发：业务流程实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="核心功能开发：业务流程实现"></a><div class="content"><a class="title" href="/post/d67b0a8b.html" title="核心功能开发：业务流程实现">核心功能开发：业务流程实现</a><time datetime="2025-08-30T03:02:00.000Z" title="发表于 2025-08-30 11:02:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b85186f.html" title="基础开发：环境搭建与核心配置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础开发：环境搭建与核心配置"></a><div class="content"><a class="title" href="/post/b85186f.html" title="基础开发：环境搭建与核心配置">基础开发：环境搭建与核心配置</a><time datetime="2025-08-30T03:01:00.000Z" title="发表于 2025-08-30 11:01:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/25e0fe54.html" title="项目概述：架构与需求分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目概述：架构与需求分析"></a><div class="content"><a class="title" href="/post/25e0fe54.html" title="项目概述：架构与需求分析">项目概述：架构与需求分析</a><time datetime="2025-08-30T03:00:00.000Z" title="发表于 2025-08-30 11:00:00">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/g86c4e7a.html" title="第 7 章 计算机系统结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 7 章 计算机系统结构"></a><div class="content"><a class="title" href="/post/g86c4e7a.html" title="第 7 章 计算机系统结构">第 7 章 计算机系统结构</a><time datetime="2025-08-28T21:20:00.000Z" title="发表于 2025-08-29 05:20:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f75b3d6f.html" title="第 6 章 输入输出系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 6 章 输入输出系统"></a><div class="content"><a class="title" href="/post/f75b3d6f.html" title="第 6 章 输入输出系统">第 6 章 输入输出系统</a><time datetime="2025-08-28T21:19:00.000Z" title="发表于 2025-08-29 05:19:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 5 章 输入输出管理：设备协同与优化"></a><div class="content"><a class="title" href="/post/169339cb.html" title="第 5 章 输入输出管理：设备协同与优化">第 5 章 输入输出管理：设备协同与优化</a><time datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d64a2c5e.html" title="第 5 章 中央处理器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 5 章 中央处理器"></a><div class="content"><a class="title" href="/post/d64a2c5e.html" title="第 5 章 中央处理器">第 5 章 中央处理器</a><time datetime="2025-08-28T21:18:00.000Z" title="发表于 2025-08-29 05:18:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 4 章 文件管理：存储与访问机制"></a><div class="content"><a class="title" href="/post/790dfc8c.html" title="第 4 章 文件管理：存储与访问机制">第 4 章 文件管理：存储与访问机制</a><time datetime="2025-08-28T21:17:00.000Z" title="发表于 2025-08-29 05:17:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b93e5f6d.html" title="第 4 章 指令系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 4 章 指令系统"></a><div class="content"><a class="title" href="/post/b93e5f6d.html" title="第 4 章 指令系统">第 4 章 指令系统</a><time datetime="2025-08-28T21:17:00.000Z" title="发表于 2025-08-29 05:17:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ce20e5e9.html" title="第 3 章 内存管理：地址映射与虚拟内存"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 3 章 内存管理：地址映射与虚拟内存"></a><div class="content"><a class="title" href="/post/ce20e5e9.html" title="第 3 章 内存管理：地址映射与虚拟内存">第 3 章 内存管理：地址映射与虚拟内存</a><time datetime="2025-08-28T21:16:00.000Z" title="发表于 2025-08-29 05:16:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a81d4c7b.html" title="第 3 章 存储系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 3 章 存储系统"></a><div class="content"><a class="title" href="/post/a81d4c7b.html" title="第 3 章 存储系统">第 3 章 存储系统</a><time datetime="2025-08-28T21:16:00.000Z" title="发表于 2025-08-29 05:16:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/833e46bb.html" title="第 2 章 进程与线程：并发管理核心"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 2 章 进程与线程：并发管理核心"></a><div class="content"><a class="title" href="/post/833e46bb.html" title="第 2 章 进程与线程：并发管理核心">第 2 章 进程与线程：并发管理核心</a><time datetime="2025-08-28T21:15:00.000Z" title="发表于 2025-08-29 05:15:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e72f3b9c.html" title="第 2 章 数据的表示与计算"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 2 章 数据的表示与计算"></a><div class="content"><a class="title" href="/post/e72f3b9c.html" title="第 2 章 数据的表示与计算">第 2 章 数据的表示与计算</a><time datetime="2025-08-28T21:15:00.000Z" title="发表于 2025-08-29 05:15:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b328aa63.html" title="第 1 章 操作系统概述：计算机系统基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 1 章 操作系统概述：计算机系统基础"></a><div class="content"><a class="title" href="/post/b328aa63.html" title="第 1 章 操作系统概述：计算机系统基础">第 1 章 操作系统概述：计算机系统基础</a><time datetime="2025-08-28T21:14:00.000Z" title="发表于 2025-08-29 05:14:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c45d1e8a.html" title="第 1 章 计算机系统概述"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第 1 章 计算机系统概述"></a><div class="content"><a class="title" href="/post/c45d1e8a.html" title="第 1 章 计算机系统概述">第 1 章 计算机系统概述</a><time datetime="2025-08-28T21:14:00.000Z" title="发表于 2025-08-29 05:14:00">2025-08-29</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：Linux环境与自动化部署"/></a><div class="content"><a class="title" href="/post/reggie-deployment.html" title="瑞吉外卖：Linux环境与自动化部署">瑞吉外卖：Linux环境与自动化部署</a><time datetime="2025-09-02T02:04:00.000Z" title="发表于 2025-09-02 10:04:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：性能优化与架构升级"/></a><div class="content"><a class="title" href="/post/reggie-optimization.html" title="瑞吉外卖：性能优化与架构升级">瑞吉外卖：性能优化与架构升级</a><time datetime="2025-09-02T02:03:00.000Z" title="发表于 2025-09-02 10:03:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：移动端交互与用户端实现"/></a><div class="content"><a class="title" href="/post/reggie-mobile.html" title="瑞吉外卖：移动端交互与用户端实现">瑞吉外卖：移动端交互与用户端实现</a><time datetime="2025-09-02T02:02:00.000Z" title="发表于 2025-09-02 10:02:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：核心业务功能开发"/></a><div class="content"><a class="title" href="/post/reggie-business.html" title="瑞吉外卖：核心业务功能开发">瑞吉外卖：核心业务功能开发</a><time datetime="2025-09-02T02:01:00.000Z" title="发表于 2025-09-02 10:01:00">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖：项目概述与整体架构"/></a><div class="content"><a class="title" href="/post/reggie-overview.html" title="瑞吉外卖：项目概述与整体架构">瑞吉外卖：项目概述与整体架构</a><time datetime="2025-09-02T02:00:00.000Z" title="发表于 2025-09-02 10:00:00">2025-09-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> By Lorinda</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="日间和夜间模式切换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="to_comment" type="button" title="前往评论" onclick="FixedCommentBtn();"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-three-beta.vercel.app/',
      region: 'ap-beijing',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-three-beta.vercel.app/',
      region: 'ap-beijing',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async src="//at.alicdn.com/t/c/font_4860073_9duzoqyl2cn.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="/js/pagination-jump.js"></script><script async src="/js/fps.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async data-pjax src="/js/music.js"></script><script defer src="/js/lunar.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script> let backimg =["url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/d42bcc24810cda2c22eaed769b79a93.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/2f5e89ae13329dd89bdcdbfc68c5fde.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/48b137c38cc79ad960ecf2a9a12fc20.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/4474312751631fedb37381e37cdb9c0.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/be978bd80f41d2781455513ba1676a2.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a01223e0819746191dd135670a2d7da.jpg)","url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/af380cb8a5ed3f047e66dbfe731f488.jpg)"];let index = Math.floor(Math.random() * backimg.length);;document.getElementById("web_bg").style.backgroundImage = backimg[index]</script><script type="text/javascript" src="/js/rightmenu.js"></script><script src="/js/history.js"></script><script src="/js/historyroll.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script defer src="/js/day.js"></script><script async src="/js/title.js"></script><script defer src="/js/random.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="/js/sun_moon.js" async></script><script>
  document.addEventListener('copy', function(e) {
    const selection = window.getSelection().toString()
    if (selection.length > 30) {
      const notice = document.createElement('div')
      notice.className = 'copy-notification'
      notice.textContent = '内容已复制到剪贴板'

      document.body.appendChild(notice)
      setTimeout(() => notice.classList.add('show'), 10)

      setTimeout(() => {
        notice.classList.remove('show')
        setTimeout(() => notice.remove(), 300)
      }, 2000)
    }
  })
</script>
<div class="aplayer no-destroy" data-id="7338633309" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script async data-pjax src="/js/newYear.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-nest.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-show-text.min.js" data-mobile="false" data-text="Ha,Ha,Ha" data-fontsize="15px" data-random="false" async="async"></script><script>(() => {
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "cbe39e5f-e68f-4a07-b9cd-3ebbb6aa9ae8";
  (function () {
    d = document;
    s = d.createElement("script");
    s.src = "https://client.crisp.chat/l.js";
    s.async = 1;
    d.getElementsByTagName("head")[0].appendChild(s);
  })();
  $crisp.push(["safe", true])

  const isChatBtn = true
  const isChatHideShow = false

  if (isChatBtn) {
    const open = () => {
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])
    }

    const close = () => $crisp.push(["do", "chat:hide"])

    close()

    $crisp.push(["on", "chat:closed", close])

    window.chatBtnFn = () => $crisp.is("chat:visible") ? close() : open()

  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => $crisp.push(["do", "chat:hide"]),
      show: () => $crisp.push(["do", "chat:show"])
    }
  }
})()</script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementsByClassName('recent-posts')[0];
      var item_html = '<div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155818.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">系统基础</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术栈/&quot;);" href="javascript:void(0);">技术栈</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">技术工具</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程语言/&quot;);" href="javascript:void(0);">编程语言</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">语言入门</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/4e357962b00044466380f6850a120ec.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/瑞吉外卖项目/&quot;);" href="javascript:void(0);">瑞吉外卖项目</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">数技核心</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155709.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机基础/&quot;);" href="javascript:void(0);">计算机基础</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">计基要点</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160015.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/大数据技术/&quot;);" href="javascript:void(0);">大数据技术</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">瑞吉实践</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160113.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/苍穹外卖项目/&quot;);" href="javascript:void(0);">苍穹外卖项目</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">苍穹实践</span></li><li class="categoryBar-list-item" style="background:url(https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155951.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机基础/专业课/&quot;);" href="javascript:void(0);">专业课</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">专业课程</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementsByClassName('recent-posts')[0] && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '9aac1b5db191491a8993c445d664de8f';
  var gaud_map_key = '3cc01a5a19f500daa0e9e680ef0f6db2';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '120.780172,40.624088';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt="">第 7 章 计算机系统结构</a><div class="blog-slider__text">阐述计算机系统结构的基本概念，分析并行处理技术的实现方式，详解存储层次的优化策略，介绍系统性能的评价指标与方法。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/g86c4e7a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt="">第 6 章 输入输出系统</a><div class="blog-slider__text">介绍I/O设备的分类与特性，详解程序查询、中断与DMA三种控制方式，分析中断系统的处理机制，理解设备与主机的信息交换过程。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/f75b3d6f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt="">第 5 章 中央处理器</a><div class="blog-slider__text">详解CPU的功能组成与工作原理，分析时序系统的作用，对比微程序与硬布线控制方式，介绍流水线技术的性能优化机制。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/d64a2c5e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-deployment.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-deployment.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：Linux环境与自动化部署</a><div class="blog-slider__text">详解瑞吉外卖部署流程，包括Linux环境配置、Git版本管理、自动化脚本与项目发布实践。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-deployment.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112914.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt="">第 4 章 指令系统</a><div class="blog-slider__text">详解指令的基本格式与寻址方式，对比CISC与RISC体系结构特点，分析指令的执行流程，理解指令系统对硬件的适配关系。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b93e5f6d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/ce4585c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/ce4585c2.html&quot;);" href="javascript:void(0);" alt="">前端实现：界面与交互逻辑</a><div class="blog-slider__text">详解苍穹外卖前端开发实现，包括Vue组件架构设计、核心页面（登录、首页、订单页）开发，接口交互封装与状态管理，确保前端界面与后端服务高效协同。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/ce4585c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-optimization.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-optimization.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：性能优化与架构升级</a><div class="blog-slider__text">详解瑞吉外卖优化方案，包括Redis缓存应用、数据库读写分离、系统架构升级等性能提升手段。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-optimization.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt="">第 3 章 存储系统</a><div class="blog-slider__text">分析存储系统的层次结构设计，详解主存储器的组成与工作流程，阐述Cache的映射方式与替换策略，介绍存储器性能优化方法。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/a81d4c7b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/d67b0a8b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/d67b0a8b.html&quot;);" href="javascript:void(0);" alt="">核心功能开发：业务流程实现</a><div class="blog-slider__text">聚焦苍穹外卖核心业务功能开发，详解用户管理、菜品管理、订单全流程及购物车交互逻辑，结合数据统计功能实现业务闭环，覆盖项目核心场景。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/d67b0a8b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112855.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt="">第 2 章 数据的表示与计算</a><div class="blog-slider__text">详解数制转换规则，阐述定点数与浮点数的表示方法，分析补码运算机制，介绍ALU的功能与实现，掌握数据在计算机中的处理方式。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/e72f3b9c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b85186f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112626.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b85186f.html&quot;);" href="javascript:void(0);" alt="">基础开发：环境搭建与核心配置</a><div class="blog-slider__text">详解苍穹外卖项目基础开发流程，包括本地开发环境搭建、数据库表结构设计与初始化，核心配置（跨域、日志等）及基础工具类实现，构建项目开发基石。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b85186f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-business.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-business.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：核心业务功能开发</a><div class="blog-slider__text">详解瑞吉外卖后端核心业务实现，包括员工管理、菜品分类、订单流程等功能的接口与逻辑开发。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-business.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-mobile.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_155656.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-mobile.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：移动端交互与用户端实现</a><div class="blog-slider__text">详解瑞吉外卖移动端用户端开发，包括手机验证码登录、地址簿管理、菜品 / 套餐展示、购物车增删改查、用户订单创建与再来一单功能，及前后端接口交互逻辑。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-mobile.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112813.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt="">Redis</a><div class="blog-slider__text">Redis 作为内存 NoSQL 数据库的定位，支持 String/Hash 等多数据结构，具备 RDB/AOF 持久化与主从高可用，核心用于缓存、分布式锁，性能高效。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/bae4ff13.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt="">第 1 章 计算机系统概述</a><div class="blog-slider__text">介绍计算机系统的硬件与软件组成，详解五大功能部件及总线工作机制，阐述指令集体系结构的核心作用，建立计算机系统的整体认知。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/c45d1e8a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/25e0fe54.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112618.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/25e0fe54.html&quot;);" href="javascript:void(0);" alt="">项目概述：架构与需求分析</a><div class="blog-slider__text">全面解析苍穹外卖项目的整体规划，包括项目背景、核心需求、技术栈选型依据，详解系统架构设计与开发规范，为项目开发提供整体指导。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/25e0fe54.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112758.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt="">王道计组pdf</a><div class="blog-slider__text">计算机组成原理</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/77666db.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112650.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt="">第 2 章 进程与线程：并发管理核心</a><div class="blog-slider__text">讲解进程与线程的定义、状态转换及控制逻辑，分析进程调度策略，阐述进程同步互斥（PV 操作）与死锁的处理机制，是操作系统并发管理的核心。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/833e46bb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112844.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt="">第 5 章 输入输出管理：设备协同与优化</a><div class="blog-slider__text">详解I/O设备分类与控制方式（程序直接控制/DMA/通道），分析磁盘结构与调度策略，介绍SPOOLing等I/O优化技术，保障设备与CPU、内存的高效协同。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/169339cb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt="">第 4 章 文件管理：存储与访问机制</a><div class="blog-slider__text">介绍文件的逻辑与物理结构，讲解目录管理（按名存取）、索引节点功能及外存空闲空间分配策略，实现文件的安全存储与高效共享。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/790dfc8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt="">第 3 章 内存管理：地址映射与虚拟内存</a><div class="blog-slider__text">覆盖内存分配方式（连续/分页/分段）与地址转换机制，详解虚拟内存技术、请求分页流程及页面置换策略，解决多道程序下内存利用率与地址映射问题。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/ce20e5e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt="">第 1 章 操作系统概述：计算机系统基础</a><div class="blog-slider__text">阐述操作系统的定义与核心功能，详解四大特征（并发 / 共享 / 虚拟 / 异步）、处理器运行模式及系统结构分类，介绍 OS 引导流程，奠定操作系统认知基础。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b328aa63.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt="">数据结构</a><div class="blog-slider__text">数据结构的核心是高效组织数据，区分逻辑结构（线性 / 非线性）与物理结构（顺序 / 链式），覆盖数组、树、图等核心类型，为优化算法效率、支撑工程应用奠定基础。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/79666db.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/reggie-overview.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2024_1123_160146.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/reggie-overview.html&quot;);" href="javascript:void(0);" alt="">瑞吉外卖：项目概述与整体架构</a><div class="blog-slider__text">全面解析瑞吉外卖项目背景、技术选型、整体架构设计及核心业务流程，建立项目全局认知。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/reggie-overview.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2025_0314_112938.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt="">java基础</a><div class="blog-slider__text">Java基础</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b8b0eacd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>