---
title: 数据结构
categories:
  - 计算机基础
tags:
  - c
  - 数据结构
description: 数据结构
swiper_index: 1
abbrlink: 79666db
date: 2025-03-12 16:47:00
---

数据的==逻辑==结构是指==数据元素之间==的逻辑关系，它与所使用的计算机无关。

数据的==物理==结构，又称==存储结构==，是指数据结构在计算机中的表示，它包括数据元素的表示和元素的表示，其中数据元素之间的关系在计算机中有**顺序**存储结构和**链式**存储结构两种。

==逻辑结构==
集合，线性，树，图
- 线性结构：线性表，栈，队列，串
- 非线性结构：树，图

物理结构(存储结构)
- 顺序
- 链式
- 索引
- 散列(Has存储)

运算的定义针对:逻辑结构
运算的实现针对:存储结构

==数据>数据元素>数据项==

算法特性(必须全具备)
- 有穷性：算法必须有穷，程序可以无穷
- 确定性
- 可行性
- 输入
- 输出

# 复杂度

## **1. 线性查找时间复杂度**
- **最坏情况**：目标元素在最后一个位置，需遍历整个链表，时间复杂度为 **O(n)**。
- **平均情况**：假设目标元素在各位置概率相等，平均比较次数为 **(n+1)/2**，时间复杂度 **O(n)**
## **2. 单循环链表的头尾访问**
- **带尾指针的单循环链表**：
  - 找表头结点：通过尾指针的 `next` 直接访问，时间复杂度 **O(1)**。
  - 找表尾结点：直接访问尾指针，时间复杂度 **O(1)**。
- **带头结点的单循环链表**：
  - 找表头结点：直接访问头结点，时间复杂度 **O(1)**。
  - 找表尾结点：需从头遍历到尾，时间复杂度 **O(n)**。
## **3. 链表合并的时间复杂度**
- **将长度为 n 的单链表链接到长度为 m 的单链表之后**：
  - 需要找到链表 m 的尾节点（耗时 **O(m)**），然后修改其 `next` 指针指向链表 n 的头节点（耗时 **O(1)**）。
  - 总时间复杂度为 **O(m)**。
## **4. 插入操作的时间复杂度**
- **数组的插入操作**（假设在位置 i 插入元素）：
  - **移动次数**：需将第 i 个位置后的所有元素后移，共移动 **n - i** 次。
  - **总移动次数**：插入所有可能位置（共 **n+1** 种）的移动次数总和为  **(n+1)/2**
  - **平均移动次数**：n/2，时间复杂度 **O(n)**。
- **链表的插入操作**（假设已知插入位置的前驱节点）：
  - 仅需修改指针，时间复杂度 **O(1)**。
  - 若需遍历找到插入位置，时间复杂度 **O(n)**。
## **5. 删除操作的时间复杂度**
- **数组的删除操作**（假设删除位置 i 的元素）：
  - **移动次数**：需将第 i 个位置后的所有元素前移，共移动 **n - i - 1** 次。
  - **总移动次数**：删除所有可能位置（共 **n** 种）的移动次数总和为  **n(n-1)/2**
  - **平均移动次数**： **(n-1)/2**，时间复杂度 **O(n)**。
- **链表的删除操作**（假设已知删除节点的前驱节点）：
  - 仅需修改指针，时间复杂度 **O(1)**。
  - 若需遍历找到删除节点，时间复杂度 **O(n)**。
1. **链表与数组的差异**：
   - **链表**的插入和删除操作时间复杂度取决于是否已知操作位置的前驱节点：
     - 已知前驱节点：**O(1)**。
     - 需遍历查找位置：**O(n)**。
   - **数组**的插入和删除操作需移动元素，时间复杂度为 **O(n)**。

| 操作        | 数组（平均 / 最坏）    | 链表（已知前驱节点）     | 链表（需遍历）        |
| --------- | -------------- | -------------- | -------------- |
| **插入元素**  | O(n)       | O(1)       | O(n)       |
| **删除元素**  | O(n)       | O(1)       | O(n)       |
| **查找元素**  | O(n)       | O(n)       | O(n)       |
| **访问头节点** | O(1)       | O(1)       | O(1)       |
| **访问尾节点** | O(1)（有尾指针） | O(1)（带尾指针） | O(n)（无尾指针） |

# 线性表
顺序存储的物理和逻辑是一一对应的
链式存储可用于存储线性和非线性的数据结构

```C++
#include <iostream>
#include <cstdlib>
#include <cstdio>
using namespace std;

#define LIST_INIT_SIZE 10    // 线性表初始容量
#define LIST_INCREMENT 2     // 容量不足时的增量
#define OK 1
#define ERROR 0

typedef int ElemType;        // 元素类型
typedef int Status;          // 操作状态

// 顺序表结构体
typedef struct {
    ElemType* data;         // 存储空间基址
    int length;             // 当前元素个数
    int capacity;           // 当前分配的存储容量
} SqList;

// 初始化顺序表
Status InitList(SqList &L) {
    L.data = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if (!L.data) exit(OVERFLOW);
    L.length = 0;
    L.capacity = LIST_INIT_SIZE;
    return OK;
}

// 销毁顺序表
Status DestroyList(SqList &L) {
    if (L.data) {
        free(L.data);
        L.data = NULL;
    }
    L.length = 0;
    L.capacity = 0;
    return OK;
}

// 获取指定位置的元素
Status GetElem(SqList L, int i, ElemType &e) {
    if (i < 1 || i > L.length) return ERROR;
    e = L.data[i - 1];
    return OK;
}

// 获取前驱元素
Status PriorElem(SqList L, ElemType cur_e, ElemType &pre_e) {
    for (int i = 1; i < L.length; i++) {
        if (L.data[i] == cur_e) {
            pre_e = L.data[i - 1];
            return OK;
        }
    }
    return ERROR;
}

// 插入元素
Status ListInsert(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) return ERROR;

    // 扩容处理
    if (L.length >= L.capacity) {
        ElemType* newbase = (ElemType*)realloc(L.data,
            (L.capacity + LIST_INCREMENT) * sizeof(ElemType));
        if (!newbase) exit(OVERFLOW);
        L.data = newbase;
        L.capacity += LIST_INCREMENT;
    }

    // 插入元素
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return OK;
}

// 删除元素
Status ListDelete(SqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length) return ERROR;
    e = L.data[i - 1];
    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return OK;
}

// 遍历顺序表
void ListTraverse(SqList L, void (*visit)(ElemType)) {
    for (int i = 0; i < L.length; i++) {
        visit(L.data[i]);
    }
    printf("\n");
}

// 合并两个有序顺序表
Status MergeSortedLists(SqList La, SqList Lb, SqList &Lc) {
    // 初始化结果表
    Lc.capacity = La.length + Lb.length;
    Lc.data = (ElemType*)malloc(Lc.capacity * sizeof(ElemType));
    if (!Lc.data) exit(OVERFLOW);

    // 合并操作
    int i = 0, j = 0, k = 0;
    while (i < La.length && j < Lb.length) {
        Lc.data[k++] = (La.data[i] <= Lb.data[j]) ? La.data[i++] : Lb.data[j++];
    }

    // 处理剩余元素
    while (i < La.length) Lc.data[k++] = La.data[i++];
    while (j < Lb.length) Lc.data[k++] = Lb.data[j++];

    Lc.length = k;
    return OK;
}

int main() {
    SqList L;
    InitList(L);

    // 插入测试
    for (int i = 1; i <= 5; i++) {
        ListInsert(L, i, i * 10);
    }
    printf("插入元素后: ");
    ListTraverse(L, PrintElement);

    // 删除测试
    ElemType e;
    ListDelete(L, 3, e);
    printf("删除第3个元素: %d\n", e);
    printf("删除后: ");
    ListTraverse(L, PrintElement);

    // 合并测试
    SqList La, Lb, Lc;
    InitList(La);
    InitList(Lb);

    for (int i = 1; i <= 5; i++) {
        ListInsert(La, i, i * 2);
        ListInsert(Lb, i, i * 3);
    }

    MergeSortedLists(La, Lb, Lc);
    printf("合并后结果: ");
    ListTraverse(Lc, PrintElement);

    // 资源清理
    DestroyList(L);
    DestroyList(La);
    DestroyList(Lb);
    DestroyList(Lc);

    return 0;
}
```

## 顺序表的合并
![Untitled 8 70](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2070.png)
![Untitled 9 67](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2067.png)
  ![Untitled 10 63](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2063.png)时间复杂度Q(ListLength(La)+ListLength(Lb))
  空间复杂度O(1)


## 单链表
```C
typedef struct LNode {
ElemType data;
struct LNode* next;
}LNode,*LinkList;
```
普通变量是LNode.成员名，指针变量是LinkList->成员名
Linklist强调单链表，LNode*强调结点

定义链表L：LNode * L == LinkList L(更常用)
定义结点指针：LNode *p(更常用) == LinkList p
L->next有两层含义，可以表示L的后继节点指针，又可表示L的指针域（单链表的指针域只有后继指针域，双链表的指针域分为前驱指针域和后继指针域））
p = L就是p = 头结点，p = L->next就是让p = 头结点的后一个节点。

头指针：是指向链表第一个结点的指针
首元结点：是指向链表中存储第一个数据元素a1的结点
头结点：是在链表的首元结点之前附设的一个结点。链表中的头结点仅起到标识的作用。
![5e68616c9b390b7ef84a08401462f0d](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/5e68616c9b390b7ef84a08401462f0d.jpg)
带==头结点==的好处：
1. 便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。
2. 便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此统一。
3. 头结点的指针域可以为空，可以存放长度等，但==不计入链表的长度值==。

表示空表
- 无头结点：头指针为空
- 有头结点：头结点的指针域为空

链表特点：
- 结点在存储器中位置任意
- 只能通过头指针进入链表，顺序扫描。寻找第一个结点很容易。==顺序表是随机存储法==
- 结点空间可以动态申请和释放
- 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素
- 缺点：存储密度小，利用率小，每个结点的指针域额外占用存储空间
- 静态链表中的指针表示的是数组下标

## 头插（逆序）
带头结点
![7ae0a7bd64d74b5d9a149f7849e38f93](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7ae0a7bd64d74b5d9a149f7849e38f93.gif)
不带头结点
![e062fe1ed673468681ecce4d84a865ae](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/e062fe1ed673468681ecce4d84a865ae.gif)
## 尾插
![Untitled 7 75|Untitled 7 75.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2075.png)
![IMG_20231010_091813](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/IMG_20231010_091813.jpg)
带头结点
![f47832ac0b274b19b1fb2e5ba8d5fcb9](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/f47832ac0b274b19b1fb2e5ba8d5fcb9.gif)
不带头结点同上


![a9b4f515e81d49d9abbc6456ff2bb60e](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a9b4f515e81d49d9abbc6456ff2bb60e.jpg)

## 带头结点的单链表
```c
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef int Status;
#define OK 1
#define ERROR 0

// 链表节点结构
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 初始化带头结点的链表
Status InitList(LinkList &L) {
    L = (LNode*)malloc(sizeof(LNode));  // 创建头结点
    if (!L) return ERROR;
    L->next = NULL;
    return OK;
}

// 头插法建立链表
void CreateList_H(LinkList &L, int n) {
    L = (LNode*)malloc(sizeof(LNode));
    L->next = NULL;

    for(int i=0; i<n; i++) {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        p->data = i*2;  // 测试数据
        p->next = L->next;
        L->next = p;
    }
}

// 尾插法建立链表
void CreateList_T(LinkList &L, int n) {
    L = (LNode*)malloc(sizeof(LNode));
    LNode *tail = L;

    for(int i=0; i<n; i++) {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        p->data = i*3;  // 测试数据
        tail->next = p;
        tail = p;
    }
    tail->next = NULL;
}

// 按位置插入
Status ListInsert(LinkList &L, int i, ElemType e) {
    LNode *p = L;
    int j = 0;

    while(p && j<i-1) {  // 找到第i-1个结点
        p = p->next;
        j++;
    }

    if(!p || j>i-1) return ERROR;

    LNode *s = (LNode*)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// 按位置删除
Status ListDelete(LinkList &L, int i, ElemType &e) {
    LNode *p = L;
    int j = 0;

    while(p->next && j<i-1) {
        p = p->next;
        j++;
    }

    if(!(p->next) || j>i-1) return ERROR;

    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

// 遍历链表
void ListTraverse(LinkList L) {
    LNode *p = L->next;
    while(p) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// 销毁链表
void DestroyList(LinkList &L) {
    LNode *p;
    while(L) {
        p = L;
        L = L->next;
        free(p);
    }
}
```

## 不带头结点的单链表
```c
typedef struct Node {
    ElemType data;
    struct Node *next;
} Node, *NoHeadList;

// 初始化不带头结点的链表
Status InitList(NoHeadList &L) {
    L = NULL;
    return OK;
}

// 头插法建立链表
void CreateList_H(NoHeadList &L, int n) {
    L = NULL;
    for(int i=0; i<n; i++) {
        Node *p = (Node*)malloc(sizeof(Node));
        p->data = i*2;
        p->next = L;
        L = p;
    }
}

// 尾插法建立链表
void CreateList_T(NoHeadList &L, int n) {
    Node *tail = NULL;
    L = NULL;

    for(int i=0; i<n; i++) {
        Node *p = (Node*)malloc(sizeof(Node));
        p->data = i*3;
        p->next = NULL;

        if(!L) {
            L = p;
        } else {
            tail->next = p;
        }
        tail = p;
    }
}

// 按位置插入
Status ListInsert(NoHeadList &L, int i, ElemType e) {
    if(i < 1) return ERROR;

    if(i == 1) {  // 特殊处理第一个结点
        Node *s = (Node*)malloc(sizeof(Node));
        s->data = e;
        s->next = L;
        L = s;
        return OK;
    }

    Node *p = L;
    int j = 1;

    while(p && j < i-1) {
        p = p->next;
        j++;
    }

    if(!p || j > i-1) return ERROR;

    Node *s = (Node*)malloc(sizeof(Node));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// 按位置删除
Status ListDelete(NoHeadList &L, int i, ElemType &e) {
    if(i < 1 || !L) return ERROR;

    if(i == 1) {  // 特殊处理第一个结点
        Node *q = L;
        e = q->data;
        L = L->next;
        free(q);
        return OK;
    }

    Node *p = L;
    int j = 1;

    while(p->next && j < i-1) {
        p = p->next;
        j++;
    }

    if(!(p->next) || j > i-1) return ERROR;

    Node *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

// 遍历链表
void ListTraverse(NoHeadList L) {
    Node *p = L;
    while(p) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// 销毁链表
void DestroyList(NoHeadList &L) {
    Node *p;
    while(L) {
        p = L;
        L = L->next;
        free(p);
    }
}
```
**为什么不是 `free(*r)`？**
- `free()` 的参数必须是一个指针，指向动态分配的内存块的起始地址。
- 如果 `r` 是一个指针变量（例如 `int* r`），则 `free(r)` 是正确的用法，因为 `r` 本身就是一个指针。
- 如果 `r` 是一个指向指针的指针（例如 `int** r`），则 `free(*r)` 是正确的用法，因为 `*r` 是一个指针，指向动态分配的内存块
## 代码思路整理

## 1. 结构差异对比
| 特性         | 带头结点                    | 不带头结点             |
| - | -- | -- |
| 初始化        | 需要创建头结点，头指针指向头结点        | 直接置空指针            |
| 首元结点处理     | 统一通过头结点的 next 指针访问      | 直接通过头指针访问         |
| 空表判断       | L->next == NULL         | L == NULL         |
| 插入 / 删除首结点 | 不需要特殊处理                 | 需要单独处理头指针变化       |
| 算法复杂度      | 各操作时间复杂度 O (n)，但边界处理更简单 | 时间复杂度相同，但需要更多条件判断 |

## 2. 关键实现要点
- **头插法**：新结点始终插入到链表头部
- **尾插法**：需要维护尾指针以提高效率
- **位置索引**：统一采用1-based索引
- **内存管理**：每次操作后及时释放内存
- **错误处理**：对非法位置进行有效性检查

## 3. 推荐使用场景
- **带头结点**：适合需要频繁进行首结点操作的场景
- **不带头结点**：适合内存敏感或需要直接操作首结点的场景

## 双链表
在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了由两个方向不同的链，表头结点的prior指向NULL，表尾结点的next指向NULL
```c
typedef struct DNode {
    int data;               // 数据域
    struct DNode *prior;    // 前驱指针
    struct DNode *next;     // 后继指针
} DNode, *DLinkList;
```
## **初始化双链表**
```c
void InitDLinkList(DLinkList &L) {
    L = (DNode *)malloc(sizeof(DNode));  // 创建头结点
    if (!L) exit(OVERFLOW);
    L->prior = NULL;
    L->next = NULL;
}
```
## **插入操作（在节点 p 后插入节点 s）**
```c
void InsertAfterDNode(DNode *p, DNode *s) {
    if (!p || !s) return;  // 检查参数合法性

    s->next = p->next;     // 1. s 的后继指向 p 的后继
    if (p->next)           // 如果 p 不是最后一个节点
        p->next->prior = s; // 2. p 的后继的前驱指向 s
    s->prior = p;          // 3. s 的前驱指向 p
    p->next = s;           // 4. p 的后继指向 s
}
```
## **删除操作（删除节点 p 的后继节点）**
```c
void DeleteAfterDNode(DNode *p) {
    if (!p || !p->next) return;  // 检查参数合法性

    DNode *q = p->next;  // q 指向待删除节点
    p->next = q->next;   // 1. p 的后继指向 q 的后继
    if (q->next)         // 如果 q 不是最后一个节点
        q->next->prior = p; // 2. q 的后继的前驱指向 p
    free(q);             // 3. 释放 q 的内存
}
```


## 循环双链表
表头结点的prior指向表尾结点，表尾结点的next指向头结点
![Untitled 1 129](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20129.png)
对称性：p→prior→next = p = p→next→prior
```c
typedef struct CDNode {
    int data;               // 数据域
    struct CDNode *prior;   // 前驱指针
    struct CDNode *next;    // 后继指针
} CDNode, *CDLinkList;
```
## **初始化循环双链表**
```c
void InitCDLinkList(CDLinkList &L) {
    L = (CDNode *)malloc(sizeof(CDNode));  // 创建头结点
    if (!L) exit(OVERFLOW);
    L->prior = L;  // 头结点的前驱指向自己
    L->next = L;   // 头结点的后继指向自己
}
```
## **插入操作（在节点 p 后插入节点 s）**
```c
void InsertAfterCDNode(CDNode *p, CDNode *s) {
    if (!p || !s) return;  // 检查参数合法性

    s->next = p->next;     // 1. s 的后继指向 p 的后继
    s->prior = p;          // 2. s 的前驱指向 p
    p->next->prior = s;    // 3. p 的后继的前驱指向 s
    p->next = s;           // 4. p 的后继指向 s
}
```
## **删除操作（删除节点 p 的后继节点）**
```c
void DeleteAfterCDNode(CDNode *p) {
    if (!p || p->next == p) return;  // 检查参数合法性（空表或只有头结点）

    CDNode *q = p->next;  // q 指向待删除节点
    p->next = q->next;    // 1. p 的后继指向 q 的后继
    q->next->prior = p;   // 2. q 的后继的前驱指向 p
    free(q);              // 3. 释放 q 的内存
}
```
![Pasted image 20250306144931](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306144931.jpg)
1234——s的前驱和后继->pnext的前驱->p的后继
s->prior=p;
s->next=p->next;
p->next->perior=s;
p->next=s;
3214——pnext的前驱->s的后继->s的前驱->p的后继
3241——pnext的前驱->s的后继->p的后继->s的前驱
![Untitled 3 96](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2096.png)
不用头指针的原因：由表头找到表尾较费时，删表头O(1)，插表尾O(n)
让L指向尾指针：都是O(1)
终止条件：判断是否等于头指针
单链表：
p≠NULL;
p→next≠NULL;
单循环链表：
p≠L;
p→next≠L;

带尾指针的循环链表的合并(Tb合并在Ta之后)
![Untitled 225|Untitled 225.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20225.png)
p存表头结点（p = Ta→next）→Tb表头连接Ta表尾（Ta→next = Tb→next→next）→释放Tb表头结点（delete Tb→next）→修改指针（Tb→next = p）
## **插入操作（以双链表为例）**
1. **`s->next = p->next;`**：
   - 将新节点 `s` 的后继指向 `p` 的后继。
2. **`if (p->next) p->next->prior = s;`**：
   - 如果 `p` 不是最后一个节点，将 `p` 的后继的前驱指向 `s`。
3. **`s->prior = p;`**：
   - 将新节点 `s` 的前驱指向 `p`。
4. **`p->next = s;`**：
   - 将 `p` 的后继指向 `s`。

## **删除操作（以双链表为例）**
1. **`p->next = q->next;`**：
   - 将 `p` 的后继指向 `q` 的后继。
2. **`if (q->next) q->next->prior = p;`**：
   - 如果 `q` 不是最后一个节点，将 `q` 的后继的前驱指向 `p`。
3. **`free(q);`**：
   - 释放 `q` 的内存。
## **双链表**
```c
#include <stdio.h>
#include <stdlib.h>

#define OVERFLOW -1

typedef struct DNode {
    int data;
    struct DNode *prior;
    struct DNode *next;
} DNode, *DLinkList;

void InitDLinkList(DLinkList &L) {
    L = (DNode *)malloc(sizeof(DNode));
    if (!L) exit(OVERFLOW);
    L->prior = NULL;
    L->next = NULL;
}

void InsertAfterDNode(DNode *p, DNode *s) {
    if (!p || !s) return;
    s->next = p->next;
    if (p->next) p->next->prior = s;
    s->prior = p;
    p->next = s;
}

void DeleteAfterDNode(DNode *p) {
    if (!p || !p->next) return;
    DNode *q = p->next;
    p->next = q->next;
    if (q->next) q->next->prior = p;
    free(q);
}

void PrintDLinkList(DLinkList L) {
    DNode *p = L->next;
    while (p) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main() {
    DLinkList L;
    InitDLinkList(L);

    DNode *s1 = (DNode *)malloc(sizeof(DNode));
    s1->data = 10;
    InsertAfterDNode(L, s1);

    DNode *s2 = (DNode *)malloc(sizeof(DNode));
    s2->data = 20;
    InsertAfterDNode(s1, s2);

    PrintDLinkList(L);  // 输出：10 20

    DeleteAfterDNode(L);
    PrintDLinkList(L);  // 输出：20

    return 0;
}
```

## **循环双链表**
```c
#include <stdio.h>
#include <stdlib.h>

#define OVERFLOW -1

typedef struct CDNode {
    int data;
    struct CDNode *prior;
    struct CDNode *next;
} CDNode, *CDLinkList;

void InitCDLinkList(CDLinkList &L) {
    L = (CDNode *)malloc(sizeof(CDNode));
    if (!L) exit(OVERFLOW);
    L->prior = L;
    L->next = L;
}

void InsertAfterCDNode(CDNode *p, CDNode *s) {
    if (!p || !s) return;
    s->next = p->next;
    s->prior = p;
    p->next->prior = s;
    p->next = s;
}

void DeleteAfterCDNode(CDNode *p) {
    if (!p || p->next == p) return;
    CDNode *q = p->next;
    p->next = q->next;
    q->next->prior = p;
    free(q);
}

void PrintCDLinkList(CDLinkList L) {
    CDNode *p = L->next;
    while (p != L) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main() {
    CDLinkList L;
    InitCDLinkList(L);

    CDNode *s1 = (CDNode *)malloc(sizeof(CDNode));
    s1->data = 10;
    InsertAfterCDNode(L, s1);

    CDNode *s2 = (CDNode *)malloc(sizeof(CDNode));
    s2->data = 20;
    InsertAfterCDNode(s1, s2);

    PrintCDLinkList(L);  // 输出：10 20

    DeleteAfterCDNode(L);
    PrintCDLinkList(L);  // 输出：20

    return 0;
}
```

## 静态链表
用数组实现的链表结构，它通过数组的下标来模拟链表的指针。静态链表的特点是不需要动态分配内存，而是预先分配一个**固定大小**的数组来存储链表节点。
静态链表的结构
- **数组存储**：
  - 静态链表使用数组来存储节点，每个节点包含两个部分：
    - **数据域**：存储数据。
    - **游标（或指针域）**：存储下一个节点的数组下标。
  - 数组的每个位置可以看作一个节点，游标指向下一个节点的位置。

- **头结点和空闲链表**：
  - 静态链表通常有一个头结点，用于指向链表的第一个节点。
  - 空闲链表用于管理未使用的数组位置，方便插入新节点。

为什么不需要移动元素
## **插入操作**
- **插入新节点**：
  - 从空闲链表中获取一个空闲位置（数组下标）。
  - 修改游标，将新节点插入到链表中。
  - **不需要移动其他元素**，只需修改游标。
## **删除操作**
- **删除节点**：
  - 将要删除的节点从链表中移除。
  - 将该节点的位置加入空闲链表。
  - **不需要移动其他元素**，只需修改游标。
## **修改游标**
- 静态链表通过修改游标（数组下标）来维护链表结构，而不是通过移动数据元素。
- 这种方式类似于动态链表，但使用数组下标代替指针。

 **与动态链表的对比**

|**特性**|**动态链表**|**静态链表**|
|---|---|---|
|**存储结构**|使用指针连接节点|使用数组下标（游标）连接节点|
|**内存分配**|动态分配内存|预先分配固定大小的数组|
|**插入/删除**|修改指针|修改游标|
|**移动元素**|不需要移动元素|不需要移动元素|
|**内存管理**|需要动态内存管理|不需要动态内存管理|
|**适用场景**|数据量不确定，频繁插入删除|数据量固定，内存受限的场景|

```c
#define MAX_SIZE 100

typedef struct {
    int data;  // 数据域
    int next;  // 游标（下一个节点的下标）
} Node;

Node staticList[MAX_SIZE];  // 静态链表数组
int head;                   // 头结点下标
int freeList;               // 空闲链表头结点下标
```

## **插入操作**
```c
void insert(int data) {
    if (freeList == -1) {
        printf("静态链表已满，无法插入新节点！\n");
        return;
    }

    // 从空闲链表中获取一个节点
    int newNodeIndex = freeList;
    freeList = staticList[freeList].next;

    // 插入新节点
    staticList[newNodeIndex].data = data;
    staticList[newNodeIndex].next = staticList[head].next;
    staticList[head].next = newNodeIndex;
}
```

## **删除操作**
```c
void delete(int data) {
    int prev = head;
    int curr = staticList[head].next;

    while (curr != -1) {
        if (staticList[curr].data == data) {
            // 从链表中移除节点
            staticList[prev].next = staticList[curr].next;

            // 将节点加入空闲链表
            staticList[curr].next = freeList;
            freeList = curr;

            return;
        }
        prev = curr;
        curr = staticList[curr].next;
    }

    printf("未找到要删除的元素！\n");
}
```
- **静态链表不需要移动元素**，因为它通过修改游标（数组下标）来维护链表结构。
- 插入和删除操作只需修改游标，而不需要移动数据元素。
- 静态链表适用于内存受限的场景，但灵活性不如动态链表。


![Untitled 2 46](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2046.png)
![Untitled 3 40](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2040.png)
顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取
在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂
双链表中可以快速访问任何一个结点的前驱和后继结点,选项D正确。
##  错题

^3afb0f

1. ![Pasted image 20250306152709](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png)c
2. ![Pasted image 20250306152709](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png)c
3. ![Pasted image 20250306152828](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152828.png)c
4. ![Pasted image 20250306154314](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306154314.png)d
5. ![Pasted image 20250306160930](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306160930.png)链式存储设计时，各个不同结点的==存储空间==可以不连续，但结点内的==存储单元地址==必须连续
6. ![Pasted image 20250306161045](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161045.png)![Pasted image 20250306161310](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161310.png)
7. ![Pasted image 20250306162035](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162035.png)![Pasted image 20250306162229](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162229.png)
8. ![Pasted image 20250306163931](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163931.png)设单链表递增有序，首先要在单链表中找到第一个大于x的结点的直接前驱p，在p之后插入该结点。查找的时间复杂度为 O(n)，插入的时间复杂度为 0(1)，总时间复杂度为 O(n)。
9. ![Pasted image 20250306162259](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162259.png)![Pasted image 20250306162245](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162245.png)
10. ![Pasted image 20250306162348](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162348.png)b有关因为需要遍历链表找到倒数第二个节点。d无关，因为尾指针 r 直接指向最后一个节点，无需遍历
11. ![Pasted image 20250306162745](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162745.png)d线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素 a50 不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。
12. ![Pasted image 20250306163806](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163806.png)改四个指针域，分别是:新结点的前驱指针域，指向第一个结点:新结点的后继指针域，指向第二个结点;第一个结点的后继指针域，指向新结点;第二个结点的前驱指针域，指向新结点。
13. ![Pasted image 20250306164359](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306164359.png)带头结点的循环单链表工为空表时，满足L->next == L，即头结点的指针域与L的值相等,而不是头结点的指针域与工的地址相等。注意，带头结点的循环单链表中不存在空指针。
14. ![Pasted image 20250306165707](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306165707.png)a
15. ![Pasted image 20250306170529](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170529.png)![Pasted image 20250306170531](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170531.png)对于选项 A，删除尾结点* p 时，需要找到* p的前一个结点，时间复杂度为 O(n)。对于选项B，删除首结点* p时，需要找到* p结点,这里没有直接给出头结点指针，而通过尾结点的 prior指针找到* p 结点的时间复杂度为 O(n)。对于选项 D，删除尾结点* p 时，需要找到* p 的前一个结点，时间复杂度为 O(n)。对于C，执行这四种算法的时间复杂度均为 O(1)。
16. ![Pasted image 20250306171120](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171120.png)在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为 O(1)。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在 0(1)的时间找到尾结点:若只有表头指针，则需要遍历整个链表找到尾结点，时间为0(n)。
17. ![Pasted image 20250306171301](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171301.png)对一个空循环单链表，有 head->next== head，推理 head->next->next== head->next== head。对含有一个元素的循环单链表，头结点(头指针 head 指示)的 next 域指向这个唯一的元素结点，该元素结点的next 域指向头结点，因此也有 head->next->next=head。
18. ![Pasted image 20250306171913](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171913.png)对于两种双链表，删除首结点的时间复杂度都是 0(1)。对于非循环双链表，删除尾结点的时间复杂度是 0(m);对于循环双链表，删除尾结点的时间复杂度是0(1)。
19. ![Pasted image 20250306172027](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172027.png)对于选项 A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为 O(n);而删除第一个元素时，为保持循环单链表的性质(尾结点指向第一个结点)，要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为 O(n)。对于选项 B,双链表的情况与单链表的相同，一个是 O(n),一个是 O(1)。对于选项C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置,时间复杂度为 0(n);删除第一个元素的时间复杂度为 O(1)。对于选项 D，与选项 A 的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为0(1)
20. ![Pasted image 20250306172625](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172625.png)静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。
21. ![Pasted image 20250306173426](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306173426.png)静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。并非每个空间都存储了元素，因此会造成存储空间的浪费。
22. ![Pasted image 20250306174519](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174519.png)![Pasted image 20250306174543](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174543.png)
23. ![Pasted image 20250306175206](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306175206.png)c
24. ![Pasted image 20250306191738](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191738.png)![Pasted image 20250306191747](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191747.png)
25.

# 栈LIFO
栈和队列都是**操作受限**线性表
应用：撤销，递归，进制转换，迷宫求解，表达式求值，括号匹配，处理函数或过程调用时的局部变量、返回地址、参数，深度优先遍历DFS
在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。
栈只能操作栈顶

## 顺序栈
在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。
```C
typedef struct{
	int data[MaxSize];
	int top;
}SqStack;
```
![Pasted image 20250307111852](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307111852.png)栈顶指针：S.top，初始时设置S.top=-1
栈底 0
栈顶元素：S.data[S.top]
入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶 S.data[++S.top] = x
出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1 x = S.data[S.top--]
栈空条件：S.top == -1
栈满条件：S.top== MaxSize-1
栈长：S.top+1
另一种常见的方式是：
初始设置栈顶指针 S.top=0
入栈时先将值送到栈顶，栈顶指针再加 1
出栈时，栈顶指针先减1，再取栈顶元素
栈空条件是 S.top== 0
栈满条件是S.top== MaxSize.
顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。

```C
typedef struct {
SElemType* base;
SElemType* top;
int stacksize;//最大容量
}SqStack;
```
![Pasted image 20250307121133|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307121133.png)
top指示真正栈顶元素之上的下标地址
stacksize表示栈的最大容量，共stacksize-1个元素
空栈：base== top
栈满：top-base== stacksize
下溢：栈空还要弹出元素，一般当作一种结束条件
上溢：是错误

3+2的前缀表达形式就是+ 3 2
3+2的后缀表达形式就是3 2 +
后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)

## 共享栈
两个栈共享一个数组空间的好处：存储空间，降低上溢出发生的机率。其存取数据的时间复杂度均为0(1)，所以对存取效率没有什么影响。
![Pasted image 20250307112107](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112107.png)
两个栈的栈顶指针都指向栈顶元素
top0=-1时0号栈为空，top1=Maxsize 时1号栈头空
仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满
当0号栈入栈时 top0 先加再赋值，1号栈入栈时 top1 先减1再赋值，出栈时则刚好相反![Untitled 2 47|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2047.png)

## 链栈
使用单链表实现，且所有操作都是在表头进行，没有头结点，Lhead指向栈顶元素
栈顶->栈底
![Pasted image 20250307112353](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112353.png)
```C
typedef struct {
	int data;
	struct LinkNode *next;
}*LinkNode,LiStack;
```
采用链式存储，便于结点的插入与删除
链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行
需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同
有多少种不同的出栈序列
卡特兰数：
![Screenshot_2023_1203_103148|90 ](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_1203_103148.png)
- **时间复杂度**
    - 链栈和顺序栈的进栈和出栈操作时间复杂度均为 O(1)
- **空间性能**：
    - 链栈不需要预先分配固定空间，但每个节点需要额外的指针域。
    - 顺序栈需要预先分配固定空间，可能导致内存浪费，但存取方便。
- **选择建议**
    - 如果栈的长度变化不可预料，建议使用链栈。
    - 如果栈的长度变化在可控范围内，建议使用顺序栈。

## 错题
1.![Pasted image 20250307112815](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112815.png)栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同
2. ![Pasted image 20250307112922](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112922.png)栈和队列都是限制存取点的线性结构
3. ![Pasted image 20250307113142](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113142.png)顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间
4. ![Pasted image 20250307113421](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113421.png)对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而循环单链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于选项C，插入和删除结点后，找尾结点所需的时间为 O(n)。
5. ![Pasted image 20250307114112](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114112.png)第n个元素第一个出栈，说明前n-1个元素都已经按顺序入栈d
6. ![Pasted image 20250307114354](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114354.png)d
7. ![Pasted image 20250307114611](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114611.png)p3=1第一个出栈，此时栈内有p1,p2;2第二个出栈，所以2只可能是p2或者p4,p5..;因此选C
8. 将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-* -g+时,用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空,则转换过程中同时保存在栈中的操作符的最大个数是() A. 5 B. 7 C. 8 D. 11
   在转换过程中，栈中的操作符最多有5个。这种情况出现在第二个“+”号入栈后，栈中的操作符分别为：“-”，“”，“(”，“(”，“+”。![Pasted image 20250307190631](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190631.png)
9. ![Pasted image 20250307190913](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190913.png)![Pasted image 20250307190923](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190923.png)
10.


# 队列FIFO
==头删尾插==
栈和队列是受限的线性表，它们的共同点是只允许在端点处插入和删除元素。
栈只允许在一端进行插入、删除操作
队列只允许在一端进行插入,在另一端进行删除
应用：缓冲区，层次遍历，CPU资源竞争，广度优先搜索BFS，消息队列
采用==尾指针==的循环单链表适合作为队列的存储结构
队列一般情况下需要修改队尾指针，但是当队列为空时需要同时修改头尾指针
最适合用作链式队列的链表是带有队头指针和队尾指针的非循环单链表
为了防止队列发生假溢出，应该使用循环队列

![Pasted image 20250307122136|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307122136.png)
```C++
typedef struct {
	 int data[MaxSize];
	 int front,rear;
}SqQueue;
```
初始时:Q.front=Q.rear=0。
入队操作：队不满时，先送值到队尾元素，再将队尾指针加1
出队操作：队不空时，先取队首元素值，再将队首指针加1
![Pasted image 20250307123048|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123048.png)
不能用 Q.rear== Maxsize 作为队列满的条件(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出””，但这种溢出并不是真正的溢出，在 data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。
## 循环队列
因为每次入队或者出队都是font或者rear向后移动一位,font指针无法往前移动,此时就会造成删除的空间无法使用，循环队列即可解决问题
把存储队列元素的表从逻辑上视为一个环,称为循环队列
当队首指针 Q.front=Maxsize-1后，再前进一个位置就自动到0，这可以利用除法取模运算(%)来实现。
初始时：Q.front=Q.rear=0。
队首指针进1：Q.front=(Q.front+1)%Maxsize。
队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。
队列长度：(Q.rear+Maxsize-Q.front)%Maxsize。
出入队时：指针都按顺时针方向进1
循环队列需要几个参数来确定?以及各个参数的含义？
需要2个参数,第一个参数是front,第二个参数是rear;
![Pasted image 20250307123713|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123713.png)
![Pasted image 20250307124944](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307124944.png)
队满条件：（Q.rear+1）%MaxSize== Q.front
队空条件：Q.front== Q.rear

## 链式队列
```C
typedef struct Qnode {
	QElemType data;
	struct Qnode* next;
}QNode,*QueuePtr;
```
不带头结点时，当Q.front== NULL且Q.rear== NULL 时，链式队列为空
插入r→next=s;s->next=NULL;r=s;
用链头作为队头



## 静态队列
基于数组实现的，如果是普通数组，规定front指向第一个元素的位置，rear指向最后一个元素位置的下一个位置
如果front指向第一个的前一个元素，rear就指向最后一个元素。
初始状态（队空条件）：Q->front == Q->rear == 0。
进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。
出队操作：队不空时，先取队头元素值，再将队头指针加1。

## 双端队列
允许两端都可以进行插入和删除操作的线性表
输入受限：一端插入删除，另一端删除
输出受限：一端插入删除，另一端插入

## 错题
1. ![Pasted image 20250307131237](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307131237.png)c
2. ![Pasted image 20250307171220](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307171220.png)循环队列中，每删除一个元素，队首指针 front=(front+1)%6，每插入一个元素，队尾指针 rear=(rear+1)%6。上述操作后，front=0，rear=3
3. ![Pasted image 20250307172039](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307172039.png)虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的入队和出队时间复杂度均为O(1)。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。
4. ![Pasted image 20250307175308](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175308.png)a
5. ![Pasted image 20250307174201](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174201.png)因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要 0(n)的时间。选项 B、C和D均可在 0(1)的时间内找到队首和队尾。
6. ![Pasted image 20250307174444](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174444.png)队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素,则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，修改队尾指针为rear=front。
7. ![Pasted image 20250307175540](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175540.png)![Pasted image 20250307175551](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175551.png)
8. ![Pasted image 20250307180416](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180416.png)![Pasted image 20250307180430](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180430.png)
9. ![Pasted image 20250307181119](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307181119.png)第一个元素进入队列后存储在A[0]处，此时 front 和 rear 值都为0。入队时因为要执行(rear+1)%n 操作，所以若入队后指针指向 0，则 rear 初值为 n-1，而因为第一个元素在A[0]中，插入操作只改变rear 指针，所以front为0不变
10. ![Pasted image 20250307182400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182400.png)利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得 R1，C入栈，计算得 R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D依次计算得栈深为 4、3、3。因此选择选项 B
11. ![Pasted image 20250307182639](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182639.png)![Pasted image 20250307182649](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182649.png)
12. ![Pasted image 20250307182804](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182804.png)b
13. ![Pasted image 20250307182833](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182833.png)c
14.

# 数组
线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。
特点：结构固定——定义后，维数和维界不再改变。
LOC(aij)=基地址+偏移量
数组偏移量基址
![Untitled 138|Untitled 138.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20138.png)
以行为例，地址=基地址+(i×n+j)×元素大小

三维数组：a mno
三维数组计算a ijk的公式为d=i* n* o+j* o+k，就是d高* 长* 宽+d长* 高+d宽

typedef elemtype array2【m】【n】;
等价
typedef elemtype array1[n];
typedef array1 array2[m];

## 压缩存储
为多个值相同的元只分配一个存储空间；对零元不分配空间。
**特殊矩阵的压缩存储**方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。目的：减少不必要的存储空间

一维数组a[i]的存放地址=起始地址+i* sizeof(ElemType)
存储目的：把一个**n维的数组定义为其数据元素为n-1维数组类型的一维数组**。
二维数组的存储结构：
==行优先存储==：定义二维数组 a：int a【4】【5】。由下图可知，对于行优先，a【2】【3】是第几个元素的求法为：行标2之前的行已填满元素，每行元素有5个，行标2所指的行的元素个数由列标指示出来，因此a【2】【3】是第2x5+3+1=14个元素，a【2】【3】之前有13个元素。
==列优先存储==：对于列优先，a【2】【3】是第几个元素的求法为：列标3之前的列已填满元素，每列元素有4个，列标3所指的列的元素个数由行标指示出来，因此a【2】【3】是第3x4+2+1=15个元素，a【2】【3】之前有14个元素。
![8ee2d0ea49804b7991042179b2c863fb](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/8ee2d0ea49804b7991042179b2c863fb.jpg)

按列
 LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))* L
按行
LOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))* L


## 特殊矩阵
矩阵下标默认从1开始
数组默认从0开始
## 对称矩阵
n阶方阵，aij=aji（1⩽i,j⩽n）
![Pasted image 20250308104031|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104031.png)存储策略：只存储主对角线+上/下三角区
元素个数为n(n+1)/2
n阶矩阵A可以用一维数组B== [n(n+1)/2]== 以行序为主序存储其下三角（包括对角线）中的元素，那么B[k]与aij之间存在一一对应关系：![Pasted image 20250308104132|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104132.png)

![c694632cf58d4933a61613c570a30ddb](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/c694632cf58d4933a61613c570a30ddb.jpg)

一般存下三角+主对角线，用等差数列，上三角i，j互换就可以

## 三角阵
存储方法与对称矩阵类似，使用n(n+1)/2+1个存储空间，其中最后一个空间用来存放常数c，在一维数组中的存储结果如下图：
![a588174886ae4654a8ae7fafcb71d526](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a588174886ae4654a8ae7fafcb71d526.jpg)
下三角：i<j时，有aij=0
上三角：i>j时，有aij=0 上三角为0
![Untitled 1 131|Untitled 1 131.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20131.png)
上三角矩阵的压缩存储公式
![Screenshot_2023_0815_075029|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0815_075029.png)

## 三对角矩阵
n(n>=3)阶三对角矩阵中的非零元素都集中在以主对角线为中心的带状区域中，其他区域均为零元，也即当|i-j|>1时，有aij=0。![Pasted image 20250308120026](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308120026.png)
- 对于 n×nn×n 的三对角矩阵：
    - 第 1 行和最后 1 行只有 2 个非零元素。
    - 中间的行有 3 个非零元素。
那么以行序将这些非零元素存储到一维数组B[3n-3]中，那么对应关系是：
k=2i+j−3（数组下标从0开始）
那么以行序将这些非零元素存储到一维数组B[3n-2]中，那么对应关系是：
k=2i+j−2（数组下标从1开始）
![89d0f9130782418894dfe03158fe2059](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/89d0f9130782418894dfe03158fe2059.jpg)

## 稀疏矩阵
0的个数比非零的多
稀疏矩阵进行压缩存储通常有两种方法:顺序存储(三元组)和链式存储(十字链表)
稀疏矩阵采用压缩存储后的缺点主要是==丧失随机存取的特性==

## 错题
1. ![Pasted image 20250308111917](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308111917.png)A[0][0] 存放在 B[0]
   对于第 i行，存储的元素为i0 i1 … ii
   第 i 行的元素个数为 i+1
   前 i 行的元素总数为：1+2+3+⋯+i=(i+1)i/2
2. 二维数组 A 按行优先存储，其中每个元素占1个存储单元。若 A11的存储地址为420，A33的存储地址为446，则A55的存储地址为()
   由行优先存储得到aij的地址地址=基地址+(i×n+j)×元素大小，得出基地址407，12列，故a55=472
3. ![Pasted image 20250308114043](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114043.png)k=2i+j- 2，195
4. ![Pasted image 20250308114656](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114656.png)![Pasted image 20250308114705](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114705.png)
5. ![Pasted image 20250308115002](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115002.png)![Pasted image 20250308115013](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115013.png)
6. ![Pasted image 20250308115654](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115654.png)总数=2+28×3+1=2+84=87或k=2i+j-3
7. ![Pasted image 20250308122246](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122246.png)a
8. ![Pasted image 20250308122545](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122545.png)按上三角存储，m7,2对应的是m2,7，在它之前有： 第1列：1 第2列：2 第6列：6 第7列：1 前面一共1+2+3+4+5+6+1个元素，共22个元素，数组下标从0开始，故下标为m2,7的数组下标为22。
9. ![Pasted image 20250308122839](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122839.png)![Pasted image 20250308123055](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308123055.png)
10. ![Pasted image 20250308124253|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308124253.png)按列优先次序存储，A[6,7]处于第7行第8列，前面有7列，每一列8x5个单元，再加上第8列前面的6个元素6x5，即7x8x5+6x5=310
11.

# 串
定义：是由零个或多个字符组成的有限序列
S=’a1a2a3……an’
编号默认从1开始
串值用单引号括起来
子串：串中任意个连续的字符组成的子序列
字符串的子串数目为n(n+1)/2 + 1
主串：包含子串的串
字符在主串中的位置：字符在串中的序号
子串在主串中的位置：子串的第一个字符在主串中的位置
例如，有串 A='china Beijing'，B='Beijing'，c='china'，则它们的长度分别头13、7 和 5。B 和C是A的子串，B在A中的位置是 7,c 在A中的位置是1。
串是一种特殊的线性表，数据元素之间呈线性关系。但线性表以单个元素为操作对象，而串以整体（子串）为操作对象。
## 串的存储结构
## 定长顺序存储
类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。
定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。
```C
typedef struct {
	char ch[MaxLen]; // 每个分量存储一个字符
	int length; // 串的实际长度
}SString;
```
## 堆分配存储表示
堆分配存储表示仍然以一组地址==连续==的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中==动态==分配得到的。
```C
typedef struct {
	char *ch; // 按串长分配存储区，ch指向串的基地址
	int length; // 串的长度
}HString;
```
## 块链存储表示
类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a)是结点大小为4(每个结点存放4个字符)的链表，最后一个结点占不满时通常用“#”补上;图 4.1(b)是结点大小为1的链表。![Pasted image 20250308125233|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308125233.png)
## 字符串的模式匹配
字符串的模式匹配是指在主串中找到与模式串相同的子串，并返回其所在位置。常见的模式匹配算法包括朴素模式匹配算法和KMP算法。
## **1. 朴素模式匹配算法**
**基本思想**
- 将主串中所有长度为  m  的子串依次与模式串对比，直到找到一个完全匹配的子串或所有子串都不匹配为止。
- 最多需要对比  n - m + 1  个子串。![Pasted image 20250308131814|250](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308131814.png)
**时间复杂度**
- 最坏情况下，时间复杂度为  O(nm) ，其中  n  是主串长度， m  是模式串长度。
```cpp
int Index(HString S, HString T, int pos) {
    int n, m, i;
    HString sub;
    InitString(sub);
    if (pos > 0) {
        n = StrLength(S);
        m = StrLength(T);
        i = pos;
        while (i <= n - m + 1) {
            SubString(sub, S, i, m);
            if (StrCompare(sub, T) != 0)
                i++;
            else
                return i;
        }
    }
    return 0;
}
```
**优化实现（直接通过数组下标）**
```cpp
int Index1(SString S, SString T, int pos) {
    int i, j;
    if (1 <= pos && pos <= S[0]) {
        i = pos;
        j = 1;
        while (i <= S[0] && j <= T[0]) {
            if (S[i] == T[j]) {
                i++;
                j++;
            } else {
                i = i - j + 2; // i 指向下一个子串的第一个位置
                j = 1;
            }
        }
        if (j > T[0]) // S 中存在 T
            return i - T[0];
        else
            return 0;
    } else {
        return 0;
    }
}
```
## **2. KMP算法**
**基本思想**
- 利用已经匹配过的模式串信息，避免主串指针回溯。
  - 特点是在模式匹配时，指示主串的指针不会变小
- 通过预处理模式串，生成 `next` 数组，记录模式串中每个位置的最长公共前后缀长度。

![Pasted image 20250308132051](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308132051.png)
**时间复杂度**
- 预处理 `next` 数组的时间复杂度为  O(m) 。
- 匹配过程的时间复杂度为  O(n) 。
- 总时间复杂度为  O(n + m) 。
**核心思想**
- 在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位j与主串位 i比较时，两个字符不相等，则i的位移方式是 `next[j]` ，而不是从头开始匹配。主串位指针i不变
- `next` 数组的定义：`next[j]` 表示模式串中前  j  个字符的最长公共前后缀长度。
```cpp
void getNext(SString T, int next[]) {
    int i = 1, j = 0;
    next[1] = 0;
    while (i < T[0]) {
        if (j == 0 || T[i] == T[j]) {
            i++;
            j++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}

int Index_KMP(SString S, SString T, int pos) {
    int i = pos, j = 1;
    int next[T[0] + 1];
    getNext(T, next);
    while (i <= S[0] && j <= T[0]) {
        if (j == 0 || S[i] == T[j]) {
            i++;
            j++;
        } else {
            j = next[j];
        }
    }
    if (j > T[0])
        return i - T[0];
    else
        return 0;
}
```
**`next` 数组的优化（`nextval` 数组）**
- 通过进一步优化 `next` 数组，减少不必要的比较。
- 当 `T[i] == T[j]` 时，`nextval[i] = nextval[j]`；否则，`nextval[i] = j`。
```cpp
void getNextval(SString T, int nextval[]) {
    int i = 1, j = 0;
    nextval[1] = 0;
    while (i < T[0]) {
        if (j == 0 || T[i] == T[j]) {
            i++;
            j++;
            if (T[i] != T[j])
                nextval[i] = j;
            else
                nextval[i] = nextval[j];
        } else {
            j = nextval[j];
        }
    }
}
```

| **特性**     | **朴素模式匹配算法** | **KMP算法**             |
| ---------- | ------------ | --------------------- |
| **时间复杂度**  |  O(nm)   |  O(n + m)         |
| **空间复杂度**  |  O(1)    |  O(m) （`next` 数组） |
| **主串指针回溯** | 需要回溯         | 不需要回溯                 |
| **适用场景**   | 模式串较短，主串较小   | 模式串较长，主串较大            |
- **朴素模式匹配算法**：实现简单，但效率较低，适合小规模数据。
- **KMP算法**：通过预处理模式串，避免主串指针回溯，适合大规模数据。
- **`nextval` 数组**：进一步优化 `next` 数组，减少不必要的比较。
## 模式串示例
![Pasted image 20250308141430](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308141430.png)
next：
1. 前两个0,1
2. 之后在当前索引前找两个正向的最大公共子串，next为第一个子串的下一个索引值，例如索引6，看1—5有aba公共子串，next6为4

nextval：
1. 第一个为0
2. 之后看对应的next值所对应的索引字母，例如索引为3的nextval，对应的next为1，对应的索引字母为a，索引3的字母也为a，nextval为索引为1的nextval；若不是同一个字母，nextval则为对应的next值，例如索引为6的对应next4的字母为b，6为a，不一样，nextval为当前next值4
T = "abacab"
next = [0, 1, 1, 0, 1, 2]
nextval = [0, 1, 0, 1, 0, 1]

ababaaababaa
next=`[011234223456]`

aaab
next=`[0123]`
nextval=`[0003]`

## 错题
1. ![Pasted image 20250308143227](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143227.png)![Pasted image 20250308143253](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143253.png)
2. ![Pasted image 20250308143322](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143322.png)![Pasted image 20250308144541](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308144541.png)
3. ![66d2e1adc05dd53c7bb762eebfa395b|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/66d2e1adc05dd53c7bb762eebfa395b.jpg)
4. ![Pasted image 20250308145836](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308145836.png)next`[0112342]` nextval`[0101042]` j-nextval`[6]`=2
5. ![Pasted image 20250308152637](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152637.png)a
6.  ![Pasted image 20250308151042](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308151042.png)由于i=j=5时失效，故主串和模式串的位序都是从0开始的。此时i=5，next`[j]`=next`[5]`=2，c![Pasted image 20250308152257|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152257.png)
7. ![Pasted image 20250308152151](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152151.png)b


# 二叉树
1. **树的定义**
   - **m叉树**：每个结点最多有 `m` 个子结点，可以为空树。
   - **树的度**：所有结点的度的最大值。
     - **度为m的树**：各结点的度的最大值
       至少有一个结点度=m
       至少有m+1个结点
   - **叶子结点**（终端结点）：没有子结点的结点。
   - **分支结点**（非终端结点）：至少有一个子结点的结点。
   - **根结点**：唯一没有前驱的结点，既可以是叶子结点（空树），也可以是分支结点。
2. **结点与度的关系**
   - **结点数 = 总度数 + 1**
     （每个结点被父结点指向一次，根结点无父结点）
   - **分支数 = 结点数 - 1 = 总度数**
     （每个分支对应一个子结点）
   - **节点度数关系** n0​=n2​+2n3​+…+(k−1)nk​+1
   - ## **总节点数与度数关系**
     对于完全二叉树或多叉树：
     n=1+n1+2n2+3n3（总分支数 + 根节点）
     n=n0+n1+n2+n3（总节点数）
     总度数=n-1=n1+2n2+3n3
3.**树的路径与高度**
   - **路径长度**：根到每个结点的路径长度之和。
   - **树的深度/深度**：根结点的层数（通常从 1 开始）。
## 树的性质
1. **结点数范围**
   - **高度为 `h` 的 m 叉树**：
     - **至少**有 `h` 个结点（每层仅 1 个结点）。
     - **至多**有 `(m^h - 1)/(m - 1)` 个结点（满 m 叉树）
       二叉树2^n-1个
   - **高度为 `h`、度为 `m` 的树**：至少 `h + m - 1` 个结点
   - 度为 m、具有 n个结点的树的最大高度h为n-m+1
   - 度为m的树中**第i层**上至多有**m^(i-1)个结点(i≥1)
2. **最小高度公式**
   - **具有 `n` 个结点的 m 叉树**的最小高度logm(n(m-1)+1)
3. **树的形态数**
   - `n` 个结点的二叉树共有 `C(2n, n)/(n+1)` 种不同形态（卡塔兰数）。
   - 例：3 个结点的二叉树有 5 种形态。
## 二叉树
1. **定义与性质**
   - **二叉树**：每个结点最多有 2 个子结点，且左右子树**有序**。
   - **度为2**的树至少有3个结点，而二叉树可以为空
   - **非空二叉树**的叶子结点数 `n0` 与二分支结点数 `n2` 的关系：n0=n2+1
   - **高度 H 的二叉树**：
    - 最多节点数：2k − 1（满二叉树）
    - 最少节点数：k（退化为链式结构）
     - 第i层至多有2^(i-1)个结点
2. **特殊二叉树**
   - **满二叉树**：
     - 高度 `h`，结点数 `2^h - 1`。
     - 只有最后一层有叶子结点，不存在度为 1 的结点。
   - **完全二叉树**：
     - 由满二叉树删除最底层最右侧连续若干结点形成。
     - **性质**：
       - 叶子结点只出现在**最后两层**。
       - 最多一个度为 1 的结点（左孩子），为最后一个分支结点，其结点编号为`[n/2]`，且n为偶数时，若为奇数，每个分支都有左右孩子
       - 编号为 `i` 的结点，左孩子为 `2i`，右孩子为 `2i + 1`。
       - 按层次编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点
       - i≤`[n/2]`（向下取整）为**分支结点**，i>`[n/2]`（向上取整）为**叶子结点**
       - 结点数为 `n` 时，叶子结点数 `n0 = ⌈n/2⌉`（向上取整）
       - 满二叉树一定是完全二叉树
       - 当结点数目一定时，具有最小深度的二叉树是完全二叉树
       - 最少节点数：2^(h−1)
       - 最多节点数：2^h − 1
       - 深度（高度）公式：  log2(n+1)向上取整 或 (log2n)+1向下取整
       - 度为0、1、2的节点关系：
         n0=n2+1n0​=n2​+1，且 n0+n2n0​+n2​ 必为奇数。
         - **偶数节点数 2k**：n1=1, n0=k, n2​=k−1
         - **奇数节点数 2k−1**：n1​=0,n0​=k, n2​=k−1
    - **偶数节点数**：编号最大的分支节点（编号 n/2）仅有左子女。
    - **奇数节点数**：所有分支节点均有左右子女。

## 二叉排序树（BST）
1. **定义**
   - 左子树所有结点值 < 根结点值 < 右子树所有结点值。
   - **中序**遍历结果为==有序==序列。
   - 左子树和右子树又各是一颗二叉排序树
   - 最左结点数值最小
   - 对于n个结点的二叉排序树，其最大高度值为n
   - 可用于元素的排序、搜索

2. **操作与性质**
   - **插入与查找**：
     - 平均时间复杂度 `O(log2n)`（平衡时）。
     - 最坏时间复杂度 `O(n)`（退化为链表）。
   - **删除操作**：
     - **叶子结点**：直接删除。
     - **单子树结点**：用子树替代被删结点。
     - **双子树结点**：用前驱（左子树最大结点）或后继（右子树最小结点）替代。

## 平衡二叉树（AVL 树）
   - 任意结点的左右子树高度差绝对值 ≤ 1【胖、多 搜索效率更高】
   - 查找时间复杂度稳定为 `O(log n)`。
   - **平衡因子** = 左子树深度 - 右子树深度，取值范围为 {-1, 0, 1}。
   - 若所有结点平衡因子为 0，则为**满二叉树**。
   - 平均查找长度为O(log2n)
   - - 最大深度：O(log⁡2n)O(log2​n)

**二叉树的构造**



**平衡调整操作**
- **最小不平衡子树**：只需调整最近失衡的子树，上层结点会自动平衡。
当插入或删除导致平衡因子超出范围时，需通过旋转调整树结构。调整分为四种情况：
1. **LL 型（右单旋转）**：
   - **触发条件**：新结点插入在左子树的左子树中。
   - **操作**：以失衡结点为轴，向右旋转。
   - **示例**：
     ```
          A (失衡)            B
         /                  /   \
        B        →        C       A
       /
      C
     ```

2. **RR 型（左单旋转）**：
   - **触发条件**：新结点插入在右子树的右子树中。
   - **操作**：以失衡结点为轴，向左旋转。
   - **示例**：
     ```
       A (失衡)                B
        \                   /   \
         B        →        A       C
          \
           C
     ```

3. **LR 型（先左旋后右旋）**：
   - **触发条件**：新结点插入在左子树的右子树中。
   - **操作**：先对左子树左旋（转为 LL 型），再对失衡结点右旋。
   - **示例**：
     ```
          A              A            C
         /              /           /   \
        B      →       C     →    B       A
         \            /
          C          B
     ```

4. **RL 型（先右旋后左旋）**：
   - **触发条件**：新结点插入在右子树的左子树中。
   - **操作**：先对右子树右旋（转为 RR 型），再对失衡结点左旋。
   - **示例**：
     ```
       A              A                C
        \              \             /   \
         B      →       C     →    A       B
        /                \
       C                  B
     ```
![Pasted image 20250311120615|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311120615.png)

从所插入结点的路径向上查找，找到违反平衡因子的根结点连续的三个结点，min-mid-max，再按二叉排序树的性质插入剩下的结点
![Pasted image 20250309124217|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309124217.png)
![Pasted image 20250311115540|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115540.png)
![Pasted image 20250311115547|250](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115547.png)
## B 树
1. **阶数 m**：节点最多有 m 棵子树（m>=3）
2. **节点子树数约束**：
   - 根节点：至少 2 棵子树（除非仅一个节点）。
   - 非根节点：至少`[m/2]`棵子树（如 m=5 ，至少 3 棵子树）
**叶子结点**：均位于同一层，不存储数据（或存储空指针）。
**关键字与子树关系**：
   - 关键字数 = 子树数 - 1。
   - 非叶节点有 j 棵子树时，含 j-1 个关键字。
**关键字规则**：
   - 所有关键字按升序排列。
   - 关键字将子树划分为区间，如结点含关键字  k1, k2 ，则子树范围为 ( -∞, k1), ( k1, k2) , ( k2, +-∞)。
1. **2-3树**：3阶B树，非叶节点有2或3棵子树。
2. **B+树**：支持顺序查找；B树支持多路查找。
   - **根结点**：至少 2 棵子树（除非树为空）。
**B 树的操作**
1. **插入**：
   - 若结点关键字数超过上限( m-1 ），需**分裂**：
     - 将中间关键字提升到父结点，左右部分形成新结点。
     - 若父结点也溢出，递归分裂直到根结点。

2. **删除**：
   - **非叶子结点删除**：用前驱或后继关键字替代。
   - **叶子结点删除**：
     - 若删除后关键字数 ≥`[m/2]`-1，直接删除。
     - 否则需向兄弟结点借关键字或合并结点。
### **B+ 树与 B 树的区别**
| **特性**         | **B 树**                          | **B+ 树**                        |
|------------------|----------------------------------|----------------------------------|
| **关键字存储**   | 所有结点均存储数据               | 仅叶子结点存储数据，非叶结点为索引 |
| **叶子结点链接** | 无                               | 叶子结点通过指针链接，支持顺序遍历 |
| **查询效率**     | 随机查询效率高                   | 范围查询和顺序遍历效率高          |
| **结构复杂度**   | 结点结构简单                     | 非叶结点仅存索引，结构更紧凑      |
- **AVL 树**：通过平衡因子和旋转操作维持平衡，适用于频繁查找的场景。
- **B 树**：多路平衡查找树，减少磁盘 I/O 次数，适合文件系统和数据库索引。
- **B+ 树**：在 B 树基础上优化范围查询，广泛应用于数据库和操作系统中。


## 二叉树的存储结构
## 顺序存储
1. **适用场景**：完全二叉树。
2. **原理**：
   - 通过数组下标直接计算父子关系（如父结点 `i` 的左孩子为 `2i`，右孩子为 `2i+1`）。
   - 若树非完全二叉树，需填充空结点以保证结构，导致内存浪费。
3. **优缺点**：
   - **优点**：快速定位父子结点，无需额外指针。
   - **缺点**：
     - 单支树（深度为 `k`）需数组长度为 `2^k - 1`（指数级内存消耗）。
     - 非完全二叉树存在大量空位。
   ```cpp
   typedef struct TreeNode {
       ElemType value;
       bool isEmpty;
   } t[MAXSIZE];
   ```

## 链式存储
**空链域数量**：
   - 在含 `n` 个结点的二叉链表中，共有 `n+1` 个空链域。
   - **推导**：
     - 每个结点有 2 个指针（左、右），总指针数为 `2n`。
     - 树的边数为 `n-1`（树的性质），即使用的指针数为 `n-1`。
     - 空链域数 = 总指针数 - 使用指针数 = `2n - (n-1) = n+1`。
   - **用途**：空链域可用于构造线索二叉树（标记前驱/后继）。
1. **二叉链表**：
   ```cpp
   typedef struct BiTNode {
       ElemType data;
       struct BiTNode *lchild, *rchild;
   } BiTNode, *BiTree;
   ```
   - **特点**：无法直接找到父结点，需从根遍历。
   - **空链域**：`n+1` 个（同前文推导）
![Untitled 1 132|Untitled 1 132.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20132.png)
 **三叉链表**：
 空链域：n+2个
   ```cpp
   typedef struct BiTNode {
       ElemType data;
       struct BiTNode *lchild, *rchild, *parent;
   } BiTNode, *BiTree;
   ```
   - **特点**：增加父结点指针，方便反向查找  ![Pasted image 20250309152923|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309152923.png)

## 二叉树的遍历
1. **遍历顺序**：
   - **先序遍历**：根 → 左 → 右
   - **中序遍历**：左 → 根 → 右
   - **后序遍历**：左 → 右 → 根
   - **层序遍历**：自上而下、从左到右逐层遍历。

2. **递归实现与栈的关系**：
   - 递归遍历的本质是隐式使用系统调用栈，空间复杂度为树高  O(h) 。
   - **前序序列与中序序列的关系**：
     - 前序序列相当于**入栈顺序**，中序序列相当于**出栈顺序**。
     - 例如：前序 `[A,B,C]` 和中序 `[B,A,C]`，可唯一确定一棵二叉树。

3. **层序遍历实现**：
   - ==**队列==辅助**：
     1. 根结点入队。
     2. 循环：出队结点访问，并将其左右孩子入队。
     ```cpp
     void LevelOrder(BiTree T) {
         Queue Q;
         InitQueue(Q);
         EnQueue(Q, T);
         while (!IsEmpty(Q)) {
             BiTNode* p;
             DeQueue(Q, p);
             visit(p);
             if (p->lchild) EnQueue(Q, p->lchild);
             if (p->rchild) EnQueue(Q, p->rchild);
         }
     }
     ```
   - **特点**：按层输出，适合求树的最小宽度或层次相关操作。

**遍历序列的唯一性**
1. **单一遍历序列无法唯一确定二叉树**：
   - 例如：前序 `[A,B]` 可对应两种结构（B为左孩子或右孩子）。
2. **唯一确定条件**：
   - **中序 + 前序/后序/层序**：可唯一还原二叉树。
   - **前序 + 后序**：仅当树是满二叉树时可唯一确定。
若只给出一棵二叉树的前/中/后/层 序遍历的一种，不能唯一确定一棵二叉树。
一定是由中+前/后/序
若有一个==叶结点==是二叉树中某个子树的==中序==遍历结果序列的最后一个结点，则它一定是该子树的==前序==遍历结果序列的最后一个结点
**前、中、后遍历序列中==叶子结点==的相对位置是不变的**
若一棵二叉树的中序序列和后序序列相同，则二叉树为空树或二叉树任一结点没有右子树；反之，前序和中序相同，左
若先序和后序相反，则高度=结点数
已知先/后序与中序：
x轴是中序，y轴是 先序 或 倒的后序
找最高点M，在M左侧找最高点L，右侧最高点R，连接，递归
如果先序遍历序列和层序遍历序列相同，则这个二叉树是一个单支树

## 线索二叉树
**线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。**
**由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在**==**遍历**==**的过程中修改空指针的过程。**
若无左子树，令lchild指向其前驱结点；
若无右子树，令rchild指向其后继结点。
左前驱，右后继
![v2-014d37e12cb6f8fa81143a1ae372f854_b|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/v2-014d37e12cb6f8fa81143a1ae372f854_b.png)
还需要增加两个标志语表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。
l
1. ltag== 0，指向左孩子；ltag== 1，指向前驱结点【指线索/指针/地址】
2. rtag== 0，指向右孩子；rtag== 1，指向后继结点
   ```cpp
   typedef struct ThreadNode {
       ElemType data;
       struct ThreadNode *lchild, *rchild;
       int ltag, rtag; // 0:孩子指针；1:线索
   } ThreadNode, *ThreadTree;
   ```
   - `ltag=1`：左指针指向前驱；`rtag=1`：右指针指向后继。
![10ae36162db147adb9e3662d9072f8dd](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/10ae36162db147adb9e3662d9072f8dd.png)
![Pasted image 20250310102313|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310102313.png)

有了这些前驱后继信息的好处是：在查找某个结点时就可以类似链表那样很方便的从表头遍历到表尾，并且空间复杂度只有 O ( 1 ) 。而前面二叉树的遍历中，无论递归还是非递归，都要用到栈，空间复杂度跟二叉树的具体形态有关。
二叉树在线索化后，仍不能有效求解的问题是==后序线索二叉树中求后序后继==

- **逻辑结构**：描述数据元素之间的抽象关系，如二叉树、链表、图等。
    - **二叉树**：一种分层结构，每个结点最多有两个子结点，用于表达数据间的层次关系，属于逻辑结构。
- **物理结构**：描述数据在计算机内存中的具体存储方式，如顺序存储（数组）、链式存储（指针）等。
    - **线索二叉树**：在链式存储的基础上，通过修改空指针为线索（前驱/后继），优化遍历效率，属于物理结构。

**后序线索二叉树无法有效求解后序后继的原因**
后序遍历的顺序为 **左→右→根**，根结点最后被访问。后序线索化的局限性体现在以下场景：
**场景 1：分支结点的左右子树均为叶结点**
假设结点 `A` 是父结点 `P` 的左孩子，且 `A` 的左右子树均为叶结点：
- **后序遍历顺序**：左叶 → 右叶 → `A` → `P` 的右子树 → `P` → ...
- **问题**：`A` 的后继应为 `P` 的右子树的最左下叶结点，但 `A` 的右指针可能直接指向 `P`（作为线索），无法跳转到 `P` 的右子树，导致无法直接找到正确后继。
**场景 2：根结点的右子树非空**
- **后序遍历顺序**：左子树 → 右子树 → 根结点。
- **问题**：根结点的右指针指向实际右子结点，而非线索化的后继（因为根结点是最后一个被访问的结点，没有后继）。
- **示例**：根结点 `R` 有右子树，遍历到 `R` 时，其右指针指向右子结点，而非空，无法通过线索直接确定后继。
**关键限制**
- **无法回溯父结点**：后序线索仅记录直接前驱/后继，但某些后继需要通过父结点的右子树路径确定。
- **依赖栈或父指针**：在非线索化遍历中，栈用于记录路径以回溯父结点；而线索化无法提供此信息，导致必须额外维护栈。

- 先序线索二叉树 ABDGECF
    ![Untitled 6 80|Untitled 6 80.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%206%2080.png)
    ![Untitled 7 76|Untitled 7 76.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2076.png)
- 中序线索二叉树
    ![Untitled 8 71|Untitled 8 71.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2071.png)
1. **中序线索树**：
   - 某结点有右孩子 → 其后继为右子树的最左下结点。
   - 某结点有左孩子 → 其前驱为左子树的最右下结点。
注意：
1. **限制**：
   - **后序线索二叉树**：无法高效求解后序后继（需栈支持）。
   - **前序/中序线索树**：可无栈遍历，时间复杂度 O(n)，空间复杂度O(1)
2. **线索化目的**：
   - 利用空链域（`n+1`个）记录前驱/后继，加速遍历。
   - **实质**：遍历时修改空指针为线索。

**应用场景**
1. **求树深度**：
   - 递归遍历左右子树深度，取最大值加1。
   ```cpp
   int Depth(BiTree T) {
       if (T == NULL) return 0;
       int left = Depth(T->lchild);
       int right = Depth(T->rchild);
       return max(left, right) + 1;
   }
   ```

2. **线索化优势**：
   - 遍历无需栈，空间复杂度优化为  O(1) 。
   - 适用于频繁遍历但插入/删除较少的场景。
3. **设计选择**：
   - 频繁查找前驱/后继 → 线索二叉树。
   - 频繁插入/删除 → 普通链式存储。
- 线索化本质是空间换时间，适用于遍历密集型操作。

## 树的存储结构
1. **双亲表示法**：
   - **原理**：每个结点存储数据及其父结点索引（根结点的父结点索引为空）。
   - **优点**：
     - 快速查找父结点（时间复杂度  O(1) ）。
     - 存储结构简单，仅需一个数组即可表示整棵树。
   - **缺点**：
     - 查找子结点需遍历整个表（时间复杂度  O(n) ）。
     - 插入或删除结点时需维护索引一致性，复杂度较高。
   - **适用场景**：频繁查找父结点且子结点操作较少的场景，如家谱关系管理。
![Pasted image 20250310130809|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310130809.png)
2. **孩子表示法**：
   - **原理**：每个结点存储数据及子结点链表的头指针。
   - **优点**：
     - 快速查找子结点（直接通过链表访问，时间复杂度  O(k) ， k  为子结点数）。
     - 适合动态增删子结点的场景。
   - **缺点**：
     - 查找父结点需从根结点遍历，效率低（时间复杂度  O(n) ）。
     - 存储空间较大（每个结点需额外维护链表指针）。
   - **适用场景**：需要频繁操作子结点（如文件系统目录树）。
![Pasted image 20250310131023](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310131023.png)
3. **二叉树表示法（孩子兄弟表示法）**：
   - **原理**：将普通树转换为二叉树，规则如下：
     - **左指针**指向第一个孩子结点（最左子结点）。
     - **右指针**指向当前结点的下一个兄弟结点。
   - **特点**：
     - 一个普通树转化成的二叉树一定没有右子树。
     - **森林转换**：先把森林转化为二叉树，再存储二叉树（如森林 {T1, T2}转换为 T1->T2）。
   - **优点**：
     - 统一使用二叉树结构，可复用二叉树的遍历、插入、删除等算法。
     - 节省存储空间（仅需两个指针）。
   - **缺点**：
     - 逻辑结构需通过指针关系间接理解，初次接触可能较难适应。
     - 遍历时需区分“孩子”与“兄弟”指针，逻辑稍复杂。
   - **适用场景**：需要利用二叉树算法处理一般树或森林的场景（如编译器语法树）。
  双亲表示法是顺序存储结构，孩子表示法和孩子兄弟表示法是链式存储结构


- **存储效率**：
  - 双亲表示法最节省空间，但功能单一；
  - 孩子兄弟表示法在空间和功能间取得平衡，适合通用场景。

- **操作效率**：
  - 若需频繁查找父结点，双亲表示法最优；
  - 若需频繁操作子结点，孩子表示法或双亲孩子表示法更优。

- **转换：
  - **树 → 二叉树**：  ![Pasted image 20250310160725|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310160725.png)
  - **森林 <-> 二叉树**：  ![Pasted image 20250310161030|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310161030.png)
    森林->二叉树，右子树非空（因为各树根节点通过右指针链接）
     二叉树->森林，若根节点有右子树，则右子树拆分成独立的树
     **森林与二叉树的转换**是唯一的，且右指针为空的数量与非终端结点数相关
     森林树的数量=森林结点数-边数
    **森林的非终端结点数 n → 二叉树右指针为空的结点数 n+1**：
    非终端节点指有子结点的节点（包括跟根节点）
    每个非终端结点对应一个右指针，最后一个兄弟右指针为空。
    **森林的叶结点数 = 二叉树左指针为空的结点数**
    原森林的叶结点在二叉树中无左孩子
    高度为h的满二叉树对应森林所含树的个数为h
- **树转二叉树**：无右子树。
- **森林转二叉树**：右子树存在（各树根通过右指针链接）。

## 树的遍历方式
## 树的先根遍历（深度优先遍历）
先访问树的根节点，然后依次先根遍历根的每棵子树。这种遍历方式和二叉树的先序遍历（先访问根节点，再访问左子树，最后访问右子树）类似。
![Untitled 234|Untitled 234.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20234.png)
## 树的后根遍历（深度优先遍历）
先依次后根遍历根的每棵子树，然后再访问根节点。这种遍历方式类似于二叉树的中序遍历（先访问左子树，再访问根节点，最后访问右子树） 。
![Untitled 1 135|Untitled 1 135.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20135.png)
## 树的层次遍历（广度优先遍历）
按照层次，从根节点开始，一层一层地访问节点，同一层的节点按照从左到右的顺序进行访问。
![Untitled 2 119|Untitled 2 119.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%20119.png)
## 森林的遍历方式
森林是由 m（m≥0）棵互不相交的树组成的集合。
## 森林的先序遍历
依次对森林中的各个树进行先根遍历，这等同于依次对与森林对应的二叉树进行先序遍历。具体过程是：先访问森林中第一棵树的根节点，然后先序遍历第一棵树的子树森林，接着先序遍历除去第一棵树之后剩余的树组成的森林。
## 森林的中序遍历
依次对森林中的各个树进行后根遍历，也就相当于依次对与森林对应的二叉树进行中序遍历。具体过程为：先中序遍历森林中第一棵树的子树森林，然后访问第一棵树的根节点，接着中序遍历除去第一棵树之后剩余的树组成的森林。
![Pasted image 20250310163959](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310163959.png)
关键结论 ：
- **顺序存储**适合完全二叉树，否则内存浪费严重。
- **线索二叉树**通过利用空链域优化遍历，但后序线索化无法完全消除栈依赖。
- **普通树转二叉树**后右子树为空（根无兄弟），森林转换则通过右指针链接各树根。
- **三叉链表**以空间换时间，支持父结点快速访问。

## 哈夫曼树和哈夫曼编码
是对数据压缩和编码长度的优化
1. **带权路径长度（WPL）**
   - **定义**：树中所有叶结点的带权路径长度之和。
   - **公式**：
    ![Pasted image 20250310172719|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310172719.png)![Pasted image 20250310173324|450](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173324.png)
    加权平均长度=带权路径长度/所有结点频次之和_
1. **哈夫曼树（最优二叉树）**
   - **目标**：构造 WPL 最小的二叉树。
   - **特点**：
     - 权值越小的叶结点离根越远，路径长度越大。
     - 构造过程中新建  n-1  个内部结点，总结点数为  2n-1 。
     - 不存在度为 1 的结点（n0=n2+1，已知n0叶结点可求n2双分支节点）
     - n个初始节点构造哈夫曼树共新建n-1个双分支结点，因此哈夫曼树的节点总数是2n-1，是奇数
     - 权值最小的两个结点互为兄弟。
     - 用一组权值构造出的哈夫曼树可能不唯一（左右子树不同），但带权路径长度唯一
![Pasted image 20250310173511|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173511.png)
1. **前缀编码**
   - **定义**：没有一个编码是另一个编码的前缀，保证解码唯一性【检查所有编码是否互不为前缀】
   - **实现方式**：通过哈夫曼树生成可变长度编码，左分支标记为 `0`，右分支标记为 `1`。
## 哈夫曼树构造步骤
1. **初始化**：将  n  个权值作为独立的单结点树。
2. **合并子树**：
   - 每次选择权值最小的两棵树合并，生成新结点作为其父结点，权值为子树权值之和。
   - 重复此过程直至只剩一棵树。
1. **贪心算法依据**：局部最优选择（合并最小权值树）保证全局最优（WPL 最小）。
![Pasted image 20250310173701|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173701.png)
## 应用场景与优势
1. **数据压缩**：
   - 对高频字符分配短编码，低频字符分配长编码，显著减少总编码长度。
2. **文件传输**：
   - 结合前缀编码，实现高效无损压缩（如 ZIP、JPEG 中的哈夫曼编码）。

1. **唯一性与最优性**：
   - 哈夫曼树不唯一（左右分支标记可互换），但所有哈夫曼树的 WPL 相同且最小。
2. **时间复杂度**：
   - 构造哈夫曼树： O(n \log n) （使用优先队列优化选择最小权值）。
   - 生成编码： O(n) 。

## 并查集
**并查集**是一种用于管理**不相交集合**的数据结构，支持以下两种核心操作：
1. **查询（Find）**：确定元素属于哪个集合（通常通过根节点标识）![Pasted image 20250311104951|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311104951.png)
2. **合并（Union）**：将两个集合合并为一个集合。
并查集的结构是一种==双亲表示法==存储的树

**应用场景**：
- 判断图的连通分支数（如判断森林中有几棵树）。
- 动态连通性问题（如网络节点是否可达）。
- Kruskal 算法中判断边是否会形成环。

**核心构成**
1. **数组 `parent[]`**：
   - 记录每个节点的父节点。
   - 根节点的父节点指向自身（即 `parent[root] = root`）。
2. **函数 `find(x)`**：
   - 查找节点 `x` 所属集合的根节点。
3. **函数 `union(x, y)`**：
   - 合并 `x` 和 `y` 所属的集合。

**基本实现与时间复杂度**
1. **未优化版本**：
   - **`find(x)`**：逐层向上查找根节点，最坏时间复杂度为  O(n) 。
   - **`union(x, y)`**：需要先调用 `find(x)` 和 `find(y)`，时间复杂度  O(n) 。
   ```python
   # 初始化：每个节点的父节点指向自己
   parent = list(range(n))

   def find(x):
       while parent[x] != x:
           x = parent[x]
       return x

   def union(x, y):
       root_x = find(x)
       root_y = find(y)
       if root_x != root_y:
           parent[root_y] = root_x
   ```

2. **优化目标**：
   - 通过**路径压缩**和**按秩合并**，将操作的时间复杂度优化至  O(\alpha(n)) ，其中α(n) 是阿克曼函数的反函数（实际应用中接近常数）。

**优化方法**
1. **按秩合并（Union by Rank）**：
   - **原理**：将小树合并到大树中，避免树高度过高。
   - **实现**：
     - 用 `rank[]` 数组记录每个根节点的树高（或节点数）。
     - 合并时，将小树的根节点指向大树的根节点。
   ```python
   rank = [1] * n

   def union(x, y):
       root_x = find(x)
       root_y = find(y)
       if root_x == root_y:
           return
       # 小树合并到大树
       if rank[root_x] > rank[root_y]:
           parent[root_y] = root_x
       else:
           parent[root_x] = root_y
           if rank[root_x] == rank[root_y]:
               rank[root_y] += 1
   ```
2. **路径压缩（Path Compression）**：
   - **原理**：在 `find(x)` 过程中，将路径上的所有节点直接指向根节点，缩短后续查找路径。
   - **实现**：
   ```python
   def find(x):
       if parent[x] != x:
           parent[x] = find(parent[x])  # 递归压缩路径
       return parent[x]
   ```

| 操作            | 未优化  | 按秩合并     | 按秩合并 + 路径压缩 |
| ------------- | ---- | -------- | ----------- |
| `find(x)`     | O(n) | O(log n) | O(α(n)）     |
| `union(x, y)` | O(n) | O(log n) | O(α(n)）     |

- **阿克曼函数 α(n) ：增长极慢，对任何实际输入的n（如n <= 10^80），α(n) <= 5。

**应用示例**
1. **连通分支数统计**：
   - 初始化每个节点为独立集合。
   - 遍历所有边，执行 `union(u, v)`。
   - 最终统计根节点数量即为连通分支数。

2. **Kruskal 算法**：
   - 按边权重排序后，依次选择边并检查是否连通（`find(u) == find(v)`）。
   - 若未连通，执行 `union(u, v)` 并加入生成树。

**常见问题**
1. **如何判断编码是否合法？**
   - **前缀编码冲突**：若某编码是另一编码的前缀，则无法唯一解码。
   - **哈夫曼编码性质**：通过构造哈夫曼树生成的编码天然为前缀编码，保证唯一性。

2. **为什么并查集适合动态连通性问题？**
   - 并查集支持高效的动态合并与查询操作，时间复杂度接近常数，适合处理大规模数据。

- **并查集的核心优化**：路径压缩 + 按秩合并，时间复杂度接近  O(1) 。
- **应用场景**：连通性问题、图论算法、动态等价类划分。

并查集：路径压缩 + 按秩合并 → 时间复杂度O(α(n))
应用：连通分支数统计、Kruskal 算法、动态连通性检测。




## 错题
1. **完全二叉树结点数计算**
   - 例：第 6 层有 8 个叶子结点，总结点数最多为 111，最少为 39。
   - **最多**：第6层有8个叶结点，说明第7层不存在。前5层满（25−1=31），第6层最多有2^5=32个节点，其中8个为叶结点，非叶节点为24个。总节点数：31+24×2+8=111。
   - **最少**：第6层的8个叶结点集中在左侧，第6层有8个节点（均为叶结点）。总节点数：前5层满（31） + 第6层8个 = 39。
2. **完全二叉树叶结点数**
   - 例：768 个结点的完全二叉树，叶结点数为 `384`（`n0 = ⌈768/2⌉`）。
3. **B 树关键字数范围**：
   - 对于 5 阶 B 树（ m=5 ）：
     - 非根结点关键字数： 2 \leq \text{关键字数} \leq 4 。
     - 根结点关键字数： 1 \leq \text{关键字数} \leq 4 。
4. **B 树高度与结点数关系**：
   - 含  n  个关键字的  m  阶 B 树，最小高度  h  满足：
     n <= (m-1)(1 + m + m^2 + … + m^(h-1)) = m^h - 1
   - 最大高度  h  满足：
     n >= 2(`[m/2]`^(h-1) - 1)
1. 设有一棵度为3的树，其中度为3的结点数n3=2，度为2的结点数n2=1，叶结点数n0=6，则该树的结点总数为() A. 12  B.9 C.10 D.>=9 的任意整数![Pasted image 20250311124831](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311124831.png)
2. ![Pasted image 20250309134338](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134338.png)![Pasted image 20250309134401](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134401.png)
3. ![Pasted image 20250309134836](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134836.png)若森林F有 15 条边、25 个结点，则下包含树的个数是( )。8/9/10/11
![Pasted image 20250309134844](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134844.png)
4. 二叉树为空意味着二叉树（）
   A.根结点没有子树 B.不存在 C.没有结点 D.由一些没有赋值的空结点构成
   二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图(图中不能没有结点)
5. 设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为( )。 A. h B. 2h-1 C. 2h+1 D. h+1![Pasted image 20250309142623](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309142623.png)
6. 具有n个结点且高度为n的二叉树的数目为()。A. log2n B. n/2 C. n D. 2^n-1
   d
7. 设二叉树有 2n个结点，且m<n，则不可能存在()的结点
   A. n 个度为 0  B. 2m 个度为 0  C.2m 个度为1  D.2m 个度为2
   叶子结点数 n0=n2+1，总结点数：n0+n1+n2=2n。带入A对；B是n0=2m，得4m-1+n1=2n，当m=1,n=2,n1=1符合；C是n1=2m，得n2=(2n-2m-1)/2，矛盾不存在；D是n2=2m，得4m+1+n1=2n，当m=1,n=3，符合
8. ![Pasted image 20250309150857](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309150857.png)若一棵二叉树有 126 个结点，在第7层(根结点在第1层)至多有( )个结点。
   A. 32 B.64 C.63 D.不存在第7层
   要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有 127 个结点，126 仅比 127 少1个结点，只能少在第7层，所以第7层最多有 2^6-1=63 个结点。
9. 一棵有 124 个叶结点的完全二叉树，最多有()个结点。
   A. 247 B. 248 C.249 D.250
  124<2^7=128，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120 个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1 个左孩子(不改变叶结点数)，因此结点总数=2^7-1+120+1=248。
   也可以用总结点数为偶数2k，n1=1, n0=k, n2​=k−1，k=124，求出
10. 某完全二叉树T中，结点个数最大的层有8个结点，则T中至多有()个结点。
    A. 8  B.15  C.23  D. 31
    在完全二叉树中，第4层刚好最多有8个结点(前4层对应高度为4的满二叉树)，若第5层也有8个结点，则对应于结点个数最多的情况，此时树高为5，总结点数为15+8=23。
11. ![Pasted image 20250309153206](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153206.png)I正确；II若该结点非根结点，其双亲指针还会指向父结点，共 三个指针。但根结点度为 2 时，无双亲指针，仅被两个孩子指向，只有两个指针；IIIn=1（无双亲根节点） 时，唯一结点是叶结点且无指针指向
12. ![Pasted image 20250309153328](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153328.png)![Pasted image 20250309153335](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153335.png)
13. ![Pasted image 20250309154115](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309154115.png)**奇数节点数 2k−1**：n1​=0,n0​=k, n2​=k−1
14. 对于任意一棵高度为5且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元(仅存放结点的数据信息)，则存放该二叉树需要的存储单元数量至少是()。A.31 B. 16 C.15 D.10
    即使实际只有10个结点，存储时仍需覆盖所有可能的位置，以确保父结点与子结点的位置关系可通过下标直接计算。因此，存储单元数量至少为2^5-1=31
15. 设n,m 为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D.n是m子孙
    c
16. 设n,m 为一棵二叉树上的两个结点，在后序遍历时，n在m前的充分条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D. n是m 子孙
    d
17. 对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用( )次序的遍历实现编号 A.先序 B.中序 C.后序 D.层次
    c
18. 一棵二叉树的先序遍历序列为 1234567，它的中序遍历序列可能是()。
    A. 3124567 B. 1234567 C.4135627 D.1463572
    b
19. 某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用()遍历方法最合适。A. 中序 B.层次 C.后序 D.先序
    删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。
20. 某二叉树T采用二叉链表存储结构，T的中序遍历序列为一个升序序列，要求采用某种方法对 T进行某种操作之后得到一棵新的二叉树T,要求 T"的中序遍历序列为一个降序序列，则下列关于该算法的叙述中，正确的是()
    A. 采用中序遍历的方法最合适 B. 采用后序遍历的方法最合透
    C.T中的根结点还是原T中的根结点 D. T中的叶结点不一定是原T中的叶结点
    选项 B（采用后序遍历的方法最合适）
    - 后序遍历（左→右→根）允许先递归处理左右子树，再交换当前结点的左右子树。这种顺序确保子树已完全处理后再调整父结点的结构，避免逻辑混乱。通过后序遍历交换所有分支结点的左右子树，最终中序遍历序列自然逆序为降序。因此，后序遍历是最合适的方法。
    选项 C（T'中的根结点还是原T中的根结点）
    - 镜像翻转操作仅交换分支结点的左右子树，不会改变根结点的位置或值。因此，根结点保持不变，选项 C 正确。
    选项 D（T'中的叶结点不一定是原T中的叶结点）
    - 叶结点没有左右子树，交换操作对其无影响，原叶结点在 T' 中仍为叶结点（仅位置可能变化）。因此，选项 D 错误
21. 一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是()。
    A. 不确定  B.0个  C.1个 D.2 个
    根结点的左指针：1 个空链域，最右侧叶结点的右指针：1 个空链域，所以线索化后，树中空链域有2个。
22. 某二叉树的先序序列和后序序列正好相反，则该二叉树一定是()。
    A.空或只有一个结点           B.高度等于其结点数
    C.任意一个结点无左孩子   D.任意一个结点无右孩子
    最多只有一个子结点，即树退化为单链结构（如所有结点只有右孩子或只有左孩子）此时，树的高度等于结点数 h=n，b。C或D属于选项 B 的子集
23. ![Pasted image 20250310122100](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310122100.png)d
24. 若一棵二叉树的前序遍历序列为 a,e,b,d,c，后序遍历序列为 b,c,d,e,a，则根结点的孩子结点()。A.只有e  B.有e、b  C.有e、c  D.无法确定
    根 `a` 的唯一孩子是左孩子 `e`
25. 先序序列为 a,b,c,d的不同二叉树的个数是( )。13/14/15/16
    (C4 8)/ 5 = 14
26. 利用二叉链表存储森林时，根结点的右指针是()。
    A. 指向最左兄弟 B.指向最右兄弟 C.一定为空 D.不一定为空
    森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。
27. 设森林F中有3棵树，第 1、2、3 棵树的结点个数分别为 M1,M2和M3，与森林F对应的二叉树根结点的右子树上的结点个数是()
    A. M1 B.M1+M2 C.M3 D.M2+M3
    d
28. 设森林 F中有 4棵树，第 1、2、3、4 棵树的结点数分别为 a、b、c和 d，与森林F对应的二叉树的根结点的左子树上的结点数是()
    A. a  B. b+c+d  C.a-1  D. a+b+c
    c
29. 设森林F对应的二叉树是一棵具有 16 个结点的完全二叉树，则森林F中树的数目和结点最多的树的结点数分别是() A. 2和8  B.2和9  C.4和8  D. 4和9![Pasted image 20250310165243|250](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310165243.png)
30. 设X是树T中的一个非根结点，B是T所对应的二叉树。在B中，X是其双亲结点的右孩子，下列结论中正确的是()。
    A.在树T中，X是其双亲结点的第一个孩子
    B.在树T中，X一定无右边兄弟
    C.在树T中，X一定是叶结点
    D.在树T中，X一定有左边兄弟在二叉树
    B中，X是其双亲的右孩子，因此在树T中，X必是其双亲结点的右兄弟，换句话说，X在树中必有左兄弟。
31. ![Pasted image 20250310170049](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310170049.png)A. 双亲表示法中，每个非根结点有一个指向双亲的指针。若树有 n个结点，则双亲指针数为 n−1，正确；B对；C. O(n)；D对
32. 已知一棵有 2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点个数是()。 A. 115  B. 116  C. 1895 D.1896
33. 下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是
    A. 24,10,5 和 24,10,7      B. 24,10,5 和 24,12,7
    C. 24,10,10 和 24,14,11  D. 24,10,5 和 24,14,6
34. 根据使用频率为5个字符设计的哈夫曼编码不可能是()
    A. 000,001,010,011,1   B.0000,0001,001,01,1
    C. 000,001,01,10,11     D. 00,100,101,110,111
    D构造出来有度为1的结点，不对
35. 设哈夫曼编码的长度不超过 4，若已对两个字符编码为1和 01，则还最多可对( )个字符编码。
    根据前缀编码规则，得到新编码必须以00开头，且总长度<=4，0000，0001，0010，0011，共四个
36. 一棵哈夫曼树共有 215 个结点，对其进行哈夫曼编码，共能得到( )个不同的码字。A. 107   B. 108  C.214   D. 215
    树有 `n` 个叶子结点，则总结点数为 `2n - 1`，得到n=108
37. 并查集中最核心的两个操作是:查找，查找两个元素是否属于同一个集合;合并，若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为 10(0~9)的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9 的顺序进行查找和合并操作，最终并查集共有( )个集合。A. 1 B.2 C.3D.4
    初始时，0~9各自成一个集合。查找 1-2 时，合并{1}和{2};查找 3-4 时，合并{3}和{4};查找 5-6 时，合并(5}和(6};査找 7-8时，合并{7}和{8}:查找 8-9 时，合并{7,8,和{9};查找1-8 时，合并(1,2和{7,8,9}:查找 0-5 时，合并(0}和{5,6}:查找 1-9 时，它们属于同一个集合。最终的集合为10,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项 C。
38. 下列关于大根堆(至少含2个元素)的叙述中正确的是
    I. 可以将堆看成一棵完全二叉树      II. 可采用顺序存储方式保存堆
    III. 可以将堆看成一棵二叉排序树    IV. 堆中的次大值一定在根的下一层
    A. 仅1、II      B. 仅1、III       C. 仅I、II、IV        D. 仅I、II、IV
    c
39. 已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二又树中无右孩子的结点的个数是() A. 115    B. 116    C. 1895    D. 1896
    非叶子结点=1895，数转换成的二叉树没有右孩子，原树中每个非叶结点对应一个无右孩子的结点，无右孩子结点数为1895，根节点也无右孩子+1，1896
40. 有n(n>0)个分支结点的满二叉树的深度是
    A. n^2-1    B. log2(n+1)+1    C. log2(n+1)     D. log2(n-1)
    满二叉树的结点总数 N 与深度 h的关系为:N=2^h -1
    分支结点数 n 与叶子结点数L的关系为:n=L-1
    对于满二叉树，叶子结点数  L=2^(h-1)，因此:n=2^(h-1)-1
    可得:h=log2(n+1)+1
41. 若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的分支结点的个数是()![Pasted image 20250311115823|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115823.png)3
42. 一个关键字序列为{50，20，60，30，35}，依次构造平衡二叉树，当插入25后引起不平衡，则应进行的平衡旋转是()型旋转 LL?![Pasted image 20250311123317](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123317.png)
43. 对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是
    A. 92，20，91，34，88，35              B. 95，22，91，24，94，71
    C. 21，89，77，29，36，38              D. 12，25，71，68，33，34
    由二叉排序树的性质可知，一个数后面的数字都要全部大于或全部小于它 b选项的91后面既有小于它的数，也有大于它的数
44. ![Pasted image 20250311123606](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123606.png)
45. 设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平3.在平衡二叉树中插入一个结点后造成了不平衡，因子为1，则应作()型调整以使其平衡。 A.LL B. LR C.RL D.RR![Pasted image 20250311130434](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311130434.png)c
46.


# 图
![Pasted image 20250311143034|450](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311143034.png)由顶点集  V （非空）和边集  E  组成，记为G = (V, E)
  - **注意**：线性表、树可以为空，但图不能为空（V ≠ ∅）
## 无向图与有向图
1. **无向图**：
   - **边（Edge）**：无序对 (v, w) = (w, v)
   - **度数性质**：所有顶点的度数之和= 2 × |E|（必为偶数）

2. **有向图**：
   - **弧（Arc）**：有序对  <v, w>≠ <w, v> 。
   - **度数性质**：
     - 入度：指向该顶点的边数。
     - 出度：从该顶点出发的边数。
- 稀疏图：顶点很多而边很少的图
- 稠密图：顶点多边也多的图

## 图的分类
1. **简单图**：
   - 无重复边，无自环（顶点到自身的边）。
2. **多重图**：
   - 允许两点间有多条边（适用于交通网络等场景）。
3. **完全图**（也称简单完全图）： 对于给定的一组顶点，顶点间都存在边
   - **无向完全图**：任意两顶点间均有边，边数=n(n-1)/2
   - **有向完全图**：任意两顶点间有两条方向相反的弧，弧数= n(n-1)
4. 生成子图：点都有
5. **极大连通分量**：子图连通，且包含尽可能多的顶点和边
   **极大连通子图**：要求子图必须连通，而且包含尽可能多的顶点和边
   **极小连通子图**：既要保持子图连通又要使得边数最少的子图
   **连通分量**：==无向==图中的**极大连通子图**
   **强连通分量**：==有向==图中的极大连通分量（在有向图中考虑强连通性）
6. 无向==连通图==的==生成树==：是包含**全部顶点**的一个**极小连通子图** n-1条边
   ==非连通==的==生成森林==：非连通图分解的多个连通分量，多个连通分量对应的多棵生成树
7. 有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。
8. ==完全图一定是连通图，但连通图不一定是完全图==
## 连通性与路径
1. **无向图的连通性**：
   - **连通图**：任意两顶点间存在路径，最少边数 = n-1（树结构）。
   - **非连通图**：最多边数=(n-1)(n-2)/2（一个孤立顶点，其余构成完全图）。

2. **有向图的连通性**：
   - **强连通图**：任意两顶点间双向可达，最少弧数=n（环形结构）。
   - **弱连通图**：忽略方向后为连通无向图。

3. **路径与环**：
   - **简单路径**：顶点不重复出现，最多 n 个顶点，n-1 条边。
   - **回路（环）**：起点与终点相同的路径。
   - 若一个图有n个顶点，且有大于n-1条边，此图一定有**环**



## 生成树与生成森林
1. **生成树**：
   - **定义**：无向连通图的极小==连通==子图，包含所有顶点和n-1条边。
   - **性质**：
     - 删除任意一条边会破坏连通性。
     - 添加任意一条边会形成回路。
**生成树 G′** 是图 G 的一个子图，满足以下条件：
1. **连通性**：G′ 是连通的。
2. **无环性**：G′ 是无环的。
3. **极小性**：G′ 是 GG 的极小连通子图（删除任意一条边会破坏连通性）。
4. **顶点集**：G′ 包含 GG 的所有顶点（V′=V）。
5. **生成森林**：
   - **定义**：非连通图的多个连通分量对应的生成树的集合。

### 关键公式与结论
- 对于n个顶点的**无向图G**
  - 若G是==连通==图，>= ==n-1==条边（树），若|E|>n-1，则一定有**回路**。
  - 保证G在**任何**情况下均连通的最少边数:(n-1)(n-2)/2+1
  - 若G是==非连通==图，<= ==C2 n − 1==条边【即(n-1)(n-2)/2】，若超过此值，图必**连通**
  - 无向完全图共有C2 n条边【即n(n-1)/2】
- 对于n个顶点的**有向图G**
  - 若G是==强连通==图，>= ==n==条边（形成简单回路）
  - ==有向完全==图共有==2C2 n== 条边【即n(n-1)】
- 求有向图的强连通分量
  - 找入度或出度为0的顶点
  - 依次删掉这些顶点以及相连的弧，直到没有存在入度或出度为0的顶点、
  - 删掉的顶点以及剩下的有向图，就是强连通分量![Pasted image 20250311164300|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311164300.png)
- **顶点度数**：
  - 无向图顶点最大度数 = n-1
  - 有向图顶点最大度（入度 + 出度） = 2(n-1)

### 算法与应用
1. **判断回路**：
   - **有向图**：拓扑排序、深度优先遍历（DFS）检测环。
   - **无向图**：并查集或DFS检测环。

2. **连通分量**：
   - **无向图**：广度优先遍历（BFS）或DFS求所有连通分量。
   - **有向图**：Kosaraju算法求强连通分量。

3. **最小生成树**：
   - **Kruskal算法**：按边权升序选择，避免成环。
   - **Prim算法**：从顶点出发逐步扩展最小边。

- **完全图边数**：
  - 无向完全图边数  n(n-1)/2，有向完全图弧数n(n-1)
- **邻接表结点数**：
  - 无向图邻接表结点总数  2|E| ，有向图邻接表结点总数  |E| 。

##  图的存储结构
### 邻接矩阵（数组、顺序存储）
   - 用 n×n 矩阵表示顶点间关系，适用于稠密图。
![Pasted image 20250311142927|500](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311142927.jpg)
无向图邻接矩阵：
1. 无向图的邻接矩阵一定是一个**对称矩阵**。 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。
2. 对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个顶点的度
3. 求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍， `A[i][j]`为 1就是邻接点。
4. 无向图非零元素至少有2 * 边数个
5. 在含有 n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为n^2 - 2e
6.

有向图邻接矩阵：
1. 主对角线上数值依然为0，但矩阵并不对称。
2. 有向图入度是一列和，出度是一行和==（出行入列）==
3. 与无向图同样的办法，判断顶点vi​到vj​是否存在弧，只需要查找矩阵中`A[i][j]`是否为1即可。

邻接矩阵的 存储结构：
``` C
#define MaxVertexNum 100	//顶点数目的最大值
typedef char VertexType;	//顶点的数据类型
typedef int EdgeType;	//带权图中边上权值的数据类型
typedef struct{
	VertexType Vex[MaxVertexNum];	//顶点表
	EdgeType Edge[MaxVertexNum][MaxVertexNum];	//邻接矩阵，边表
	int vexnum, arcnum;	//图的当前顶点数和弧树
}MGraph;
```
- 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。
- 当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。
- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。
- 邻接矩阵表示法的空间复杂度为O(n^2)， 其中n为图的顶点数|V|
- 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。
- ==稠密图==适合使用邻接矩阵的存储表示。
- `A^n[i][j]`表示从顶点 i 到 j 的长度为 n 的路径数目
  ![Pasted image 20250312110923|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312110923.png)

### 邻接表（顺序+链式）
   结合顺序+链序存储，不唯一
   对于==稀疏图==，采用邻接表表示将极大地节省存储空间
![Pasted image 20250311145242|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311145242.png)
   - **无向图**：每个顶点的邻接表存储其邻接顶点，总边结点数为 2|E|，所需的存储空间为==O(|V|+2|E|)==
   - **有向图**：邻接表存储出边，逆邻接表存储入边，总边结点数为 |E|，所需的存储空间为 ==O(|V|+|E|)==
   有向图邻接表的总结点个数 = 表头结点数（顶点数 ∣V∣） + 表结点数（边数 ∣E∣）

| 操作            | 邻接表    | 邻接矩阵  |
| ------------- | ------ | ----- |
| **查找邻边**      | O(1)   | O(n)  |
| **判断边是否存在**   | O(d)   | O(1)  |
| **计算出度（有向图）** | O(1)   | O(n)  |
| **计算入度（有向图）** | O(n+e) | O(n)  |
| **空间复杂度**     | O(n+e) | O(n2) |
- **邻接表**：
    - 适合稀疏图（边数远小于 n^2）。
    - 需要频繁查找邻边的场景（如DFS/BFS遍历）。
- **邻接矩阵**：
    - 适合稠密图（边数接近 n^2）。
    - 需要频繁判断边是否存在的场景（如最短路径算法）

### 十字链表（有向图）

![Untitled 9 69|Untitled 9 69.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2069.png)

![Screenshot_2023_0824_165443](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0824_165443.png)

顶点节点表三个格子，边节点表四个格子
弧节点表：
第一个格子是当前节点的索引
第二个格子是箭头所指节点的索引
第三个格子先空着，前两个格子全部写完，再由节点表的第二个格子指向与弧节点表的第二个格子索引值一样的弧节点的第三个格子，弧节点表的第三个格子依次指向下一个索引值一样的边节点，后面没有了写”空“
第四个格子是当前行的最后一个弧界点就写“空”
![Pasted image 20250312111806|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312111806.png)
在十字链表中，既容易找到Vi为尾的弧，也容易找到Vi为头的弧，因而容易求得顶点的出度和入度
图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。

### 邻接多重表（无向图）
![Untitled 10 65|Untitled 10 65.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2065.png)
顶点节点两个格子，弧节点四个格子
弧节点：
第一个格子是当前节点的索引
第三个格子是箭头所指节点的索引（连完之后把线叉掉）
两两节点一起，顶点节点空格指向所有弧节点中一/三节点索引一样的二/四空格，直到没有写“空 ”
![Pasted image 20250312113325|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312113325.png)

空间复杂度O(|V|+|E|)
删除边、结点方便

| 特性     | 邻接矩阵                      | 邻接表                                        | 十字链表             | 邻接多重表            |
| ------ | ------------------------- | ------------------------------------------ | ---------------- | ---------------- |
| 空间复杂度  | O(\|V\|^2)                | 无向图：O(\|V\| + 2\|E\|) 有向图：O(\|V\| + \|E\|) | O(\|V\| + \|E\|) | O(\|V\| + \|E\|) |
| 找相邻边   | 遍历对应行或列，时间复杂度O(\|V\|) | 找有向图的入边需遍历整个邻接表                            | 很方便              | 很方便              |
| 删除边或顶点 | 删边方便，删顶点需大量移动数据           | 无向图中删边或顶点都不方便                              | 很方便              | 很方便              |
| 适用于    | 稠密图                       | 稀疏图和其他                                     | 只能存有向图           | 只能存无向图           |
| 表示方式   | 唯一                        | 不唯一                                        | 不唯一              | 不唯一              |

| 图类型     | 存储结构  | 操作类型         | 时间复杂度说明                                   |
| ------- | ----- | ------------ | ----------------------------------------- |
| **无向图** | 邻接矩阵  | 查找相邻边        | 遍历对应行 / 列，时间复杂度 O(\|V\|)（\|V\|为顶点数）       |
|         |       | 删除边          | 直接修改矩阵元素，时间复杂度 O(1)                       |
|         |       | 计算顶点的度       | 统计对应行 / 列非零元素个数，时间复杂度 O(\|V\|)            |
|         | 邻接表   | 查找相邻边        | 遍历顶点对应链表，时间复杂度 O(d)（d为顶点度）                |
|         |       | 删除边          | 需遍历链表找到对应边结点，时间复杂度 O(d)                   |
|         |       | 计算顶点的度       | 统计顶点对应链表的结点数，时间复杂度 O(d)                   |
|         | 邻接多重表 | 查找相邻边        | 通过指针直接定位关联边，时间复杂度 O(1)（理想情况，实际与存储组织相关）    |
|         |       | 删除边          | 标记或移除边结点，时间复杂度 O(1)（需提前定位边，定位时间另计）        |
|         |       | 计算顶点的度       | 统计顶点关联的边结点数，时间复杂度 O(d)                    |
| **有向图** | 邻接矩阵  | 查找出边         | 遍历对应行，时间复杂度 O(\|V\|)                      |
|         |       | 查找入边         | 遍历对应列，时间复杂度 O(\|V\|)                      |
|         |       | 删除边（出边 / 入边） | 直接修改矩阵元素，时间复杂度 O(1)                       |
|         |       | 计算出度         | 统计对应行非零元素个数，时间复杂度 O(\|V\|)                |
|         |       | 计算入度         | 统计对应列非零元素个数，时间复杂度 O(\|V\|)                |
|         | 邻接表   | 查找出边         | 遍历顶点对应链表，时间复杂度 O(d出)（d出为出度）               |
|         |       | 查找入边         | 需遍历全表，时间复杂度 O(\|V\| + \|E\|)（\|E\|为边数）    |
|         |       | 删除出边         | 遍历链表找到对应边结点，时间复杂度 O(d出)                   |
|         |       | 计算出度         | 统计顶点对应链表的结点数，时间复杂度 O(d出)                  |
|         |       | 计算入度         | 需遍历全表统计，时间复杂度 O(\|V\| + \|E\|)            |
|         | 十字链表  | 查找出边 / 入边    | 通过结点指针直接定位，时间复杂度 O(1)（理想情况，实际与存储组织相关）     |
|         |       | 删除边（出边 / 入边） | 调整指针关系，时间复杂度 O(1)（需提前定位边，定位时间另计）          |
|         |       | 计算出度 / 入度    | 直接读取结点记录的出度 / 入度值（十字链表可存储度数信息），时间复杂度 O(1) |

稀疏矩阵用三元组：(x,y,z):(行，列，非零值）的顺序表；十字链表（有向图）存储

## 图的遍历
### 深度优先遍历（DFS）
1. **核心思想**：
   - 类似树的**先序遍历**，沿着一条路径尽可能深入探索，直到无法继续时回溯。
   - ==递归==或显式使用==栈==实现。

2. **特点**：
   - **树高较大**：DFS 的递归深度或栈深度可能接近图的顶点数（如单链结构）。
   - **空间复杂度**：最坏情况下为O(|V|) ，由递归栈深度或显式栈大小决定。

3. **时间复杂度**：
   - **邻接矩阵**： O(|V|^2) 。
     - 每个顶点需遍历所有其他顶点以查找邻接点。
   - **邻接表**： O(|V| + |E|) 。
     - 仅遍历实际存在的边。

4. **适用场景**：
   - **稠密图**（邻接矩阵效率更高）。
   - **拓扑排序**、**强连通分量**（如 Tarjan 算法）。
### 广度优先遍历（BFS）
1. **核心思想**：
   - 类似树的**层序遍历**，逐层访问顶点。
   - 使用==队列==作为辅助数据结构，**每个顶点仅入队一次**。

2. **特点**：
   - **最短路径**：BFS 天然适合求解无权图的最短路径问题。
   - **连通分量**：通过 BFS 可遍历一个连通分量中的所有顶点。

3. **时间复杂度**：
   - **邻接矩阵**： O(|V|^2) 。
   - **邻接表**： O(|V| + |E|) 。

4. **适用场景**：
   - **稀疏图**（邻接表更高效）。
   - **社交网络分析**（如六度分隔理论）。

#### **生成树与生成森林**
1. **广度优先生成树**：
   - **邻接表不唯一性**：邻接表中顶点的邻接顺序不固定，导致生成树结构可能不同。
   - **邻接矩阵唯一性**：邻接矩阵的邻接顺序固定（按顶点编号），生成树唯一。

2. **广度优先生成森林**：
   - 针对非连通图，每个连通分量生成一棵广度优先生成树。

| 特性    | DFS                          | BFS                          |
| ----- | ---------------------------- | ---------------------------- |
| 遍历方式  | 深度优先（单路径深入）                  | 广度优先（逐层扩展）                   |
| 数据结构  | 栈（递归或显式栈）                    | 队列                           |
| 空间复杂度 | O(∣V∣)（最坏情况）                 | O(∣V∣)（队列存储顶点）               |
| 时间复杂度 | 邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣) | 邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣) |
| 应用场景  | 拓扑排序、路径存在性检测                 | 最短路径、连通分量统计                  |
#### **关键结论**
- **时间复杂度与存储结构的关系**：
  - 邻接矩阵需遍历所有顶点，时间复杂度较高；邻接表仅遍历实际边，效率更高。
- **生成树的唯一性**：
  - 邻接表因邻接顺序不固定，生成树可能不唯一；邻接矩阵生成树唯一。
- **空间复杂度**：
  - DFS 和 BFS 的最坏空间复杂度均为O(|V|) ，与搜索路径无关。




## 错题
1. 一个有 28 条边的非连通无向图至少有()个顶点。7/8/9/10
   为了使顶点数最小，应使其中一个连通分量为孤立顶点（无边），另一个连通分量为完全图（边数最多），完全图边数n(n-1)/2，可得n=8，总顶点数=n+1=9
2. 在有n个顶点的有向图中，顶点的度最大可达() A. n B. n-1 C.2n D.2n-2
   在有向图中，顶点的度等于入度与出度之和。n个顶点的有向图中，任意一个顶点最多还可以与其他n-1个顶点有一对指向相反的边相连。注意，数据结构中仅讨论简单图。
3. ![Pasted image 20250311161002](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311161002.png)一个连通图的生成树是一个极小连通子图，显然它是无环的，因此选项 Ⅱ、 正确。极大连通子图称为连通分量，G'连通但非连通分量。这里再补充一下“极大连通子图”:若图本来就是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。
4. 具有51个顶点和21条边的无向图的连通分量最多为 A. 33 B.34 C. 45 D.32
   要想连通分量最多，就要使图中孤立的点数量最多（每一个孤立的点都是一个连通分量）  问题转为最少用多少点可连21条边，设用x个点.则有x(x-1)/2≥21，得xmin=7  ，这7个点作为1个连通分量，剩余51-7=44个孤立的点，每一个点作为一个连通分量，故连通分量最多为1+(51-7)=45个
5. 在如下图所示的有向图中，共有()个强连通分量。1/2/3/4
   ![Pasted image 20250311162046|150](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311162046.png)2个，b和其他
6. 若具有 n个顶点的图是一个环，则它有()棵生成树 A. n B. n C. n-1 D.1
   环图删除任意一条边可形成生成树，共有 nn 种选择
7. 若一个具有 n个顶点、e条边的无向图是一个森林，则该森林中必有()棵树。
   A.n  B.e  C.n-e  D.1
   n个结点的树有n—1条边，假设有x棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是n+1，边数是e+x，从而可知x=n—e，也就是n—e棵树了
8. 下列关于无向连通图特性的叙述中，正确的是()
   I.所有顶点的度之和为偶数
   II.边数大于顶点个数减1
   III.至少有一个顶点的度为1
   A. 只有I    B.只有II    C.I和II    D.I和III
   - I正确（度数之和为边数两倍，必为偶数）。
   - II错误（树结构边数 n−1，不大于顶点数减1）。
   - III错误（环图所有顶点度为2）。
1. 若无向图 G=(V,E)中含有6个顶点，要保证图 G在任何情况下都是连通的，则需要的边数最少是() 8/9/10/11
   特定情况下6条，就连通；任意情况下，==n-1个点的完全图+单独出去的一条边连剩下一个点==，答案是11。如果题目求的是有向图，==n-1个点的有向完全图+单独出去的一条边连剩下一个点==，答案是21![Pasted image 20250311165458|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165458.png)
2. 对于无向图G=(V,E)，下列选项中，正确的是()。
    A.|V|>|E|时，G 一定是连通的
    B.当|V|<|E|时，G一定是连通的
    C.当|V|=|E|-1时，G一定是不连通的
    D.当|V|=|E|+1时，G一定是不连通的
    d![Pasted image 20250311171144](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311171144.png)
3. 用有向无环图描述表达式(x+y)((x+y)/x)，需要的顶点个数至少是5/6/8/9
    ![Pasted image 20250311165839|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165839.png)5
4. ![Pasted image 20250312122108](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312122108.png)bd
5. 假设有 n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)
    **删出边**：遍历v的顶点表结点及其边表，删除出边，最多n-1条，时间复杂度O(n)。
    **删入边**：扫描整个边表（含剩余顶点表结点及边表），删除v的入边，时间复杂度O(n+e)。
6. 假设有 n个顶点、e条边的有向图用邻接表表示，则某个顶点v的入度时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)
    为了求顶点v的入度，只需要遍历邻接表中的所有边表，检查每条边是否指向顶点"，这相当于遍历整个邻接表，因此算法的时间复杂度为 O(n+e)。
7. 无向图邻接多重表求顶点b，d的度![Pasted image 20250312125659|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312125659.png)
    b的入度1，出度2；d的入度1，出度3
8.























































































