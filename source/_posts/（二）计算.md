---
title: 计算机组成原理（二）
categories:
  - 计算机基础
  - 专业课
tags:
  - c
  - 计算机组成原理
description: 计算机组成原理
swiper_index: 1
# abbrlink: 79666db
date: 2025-04-07 21:11:00
---

# 1 计算机内部的数据表示
## 1.1 数值转换与编码
基数r：进位计数制中，每个数位所用到的不同数码个数
真值（前面带+/-）：现实中用于计算的数据，在计算机中不存在；
正数或负数的真值为其绝对值对应的二进制数前面加上正号或负号。
例如+1 表示为 +00000001，-1 表示为 -00000001；
移码大真值就大
补码若符号位相同，数值位越大（即二进制中1的位数越多），码值越大。若 `1` 的个数相同，**最高位的 `1` 位置越靠左（权重越大），码值越大**。

| **进制名称** | **基数** | **数码范围**               | **进位规则** | **权值** | **示例**              | **二进制转换规则**    | **表示方法（后缀/前缀）**   | **C语言表示**      |
| -------- | ------ | ---------------------- | -------- | ------ | ------------------- | -------------- | ----------------- | -------------- |
| **二进制**  | 2      | 0, 1                   | 逢二进一     | 2^i    | 101011<sub>2</sub>  | 3位二进制 → 1位八进制  | 后缀`B`（如`101011B`） | `0b101011`     |
| **八进制**  | 8      | 0, 1, 2, 3, 4, 5, 6, 7 | 逢八进一     | 8^i    | 101011<sub>8</sub>  | 1位八进制 → 3位二进制  | 后缀`O`（如`101011O`） | `0101011`（前导0） |
| **十进制**  | 10     | 0, 1, 2, ..., 9        | 逢十进一     | 10^i   | 101011<sub>10</sub> | 无直接转换          | 无后缀（如`101011`）    | `101011`       |
| **十六进制** | 16     | 0-9, A-F（10-15）        | 逢十六进一    | 16^i   | 101011<sub>16</sub> | 4位二进制 → 1位十六进制 | 后缀`H`（如`101011H`） | `0x101011`     |
2^-1=0.5，2^-2=0.25，2^-3=0.125
1. **二进制↔八进制数**
   二进制→八进制：从小数点向左右划分，每三个一组，不够的补零
   八进制→二进制：每个八进制数转换为三位二进制数，前后去0
2. **二进制↔十六进制数**
   二进制→十六进制：从小数点向左右划分，每四个一组，不够的补零
   十六进制→二进制：每个十六进制数转换为四位二进制数，前后去0
3. **八进制→十六进制**
   先转二进制，在转十六进制
4. **十进制小数→任意进制（除基取余，乘基取整）**
   除基取余针对整数部分，乘基取整针对小数部分
   ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328084356810.png)![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328084506522.png)
   - **注**：
     若转换后无限循环（精度缺失），需根据精度要求截断。
     十进制小数转八进制和十六进制小数也可能出现精度缺失

5. **BCD码（Binary-Co ded Decimal）**
   - **压缩BCD码**：用<font color="#ff0000">4位</font>二进制表示1位十进制数（如 `9 → 1001`）。
   - **非压缩BCD码**：用<font color="#ff0000">8位</font>二进制表示1位十进制数（如 `9 → 00001001`）。  ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328090505451.png)
   - **常见编码类型**：
     - **8421码（自然BCD码）**：
       - 加法后若结果超过9（如 `1001 + 1001 = 1 0010`），需加 `0110`（6）校正。  ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328090725385.png)
     - **余3码**：无权码，每个数比原值大3（如 `0 → 0011`）。
     - **2421码**：有权码，5~9的最高位为1（如 `5 → 1011`）。

6. **ASCII码**
   - **范围**：
     - `0-9`：`30H-39H`（48-57）。
     - `A-Z`：`41H-5AH`（65-90）。
     - `a-z`：`61H-7AH`（97-122）。
## 1.2 定点数的编码
### 1.2.1 定点数
- **定义**：小数点位置固定，分为**定点整数**和**定点小数**。
- **表示范围**：

| 类型       | 范围（n位）                             | 8位二进制范围  |
| -------- | ---------------------------------- | -------- |
| **定点整数** | $-2^{n-1} \leq x \leq 2^{n-1} - 1$ | -128~127 |
| **定点小数** | $-1 \leq x \leq 1 - 2^{-(n-1)}$    | -1~0.992 |
- 数据范围影响因素
  - 机器字长：越长，越大
  - 所采用的机器码：补码和移码所能表示的数据范围，比原码和反码所能表示的数据范围要多一个最小负数。
- **定点整数**：
  - 小数点固定在数值位最右侧。
    一般用==补码==表示
    总位数为 n+1 位，给定真值  x ，其补码 [x]补 定义为：$[x]_{\text{补}} = \begin{cases} x & \text{若 } 0 \leq x < 2^{n}, \\2^{n+1} + x & \text{若 } -2^{n} \leq x < 0 \ (\text{mod } 2^{n+1}).\end{cases}$
    - **模数**： $2^{n+1}$ ，即补码表示的数值范围在模  $2^{n+1}$  下。
      以  n = 3 （总位数  n+1 = 4 ）为例：
    -  x = -5 ：补码为  $2^{4} + (-5) = 16 - 5 = 11$ ，即 `1011`。

- **定点小数**：
  - 小数点固定在符号位右侧。
  - **示例**：`1.011`表示`-0.625`（补码）。

注：拓展位不一样
定点小数：
[x]原=1.110
[x]原= 1.1100000
定点整数：
[x]原=1,110
[x]原= 1,0000110
### 1.2.2 原码
1. **定义**：
   - 原码是最基础的二进制表示方法，**符号位 + 数值位**。
   - **符号位**：最高位，`0`表示正数，`1`表示负数。
   - **数值位**：绝对值的二进制形式。

2. **示例**：
   - `+5`（4位）：`0 101`
   - `-5`（4位）：`1 101`

3. **特点**：
   - **优点**
     - 与真值的对应关系简单、直观，与真值的转换简单
     - 用原码实现乘除运算比较简便。
   - **缺点**：
     - **符号位不能直接参与运算**，用原码实现加减运算比较复杂
     - **0的表示不唯一，有±0两个编码**：`+0`（`0 000`）和 `-0`（`1 000`）。

原码在计算机中仅用于表示浮点数的尾码
计算：
加法:正+正或负+负 结果可能溢出
减法：负数取反
### 1.2.3 反码
1. **定义**：
   - **正数**：与原码相同。
   - **负数**：符号位不变，数值位按位取反。

2. **示例**：
   - `+5`（4位）：`0 101`
   - `-5`（4位）：`1 010`

3. **优点**：
   - 符号位可以参与运算
4. **缺点**：
     - 最高位(符号位)产生的进位要加到运算结果的低位(循环进位)
     - 真值0在反码中有两种不同的表示
### 1.2.4 补码
1. **定义**：
   - **正数**：与原码相同。
   - **负数**：反码加1（符号位不变）。

2. **示例**：
   - `+5`（4位）：`0 101`
   - `-5`（4位）：`1 011`（反码`1 010` + 1）

3. **优点**：
   - **统一加减法**：减法可转换为加法（`A - B = A + (-B)`）。
   - **唯一0表示**：`0 000`，无`-0`。使得补码比原码多表示一个最小负数
   - **硬件友好**：无需额外处理符号位，简化电路设计。
4. **缺点**：
    补码的表示相对原码更加复杂。
    原码的数值位与真值的绝对值相同。因此，通过原码可以很容易地得出真值。但是，补码就没有这么简单了。
5. **补码快速转换**：
   - 从右往左找到第一个`1`，该位左侧数值位取反。
   - **示例**：`-5`（原码`1 101` → 补码`1 011`）。

补码1111 1111是-1
补码1000 0000是-128
8位补码所表示的真值x的范围：-128 ≤ x ≤ 127
16位补码所表示的真值x的范围：-32768 ≤ x ≤ 32767
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328123122040.png)
3. **补码运算示例**：
   $[A + B]_{\text{补}} = [A]_{\text{补}} + [B]_{\text{补}}, \quad [A - B]_{\text{补}} = [A]_{\text{补}} + [-B]_{\text{补}}$
   可以验证结果$[A + B]_{\text{补}} = [A+B]_{\text{补}}$
   $(-5) + 3 = 11111011_2 + 00000011_2 = 11111110_2 = -2_{10}$
   [-0.0101]原=[1.1011]补
   ![image.png|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328123942413.png)补码的补码是原码
   [x]补=1,011 0100 [x]原=1,100 1100
4. 补码的真值计算公式为：
   $真值=−符号位×2^{n−1}+剩余位的无符号值$
   对于 `11100000`：$真值=−1×2^7+1100000_2=−128+96=−32$
   技巧：对于n位补码，其真值为最高位的-2^(n-1)加上其余各位的正权重之和。
   eg.`1 1011`=-2^4+8+2+1=-5
5. $[-x]_{\text{补}} = \text{全部位取反}([x]_{\text{补}}) + 1$
   ==对-40求补运算，就是求40的补码。就是求相反数的补码==
	1. **正数转负数**：
	   - 设\[x\]补 = `00000101`（+5）
	     - **取反**：`11111010`
	     - **加1**：`11111010 + 1 = 11111011`
	     - **结果**：\[-x\]补 = `11111011`（-5）

	2. **负数转正数**：
	   - 设\[x\]补 = `11111011`（-5）
	     - **取反**：`00000100`
	     - **加1**：`00000100 + 1 = 00000101`
	     - **结果**：\[-x\]补 = `00000101`（+5）
6. 定点小数的补码
   正数补码和原码相同，负数补码定义为$[X]_{\text{补}} = 2 + X$（模2）。
   负数的补码是其绝对值的“模2补数”。
   eg.X = -0.101，则：$[X]_{\text{补}} = 2 + (-0.101) = 10.000 + 1.011 = 11.011(\text{舍去超过整数位的最高位}) = 1.011 \quad (\text{二进制})$
   对于整数部分占1位、小数部分占n位的数，补码的一般形式为：$[X]_{\text{补}} = 2^{n+1} + X \quad (\text{模 } 2)$
   eg.n=3，X = -0.101$[X]_{\text{补}} = 2^{4} + (-0.101) = 16 - 0.625 = 15.375 \mod 16 = 1.011 \quad (\text{二进制})$  对应补码 `1.011`（十进制 -0.101）。
7. 补码加减法的硬件实现
   补码加减法可通过**同一个加法器**实现，核心设计如下：
   - **控制信号 `Sub`**：决定执行加法或减法。
    - **`Sub = 0`**：加法运算，输入为 `X` 和 `Y`。
    - **`Sub = 1`**：减法运算，输入为 `X` 和 `Y` 的反码，并**末位加1**（通过低位进位实现）。
   - **电路设计**：
    - **多路选择器（MUX）**：选择 `Y` 或 `~Y`（取反）。
    - **加法器**：接收 `X` 和 MUX 输出，同时将 `Sub` 作为初始**低位进位输入**（减法时 `C_in = 1`）。
   **示例**：
   - 减法运算：`X - Y` 转换为 `X + (~Y) + 1`，即 `[X]补 + [-Y]补`。
   - 电路公式：`Result = X + (Y ^ {n{Sub}}) + Sub`（异或门实现按位取反）。
### 1.2.5 移码
1. 移码就是在真值上加一个常数 2^n（补码最前一位取反）
2. 在数轴上，移码所表示的范围对应于真值在数轴上的范围向轴的正方向移动2^n个单元
3. 移码只用于**定点整数**的表示。
4. 优点：
   - 真值0在移码中只有一种表示。
   - 移码保持了真值原有的大小顺序，可以**直接比较大小**。最小真值的移码为全0，最大真值的移码为全1，符合人们的习惯
   - 当浮点数的阶码用移码来表示时，就能很方便地比较阶码的大小。

注：
**1. 移码与补码的转换适用场景**
- **移码** 主要用于 **浮点数的阶码（指数部分）**，目的是将指数值转换为无符号整数，便于直接比较大小。
- **补码** 用于 **普通有符号整数**，简化加减法运算。
- **关键区别**：
  - 移码的真值计算依赖 **偏置值**，公式为：$\text{真值} = \text{移码值} - \text{偏置值}$
  - 补码的真值计算依赖 **符号位和数值位**，无需偏置值。
  - <font color="#ff0000">移码和补码的转换 仅在浮点数阶码处理时结合使用，普通整数无需混合操作。</font>

在IEEE 754中，移码用于表示浮点数的指数（阶码），其核心公式为：
- **偏置值**：对于8位阶码，IEEE 754单精度浮点数使用 **Bias = 127**。其他情况是128
- **真值范围**：移码值是无符号整数，8位范围为 $0 \leq \text{移码值} \leq 255$，对应真值范围为 $-127 \leq \text{真值} \leq 128$。
eg.**真值**：-128  $\text{移码值} = -128 + 127 = -1$
  - 由于移码值需为无符号数，负数结果需进行模运算：
    $-1 \mod 256 = 255 \quad \Rightarrow \quad 255_{(10)} = 11111111_{(2)}$
eg.- **真值**：-127  $\text{移码值} = -127 + 127 = 0$
  - 直接转换为无符号数：$0_{(10)} = 00000000_{(2)}$

![image.png|450](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328131557327.png)
n位能表示$2^{n-1}$个原码，$2^n$个补/移码

| **编码类型**          | **合法表示范围**                                                             | **最大的数（二进制）假设8位**      | **最小的数（二进制）**           | **真值0的表示**                         |
| ----------------- | ---------------------------------------------------------------------- | ---------------------- | ----------------------- | ---------------------------------- |
| **原码（n+1位）**      | $-(2^n - 1) \leq x \leq 2^n - 1$<br>[-127,127] 255个<br>最小正数1<br>最大负数-1 | `0,1111111`$2^n - 1$   | `1,1111111`$-(2^n - 1)$ | `0,0000000`（+0）<br>`1,0000000`（-0） |
| **反码（n+1位）**      | $-(2^n - 1) \leq x \leq 2^n - 1$<br>[-127,127] 255个<br>最小正数1<br>最大负数-1 | `0,1111111`$2^n - 1$   | `1,0000000`$-(2^n - 1)$ | `0,0000000`（+0）<br>`1,1111111`（-0） |
| **补码（n+1位）**      | $-2^n \leq x \leq 2^n - 1$<br>[-128,127] 256个<br>最小正数1<br>最大负数-1       | `0,1111111`$2^n - 1$   | `1,0000000`$-2^n$       | `0,0000000`（唯一表示）                  |
| **移码（8位，偏移量128）** | $-2^n \leq x \leq 2^n - 1$<br>[-128,127] 256个<br>最小正数1<br>最大负数-1       | `11111111`$2^n - 1$    | `00000000`$-2^n$        | `10000000`（偏移后0）                   |
| **无符号整数（n+1位）**   | $0 \leq x \leq 2^{n+1} - 1$<br>[0,255] 256个                            | `1111111`$2^{n+1} - 1$ | `00000000`（0）           | `00000000`                         |
| **定点小数：原码**       | $−(1−2^{−n})≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$              | `01111111`$1-2^{-n}$   | `1111111`$-(1-2^{-n})$  | `0,0000000`（+0）<br>`1,0000000`（-0） |
| **定点小数：反码**       | $−(1−2^{−n})≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$              | `01111111`$1-2^{-n}$   | `10000000`$-(1-2^{-n})$ | `0,0000000`（+0）<br>`1,1111111`（-0） |
| **定点小数：补码**       | $-1≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$                       | `01111111`$1-2^{-n}$   | `10000000`（-1）          | `0,0000000`（唯一表示）                  |

### 1.2.6 负数大小判断
原码：数值位越大，值越小
补码和反码：数值位越小，值越小
原码很容易判断大小，而负数的补码、反码很难直接判断大小

### 1.2.7 定点数的位数扩展
#### 1.2.7.1 定点整数与定点小数的扩展规则

| **类型**   | **扩展方向** | **规则**                               |
| -------- | -------- | ------------------------------------ |
| **定点整数** | 高位扩展     | 根据编码方式（原码、补码、反码）决定填充 `0` 或 `1`（见下文）。 |
| **定点小数** | 低位扩展     | 小数部分低位补 `0`（保持精度），高位扩展规则与编码方式一致。     |
#### 1.2.7.2 原码、补码、反码的扩展规则

| **编码类型** | **正数扩展规则**         | **负数扩展规则**               | **示例（8位 → 16位）**                                                                       |
| -------- | ------------------ | ------------------------ | -------------------------------------------------------------------------------------- |
| **原码**   | 符号位 `0`，数值位高位补 `0` | 符号位 `1`，数值位高位补 `0`       | `+5`（原码 `00000101` → `00000000 00000101`）<br>`-5`（原码 `10000101` → `10000000 00000101`） |
| **补码**   | 符号位 `0`，数值位高位补 `0` | 符号位 `1`，数值位高位补 `1`（符号扩展） | `+5`（补码 `00000101` → `00000000 00000101`）<br>`-5`（补码 `11111011` → `11111111 11111011`） |
| **反码**   | 符号位 `0`，数值位高位补 `0` | 符号位 `1`，数值位高位补 `1`       | `+5`（反码 `00000101` → `00000000 00000101`）<br>`-5`（反码 `11111010` → `11111111 11111010`） |
## 1.3 整数表示与运算
1. **无符号整数（unsigned）** 没有符号位
   - **范围**：$0 \sim 2^{n-1}$`（n为机器字长）。
     8位2进制范围：`[0,255]`
   - **硬件实现**：直接存储二进制原码，无符号位。
     无符号数用来存地址
   - 无符号整数溢出时，结果自动对 $2^n$ 取模（n 为位数）。
     - **示例**：
       - 8位无符号数：256 \mod 256 = 0，-1 \mod 256 = 255。
       - 移码计算中，负数真值转换为无符号移码值：$\text{移码值} = (\text{真值} + \text{Bias}) \mod 2^n$
    如8位移码（Bias=127）：$-128 + 127 = -1 \quad \Rightarrow \quad -1 \mod 256 = 255 = 11111111_{(2)}$
2. **有符号整数（补码表示）**
   - **范围**：$- 2^{n-1} \sim 2^{n-1} - 1$。
      8位2进制范围：`[-128,128]`
      −128<sub>10</sub>​=1000 0000<sub>2</sub> 补码仍为1000 0000<sub>2</sub>
   - **补码转换规则**：
     - **正数**：原码、反码、补码相同。
     - **负数**：原码符号位不变，数值位取反加1。
3. **溢出判断**
   - 加减法溢出判断
	   - ==**有符号==数溢出（OF）**：只有符号位相同才有可能溢出
	     - 看符号位与次高位进位是否异或$OF = C_{符号位} \oplus C_{次高位}$       $0111_2 (+7) + 0001_2 (+1) = 1000_2 (-8) \quad (\text{OF}=1)$
	     - 最高数值的进位C<sub>n-1</sub>与符号位C<sub>n</sub>的进位是否一致$OF = C_{n-1} \oplus C_{n}$![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330101044131.png)
	     - 变形补码（模4补码）01正溢出，10负溢出
	       模4 补码具有模2补码的全部优点且更易检查加减运算中的溢出问题
	       存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的
	       只在把两个模 4 补码的数送往 ALU 完成加减运算时，才把个数的符号位的值同时送到ALU的双符号位中，即只在 ALU 中采用双符号位
	       采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出。
		     - **正溢出**：两个正数（符号位为 `0`）相加，结果符号位为 `1`（负数）。
			- **负溢出**：两个负数（符号位为 `1`）相加，结果符号位为 `0`（正数）。
	   - ==**无符号==数进位（CF）**：最高位进位（加法）或借位（减法）。

   - 2个n位无符号与有符号乘法的溢出条件
	- 无符号乘法溢出条件：高n位 ≠0
	   两个n位无符号数的乘积最多需要 **2n位** 表示，范围是 $0 \leq \text{乘积} \leq (2^n - 1)^2$。
	   - 若乘积的 **高n位全为0**，说明结果可用n位无符号数表示（范围 $0 \leq \text{结果} \leq 2^n - 1$），**不溢出**。
	   - 若高n位不全为0，说明结果超出n位范围（> $2^n - 1$），**溢出**。
	- 有符号乘法溢出条件：高n+1位≠全0或全1
	  两个n位补码数的乘积最多需要 **2n位** 表示，范围是 $-2^{2n-2} \leq \text{乘积} \leq (2^{n-1}-1)^2$。
	  - 若乘积的 **高n+1位全为0或全为1**，说明结果可用n位补码表示（符号位扩展一致），**不溢出**。
	  - 若高n+1位不全为0或不全为1，说明结果超出n位补码范围，**溢出**。
		  - 补码乘法需要符号位扩展。若乘积的高n+1位全为0，表示正数且数值在n位范围内。
		  - 若高n+1位全为1，表示负数且数值在n位范围内。
		  - 若高n+1位不一致（如部分0和部分1），说明结果无法正确用n位补码表示。

| **类型**    | **溢出条件**              | **示例（n=4）**              |
| --------- | --------------------- | ------------------------ |
| **无符号乘法** | 乘积高n位不全为0 → 溢出        | $15 \times 15 = 225$（溢出） |
| **有符号乘法** | 乘积高n+1位不全为0或不全为1 → 溢出 | $-8 \times -8 = 64$（溢出）  |
- 零标志ZF=1 结果为零【都】
- 符号标志SF=1 结果为负【有符号数】
- **运算器不区分数据类型**：同一电路处理两种数（有符号、无符号），但需通过**标志位**解释结果。

| **标志位** | **名称**  | **作用**                      | **逻辑表达式**                |
| ------- | ------- | --------------------------- | ------------------------ |
| **ZF**  | 零标志     | 结果为0时置1，否则置0。对所有运算有效。       | `ZF = 1` ⇨ `Result == 0` |
| **OF**  | 溢出标志    | **仅对有符号数有效**，表示结果超出范围。      | `OF = C_n ⊕ C_{n-1}`     |
| **SF**  | 符号标志    | **仅对有符号数有效**，表示结果的符号（最高位）。  | `SF = Result[n-1]`       |
| **CF**  | 进位/借位标志 | **仅对无符号数有效**，加法表示进位，减法表示借位。 | `CF = Sub ⊕ C_out`       |
4. 数值比较的逻辑
 **(1) 无符号数比较（执行 `A - B`）**

| **条件**  | **标志位状态**        | **结论** |
| ------- | ---------------- | ------ |
| `A = B` | `ZF = 1`         | 相等     |
| `A > B` | `ZF = 0, CF = 0` | A大于B   |
| `A < B` | `ZF = 0, CF = 1` | A小于B   |
**(2) 有符号数比较（执行 `A - B`）**

| **条件**  | **标志位状态**         | **结论** |
| ------- | ----------------- | ------ |
| `A = B` | `ZF = 1`          | 相等     |
| `A > B` | `ZF = 0, OF = SF` | A大于B   |
| `A < B` | `ZF = 0, OF ≠ SF` | A小于B   |
- **未溢出（`OF = 0`）**：直接根据 `SF` 判断（`SF=0` 结果非负，`SF=1` 结果为负）。
- **溢出（`OF = 1`）**：符号位 `SF` 与实际大小相反，需结合 `OF` 修正判断。

5. 示例分析
**(1) 无符号数比较**
- **`A = 0000 0011 (3), B = 0000 0010 (2)`**：
  - `A - B = 0000 0001` → `ZF = 0, CF = 0` → `A > B`。
- **`A = 0000 0000 (0), B = 0000 0001 (1)`**：
  - `A - B = 1111 1111` → `ZF = 0, CF = 1` → `A < B`。

**(2) 有符号数比较**
- **`A = 0111 (7), B = 1011 (-5)`**（补码）：
  - `A - B = 0111 + 0101 = 1100` → `SF = 1, OF = 1 → `A > B`

| **位** | 操作                | 进位   |
| ----- | ----------------- | ---- |
| 第1位   | 1 + 1 = 0，进位1     | C0=1 |
| 第2位   | 1 + 0 + 1 = 0，进位1 | C1=1 |
| 第3位   | 1 + 1 + 1 = 1，进位1 | C2=1 |
| 第4位   | 0 + 0 + 1 = 1，进位0 | C3=0 |
    OF=C3⊕C2=0⊕1=1（溢出发生）

## 1.4 定点数运算
### 1.4.1 移位运算
   - **算术移位（有符号数）**：
     - **原码**：符号位不变，数值位补0（左移）或舍弃（右移）。
     - **补码**：正数同原码；负数左移补0，右移补1。
     - **反码**：负数空位补1
   - **逻辑移位（无符号数）**：统一补0。
     应用：RGB
   - **循环移位**：带进位时用于数据高低位交换（如大端转小端）。
     适合将数据的第字节数据和高字节数据呼唤
#### 1.4.1.1 逻辑移位（无符号数）
##### 1.4.1.1.1 按位或（`|`）：将某位置1
**用途**：将特定位设为1，其他位保持不变。
```c
#define BIT3_MASK (1U << 3)  // 掩码: 0x00000008
regData |= BIT3_MASK;         // 第3位置1
```
- 若 `regData = 0x00000000` → 结果 `0x00000008`。
- 若 `regData = 0x00000004` → 结果 `0x0000000C`（第2位和第3位均为1）。
##### 1.4.1.1.2 按位与（`&`）：将某位清0
**用途**：将特定位设为0，其他位保持不变。
```c
#define BIT5_MASK ~(1U << 5)  // 掩码: 0xFFFFFFDF
regData &= BIT5_MASK;          // 第5位清0
```
- 若 `regData = 0x00000020` → 结果 `0x00000000`。
- 若 `regData = 0xFFFFFFFF` → 结果 `0xFFFFFFDF`（仅第5位为0）。
##### 1.4.1.1.3 按位异或（`^`）：切换某位状态
**用途**：若目标位为1则置0，若为0则置1（翻转位状态）。
```c
#define BIT2_MASK (1U << 2)  // 掩码: 0x00000004
regData ^= BIT2_MASK;         // 切换第2位状态
```
- 若 `regData = 0x00000000` → 结果 `0x00000004`（第2位置1）。
- 若 `regData = 0x00000004` → 结果 `0x00000000`（第2位清0）。

##### 1.4.1.1.4 按位非（`~`）：取反所有位
**用途**：将所有位取反（1变0，0变1）。
```c
regData = ~regData;  // 所有位翻转
```
- 若 `regData = 0x0000000F` → 结果 `0xFFFFFFF0`。
- 若 `regData = 0x12345678` → 结果 `0xEDCBA987`。


```c
// 设置第1位和第4位，同时清除第3位
#define SET_MASK   ((1U << 1) | (1U << 4))  // 0x00000012
#define CLEAR_MASK ~((1U << 3))             // 0xFFFFFFF7

regData |= SET_MASK;    // 第1、4位置1
regData &= CLEAR_MASK;  // 第3位清0
```
- 若 `regData = 0x00000000` → 结果 `0x00000012`。
- 若 `regData = 0x00000008` → 结果 `0x00000010`（第3位清0，第4位置1）。

| **操作符** | **作用** | **示例代码**              |
| ------- | ------ | --------------------- |
| \|      | 置1特定位  | regData \|= (1U << n) |
| &       | 清0特定位  | regData &= ~(1U << n) |
| ^       | 翻转特定位  | regData ^= (1U << n)  |
| ~       | 取反所有位  | regData = ~regData    |

eg1.
要将变量 `regData` 中的第6位（从0开始计数）置1而不影响其他位，假设寄存器的内容保存在变量regData中，可以使用以下C语言代码：
```c
#define b6_mask (1 << 6)  // 定义掩码，确保无符号移位
regData |= b6_mask;        // 按位或操作置位
```
1. **掩码定义**：
   `#define b6_mask (1 << 6)`
   无符号整型常量1，左移6位后得到二进制掩码 `01000000`（即十六进制 `0x40`）。
2. **置位操作**：
   `regData |= b6_mask;`
   - 按位或操作 (`|=`) 将 `regData` 的第6位设置为1，其他位保持不变。

**假设 `regData` 初始值为 `0x28`（二进制 `00101000`）：**
`regData |= b6_mask;  // regData = 0x68 (二进制 01101000)`
eg2.
要将变量 `regData` 中的第6位（从0开始计数）清0而不影响其他位，假设寄存器的内容保存在变量regData中，可以使用以下C语言代码：
``` C
#define b6_mask ~(1 << 6)
regData &= b6_mask
```
eg3.
要将某个8位寄存器的b0和b5的内容清0、b2和b3的内容置1，并且不影响寄该寄存器中的其他各位，请使用C语言编程实现(假设该寄存器的内容保存在变量regData中)。
```C
#define CLEAR_MASK ((1U << 0) | (1U << 5))
#define SET_MASK   ((1U << 2) | (1U << 3))
regData &= ~CLEAR_MASK;  // 清0 b0和b5
regData |= SET_MASK;     // 置1 b2和b3
```

#### 1.4.1.2 算数移位（有符号数）
针对定点数（定点整数、顶点小数）
不论正数还是负数，符号位保持不变，仅对数值位进行移位
左移×2^n 【<< 对应逻辑左移（高位移除，低位补0）】
右移÷2^n 【>> 无符号对应逻辑右移（低位移除，高位补0），有符号对应算术右移（低位移除，低位补符号位）】
注意：补码的算数移位：
- **右移**：符号位保留（填充符号位）。
- **左移**：
    - 若左移未溢出，符号位保留。
    - 若左移导致符号位改变（如正数变负数或负数变正数），则符号位不保留，**溢出发生**。
- 补码 `00001101`（+13）左移1位 → `00011010`（+26），符号位保留。
- 补码 `11110011`（-13）左移2位 → `11001100`（-52），符号位保留。
- 补码 `01111111`（+127）左移1位 → `11111110`（-2），符号位改变，**溢出**。

| **真值**         | **机器码**  | **空位添补** | **丢位情况**                                          |
| -------------- | -------- | -------- | ------------------------------------------------- |
| **正数**（符号位不保留） | 原码=补码=反码 | 补0       | - **最高位丢1**：结果溢出（出错）  <br>- **最低位丢1**：精度缺失（值变小）   |
| **负数**（符号位保留1） | **原码**   | 补0       | - **最高位丢0**：结果溢出（出错）  <br>- **最低位丢0**：精度缺失（绝对值变大） |
|                | **反码**   | 补1       | - **最高位丢0**：结果溢出（出错）  <br>- **最低位丢1**：精度缺失（绝对值变大） |
|                | **补码**   | 左移补0右移补1 | - **最高位丢0**：结果溢出（出错）  <br>- **最低位丢1**：精度缺失（值变小）   |
**有符号定点数**的**补码**的另一种算术移位方法，即“符号位也参与移位”，具体规则如下
左移：高位移除，低位添补0；移动前后若符号位发生变化，则发生**溢出**。
右移：低位移除，高位添补符号。
注：题目中有机器数、寄存器等用机器移动，左移符号位和数值位一起移。算数右移保留符号位
补码算术左移时，高位移出，低位补0，若左移前后的符号位不同，则发生溢出
无符号数逻辑左移时，若最高位移出的是1，则发生溢出
逻辑左移和补码算术左移的结果都一样，都是移出最高位，并在低位补0
#### 1.4.1.3 循环移位（无符号数）
将无符号数二进制形式中的各个位向左或向右移动，被移出的位会重新出现在另一端，形成循环。
在很多处理器架构中，循环移位指令会影响状态寄存器中的**进位标志CF(CarnyFlag)位**，CF标志位用于标识在执行算术或逻辑操作时是否发生了**进位**。
根据CF标志位是否加入循环移位过程，循环移位可分为以下四种:
小循环：CF不参与循环，但是保留当前循环的移位
不带CF标志位的循环右移
不带CF标志位的循环左移
大循环：CF参与循环
带CF标志位的循环右移
带CF标志位的循环左移
循环移位的应用主要有：**加密算法、哈希函数、优化算法**
加密算法：通过循环移位可以实现数据的混淆和置换，增强加密算法的安全性。
哈希函数：通过循环移位可以用来改变输入数据的排列顺序，以产生不同的哈希值，有利于增强哈希函数的混淆性和扩散性。
优化算法:
在某些算法中，循环移位可以用于优化性能和节省资源。例如，在图形处理和数字信号处理中，循环移位可以用于加速算法的执行。

可以使用移位运算操作符(左移“<<”或右移“>>”)和位运算操作符(例如:或运算)来实现。

| **移位类型** | **数值类型** | **溢出判断条件**      | **示例（4位）**              |
| -------- | -------- | --------------- | ----------------------- |
| **逻辑左移** | 无符号数     | 移出有效位（`CF = 1`） | `1100 << 1 → 1000`（未溢出） |
| **算术左移** | 有符号数     | 符号位改变（`OF = 1`） | `0100 << 1 → 1000`（溢出）  |
| **逻辑右移** | 无符号数     | 不会溢出            | `1100 >> 1 → 0110`（无溢出） |
| **算术右移** | 有符号数     | 不会溢出            | `1100 >> 1 → 1110`（无溢出） |
## 1.5 逻辑门
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330110026671.png)
### 1.5.1 半加器
和数S，进位数C
![image.png|300](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330122433587.png)
### 1.5.2 一位全加器FA
一位全加器 = 两个半加器
FA是最基本的加法单元

![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330121705189.png)
### 1.5.3 串行进位加法器
将n个全加器相连可得到n位加法器，称为串行进位加法器，如图2.4所示。串行进位也称行波进位，每级进位直接依赖于前一级的进位，即进位信号是**逐级**形成的。
在串行进位加法器中，低位运算产生进位所需的时间将影响高位运算的时间。因此，串行进位加法器的最长运算时间主要是由进位信号的**传递时间**决定的，位数越多，延迟时间就越长，所以加快进位产生和提高传递的速度是关键。
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330121720156.png)
在n位串行进位加法器中，每个高位的一位全加器FA的运算依赖于相邻低位的一位FA的进位Ci+1因此所有一位FA不能并行运行，其时间关键延迟为(2n+4)T，与串行进位加法器的位数n呈线性关系，**当n较大时性能较差**。
![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330124049316.png)
### 1.5.4 先行进位加法器
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330130038330.png)
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330130239644.png)
针对C4，S4：
![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330125514620.png)

![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330120614661.png)
带符号整数和无符号整数的加减法**可以共用同一加法器**，因为：
1. 补码设计使得加减法操作与无符号数一致。**硬件无需区分有符号和无符号数**，加法器直接执行二进制位相加。
2. 减法统一转换为加法，仅需额外取反加1逻辑。
3. 溢出判断通过独立电路（CF和OF）区分处理，不依赖加法器本身。
   - **无符号数溢出**：
    通过**最高位进位**判断。例如，8位无符号数相加结果超过255时，最高位产生进位（Carry Flag, CF=1）。
   - **有符号数溢出**：
     通过**符号位变化**判断。若两个正数相加结果为负，或两个负数相加结果为正，则溢出（Overflow Flag, OF=1）。
   - **共用加法器，独立标志位**：
	- 加法器生成结果后，**CF** 和 **OF** 由不同电路独立计算。
	- 例如，8位运算中：
		- `CF = 第8位进位`。
		- `OF = 第7位进位异或第8位进位`。
## 1.6 乘法与除法
### 1.6.1 无符号数乘法的硬件逻辑
![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401183330629.png)
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330132332682.png)
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330133038038.png)


### 1.6.2 定点数的乘法运算
   - **原码乘法**：符号位异或，数值位累加并右移。
   - **补码乘法（Booth算法）**：根据乘数位决定加减被乘数，算数右移。
   - **原码除法（加减交替法）**：通过余数符号调整商和下一步操作。
#### 1.6.2.1 原码乘法运算的硬件逻辑实现
对于定点整数原码乘法，其过程与定点小数原码乘法完全相同，仅将符号位与数值位之间的小数点改为逗号即可。
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401185018200.png)
先加法再移位，重复n次
符号位不参与运算，符号位单独处理：符号位=x⊕y
取绝对值进行乘法计算
当前位=1，ACC加上被乘数。=0，不加
补位是逻辑右移
进行n轮加法、移位![image.png|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401200316949.png)

#### 1.6.2.2 补码乘法运算的硬件逻辑实现
补码一位乘法运算（Booth算法）：
是一种加速乘法计算的方法（比如计算 `5 × 3`），特别适合用硬件电路实现，比传统的乘法更高效。
**核心思想：用“加减”代替“乘”**
硬件不喜欢直接做乘法（电路复杂），但擅长加减和移位。Booth算法把乘法拆解成：
1. **观察乘数的相邻两位**（比如当前位是`1`，前一位是`0`，就表示“需要加被乘数”）。
2. **被乘数左移**（相当于十进制乘法中的“后面补零”）。
3. **重复步骤1和2，最后把所有结果加起来**。

**硬件**：![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402181608205.png)

1. **控制逻辑**：
   - **核心大脑**，协调所有操作：根据乘数位（MQ的当前位和附加位）判断加减、移位操作，控制循环次数（计数器），确保算法按步骤执行。

2. **时钟**：
   - **同步时序**，确保每一步操作（如加减、移位）在固定时钟周期内完成，保持硬件同步。

3. **计数器（Cn）**：
   - **记录迭代次数**，例如n位乘法需计数n次，控制循环终止。

4. **ACC（累加器）**：
   - **存储部分积**，保存当前累加结果，每次操作后与ALU结果同步，参与算术右移。

5. **MQ（乘商寄存器）**：
   - **存储乘数及附加位**，初始存放乘数Y，末尾附加一位Y₋₁（初始为0）；每次右移时，ACC和MQ联合移位。

6. **ALU（算术逻辑单元）**：
   - **执行加减操作**，根据控制信号对ACC和[X]补（或被乘数补码）进行加减，结果写回ACC。

7. **选择器（多路复用器）**：
   - **选择操作数**，例如选择被乘数[X]补或其补码（−[X]补）输入ALU，实现加减操作切换。

8. **译码器**：
   - **解析操作码**，将MQ的当前位（Y₀）和附加位（Y₋₁）转换为控制信号（如“加”“减”或“不移位”）。

9. **反相器**：
   - **生成补码**，将被乘数取反后加1，用于实现减法操作（−[X]补）。

辅助位-MQ中最低位=1，ACC+[x]补
=0，不加
=-1，ACC+[-x]补（会有辅助电路实现[-x]的转换）
补位是算数右移
进行n轮加法、移位，最后再多来一次加法
被乘数A，B采用双符号位补码，符号位参与运算；乘数C采用单符号位补码，符号参与移位，且在尾部增加一位附加位0
![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401200540813.png)
补码一位乘法中，最多需要 n 次移位，n+1次加法运算，共2n+1位。
原码乘法移位和加法运算最多均为n次。
凡是原码运算，不论加减乘除，符号位都单独处理，其中乘除运算的结果符号由参加运算的两个操作数符号相“异或”得到。

【2020年 题43】有实现x×y的两个C语言函数如下：
```c
unsigned umul (unsigned x, unsigned y) { return x*y; }
int imul (int x, int y) { return x * y; }
```
假定某计算机M中ALU只能进行加减运算和逻辑运算。请回答下列问题。
(1) 若M的指令系统中**没有**乘法指令，但有加法、减法和移位等指令，则在M上也能实现上述两个函数中的乘法运算，为什么？
(2) 若M的指令系统中有乘法指令，则基于ALU、移位器、寄存器以及相应控制逻辑实现乘法指令时，**控制逻辑**的作用是什么？
(3) 针对以下三种情况：①**没有乘法指令**；②有使用**ALU**和**移位器**实现的乘法指令；③有使用**阵列乘法器**实现的乘法指令，函数umul()在哪种情况下**执行时间**最长？哪种情况下执行的时间最短？说明理由。
(4) n位整数乘法指令可保存2n位乘积，当仅取低n位作为乘积时，其结果可能会发生溢出。当n=32、x= 231−1 、y=2时，带符号整数乘法指令和无符号整数乘法指令得到的x×y的2n位乘积分别是什么（用十六进制表示）？此时函数umul()和imul()的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低位作为乘法结果时，如何用2n位乘积进行溢出判断？
解答：
(1) 乘法本质上是**重复累加**和**位移操作**的组合。以二进制乘法为例，假设计算 `x * y`，可以将 `y` 的每一位分解为权重（如第 `i` 位对应 `2^i`），通过将 `x` 左移 `i` 位后累加到结果中。例如：  `5 * 3 = 5 * (0011B) = (5 << 1) + (5 << 0) = 10 + 5 = 15`。
- **软件实现流程**：
    1. 初始化结果为0。
    2. 逐位检查乘数 `y` 的每一位：
        - 若当前位为1，将 `x` 左移对应位数后加到结果中。
        - 若当前位为0，跳过加法。
    3. 重复上述步骤直到处理完所有位。
- **符号处理**（针对有符号乘法 `imul`）：
    - 取 `x` 和 `y` 的绝对值进行无符号乘法。
    - 根据符号位异或（`x ^ y`）确定结果的符号，最终修正结果。

(2) 控制逻辑的作用是**控制循环次数，控制加法和移位操作**。
1. **操作选择**：
   - 根据乘数的当前位（或附加位）决定加减操作。
   - 例如，在 Booth 算法中，通过检查 `CnCn-1`（当前位和前一位）的组合选择：
     - `01`：加被乘数
     - `10`：减被乘数
     - `00/11`：不操作

2. **移位控制**：
   - 管理算术右移（补码运算）或逻辑右移（无符号运算）的时机和位数。
   - 例如，每次加减操作后执行右移，保持符号位不变。

3. **迭代计数**：
   - 控制乘法步骤的循环次数。对于 `n` 位数，通常需要 `n` 次迭代。
   - 在 Booth 算法中，需额外处理附加位，总次数为 `n+1` 次加减和 `n` 次移位。

4. **符号处理**（针对补码乘法）：
   - 自动扩展符号位，确保运算过程中符号正确参与。

**(3) 三种情况下的执行时间对比**

| **情况**            | **执行时间** | **理由**                                     |
| ----------------- | -------- | ------------------------------------------ |
| ① 无乘法指令（软件实现）     | **最长**   | 需要循环逐位处理，每次循环包含条件判断、加法和移位操作，时间复杂度为 `O(n)`。 |
| ② ALU+移位器(通用硬件实现) | **中等**   | 硬件加速，但仍需多周期完成（如 `n` 次迭代），时间复杂度为 `O(n)`。    |
| ③ 阵列乘法器(专用硬件实现)   | **最短**   | 全并行电路，通过门电路直接计算每一位乘积，单周期完成，时间复杂度为 `O(1)`。  |
①的执行时间最长，③的执行时间最短。
对于①，需要使用其他指令和算法来模拟乘法操作。常见的方法是通过编写（软件）程序使用加法、位移和逻辑操作来实现乘法功能，需要反复执行很多条指令，而对于每条指令，都需要经历“取指、译码、取数、执行、保存结果”这一过程，②和③都是硬件乘法指令，所以①的执行时间最长。
对于②和③，都只需用一条乘法指令实现乘法操作。
对于③，阵列乘法器是专门用于执行乘法操作的硬件电路，可以在一个时钟周期内完成乘法运算。由于其硬件实现的特性，阵列乘法器通常是执行乘法操作最高效的方式。所以③的执行时间最短。
对于②，ALU和位移器实现的乘法指令通常需要多个时钟周期来完成乘法运算。它通过将乘法操作划分为一系列的加法、位移和逻辑操作来实现。尽管比情况①中的方法更高效，但仍然需要多个时钟周期来执行，因此相对于情况③中的阵列乘法器，执行时间较长。
- **阵列乘法器**：
  通过门电路并行生成所有部分积，并一次性相加，无需循环。例如，32位乘法器包含32×32个与门和加法器，直接输出64位结果。
- **ALU+移位器实现**：
  需要逐位迭代（如Booth算法），每个周期完成一次加减和移位，共需 `n` 个周期。

**(4) 32位乘法的溢出分析与乘积表示**
**给定条件**：
- `n = 32`
- `x = 2^31 - 1 = 0x7FFFFFFF`（32位补码最大正数）
- `y = 2`

**64位乘积计算**：
- **无符号乘法**（`umul`）：
  - `x = 0x7FFFFFFF`（无符号值为 `2^31 - 1`）
  - `x * y = (2^31 - 1) * 2 = 2^32 - 2 = 0xFFFFFFFE`
    32位无符号整数的表示范围是$[0,2^{32}-1]$
  - **64位乘积**：`0x00000000FFFFFFFE`（高32位全0，无溢出）。
- **有符号乘法**（`imul`）：
  - `x = 0x7FFFFFFF`（补码最大正数 `+2^31 - 1`）
  - `x * y = (2^31 - 1) * 2 = 2^32 - 2`，但32位补码范围为 32位无符号整数的表示范围是$[-2^{31},2^{31}-1]$，结果 `2^32 - 2` 超出范围。
  - **64位乘积**：`0xFFFFFFFE`（低32位） + 高32位符号扩展为 `0xFFFFFFFF` → 完整乘积为 `0xFFFFFFFFFFFFFFFE`（即 `-2` 的补码）。


对于无符号整数乘法运算，当仅取乘积的低 n 位作为结果时，**若 2n  位乘积的高 n 位不全为0，则说明结果发生了溢出**。以下是详细的解释：
- **输入范围**：两个 n 位无符号整数的取值范围为 $0 \leq x, y \leq 2^n - 1$
- **乘积范围**：它们的乘积最大为 $(2^n - 1) \times (2^n - 1) = 2^{2n} - 2^{n+1} + 1$，需要 2n  位才能完整表示。
- **截断后的结果**：若仅取乘积的低 n 位（即忽略高 n 位），则低 n 位的表示范围为 $0 \leq \text{结果} \leq 2^n - 1$。
- **溢出条件**：当实际乘积 $x \times y > 2^n - 1$  时，低 n 位无法正确表示真实值，此时发生溢出。

高n位的意义：
- **二进制表示**：乘积的 2n  位可拆分为高 n 位和低 n 位，即：$x \times y = (\text{高 } n \text{ 位}) \times 2^n + (\text{低 } n \text{ 位})$
- **高 n 位的作用**：
  - 若高 n 位全为0，说明乘积 $x \times y \leq 2^n - 1$ ，未溢出。
  - 若高 n 位不全为0，说明乘积 $x \times y \geq 2^n$ ，低 n 位无法容纳真实值，发生溢出。

**例1：未溢出（高 n 位全0）**
- 设 n = 4 ，x = 15(1111_2) ，y = 1(0001_2) 。
- 乘积：$15 \times 1 = 15(0000\ 1111_2)$ 。
- 高4位为 `0000`，低4位为 `1111`，结果未溢出。

**例2：溢出（高 n 位不全0）**
- 设 n = 4 ，x = 15(1111_2) ，y = 15(1111_2) 。
- 乘积：$15 \times 15 = 225(1110\ 0001_2)$ 。
- 高4位为 `1110`，低4位为 `0001`，实际值远超 2^4 - 1 = 15 ，溢出发生。


**溢出判断**：
- **无符号乘法**（`umul`）：
  - **判断方法**：检查高32位是否全为0。
  - **结果**：高32位为 `0x00000000`，未溢出，返回 `0xFFFFFFFE`。

- **有符号乘法**（`imul`）：
  - **判断方法**：结果是否超出 `[-2^31, 2^31 - 1]`。
  - **结果**：`0xFFFFFFFE` 对应 `-2`，但实际数学结果为 `+2^32 - 2`，溢出发生，返回值为截断后的错误结果。

#### 1.6.2.3 无符号阵列乘法器
原码、补码一位乘法的硬件逻辑实现，需要在时钟节拍下、通过控制逻辑的控制，执行相应轮次的“加法、右移”操作来实现，速度较慢。
为了提高运算速度，可以仅采用**组合逻辑电路**以**专用硬件**方式构建阵列乘法器
**硬件结构**
阵列乘法器的核心由**与门阵列**和**加法器阵列**组成，典型结构如下：
- **输入**： n 位无符号被乘数  $X = x_{n-1}x_{n-2}...x_0$ ， n 位无符号乘数  $Y = y_{n-1}y_{n-2}...y_0$ 。
- **输出**： 2n 位无符号乘积  $P = p_{2n-1}p_{2n-2}...p_0$ 。

 由  n × n  个与门 和 n × ( n - 1 )个全加器构成

| **特性**    | **阵列乘法器**          | **串行乘法器（原码/补码一位乘法）** |
| --------- | ------------------ | -------------------- |
| **硬件复杂度** | 高（需要  O(n^2)  门电路） | 低（仅需加法器、移位器和控制逻辑）    |
| **运算速度**  | 快（组合逻辑延迟）          | 慢（需  n  个时钟周期）       |
| **适用场景**  | 高性能计算、专用硬件         | 通用处理器、资源受限场景         |
| **控制逻辑**  | 无（纯组合逻辑）           | 需状态机控制加减和移位操作        |
![image.png|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402194158184.png)

#### 1.6.2.4 补码阵列乘法器
- **核心思想**：将补码乘法转换为无符号乘法，并通过符号修正处理负数。


### 1.6.3 定点数的除法运算
#### 1.6.3.1 原码除法
恢复余数法，不恢复余数法（加减交替法）
前提条件：
除数≠0
定点小数：|被除数| ＜ |除数|
定点整数：|被除数| ≥ |除数|

 - **恢复余数法**
   - `|x|补+[-|Y|]补`
     - 结果为正，商1，左 移+`[-|Y|]补` 【正1左负】
     - 结果为负，商0，+`[|Y|]补`（恢复）【负0恢左负】
       - 恢复后左移+`[-|Y|]补`
         - 结果为正/负，重复上述步骤，直到商位为n
      商位的符号位是异或的结果
 - **不恢复余数法**
   - `|x|补+[-|Y|]补`
     - 结果为正，商1，左移+`[-|Y|]补` 【正1左负】
     - 结果为负，商0，左移+`|Y|补`【负0左正】
    商位的符号位是异或的结果


#### 1.6.3.2 补码除法
加减交替法
符号位参与运算
被除数/余数，除数采用==双符号位==
- `[X]补`+`[Y]补`
  - 和除数`[Y]补` 同号，商1，左移+`[-Y]补` 【同1左负】
  - 和除数`[Y]补` 异号，商0，左移+`[Y]补` 【异0左正】
- 左移n次，余数×2^-n
- 商位满足后，将**商位的最后一位改成1**（精度差≤2^n）

商位的符号位是异或的结果
![520578617831cd6b53059193def8c15.jpg|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402210721111.png)



| **特性**    | **原码一位乘法**                     | **补码一位乘法（Booth算法）**                           |
| --------- | ------------------------------ | --------------------------------------------- |
| **符号处理**  | 符号位单独处理：`符号 = x⊕y`             | 符号位参与运算，无需单独处理                                |
| **操作数形式** | 取绝对值进行乘法计算                     | 直接使用补码参与运算                                    |
| **核心步骤**  | 1. 加法后移位<br>2. 重复`n`次          | 1. 根据乘数末位和附加位判断加减<br>2. 算术右移<br>3. 重复`n`次     |
| **加减条件**  | 当前位为`1`：ACC加被乘数<br>当前位为`0`：不操作 | 根据`CnCn-1`组合：<br>`01`加被乘数，`10`减被乘数，`00/11`不操作 |
| **移位方式**  | **逻辑右移**（高位补`0`）               | **算术右移**（符号位保持不变）                             |
| **加法次数**  | 最多`n`次                         | 最多`n+1`次（可能多一次修正）                             |
| **移位次数**  | `n`次                           | `n`次                                          |
| **结果形式**  | 符号位与数值位分离                      | 直接得到补码结果                                      |

| **特性**              | **原码不恢复余数法（加减交替法）**                                               | **补码不恢复余数法**                                                                        |
|-----------------------|--------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| **符号处理**           | 符号位单独处理：`符号 = x⊕y`                                                     | 符号位参与运算                                                                              |
| **余数调整**           | 最终余数为负时需恢复余数                                                        | 余数无需恢复，直接修正商                                                                     |
| **商的确定**           | 根据余数符号：<br>余数正商`1`，余数负商`0`                                       | 异号相除时：<br>余数与除数同号商`1`，否则商`0`                                               |
| **核心操作**           | 1. 余数正：减除数<br>2. 余数负：加除数<br>3. 重复`n`次                           | 1. 余数与除数同号：减除数<br>2. 余数与除数异号：加除数<br>3. 重复`n`次                      |
| **移位方向**           | 左移                                                                           | 左移                                                                                       |
| **余数修正**           | 若最终余数为负，需加除数恢复                                                    | 无需恢复余数                                                                                |
   - 原码除法（加减交替法）仅在最终余数为负时恢复余数。
   - 补码除法通过余数与除数的符号关系直接确定商。

**操作次数**：
   - 原码乘法：`n`次加法 + `n`次移位。
   - 补码乘法：最多`n+1`次加法 + `n`次移位。
   - 除法：均需`n`次迭代。

**区别总结**
1. **移位方式**：
   - 原码乘法：逻辑右移（高位补`0`）。
   - 补码乘法：算术右移（符号位不变）。

2. **修正操作**：
   - 原码除法需要恢复余数，补码除法直接修正商。

3. **符号参与**：
   - 原码运算符号独立，补码运算符号融入数值。


## 1.7 浮点数表示与运算
### 1.7.1 **浮点运算步骤**
   - **对阶**：小阶向大阶对齐，尾数右移两个阶的绝对插值（精度损失）。
   - **尾数运算**：加减后规格化，处理溢出。
   - **舍入**：就近舍入、向零舍入等。
### 1.7.2 **浮点数的溢出**
   - 上溢：阶码超过最大允许值（OF=1）
     单精度浮点数阶码最大为 127，若计算结果阶码超过 127，则上溢
   - 下溢：运算结果的绝对值小于机器所能表示的最小绝对值
     运算结果在0至规格化最小正数之间时称为正下溢，运算结果在0至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。
     单精度浮点数阶码最小为 -126，若计算结果阶码低于 -126，则下溢
### 1.7.3 **浮点数表示范围**
阶码和尾数都是**原码**表示时：
- **阶码 E**（假设 k+1 位，1 位阶符 + k 位数值）：
   - **最大值**：$E_{\text{max}} = +(2^k - 1)$
   - **最小值**：$E_{\text{min}} = -(2^k - 1)$
- **尾数 M**（假设 n+1 位，1 位数符 + n 位数值）：
   - **正数范围**：$+2^{-n} \leq M \leq (1 - 2^{-n})$
   - **负数范围**：$-(1 - 2^{-n}) \leq M \leq -2^{-n}$
如果都用**补码**表示：
- **阶码 E（k+1 位补码）**：
   - **最大值**：$E_{\text{max}} = 2^{k} - 1$
   - **最小值**：$E_{\text{min}} = -2^{k}$
- **尾数 M（n+1 位补码，定点小数）**：
   - **正数范围**：$2^{-n} \leq M \leq 1 - 2^{-n}$
   - **负数范围**：$-1 \leq M \leq -2^{-n}$

| **类型**（基数=2） | **公式**                                     | **说明**            |     |
| ------------ | ------------------------------------------ | ----------------- | --- |
| **正数最大值**    | $2^{E_{\text{max}}} \times M_{\text{max}}$ | 阶码最大，尾数最大正数。      |     |
| **正数最小值**    | $2^{E_{\text{min}}} \times M_{\text{min}}$ | 阶码最小，尾数最小正数（即精度）。 |     |
| **负数最小值**    | $2^{E_{\text{max}}} \times M_{\text{min}}$ | 阶码最大，尾数最小负数。      |     |
| **负数最大值**    | $2^{E_{\text{min}}} \times M_{\text{max}}$ | 阶码最小，尾数最大负数。      |     |
3位阶码 + 3位尾数，原码表示：
1. **阶码**（1位阶符 + 2位数值）：
   - 最大值：$E_{\text{max}} = +3$（二进制 `0,11`）
   - 最小值：$E_{\text{min}} = -3$（二进制 `1,11`）

2. **尾数**（1位数符 + 2位数值）：
   - 正数范围：
     - 最大值：$M_{\text{max}} = +0.75$（二进制 `0.11`）
     - 最小值：$M_{\text{min}} = +0.25$（二进制 `0.01`）
   - 负数范围：
     - 最小值：$M_{\text{min}} = -0.75$（二进制 `1.11`）
     - 最大值：$M_{\text{max}} = -0.25$（二进制 `1.01`）

3. **浮点数范围**：
   - **正数最大值**：$2^{+3} \times 0.75 = 8 \times 0.75 = 6$
   - **正数最小值**：$2^{-3} \times 0.25 = 0.125 \times 0.25 = 0.03125$
   - **负数最小值**：$2^{+3} \times (-0.75) = 8 \times (-0.75) = -6$
   - **负数最大值**：$2^{-3} \times (-0.25) = 0.125 \times (-0.25) = -0.03125$

eg.
(1) 设浮点数字长为8位，其中阶码3位（含1位阶符），尾数5位（含1位数符），阶码和尾数均以原码表示，基数r为8，则浮点数的最大最小值分别是多少？
(2) 设定点数原码为8位，则定点数的最大最小值分别是多少？
(3) 比较 (1) 和 (2) 能得出什么结论？
- 浮点数最大值：$8^{+3}×(+0.9375)= +480$
- 浮点数最小值：$8^{+3}×(-0.9375)= -480$
- 定点数最大值：$+(2^{7}-1)= +127$
- 定点数最小值：$-(2^{7}-1)= -127$
- 结论：浮点数有效扩大了数据表示范围

### 1.7.4 **浮点数的规格化**
规格化是调整浮点数的尾数和阶码，使得尾数的有效数字集中在高位，以最大化精度。不同基数（ r ）的浮点数规格化条件不同
浮点数规格化的好处是：增加数据的表示精度（精度最高）；使浮点数的表示形式唯一
 当尾数为==补码==表示，且为 1.0xxxx形式时为规格化数。**符号位与小数点后第一位相反**
 ==原码==表示时，正数的规格化形式为0.1x···，负数的规格化形式为 1.1x···。**尾数第一位固定为 1**
 2^110ⅹ0.0111规格化右移1位，110B=6，6-1=5=101B。∴2^101ⅹ0.1110

| **基数  r ** | **规格化条件**      | **左规操作**    | **右规操作**    |
| ---------- | -------------- | ----------- | ----------- |
| **2**      | 尾数数值部分最高位为1    | 尾数左移1位，阶码减1 | 尾数右移1位，阶码加1 |
| **4**      | 尾数数值部分最高2位不全为0 | 尾数左移2位，阶码减1 | 尾数右移2位，阶码加1 |
| **8**      | 尾数数值部分最高3位不全为0 | 尾数左移3位，阶码减1 | 尾数右移3位，阶码加1 |
| **16**     | 尾数数值部分最高4位不全为0 | 尾数左移4位，阶码减1 | 尾数右移4位，阶码加1 |
1. **规格化条件**：
   - 基数  r = 2^k  时，尾数数值部分的 **最高  k  位不全为0**。
   - 例如：
     -  r = 4 = 2^2  → 最高2位不全为0。
     -  r = 8 = 2^3  → 最高3位不全为0。

2. **左规与右规操作**：
   - **左规**：尾数左移  k  位，阶码减1（确保有效数字前移）。![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329122019961.png)
   - **右规**：尾数右移  k  位，阶码加1（防止溢出或调整精度）。 ![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329122140256.png)

eg.
r=4，二进制浮点数 110.0101
- 非规格化表示
  - $4^{11}\times0.0001100101$，操作：$4^{11}$ 减1， 0.0001100101 左移2位
  - $4^{100}\times0.000001100101$ ，操作：$4^{100}$ 减2， 0.000001100101 左移4位
- 规格化表示
  - $4^{10}\times0.0110010100$
  - $4^{10}\times0.01100101000$

浮点数规格化后的表示范围：
阶码和尾数都是**原码**表示时：
- **阶码 E**（假设 k+1 位，1 位阶符 + k 位数值）：
   - **最大值**：$E_{\text{max}} = +(2^k - 1)$
   - **最小值**：$E_{\text{min}} = -(2^k - 1)$
- **尾数 M**（假设 n+1 位，1 位数符 + n 位数值）：
   - **正数范围**：$+2^{-1} \leq M \leq (1 - 2^{-n})$
   - **负数范围**：$-(1 - 2^{-n}) \leq M \leq -2^{-1}$
只有尾数的最小正数和最大负数从$2^{-n}$变成$2^{-1}$

阶码和尾数都是**补码**表示时：
- **阶码 E（k+1 位补码）**：
   - **最大值**：$E_{\text{max}} = 2^{k} - 1$
   - **最小值**：$E_{\text{min}} = -2^{k}$
- **尾数 M（n+1 位补码，定点小数）**：
   - **正数范围**：$2^{-1} \leq M \leq 1 - 2^{-n}$
   - **负数范围**：$-1 \leq M \leq -(2^{-1}+2^{-n})$

eg1.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)，将十进制数-56写成二进制定点数和浮点数(要求规格化表示)，并分别写出它们各自的机器数(原码、反码、补码)形式。![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329115350757.png)eg2.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)将十进制数 +13/128 写成二进制定点数和浮点数(要求规格化表示)，并写出它们各自的机器数(原码、反码、补码)形式。
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329115731894.png)注：$2^{-11}$是$2^{-3}$
eg3.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)，写出十进制数- 53/512对应的浮点规格化数的原码、反码和补码以及阶码用移码、尾数用补码的形式。
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329120730451.png)
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329121728139.png)

### 1.7.5 **浮点数的加减法**
**1. 对阶（对齐阶码）**
- **原则**：小阶向大阶对齐，尾数右移（差值为阶码差的绝对值）。
- **操作**：
  - 较小阶码的尾数**算术右移**（补符号位），右移位数 = 阶码差值。
  - 阶码更新为较大的阶码。
- **关键**：右移可能导致尾数低位丢失（需隐藏保留，后续舍入处理）。
**2. 尾数求和/差**
- **操作**：对阶后的尾数按**补码规则直接加减**。
- **溢出判断**：
  - 双符号位为 `01` 或 `10`：尾数溢出，需右归（见步骤3）。
  - 双符号位一致（`00` 或 `11`）：直接进入规格化。

**3. 规格化**
- **目标**：使尾数最高有效位与符号位不同（即形如 `0.1xxx` 或 `1.0xxx`）。
左-右+

| **情况**                        | **操作**            | **调整阶码**                 |
| ----------------------------- | ----------------- | ------------------------ |
| **左归**（`00.0xxx` 或 `11.1xxx`） | 尾数左移，直到最高有效位为1    | 阶码减少左移次数                 |
| **右归**（`01.xxx` 或 `10.xxx`）   | 尾数右移1位            | 阶码加1                     |
| **溢出处理**                      | 上溢（`01.xxx`）：触发异常 | 下溢（`10.xxx`）：置为机器零（阶码全0） |
**4. 舍入与最终结果**
- **舍入**：规格化后对尾数低位进行截断或舍入
  - 截断法：直接丢弃超出机器字长的尾数低位（导致误差积累）
  - 末位恒置1法：将机器字长内的尾数的最低位恒置为1（损失1位精度，但误差积累较小）
  - 0舍1入法：当需要丢弃的尾数低位中的最高位为1时，将机器字长内的尾数的最低位加1
- **阶码检查**：若阶码超出范围（上溢/下溢），按溢出规则处理。
注：如果是转补码，按隐藏符号位的最后一个1算。eg.`[x]补=11,10100(1)，[-x]补=00,01011(1)`
![7e8a9d22d02d94cba50966f9772de0f.jpg](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7e8a9d22d02d94cba50966f9772de0f.jpg)
### 1.7.6 **IEEE 754 浮点数运算**
任何一个二进制数N可表示：N=r<sup>E</sup>×M
1. 对阶 → 2. 尾数加减 → 3. 规格化 → 4. 舍入 → 5. 溢出判断 → 输出结果。
**1. 对阶（对齐阶码）**
- **阶码表示**：采用移码（偏置码），单精度偏置值为 `127`，双精度为 `1023`。
- **对齐规则**：
  - 小阶向大阶对齐，尾数**算术右移**（移位数 = 阶差绝对值），右移时隐藏位（最高位）需显式参与。
  - **移码加减规则**：阶码相加减时，需按移码运算公式处理（实际运算需转换为真值后再调整偏置值）。
**2. 尾数运算（原码运算）**
- **隐藏位处理**：
  - 运算前需恢复隐藏的 `1.`（规格化数的隐含前导1）。
  - 运算后需重新隐藏（规格化后保留前导1）。
- **运算规则**：
  - **加法**：两尾数直接相加（原码加减需处理符号位，实际硬件中可能转换为补码运算）。
  - **减法**：转换为加法（减数符号取反）。
**3. 规格化**
- **规格化条件**：尾数必须满足 `1.xxxxx...`（原码形式）。
- **规格化操作**：

| **情况**                  | **操作**      | **阶码调整** |
| ----------------------- | ----------- | -------- |
| **左规**（尾数形式为 `0.xxxx`）  | 尾数左移1位，阶码减1 | 阶码减1     |
| **右规**（尾数形式为 `1b.xxxx`） | 尾数右移1位，阶码加1 | 阶码加1     |
**4. 舍入处理**

| **模式**       | **规则**                  |
| ------------ | ----------------------- |
| **就近舍入（默认）** | 舍入到最近的数，中间值向偶数（末位为0）舍入。 |
| **朝正∞舍入**    | 结果向正无穷方向舍入（取右侧更大的可表示数）。 |
| **朝负∞舍入**    | 结果向负无穷方向舍入（取左侧更小的可表示数）。 |
| **截断（朝0舍入）** | 直接丢弃多余位，结果向0方向舍入。       |
**5. 溢出判断**
- **上溢**：
  - 阶码超过最大可表示值（单精度阶码全1，即 `11111111`，对应真值 `+127`）。
  - 结果视为 `±∞`（根据符号位）。
- **下溢**：
  - 阶码低于最小可表示值（单精度阶码全0，即 `00000000`，对应真值 `-126`）。
  - 结果视为**非规格化数**或**机器零**（尾数全0）。

**与补码浮点运算的差异**

| **特性**    | **IEEE 754**          | **补码浮点运算**                           |
| --------- | --------------------- | ------------------------------------ |
| **阶码表示**  | 移码（偏置码）               | 补码                                   |
| **尾数表示**  | 原码（隐含前导1，需显式参与运算）     | 补码（显式符号位）                            |
| **规格化规则** | 尾数必须为 `1.xxxx`        | 补码尾数最高位与符号位不同（如 `0.1xxx` 或 `1.0xxx`） |
| **舍入模式**  | 支持多种舍入方式（如就近舍入、向偶数舍入） | 通常仅截断或简单舍入                           |
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329091853718.png)
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329092307636.png)浮点数相加：![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250405194750013.png)
浮点数相乘：![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406064555148.png)
浮点数相除：![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406064740616.png)

### 1.7.7 **浮点数结构**
用**阶码（指数）** 和**尾数**表示数值，适合大范围和高精度需求。 **IEEE 754标准**
   - **单精度（32位）**：1位符号 + 8位阶码（偏置值127） + 23位尾数。$([2^{-126},(2 - 2^{-23})\times2^{127}])$
     $(2 - 2^{-23})\times2^{127}$即$2^{128}-2^{104}$
   - **双精度（64位）**：1位符号 + 11位阶码（偏置值1023） + 52位尾数。$([2^{-1022},(2 - 2^{-52})\times2^{1023}])$
   -  **阶码范围**：单精度 `-126 ~ +127`，双精度 `-1022 ~ +1023`。
   - **偏移常数**：偏移常数（Bias）用于浮点数的阶码（指数）编码，将实际指数转换为无符号整数存储。对于 n 位阶码，偏移常数为：$2^{n-1}-1$
     单精度浮点数（32位）偏移常数127
     **作用**：将实际指数范围对称分布在正负区间，避免存储负指数时使用符号位
     为什么不采用标准的128，而采用127?
     - 若偏移值为128，**最小规格化数的实际指数为-127**（对应二进制阶码`00000001`），其倒数为2^127。
     - 但单精度浮点数的最大可表示值约为2^127（指数上限为+127）。此时倒数与最大值相等，**可能引发溢出**（因符号位或特殊值冲突）。

	 - 若偏移值为127，**最小规格化数的实际指数为-126**（对应阶码`00000001`），其倒数为2^126，而单精度的指数上限仍为+127。此时倒数2^126**完全在可表示范围内**，不会溢出。
   -  IEEE 754标准中，**规格化数**的尾数有一个隐含的**最高位1**
     1. **节省存储空间**：
        实际存储的尾数部分不包含这个1（例如单精度浮点数的23位尾数），但在计算时会自动补上。这相当于“白嫖”一个额外比特，**提高精度**。
     2. **扩展动态范围**：
        隐含的1使规格化数的实际值为 1.尾数×2^指数，而非 0.尾数×2^指数，从而能表示更大的数值范围。

### 1.7.8 **特殊值**
IEEE 754定义了多种特殊值，用于处理边界情况和异常运算：

| **数值分类**      | **符号S** | **阶码E**     | **尾数M**     | **真值公式**                                      | **说明**                                                                 |
|-------------------|-----------|---------------|---------------|--------------------------------------------------|-------------------------------------------------------------------------|
| **正零（+0）**    | 0         | 全0（0）      | 0             |  +0                                          | 符号为0，表示正零。                                                     |
| **负零（-0）**    | 1         | 全0（0）      | 0             |  -0                                          | 符号为1，表示负零。实际使用中与+0等效，但符号位不同。                   |
| **非规格化正数**  | 0         | 全0（0）      |  M \neq 0  |  (-1)^0 \times 2^{-126} \times 0.M           | 用于表示接近零的极小正数，无隐藏位1，指数固定为-126。                   |
| **非规格化负数**  | 1         | 全0（0）      |  M \neq 0  |  (-1)^1 \times 2^{-126} \times 0.M           | 类似非规格化正数，但符号为负。                                          |
| **正无穷大（+∞）**| 0         | 全1（255）    | 0             |  +∞                                          | 表示数值溢出（如非零数除以0），符号为0。                                |
| **负无穷大（-∞）**| 1         | 全1（255）    | 0             |  -∞                                          | 类似正无穷大，但符号为负。                                              |
| **NaN（非数）**   | 0或1      | 全1（255）    |  M \neq 0  |  \text{NaN}                                  | 表示无效运算结果（如0/0、负数平方根），尾数非0。                        |
| **规格化正数**    | 0         |  1 \leq E \leq 254  | 任意M |  (-1)^0 \times 2^{E-127} \times 1.M          | 常规正数，隐藏位1自动补到尾数前，指数范围为-126到+127。                 |
| **规格化负数**    | 1         |  1 \leq E \leq 254  | 任意M |  (-1)^1 \times 2^{E-127} \times 1.M          | 常规负数，隐藏位1自动补到尾数前，指数范围同上。                         |
1. **正零与负零**：
   - 实际运算中两者等效（如  +0 = -0 ），但符号位不同，某些场景（如函数极限）可能区分两者。

2. **非规格化数**：
   - **作用**：
     - 解决“**阶码下溢**”问题。当数值小于最小规格化数（ $2^{-126}$ ）时，用非规格化数平缓过渡到零。
     - 避免计算结果突然归零（例如  $1.0 \times 2^{-127}$  无法用规格化数表示，但可用非规格化数  $0.5 \times 2^{-126}$ 表示）。

3. **无穷大（±∞）**：
   - **作用**：
     - 标记数值溢出（如  1.0 / 0.0 ）或不可达值。
     - 使程序在溢出时继续运行，而非直接崩溃（例如浮点数除0返回无穷大，整数除0则报错）。

4. **NaN（非数）**：
   - **作用**：
     - 表示无效运算（如  0/0 、 ∞/∞ 、负数平方根）。
     - 程序可通过检测NaN跳过错误，避免中断（例如返回NaN后继续执行后续逻辑）。

5. **规格化数**：
   - **隐藏位1**：尾数前隐含的1无需存储，节省1位空间，提升精度（例如23位尾数实际表示24位数值）。
   - **指数范围**：阶码E偏移127，实际指数范围为  $-126 \leq E \leq +127$
- **非规格化数应用**：
  计算  $1.0 \times 2^{-128}$ （远小于最小规格化数  $2^{-126}$ ），可用非规格化数表示为  $0.25 \times 2^{-126}$ 。

- **无穷大应用**：
  当计算  1.0 / 0.0  时，结果为  +∞ ，程序可继续执行后续操作（如判断结果是否为无穷大）。

- **NaN应用**：
  计算  $\sqrt{-1}$ 时返回NaN，程序员可捕获此结果并处理异常。

总结：
  - 非规格化数：缓冲极小值，避免数值突变。
  - 无穷大：标记溢出，防止程序崩溃。
  - NaN：兜底无效运算，增强容错能力。





注：
- 浮点数加减法第一步是**对阶**
  对阶的规则是：小阶向大阶看齐。即阶码小的数的尾数==算术右移==，每右移一位，阶码加 1直到两数的阶码相等为止。
  因此不存在阶码减小、尾数左移。==只有阶码增大，尾数右移==。
  对阶不会引起阶码**上溢或下溢**
  **右规、尾数舍入**时可能引起阶码**上溢**
  **左规**时可能引起阶码**下溢**
- 在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有**规格化后阶码**超出所能表示的范围时，才发生溢出。
  判断浮点数运算是否溢出，取决于阶码是否上溢。阶码下溢可以通过非规格化数来表示。尾数上溢或下溢，可以通过左移或右移进行调整。
- 与非规格化浮点数相比，采用规格化浮点数的目的主要是为了增加数据的表示精度
- 运算结果在0至规格化最小正数之间时称为正下溢，运算结果在0至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。
- **舍入**是浮点数的概念，定点数没有舍入的概念。
- 浮点数舍入的情况有两种：对阶、右规格化。
- 舍入不一定产生误差，如向下舍入11.00 到11.0时是没有误差的
- 浮点数表示中基数的值是约定好的，因此将其隐含。
- 阶移尾原
- 偏置值=2^(n-1)-1
- 阶码决定范围，尾数决定精度。在浮点数总位数不变的情况下。**阶码**位数越多，**尾数**位数越少。即**范围越大，精度越低**
- **阶码**的值决定了**小数点的位置**
- **基数**越大，在运算中尾数**右移**的可能性越小，运算的**精度损失越小**。
- 由于**基数**大时发生因对阶或尾数溢出需右移及规格化需左移的次数显著减少，因此运算**速度**可以提高。
- **基数**越大，可表示的数的**范围**越大，所表示的数的个数越多，精度降低。

- IEEE 754浮点数格式位数有限(单精度32位、双精度64位)，无法精确表示无限循环小数。


## 1.8 C语言中的数据类型及转换
无论是无符号数还是有符号数，C语言程序并不检测数据在加、减、乘等运算中产生的**溢出**现象。
程序员应尽量避免出现这种情况，所编制的应用程序应具有对溢出进行判断的功能。
char 8
short 16
int 32
long 64
float 32
double 64
65535=1111 1111 1111 1111
==都是按照补码形式存储的==
<font color="#f79646">定义的变量值是真值，存储的是补码，输出的值是真值，要把补码转成有符号位的原码</font>
eg.
unsigned short x = unsigned short = 65535;
short y = (short)x;
y存储的值是1111 1111 1111 1111，补码全为1对应的十进制真值是-1
## 1.9 有符号数与无符号数的转换
1. **转换规则**
   - 当位数相同的**有符号数**与**无符号数**相互转换时，**二进制位保持不变**，仅改变解释方式。
     注：如果是**负数**，要转换成**补码**形式。同样，如果无符号转有符号，第一位是1，是负数，也要转成补码
   - **有符号数 → 无符号数**：符号位被当作数值的一部分。
     ①若从小字长转换到大字长，则要先对原数字的高位部分进行扩展，若原数字是无符号整数，则进行零扩展；若原数字是有符号整数，则进行符号扩展。
     ②若从大字长转换到小字长，则直接截取低位部分。也就是说，先进行字长的转换，再进行符号的转换。
     ```c
     short x = -4321;
     unsigned short y = (unsigned short)x;
     // x的二进制补码：11101111 11101111
     // y被解释为无符号数：61215
     ```
   - **无符号数 → 有符号数**：最高位被当作符号位。
     ```c
     unsigned short x = 65535;  // 二进制全1
     short y = (short)x;
     // y的二进制补码10000000 00000001解释为有符号数：-1
     ```
## 1.10 不同字长整数之间的转换
1. **大字长 → 小字长（截断高位）**
   - **规则**：直接截断高位部分，保留低位部分。
     ```c
     int x = 165537;      // 0010 1000 0110 1010 0001
     short y = (short)x;  // 保留低16位，1000 0110 1010 0001 当前是补码，负数，转真值1,111 1001 0101 1111 → 十进制-31071
     ```
     ```c
     int u = -34991;      // 存储为补码，-34491全部取反+1 0,111 1111 1111 1111 0111 0111 0101 0001
     short v = (short)u;  // 保留低16位0111 0111 0101 0001 → 十进制30545
     ```
2. **小字长 → 大字长（符号扩展或零扩展）**
   - **规则**：
     - **有符号数**：进行**符号扩展**（高位填充原符号位）。
     - **无符号数**：进行**零扩展**（高位填充0）。
     ```c
     short x = -4321;      // 二进制补码：11101111 11101111（符号位1）
     int y = x;            // 符号扩展为11111111 11111111 11101111 11101111 → 十进制-4321
     ```
     ```c
     unsigned short u = 61215;  // 二进制：11101111 11101111
     unsigned int v = u;        // 零扩展为00000000 00000000 11101111 11101111 → 十进制61215
     ```
注：
1. **混合运算的隐式转换**
   - 若表达式中混合有符号和无符号数，**有符号数会被隐式转换为无符号数**，可能导致逻辑错误。
   ```c
   int a = -1;
   unsigned int b = 100;
   if (a < b) {
       // 条件为假，因为-1被转换为无符号数（即4294967295）
   }
   ```

2. **数据溢出与截断**
   - 大字长转小字长可能导致**数据丢失**（如`int`→`short`）。
   - 小字长转大字长时，需明确扩展方式以避免数值错误。  ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329144222273.png)

3. **字符型转换的特殊性**
   - `char`类型(8位)默认按无符号整数处理，转换为`int`时进行**零扩展**。


## 1.11 浮点数之间的转换
| 转换方向                   | 情况描述              |
| ---------------------- | ----------------- |
| `float` → `double`     | 值相同               |
| `double` → `float`     | 大数可能溢出，高精度发生舍入    |
| `float/double` → `int` | 小数部分向 0 截断，大数可能溢出 |
| `int` → `float`        | 比较大的数无法精确表示       |
| `int` → `double`       | 值相同               |
假设变量 `i`、`f`、`d` 的类型分别是 `int`、`float` 和 `double`，判断下列 C 语言关系表达式是否恒为真。
1. `i == (int)(float) i;`
    - 结果：不恒为真
    - 原因：`i` 转换为 `float` 型时就可能出现精度缺失，可不考虑再转回 `int` 型。
2. `f == (float)(int) f;`
    - 结果：不恒为真
    - 原因：`f` 转换为 `int` 型时就可能出现小数部分向 0 截断 ，可不考虑再转回 `float` 型。
3. `i == (int)(double) i;`
    - 结果：恒为真
    - 原因：`i` 转换为 `double` 型后数值不变，因此再转回 `int` 型后数值不变。
4. `f == (float)(double) f;`
    - 结果：恒为真
    - 原因：`f` 转换为 `double` 型后数值不变，因此再转回 `float` 型后数值不变。
5. `d == (float) d;`
    - 结果：不恒为真
    - 原因：`d` 转换为 `float` 型时可能出现大数溢出和高精度舍入。
6. `f == -(- f);`
    - 结果：恒为真
    - 原因：浮点数取负仅将其数符（最高位）取反即可。

## 1.12 数据存储和边界对齐
1. 大小端存储
   - **小端**：低对低，高对高（如 `0x1234` 存储为 `34 12`）。
   - **大端**：低对高，高对低（如 `0x1234` 存储为 `12 34`）。  ![image.png|200](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406115230806.png)指令的二进制编码按 **操作码 → 操作数 → 立即数** 的顺序排列。
   ![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406115722956.png)
   在指令编码中，操作码（Opcode）和寄存器编号按顺序连续存放。操作码 MOV 为 40H，存放在地址 1000H；寄存器 EAX 的编号为 12H，存放在地址 1001H。**立即数**按大小端规则存放在后续地址
   在阅读以小端方式存储的机器代码时，要注意字节是按相反顺序显示的。
2. 数据边界对齐存储
   **边界对齐（Alignment）** 是计算机内存管理的重要机制，要求数据在内存中的 **起始地址** 必须是其 **自身大小的整数倍**。现代计算机（尤其是 RISC 架构）普遍采用边界对齐存储，以优化访存效率。

| **数据类型**  | **对齐要求（地址必须是...的倍数）** | **32位系统示例**                   |
| --------- | --------------------- | ----------------------------- |
| 字节（char）  | 1                     | 地址任意（如 `0x0000`, `0x0001`）    |
| 半字（short） | 2                     | 地址为偶数（如 `0x0002`, `0x0004`）   |
| 字（int）    | 4                     | 地址为4的倍数（如 `0x0004`, `0x0008`） |
在 C 语言中，结构体（`struct`）的对齐需满足以下条件：
1. **成员对齐**：每个成员的起始地址必须满足 `地址 % 对齐值 = 0`。
2. **结构体对齐**：结构体总长度必须是 **最大成员对齐值** 的整数倍（不足则填充）。

eg.
**1. 结构体 A：`struct A { int a; char b; short c; }`**
- **成员对齐**：

| **地址范围**        | **内容**         | **说明**                 |
| --------------- | -------------- | ---------------------- |
| `0x0000-0x0003` | `int a`（4字节）   | 对齐到 4 的倍数（0x0000）      |
| `0x0004`        | `char b`（1字节）  | 对齐到 1 的倍数（0x0004）      |
| `0x0005`        | **填充 1 字节**    | 确保 `short c` 对齐到 2 的倍数 |
| `0x0006-0x0007` | `short c`（2字节） | 对齐到 2 的倍数（0x0006）      |
- **总大小**：
  - 实际占用：`4 + 1 + 1（填充） + 2 = 8字节`
  - 结构体对齐：最大对齐值为4，8是4的倍数，无需额外填充。

**2. 结构体 B：`struct B { char b; int a; short c; }`**
- **成员对齐**：

| **地址范围**        | **内容**         | **说明**               |
| --------------- | -------------- | -------------------- |
| `0x0000`        | `char b`（1字节）  | 对齐到 1 的倍数（0x0000）    |
| `0x0001-0x0003` | **填充 3 字节**    | 确保 `int a` 对齐到 4 的倍数 |
| `0x0004-0x0007` | `int a`（4字节）   | 对齐到 4 的倍数（0x0004）    |
| `0x0008-0x0009` | `short c`（2字节） | 对齐到 2 的倍数（0x0008）    |
| `0x000A-0x000B` | **填充 2 字节**    | 确保结构体总大小为 4 的倍数      |
- **总大小**：
  - 实际占用：`1 + 3（填充） + 4 + 2 = 10字节`
  - 结构体对齐：最大对齐值为4，10不是4的倍数，需填充2字节至12字节。

**边界对齐 vs 边界不对齐**
1. 对齐存储
- **特点**：
  - 数据按对齐要求紧密排列，填充字节插入以对齐地址。
  - **优点**：单次访存读取完整数据，效率高。
  - **缺点**：可能浪费少量空间。
2. 不对齐存储
- **特点**：
  - 数据连续存放，无填充字节。
  - **缺点**：跨存储字的数据需多次访存并拼接，效率低。


**应用场景**
- **RISC架构**：强制边界对齐，确保指令流水线高效运行。
- **嵌入式系统**：权衡空间与效率，通常选择对齐存储。
- **网络协议**：数据包按对齐格式传输，避免接收端处理复杂度。

- **结构体设计建议**：
  - 按成员对齐值降序排列（如 `int → short → char`），减少填充字节。
## 1.13 第二章错题
1. 已知 [x]补 =1,0000000，则[-x]补 是(D)
   A.0,1111111   B.0,0000001   C.1.0000000   D.无法表示
   `1,0000000`表示真值-128（最小负数）。  计算[-x]补 )，即求+128的补码。然而，8位补码的最大正数为+127，+128超出表示范围，**无法表示**。
2. 设x为真值，x* 为其绝对值，满足 [-x*]补=[-x]补 当且仅当
   A. x任意   B.x为正数   c.x为负数   D.以上都不对
   当x为正数时，x* = x，等式成立
   当x为0时，等式成立
   当x为负数时，x* = -x， [x]补≠[-x]补，等式不成立
   b是充分条件，选d
3. 由3个“1”和5个“0”组成的8位二进制补码，能表示的最小整数是()。
   A.-126   B.-125   C.-32   D.-3
   补码若符号位相同，数值位越大（即二进制中1的位数越多），码值越大。此处1位数一样，**最高位的 `1` 位置越靠左（权重越大），对应的绝对值越小，码值越大**。故补码为1000 0011，真值为-125
   刚开始想的补码1110 0000，是一个无效补码，因为补码的最小负数是`10000000`（-128），而`11100000`不是合法的补码表示。
4. 若某浮点数为$2^{11}×1.1011$，其中阶码为原码表示，尾数为补码表示，则该浮点数()
   A.需要将尾数数值部分右移1位规格化
   B.需要将尾数数值部分右移2位规格化
   C.需要将尾数数值部分左移1位规格化
   D.已经规格化
   补码负数规格化，符号位为1，则尾数最高位应为0，将尾数数值部分左移1位规格化，即为$2^{10}×1.0110$
5. -0.4375的IEEE754单精度浮点数表示为()
   A.BEE0 0000H   B.BF60 0000H    C.BF70 0000H   D.C0E0 0000H
   -0.4375=-0.0111，应该转化为$2^{-2}×(-1.11)$，S=1，E=125=01111101，M=11，选A
6. 有如下C语言程序段：short si=-32767;unsigned short usi = si;执行上述两条语句后，usi的值为()。
   A.-32767   B.32767   C.32768   D.32769
   因为si是负数，先转换成补码形式1000 0000 0000 0001，转换成无符号数后为32769
7.  unsigned short usi=65535:short si = usi;执行上述程序段后，si的值为()。
    A.-1   B.-32767   C.-32768   D.-65535
    1111 1111 1111 1111，第一个1看作符号位，负数，转补码，即1000 0000 0000 0001，-1
8. 一个C语言程序在一台32位机器上运行。程序中定义了三个变量x，y和z，x和z为int型，y为short型当x=127，y=-9时，执行赋值语句z=x+y后，x，y和z的值分别是()。
   A.x=0000007FH，y=FFF9H，2=00000076H
   B.x=0000007FH，y=FFF9H，Z=FFFF0076H
   C.x=0000007FH，y=FFF7H，Z=FFFF0076H
   D.X=0000007FH，y=FFF7H，2=00000076H
   `x` 为 `int` 型（32位），赋值为 `127`，其补码为0x0000007\text{F}
   `y` 为 `short` 型（16位），赋值为 `-9`，其补码为0xFFF7
   `y` 从 `short` 提升为 `int` 时，进行符号扩展0xFFFFFFF7
   执行 `z = x + y`：  $\begin{align*}0x0000007\text{F} & \quad (\text{十进制 } 127) \\+\,0xFFFFFFF7 & \quad (\text{十进制 } -9) \\\hline0x00000076 & \quad (\text{十进制 } 118)\end{align*}$ d
9. 对于相同位数(设为N位，不考虑符号位)的二进制补码小数和十进制小数，二进制小数能表示的数的个数/十进制小数所能表示数的个数为()。
   A.$(0.2)^N$   B.$(0.2)^{N-1}$  C.$(0.02)^N$   D.$0.02^{N-1}$
   N位二进制小数共有2^N种状态，每种状态都能表示一个不同的小数，而十进制小数能表示的数的个数为 10^N，二者的商为(0.2)^N
10. 下列关于补码和移码关系的叙述中，()是不正确的。
    A.相同位数的补码和移码表示具有相同的数据表示范围
    B.0的补码和移码表示相同
    C.同一个数的补码和移码表示，其数值部分相同，而符号相反
    D.一般用移码表示浮点数的阶码，而补码表示定点整数
    0的补码是0000 0000，0的移码是1000 0000，选b
11. 一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则下列说法中正确的是()。
    A.若采用移码表示，偏置值为127，则此整数最小为-64
    B若采用移码表示，偏置值为128，则此整数最大为123
    C.若采用补码表示，则此整数最小为-96
    D.若采用补码表示，则此整数最大为 252
    当采用补码表示时，要使得数值最大，就要让符号位为0，且把“1”放在高位，得到的补码为01111110B=126
    要使得数值最小，就要让符号位为1，且把“1”放在低位，得到的补码为 10011111B=-97。
    当采用移码表示时，设偏置值为128，要使数值最大，就要把“1”放在高位，得到的移码为11111100B，转补码是0111 1100=124
    设偏置值为127，要使得数值最小，则应把“1”放在低位，得到的移码为 0,011 1111B，【错误：转补码是1,011 1111B，转原码是1,100 0001B=-65。移码和补码的转换仅适用于特定场景】，真值=移码值−偏置值=63−127=−64，A 正确。
12. 在计算机中，通常用来表示主存地址的是()
    A.移码   B.补码   C.原码   D.无符号数
    主存地址都是正数，因此不需要符号位，因此直接采用无符号数表示。
13. ALU作为运算器的核心部件，其属于()
    A.时序逻辑电路 B.组合逻辑电路 C.控制器 D.寄存器
    ALU 是由组合逻辑电路构成的，最基本的部件是并行加法器。单纯的ALU 不能够存储运算结果和中间变量，因此往往将 ALU 和寄存器或暂存器相连。
14. 下列四个补码整数存放于8位寄存器中，算术左移不会发生溢出的是()。A. 80H  B. 90H  C.B0H  D.C0H
    80H=(1000 0000)<<1=00000000，左移前的符号位为1，左移后的符号位为0，溢出；90H=(10010000)<<1=0010 0000，左移前的符号位为1，左移后的符号位为0，溢出；B0H=(1011 0000)<<1=01100000，左移前的符号位为1，左移后的符号位为0，溢出。C0H=(11000000)<<1=10000000，左移前的符号位为1，左移后的符号位为1，未溢出，选项D正确。
15. 设机器数字长8位(含1位符号位)，若机器数BAH为补码，算术左移1位和算术右移1位分别得()。
    A. F4H,EDH  B. B4H,6DH  C.74H,DDH  D. BSH,EDH
    题目中有机器数、寄存器等用机器移动，符号位和数值位一起移。BAH=(10111010)，算术左移1位得(01110100)= 74H，左移前后的符号位不同，溢出；算术右移1位得(1101 1101)= DDH。
16. 在定点运算器中，无论是采用双符号位还是采用单符号位，必须有()。
    A.译码电路，它一般用“与非”门来实现
    B.编码电路，它一般用“或非”门来实现
    C.溢出判断电路，它一般用“异或”门来实现
    D.移位电路，它一般用“与或非”门来实现
    无论采用单符号位还是双符号位，运算器必须包含**溢出判断电路OF=Cn​⊕Cn−1​**
    - **译码电路（A）**：用于指令译码，属于控制单元功能，非运算器必需。
    - **编码电路（B）**：用于信号编码，非运算核心部件。
    - **移位电路（D）**：乘除运算需要移位，但纯加减运算无需移位，非必需。
17. 机器运算发生溢出的根本原因是()
    A.寄存器的位数有限                 B.运算中将符号位的进位丢弃
    C.运算中将符号位的借位丢弃  D.数据运算中发生错误
    a
18. 关于模4补码，下列说法正确的是()。
    A.模4补码和模2补码不同，它不容易检查乘除运算中的溢出问题B.每个模4补码存储时只需一个符号位
    C.存储每个模4 补码需要两个符号位
    D.模4补码，在算术与逻辑单元中为一个符号位
    模4补码（即双符号位补码）是一种用于检测运算溢出的编码方式。c
19. 某计算机字长为8位，CPU中有一个8位加法器。已知无符号数x=69，y=38，若在该加法器中计算x-y，则加法器的两个输入端信息和输入的低位进位信息分别为()。
    A.01000101、00100110、0
    B.01000101、11011001、1
    C.01000101、11011010、0
    D.01000101、11011010、1
    x=01000101，y=00100110，-y的补码=11011010，低位进位Sub为1，d
20. 某8位计算机中，x和y是两个有符号整数，用补码表示，[x]补=44H，[y]补=DCH，则x-2y的机器数及相应的溢出标志OF分别是()。
    [x]补=44H = 01000100，[y]补=DCH = 11011100。执行 x - 2y 时，先将 y 算术左移一位，得到 10111000，未溢出，然后各位取反，再与 x 相加，做减法时 sub = 1，即 01000100+01000111 + 1=10001100(8CH)，两个加数的符号都为 0，而结果的符号为 1，因此发生了溢出，即 OF = 1。
21. 某C语言代码段如下:
    ``` C
    int si=65536;
    short i=si;
    unsigned j=0;
    if(i<=j-1) printf("王道");
    else printf("计算机教育");
    ```
    当上述代码段执行到i分支条件的判断时，会根据标志寄存器中的()决定执行顺序最终的输出结果是()。
    A.CF、王道   B.CF.计算机教育   C.OF,王道   D.OF，计算机教育
    **`int si = 65536`**：00000000 00000001 00000000 00000000
    **`short i = si`**：截取低16位 `0x0000`，转换为有符号 `short`，值为 **0**。
    **`unsigned j = 0`**：`j-1` 为 `0-1`，无符号运算结果为 `UINT_MAX`（如32位为 `4294967295`）。
    **比较 `i <= j-1`**：
     - 有符号 `i`（0）转换为无符号 `0`，与无符号 `j-1`（`UINT_MAX`）比较。
     - **无符号比较规则**：通过进位标志 `CF` 判断。若 `a <= b`，则 `CF=1`（借位）或 `ZF=1`（相等）。
     - 此处 `0 <= UINT_MAX` 为真，触发 `CF=1`，条件成立。

	   - **CF（进位标志）**：无符号比较时，`CF=1` 表示被减数小于减数。
	   - **OF（溢出标志）**：有符号运算溢出时触发，此处不适用。
	     **A. CF、王道**。
22. 【2024 统考真题】C语言代码段如下，执行该代码段后，j的值是()。int i=32777;short si=i;int j=si;
    A.-32777   B.-32759   C.32759   D.32777
    2^15=32768，i=000...0 1000000000001001，将32 位有符号数i强制转换为 16 位有符号数si机器数为1000000000001001，补码1,111111111110111，si=-32759。
23. 设机器数字长8位(含1位符号位)，若机器数BAH为原码，算术左移1位和算术右移1位分别得()。
    A. F4H,EDH   B. B4H,6DH   C.F4H,9DH   D.BSH,EDH
    若机器数 BAH为补码，其余条件同上题，则有
    A.F4H, DDH   B.B4H,6DH   C.F4H,9DH   D. BSH,EDH
    BA=1,0111010
    原码时：算数左移1,1110100 FAH；算数右移1,0011101 9DH
    补码时：算术左移1,1110100 FAH；算数右移1,1011101 DDH
24. 在规格化浮点运算中，若某浮点数为2^5x1.10101，其中尾数为补码表示，则该数()。
    A.不需规格化                          B.需右移规格化
    C.需将尾数左移一位规格化   D.需将尾数左移两位规格化
    补码浮点数规格化应该形如 1.0xxx，尾数左移1位，变为 1.01010，2^4×1.01010。c
25. 下列关于对阶操作说法正确的是()
    A.在浮点加减运算的对阶操作中，若阶码减小，则尾数左移
    B.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移；若阶码减小，则尾数左移
    C.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移
    D.以上都不对
    对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况，因此选项 A、B 错误。选c
26. 若某单精度浮点数、某原码、某补码、某移码的 32 位机器数均为 0xF0000000，则这些数从大到小的顺序是()
    A.浮原补移   B.浮移补原   C.移原补浮   D.移补原浮
    x=1111 000…0，浮点数=-2^113；原码=-111 000…0=-1879048192；补码=-0001 000…0=-268435456；移码=x-128=1,879,048,192
    选d
27. 已知 foat 型采用 IEEE 754单精度浮点格式,若x、y为foat型变量,且x=-126,y= 15.75,则执行语句 z=x+y时，在浮点运算单元中进行对阶操作后的结果是()
    A.x不变，y为010000101,0.001111110...0
    B.x不变，y为010000110,0.001111110...0
    C.y不变，x为 110000101,0.001111110..0
    D.y不变，x为 110000110,0.001111110...0
    -126 = -1.11111 × 2^6，阶码：`6 + 127 = 133 → 10000101`
    15.75 = 1.11111 × 2^3，阶码：`3 + 127 = 130 → 10000010`
    y是小阶，要向大阶6对齐，y的尾数相应右移3位，变为0.00111111B
    a
28. 在 IEEE 754 标准浮点格式中，非规格化浮点数表示为
    A.阶码为 0，尾数为任意非0的二进制数
    B.阶码为 255，尾数全为 0
    C.阶码为 255，尾数为任意非0的二进制数
    D.阶码为 0，尾数全为 0
    在 IEEE 754 标准格式中，阶码全为0，尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行下去。
29. 假设已定义三个 int 型变量 x、y和 z，sizeof(int)=4，double 型采用 IEEE 754 双精度浮点数格式，变量 dx、dy 和 dz 的声明和初始化如下：double dx=(double)x;double dy=(double)y;double dz=(double)z;则下列关系表达式中永远为真的是()。
    I. dx+ dy == (double)(x+y)
    Il. dx × dx >= 0
    III. dx/dx == dy/dy
    IV.(dx + dy)+ dz== dx + (dy + dz)
    A. I和 II   B.II和III   C.III和IV   D.II和IV
    选项I非永真，因为x+y可能溢出，而 dx+dy 不会溢出。如果是dx+ dy == (double)x+(double)y正确；选项Ⅱ永真，符号和数值部分分开计算，不管结果是否溢出，都不会影响乘积的符号；选项III非永真，dx 和 dy 中只要有一个为 0、另一个不为0 就不相等；选项 IV 永真，因为dx、dy 和 dz 是由 32 位 int 型转换得到的，double 型可以精确地表示 int 型，且对阶时尾数移动位数不会超过 52 位，因此尾数不会舍入，于是不会发生大数吃小数的情况。
30. 在按字节编址的计算机中，采用小端方式存储数据，某静态二维数组b的声明如下：`static short b[2][4]={{2,9,-1,5},{3,1,-6,2}};`若b的首地址为 0x8049820，采用按行优先存储，地址0x804982c中的内容是()
    A. FAH   B. FFH   C.00H   D.05H
    short型占2字节，采用按行优先存储，`b[0][0]`的地址为 0x8049820，`b[0][1]`的地址为 0x8049822，以此类推，`b[1][2]`的地址为 0x804982c。d对应值为-6，补码表示为 1111 1111 1111 1010，FFFAH，采用小端方式存储，因此地址 0x804982c存放的是低位字节 FAH。
31. 在按字节编址的 32 位计算机中，按边界对齐方式为以下结构型变量x分配存储空间：
    ```
    struct cont info{
	    char id;
	    unsigned post;
	    char phone;
	}x;
	```
	若x的首地址为 0x8049820，则成员变量phone的起始地址为()
	A.0x8049828   B.0x8049826   C.0x8049825   D.0x8049822
	char放到0x8049820，unsigned默认是unsigned int，起始地址应该是4的整数倍，0x8049821不可以，往后直到0x8049824可以，占四个字节，char是0x8049828
32. 【2009 统考真题】浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7(均含2位符号位)。若有两个数X=2^7×29/32和Y=2^5×5/8，则用浮点加法计算X+Y的最终结果是( )。
    A.001111100010   B.001110100010
    C.010000010001   D.发生溢出
    29的二进制是11101，尾数共7位，写成0011101，除32，即2^5，定点整数的小数点在最后，即0011101.，向左移动五位，00,11101，X=00,111;00,11101
    5的二进制是101，扩展位数0000101，向左3位，即0000,101，前面多的0省略并补充位数，即00,10100，Y=00.101;00,10100
    对阶：Y=00,111;00,00101
    尾数相加：01,00010
    规格化：右规，即01,000;00,10001(0)，阶码01，溢出，d
33. 【2014 统考真题】float 型数据常用 IEEE 754 单精度浮点格式表示。假设两个 foat 型变量x和y分别存放在 32位寄存器和12中,若(fl)=CC90 0000H,(f2)=B0C0 0000H,则x和y之间的关系为()
    A.x<y且符号相同      B. x<y 且符号不同
    C.x>y且符号相同      D.x>y且符号不同
    x，y都是负数，(f1)和(12)对应的二进制分别是(110011001001.),和(101100001100...)，(f1)的绝对值为 1.001×2^26，(f2)的绝对值为 1.1×2^-30，(1)的绝对值比(12)的绝对值大，而符号为负，真值大小相反，即(f1)的真值比(f2)的真值小，即 x<y。a
34. 【2018 统考真题】某 32 位计算机按字节编址，采用小端方式。若语句“inti=0:”对应指令的机器代码为“C7 45 FC 00 00 00 00”，则语句“inti=-64:”对应指令的机器代码是()。
    A. C7 45 FC CO FF FF FF   B. C 45 FC OC FF FF FF
    C. C7 45 FC FF FF FF CO   D. C7 45 FC FF FF FF OC
