---
title: 计算机组成原理（一）
categories:
  - 计算机基础
  - 专业课
tags:
  - c
  - 计算机组成原理
description: 计算机组成原理
swiper_index: 1
# abbrlink: 79666db
date: 2025-04-07 21:11:00
---
# 计算机系统概述
## 计算机系统的组成
计算机系统由**硬件系统**和**软件系统**共同组成，两者协同工作。
系统性能取决于**硬件与软件的综合能力**
结构：
- 软件
  - **系统软件（中间层）**
    - 管理硬件资源，为应用软件提供运行环境。
	- **分类**：
	    - **操作系统**：Windows、Linux、macOS（资源调度核心）
	    - **语言处理程序**：编译器（GCC）、解释器（Python）、汇编器
	    - **数据库管理系统（DBMS）**：MySQL、Oracle
	    - **服务程序**：调试工具、磁盘清理工具、诊断程序
	    - **网络系统**：网络协议栈、通信管理软件、路由器固件

  - **应用软件（最上层）**
    - 面向用户解决特定领域的问题
	- **分类**：
	    - **通用软件**：Office（文字/表格处理）、Photoshop（图像处理）
	    - **行业软件**：AutoCAD（工程设计）、MATLAB（科学计算）
	    - **事务管理**：ERP系统、财务软件
- **硬件系统（最底层）**
  - **主机**
    - **中央处理器（CPU）**：运算器、控制器、寄存器
    - **主存储器（内存）**：RAM、ROM
    - **系统总线**：数据总线、地址总线、控制总线
   - **外部设备**
    - **输入设备**：键盘、鼠标、摄像头
    - **输出设备**：显示器、打印机
    - **辅助存储器**：硬盘、SSD、U盘
>计算机系统性能的好坏，取决于硬件和软件功能的总和。
>计算机的工作特点是==快速性、准确性、通用性、逻辑性==
>当前世界上计算机用途中领域的==应用数据处理==占的比例最大
>微型计算机的发展以==微处理器==技术为标志
>v：寄存器 >Cache>内存

## 计算机的发展
第一台真正意义上的电子数字计算机——ABC
第一台实用的电子数字计算机——ENIAC
### 计算机硬件的发展
计算机的逻辑器件：==电子管(真空管)→晶体管→中小规模集成电路→大规模、超大规模集成电路==
以==元器件的更新==作为计算机技术进步和划分时代的主要标志
体积越小，功耗越低，可靠性越高，速度越快
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326084316978.png)

| 发展阶段               | 使用器件     | 运算速度（次 / 秒） | 主存（内存）      | 辅存（外存）          | 特点                                       |
| ------------------ | -------- | ----------- | ----------- | --------------- | ---------------------------------------- |
| 第 1 代（1946-1957 年） | 电子管（真空管） | 几千～几万       | 水银延迟线、磁鼓、磁芯 | 穿孔卡片、穿孔纸带       | 使用机器语言编程，无操作系统                           |
| 第 2 代（1958-1964 年） | 晶体管      | 几十万～几百万     | 磁芯          | 磁鼓、磁带、磁盘        | 主要用汇编语言，开始使用 FORTRAN、COBOL 等高级语言，单道批处理系统 |
| 第 3 代（1965-1971 年） | 集成电路     | 几百万～几千万     | 半导体存储器      | 磁带、磁盘           | 高级语言发展，出现 B 语言，多道批处理系统、分时系统              |
| 第 4 代（1972 至今）     | 超大规模集成电路 | 几十亿～几千亿     | 半导体存储器      | 磁盘、磁带、光盘、半导体存储器 | 各种高级语言（如 C/C++、Java、Python），现代操作系统       |
### 计算机软件的发展
- **编程语言**
  - **机器语言**
    用==二进制代码==表示的计算机能==直接==识别和执行的一种机器指令的集合。唯一能被硬件直接执行的语言，成为目标程序
  - **汇编语言**
    用**助记符**（如`MOV`, `ADD`）代替机器指令，与机器码**一一对应**，基本保留了机器语言的灵活性，但仍依赖硬件架构
  - **高级语言**
    面向用户的语言，通过**抽象**隐藏硬件细节，与具体机器无关
    - **编译型**（如C/C++）：
    源代码 → **编译器** → 直接生成**机器码**（或先转为汇编代码再汇编） → 链接为可执行文件（如.exe）。
	- **解释型**（如Python、JavaScript）：
    解释器逐行翻译并**边解释边执行**，无独立机器码文件。
	- **混合型**（如Java）：
    源代码 → 编译为**中间码**（如字节码） → 由虚拟机（JVM）解释/即时编译（JIT）执行。
  - **面向对象**
    高级语言的**范式演进**，以“对象”为核心组织代码（如C++、Java）
- **操作系统**
  - 提供了**在汇编语言和高级语言的使用和实现过程中所需的某些基本操作**
  - 负责**控制并管理计算机系统的全部硬件资源**（eg.CPU、内存、外部设备）和**软件资源**（eg.编译程序、应用程序）

程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器指令，由计算机最终执行。

高级语言程序转换为机器语言程序，即**翻译程序**：
编译、汇编、解释程序可统称翻译程序

| **类型**   | **输入**  | **输出**   | **特点**             | **示例语言**          |
| -------- | ------- | -------- | ------------------ | ----------------- |
| **汇编程序** | 汇编语言源代码 | 机器码目标文件  | 一对一翻译，依赖硬件架构       | x86汇编、ARM汇编       |
| **编译程序** | 高级语言源代码 | 汇编/机器码文件 | 整体翻译，生成独立可执行文件.exe | C、C++、Go          |
| **解释程序** | 高级语言源代码 | 直接执行     | 逐行翻译，无独立机器码        | Python、JavaScript |
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327160427749.png)
<font color="#ff0000">预处理→编译→汇编→链接</font>
1. **预处理（Preprocessing）**
    - 预处理器(cpp)对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以i为扩展名的源程序 hello.i。
2. **编译（Compilation）**
    - 编译器(ccl)对预处理后的源程序进行编译，生成一个**汇编语言源程序** hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。
3. **汇编（Assembly）**
    - 汇编器将汇编代码转为**机器码目标文件**（`.o`或`.obj`）。汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一个称为可重定位目标代码文件 hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。
4. **链接（Linking）**
    - 链接器(ld)将多个可重定位目标代码文件和标准库函数合并为一个可执行目标文件，简称可执行文件。本例中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。

注：
- v:==编译程序>解释程序==
  解释程序需要便翻译成机器语言边执行，故速度比机器语言慢

当前计算机的发展趋势
- 更微型化：低耗能，较高性能，多用途
- 更巨型化：超高速，并行处理，智能化


## 计算机硬件
冯·诺依曼结构（也称普林斯顿结构）是计算机设计的理论基础，其核心思想是“**存储程序**”，即程序指令和数据共同存储在存储器中，由控制器按顺序自动执行。
**存储程序原理**：
- **核心思想**：
  - 程序与数据**预先存入主存**，启动后计算机自动逐条执行指令，无需人工干预。
  - **按地址访问**：通过指令中的地址码定位存储单元，而非按内容寻址（相联存储器为特例，按内容或地址选择地址，成为按内容寻址的寄存器，不属冯氏结构基础）

冯诺依曼计算机主要特点：
1. 指令和数据均采用二进制表示
   - **形式无区分**：指令和数据均以**二进制形式**存储在**存储器**中，计算机通过**执行阶段**区分二者。【指令和数据在内存中可以有各种进制==表示==，但是==存放==的必须是二进制】
     在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。
     1)二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位制造成本比较低，例如用高、低电平或电荷的正、负极性都可以很方便地表示0和1。
     2)二进制位 1和 0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。
     3)进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。
  - **取指阶段**：从存储器中读取的是**指令**（由操作码和地址码组成）。
  - **执行阶段**：根据指令中的地址码访问**数据**或目标地址。
2. 指令和数据存放在存储器中，按地址访问。
3. 指令在存储器中按**顺序**存放。一般情况下，指令是顺序执行的。
   - **指令结构**：
  - **操作码**：指明操作类型（如取数、存数、加、减、乘、除、跳转）。
  - **地址码**：指明操作数在存储器中的位置（地址）或直接数据。

6. 机器以**运算器**为中心，输入/输出设备与存储器间的数据传送通过运算器完成，浪费很多可以用于运算的时间
   **现代改进**：当代计算机以**存储器为中心**，输入/输出可通过**DMA（直接内存访问）** 绕过CPU，提升效率。
7. 计算机硬件由**运算器、控制器、存储器、输入设备/输出设备**5大部件组成。
   > **注**：现代计算机中，运算器与控制器集成在**CPU**中，存储器主要指**主存（内存）**。
   > **内存由存储单元组成**，每个单元有唯一地址，而非由寄存器构成。
   > 存储器中可存地址（如指针变量），但地址本质是存储单元的编号。
8.  **指令流驱动**：程序执行流程由指令序列控制，PC指向当前指令地址，顺序执行或跳转。

控制器与其他部件之间通过控制器和反馈线相连，这些部件需要在控制器的控制下协调工作
图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制ALU 执行什么运算，可以控制主存是进行读操作还是写操作(读/写控制信号)。
但是这种设计，每次IO操作都需要运算器参与，浪费了很多可以用于运算的时间![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093328099.png)![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326094434509.png)
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093400793.png)
现代计算机以存储器为核心
可以让IO设备直接与存储器交换数据，以提高整体效率![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326094617374.png)控制器核心为控制单元CU(Control Unit)，主要功能如下：
- 用于解释存储器中的指令，并发出各种操作命令来执行指令。
- I/O设备也受CU控制，用于完成相应的输入/输出操作。
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093441775.png)![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093454858.png)![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326095110873.png)主机细化：![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327101101923.png)

### 相关术语
![image.png|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326112214285.png)
1. <font color="#ff0000">主机</font> = **CPU + 内存 + 系统总线**（部分定义包含I/O接口）
   **输入输出接口（I/O接口）**：属于主机与外部设备（如键盘、打印机）的**桥梁**，严格来说属于主机的一部分，但外设本身（如硬盘、显示器）不算主机。
2. **<font color="#ff0000">存储器</font>**
   - **内存（主存、主存储器）**： 临时存储正在运行的程序和数据（断电丢失），相当于办公桌。CPU可以直接访问主存储器
     - 存储体
     - MAR
     - MDR
       随着硬件技术的发展，内存都制成大规模集成电路芯片，而将==MAR和MDR集成到了CPU芯片中==
   - **外存（辅助存储器、外存储器）**：例如硬盘、U盘，长期保存文件（断电不丢），相当于文件柜。
     辅助存储器中的信息必须调入主存后，才能为CPU所访问。
3. **<font color="#ff0000">CPU</font>（中央处理器）**：计算机的“大脑”，负责计算和控制，核心由**运算器（ALU）** 和 **控制器（CU）** 组成，通过**寄存器**实现高速数据存取【运算器和控制器中都有寄存器】
    - **<font color="#ff0000">运算器</font>**：
      - **算术逻辑单元ALU**：执行定点或浮点的算术==运算操作（加减乘除）及逻辑操作（与、或、非、异或、比较、移位），也可执行地址的运算和转换。==属于组合逻辑电路
	      - 结构
	        - **加法器**：实现二进制加法，是ALU的基础单元。
		    - **选择逻辑**：通过控制信号选择输入数据（如两个操作数），决定执行何种运算。
			- **输出控制**：支持结果直接传输或移位（如左移、右移）。
	      - **重要性**：计算机性能的关键，因为大部分数据处理依赖ALU的运算速度。
      - 相关寄存器
        - **累加器ACC**，一种**专用寄存器**（非ALU直接部件），用于暂存ALU**前一次运算的结果**或**初始操作数（被加数/被减数）**，在加减法中作为运算的基准值。（例如：执行`A = A + B`时，累加器存放`A`的值）
        - **乘商寄存器MQ**：在乘法和除法运算中，存储乘数、商或中间结果。
        - **操作数寄存器X**：用于临时存储**从主存或指令中获取的第二个操作数（加数、减数、乘数）**
        - **标志寄存器PSW**：也称程序状态寄存器，存放ALU运算得到的一些标志信息或处理机的状态信息，如溢出、进位或借位、结果正负、零标志，是条件执行的基础
			- **进位标志**：加法结果超过位数时标记（如99+1=100，进位了）
			- **零标志**：结果是否为0。
        - 变址寄存器IX
        - 基址寄存器BR
        前三个是必备的
    - **<font color="#ff0000">控制器</font>**：计算机的神经中枢，指挥各个部件自动协调工作。
      核心流程为**1. 从内存取指令（取指） → 2. 分析指令（分析） → 3. 发信号让运算器/内存干活（执行）**![image.png|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326112932395.png)
	  - **核心组件**：
		- **程序计数器（PC）**：存放下一条指令的==地址==，有自动+1功能（指令长度）<u>与主存的MAR间有一条直接通路</u> 寄存信息、计数功能
		- **指令寄存器（IR）**：==存放从存储器取出的当前指令，内容来自主存的MDR。==指令中的操作码（用OP(IR)表示）送至 CU（OP(IR)→CU），用以**分析指令**并发出各种微操作命令序列；而地址码 Ad(IR)送往MAR，用以取操作数。
			- 暂存当前执行的指令
				- 分离 操作码OP和地址码 Ad
				    - OP送入控制单元CU，解码
				    - Ad用于定位操作数在内存中的地址
				- **取指阶段**：IR 接收从内存读取的指令。
			    - **执行阶段**：IR 提供操作码和地址码，驱动 CPU 完成操作（如运算、存数等）
		  注：
		  IR指令寄存器IR用来存放**当前的指令**，IR的内容来自存储器数据寄存器MDR。
		  程序计数器PC用来存放**当前欲执行指令的地址**，PC与存储器地址寄存器MAR之间有一条直接通路。PC自动形成下一条指令的地址(“自动加1”功能)
		- **控制单元（CU）**：==分析==存储器中的指令，并发出各种操作命令来执行指令。
		- **指令译码器**：解析指令的操作码（如“加法”）和地址码（如“操作数位置”）。
		- **时序部件**：生成时钟信号，同步各操作步骤。
		- **操作控制部件**：根据译码结果，向ALU、内存等发送控制信号（如“开始加法运算”）。
		- **中断机构**：处理外部紧急事件（如用户按下键盘）。
	   - 相关寄存器
    - <font color="#ff0000">寄存器</font>：CPU内部的“高速临时存储单元”，直接参与运算和控制，速度远快于内存。
       - **分类**：
        - **通用寄存器（GPRs）**：由若干个寄存器组成，早期就是累加器
	        - 存储临时数据或中间结果（如计算`(a+b)*c`时，存放`a+b`的结果）。
	        - 用户可通过编程直接访问（如x86中的`EAX`、`EBX`）。

4. **<font color="#ff0000">总线</font>（Bus）**：在计算机中连接CPU和其他芯片的导线的集合
    - 1. **地址总线AB**
	   - **寻址空间**：地址总线的位数（宽度）决定了CPU可访问的**内存地址空间**。
	    - 若地址总线为 n 位，则寻址空间为 2^n **个存储单元**。
	    - **示例**：
	      - 20位地址总线 → 2^{20} = 1,048,576 个存储单元（即1MB，若每个单元为1字节）。
	  - **存储容量**：存储器的总容量由**地址空间 × 存储单元大小**决定
	    - 若地址总线为16位（2^{16}=65536 单元），且每个单元为8位（1字节），则总容量为 **64KB**。
	  - **CPU操作**：CPU通过地址总线发送地址信号，选中目标存储单元或I/O设备。
	- **2. 数据总线（Data Bus, DB）**
	  - **机器字长**：数据总线的宽度通常等于CPU的**机器字长**，即一次能处理的二进制位数（如32位、64位）。
	    - 机器字长决定了通用寄存器的位数和ALU的运算能力（如64位CPU可一次处理64位数据）。
	  - **并行传输能力**：数据总线的宽度直接影响CPU与外界的数据传输速度。
	    - **示例**：
	      - 16位数据总线 → 一次传输2字节。
	      - 32位数据总线 → 一次传输4字节。
	  - **速度影响**：数据总线越宽，单次传输数据量越大，整体传输速率越高（速率 = 总线宽度 × 时钟频率）。
	- **3. 控制总线（Control Bus, CB）**
	  - **控制信号传输**：负责传递CPU与外部设备间的控制信号，包括：
	    - **读写命令**：如内存读（MEMR）、内存写（MEMW）。
	    - **中断请求**：如IRQ（中断请求）、NMI（不可屏蔽中断）。
	    - **总线仲裁**：如总线请求（BUSRQ）、总线响应（BUSAK）。
	    - **状态信号**：如就绪（READY）、复位（RESET）。
	  - **控制能力**：控制总线的宽度决定了可独立传输的控制信号种类数量。
	    - 更多的控制线允许更复杂的协调操作（如多设备并行管理）。

注：
**地址总线位数**决定可寻址的**存储单元数量**（2^n），而**数据总线宽度**决定每个单元的**数据位宽**（如8位、16位）。
  - **示例**：
    - 16位地址总线 + 8位数据总线 → 地址空间为 2^{16}=65536 单元，每个单元8位，总容量为 **64KB**。
    - 16位地址总线 + 32位数据总线 → 地址空间仍为65536单元，但每个单元32位，总容量为 **256KB**。
  - **结论**：地址空间仅由地址总线位数决定，与数据总线宽度无关。

| **总线类型** | **核心作用**  | **决定因素**     | **典型关联概念**    |
| -------- | --------- | ------------ | ------------- |
| **地址总线** | 指定存储单元位置  | 寻址空间（2^n 单元） | 存储容量、内存地址范围   |
| **数据总线** | 传输操作数/结果  | 机器字长、数据传输速度  | 通用寄存器、ALU运算能力 |
| **控制总线** | 协调操作与状态同步 | 控制信号种类与复杂度   | 中断管理、总线仲裁     |
- **AB、DB、CB协同工作**：地址总线定位数据位置，数据总线传输数据内容，控制总线确保操作时序与协调。
- **性能平衡**：地址总线宽度决定内存容量，数据总线宽度影响处理速度，控制总线复杂度决定系统灵活性。
5. **指令集体系结构**（ISA）：
   - **核心作用**：
    - **硬件与软件的接口**，定义计算机可执行的所有指令集合。
    - 规定指令的操作类型、操作数地址空间及数据类型（如x86、ARM指令集）。
   - **层级位置**：
    - 位于计算机系统层次结构的**软件与硬件之间**，是软件可见的最低层。
- **关键特性**：
    - **软件可见性**：程序员通过ISA编写代码，无需关心底层硬件细节。

| **寄存器/部件**      | **可见性**       | **说明**                 |
| --------------- | ------------- | ---------------------- |
| **MAR、MDR、IR**  | 不可见（对程序员透明）   | 由硬件自动控制，用户无法直接访问。      |
| **PC（程序计数器）**   | 部分可见（汇编程序员可见） | 可通过分支指令间接操作（如JMP）。     |
| **状态寄存器（Flag）** | 汇编程序员可见       | 通过条件码控制程序流程（如JZ、JC）。   |
| **通用寄存器（GPRs）** | 汇编程序员可见       | 直接参与数据运算（如ADD R1, R2）。 |
计算机基本的结构模型
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327122211999.png)
设主存储器容量为 64Kx32位，且指令字长、存储字长、机器字长三者相等。写出各寄存器的位数，并指出哪些寄存器之间有信息通路。
**各寄存器位数分析**：
1. **与地址相关的寄存器**：
   - **MAR（存储器地址寄存器）**：主存容量为64K（$2^{16}$），地址总线宽度为 **16位**。
   - **PC（程序计数器）**：存放指令地址，与MAR一致，为 **16位**。

2. **与数据相关的寄存器**：
   - **MDR（存储器数据寄存器）**：存储字长为32位，数据总线宽度为32位，故MDR为 **32位**。
   - **IR（指令寄存器）**：指令字长=存储字长=32位，故IR为 **32位**。
   - **ACC（累加器）、MQ（乘商寄存器）、X（操作数寄存器）**：机器字长=32位，均为 **32位**。

**寄存器间的信息通路**：
1. **取指令阶段**：
   - **PC → MAR**：程序计数器将指令地址发送至MAR，用于访存取指。
   - **MDR → IR**：从内存取出的指令通过MDR传送到IR。

2. **执行阶段**：
   - **Ad(IR) → MAR**：指令中的地址字段（如访存地址）从IR提取后发送至MAR。
   - **MDR → ACC**（取数操作）：内存读取的数据通过MDR传送到ACC。
   - **ACC → MDR**（存数操作）：ACC中的数据通过MDR写入内存。


## 计算机系统的层次结构
系统中的每一层都向其上层提供一个简洁和抽象的接口
每一层的实现细节对其上层而言都是“看不见”的，也就是透明的。
计算机解决问题的过程就是层次结构中的各层逐层转换的过程。
- **下层是上层的基础**（硬件 → 系统软件 → 应用软件）
- **上层拓展下层功能**（应用软件通过系统软件操作硬件）
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326085951572.png)
---
**1. 硬件层（最底层）**
- **组成**：由逻辑门、寄存器、ALU、总线等物理电路构成。
- **功能**：直接执行二进制指令（机器码），完成基本逻辑运算与数据存储。
- **特点**：完全依赖物理硬件，无抽象接口。

**2. 微程序层**
- **组成**：微程序控制器，包含微指令序列。
- **功能**：
  - 将复杂机器指令分解为**微操作**（如取数、运算、存数）。
  - 通过微指令控制硬件电路的时序与动作。
- **示例**：一条`ADD`指令可能对应多步微操作（从寄存器取数 → ALU计算 → 结果写回）。

**3. 指令系统层（机器语言层）**
- **组成**：机器指令集（如x86、ARM指令集）。
- **功能**：
  - 定义计算机可执行的所有机器指令（如`MOV`, `JMP`）。
  - 规定指令的操作类型、操作数位置及数据类型。
- **特点**：程序员需熟悉具体机器的指令格式与硬件结构。

**4. 操作系统层**
- **组成**：内核、设备驱动、系统调用接口。
- **功能**：
  - 管理硬件资源（CPU调度、内存分配、I/O控制）。
  - 为上层应用提供统一的系统服务（如文件读写、进程管理）。
- **开发要求**：
  - 需深入理解指令集、汇编语言及系统级编程语言（如C）。

**5. 汇编语言层**
- **组成**：助记符（如`ADD`, `MOV`）与目标机器指令一一对应。
- **功能**：
  - 提供机器指令的符号化表示，简化编程。
  - 需通过**汇编器**转换为机器码。
- **特点**：
  - 程序员仍需熟悉硬件细节（如寄存器布局、内存寻址）。

**6. 高级语言层（最顶层）**
- **组成**：与机器无关的编程语言（如Python、Java、C++）。
- **功能**：
  - 通过抽象语法（如变量、循环）隐藏硬件细节。
  - 程序通过**编译器/解释器**转换为机器码。
- **开发要求**：
  - 仅需掌握语法规则、算法与数据结构，无需了解底层硬件。

**各层特点对比**

| **层级** | **抽象程度** | **依赖硬件细节** | **开发复杂度** |
| ------ | -------- | ---------- | --------- |
| 高级语言层  | 最高       | 无          | 最低        |
| 汇编语言层  | 低        | 高          | 高         |
| 操作系统层  | 中        | 中          | 中         |
| 指令系统层  | 低        | 极高         | 极高        |
| 硬件层    | 无        | 完全依赖       | 最高        |
  - 硬件层与微程序层实现物理计算能力。
  - 操作系统层管理资源并向上提供接口。
  - 汇编/高级语言层构建用户可编程的软件生态。

>硬件和软件==逻辑==上有等价性，硬件执行**速度高**，软件**灵活**
>软件的功能可以用硬件取代

| **特性**    | **硬件实现**               | **软件实现**            |
| --------- | ---------------------- | ------------------- |
| **性能与速度** | 高（专用电路并行处理，如ASIC、FPGA） | 低（依赖通用CPU串行执行）      |
| **灵活性**   | 低（功能固化，修改需重新设计电路）      | 高（代码可动态更新，适应新需求）    |
| **开发成本**  | 高（需定制芯片设计、流片费用）        | 低（编写代码，复用通用硬件）      |
| **适用场景**  | 高频交易、实时信号处理、密码学加速      | 操作系统、应用软件、动态调整功能的场景 |
### 存储过程
- 主存储器：包含存储体、MAR、MDR
	- **存储体**：
	  - 由若干个**存储单元**组成
	    - 每个存储单元由若干个**存储元件**组成
	      - 每个存储元件能存储1位二进制数0/1
	    - 一个存储单元中可存储一串二进制信息，称这串二进制信息为一个**存储字**，这串二进制信息的位数称为**存储字长**（可以是8位、16位或32位等）
	   - 给每个存储单元都赋予一个编号，称为**存储单元的地址**
	- **内存地址寄存器（MAR）**
	   - 功能：
		- 保存**数据目标地址**或**数据源地址**，用于寻址主存单元。
		- **连接存储器与地址总线**，传递地址信号。
	   - 物理实现：
		- 集成于CPU中，但逻辑上属于**主存储器**的组成部分。
	   - 位数与容量：
		- **位数 = 存储单元地址数量**（如10位MAR支持2^10=1024个存储单元，即1KB），反应最多可寻址的存储单元个数
		  存储单元：存放一串二进制代码，存储器一次操作的基本单位。
		- ==MAR长度与**PC（程序计数器）** 一致==，决定寻址空间。
	- **内存数据寄存器（MDR）**：
	  **临时缓存从主存（内存）读取或写入的数据或指令**，充当 CPU 与主存之间的**数据中转站**
	   - **读取数据时**：暂存从主存读取的指令或操作数。
       - **写入数据时**：暂存待写入主存的数据。
	   - 功能：
		- 是CPU与主存之间的**唯一数据通道**
		- **连接存储器与数据总线**，传输数据信号。
	  - 物理实现：
		- 集成于CPU中，逻辑上属于**主存储器**的组成部分。
	   - 位数与字长：
		- **位数 = 存储字长**（如32位MDR对应32位存储单元）。
		  存储字长：存储单元中二进制代码的位数每个存储单元赋予一个地址号
		- 一般为字节（8位）的整数倍（如32位、64位）。

eg1.MAR=4位，MDR=8位
存储单元个数16，存储字长8位
eg2.若存储字长为8位，MAR的位数(长度)为16位，则存储体的总容量
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327120211029.png)

**主存储器的核心组件**
主存储器是计算机中用于存储程序和数据的关键部件，其核心功能是通过地址访问存储单元，完成数据的读写操作。
**主存储器按地址存取**：通过MAR指定地址，MDR暂存数据，存储体存储二进制信息。

|**组件**|**功能**|**说明**|
|---|---|---|
|**存储体**|存储二进制数据，由多个存储单元构成，每个单元有唯一地址。|每个存储单元的大小通常为1字节（8位），地址范围由地址总线的宽度决定。|
|**地址寄存器MAR**|存放当前要访问的存储单元的地址。|MAR（Memory Address Register）接收来自CPU或总线的地址信号。|
|**数据寄存器MDR**|暂存从存储器读出的数据或待写入存储器的数据。|MDR（Memory Data Register）在读写操作中作为数据缓冲，确保数据稳定传输。|
|**时序控制逻辑**|产生存储器操作所需的控制信号（如读/写信号、片选信号），协调各部件时序。|控制逻辑根据CPU指令生成时序信号，确保操作按步骤执行。|
![image.png|350](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326113413143.png) **读操作流程（MAR→存储体→MDR→CPU）**
1. **加载地址**：CPU将目标地址送入**MAR**。
2. **发出读命令**：时序控制逻辑生成**读信号**（Read Enable）。
3. **数据读取**：存储体根据MAR中的地址定位存储单元，将数据送入**MDR**。
4. **数据传输**：CPU从MDR中读取数据。


**写操作流程（CPU→MDR→MAR→存储体）**
1. **加载地址与数据**：CPU将目标地址送入**MAR**，待写数据送入**MDR**。
2. **发出写命令**：时序控制逻辑生成**写信号**（Write Enable）。
3. **数据写入**：存储体根据MAR中的地址定位存储单元，将MDR中的数据写入该单元。

**时序控制逻辑的作用**
- **同步操作**：确保地址加载、数据读写等步骤按严格时序执行。
    - 例如：在读取时，MAR地址稳定后，才允许存储体输出数据到MDR。
- **信号生成**：
    - **读信号（RE）**：允许存储体输出数据到MDR。
    - **写信号（WE）**：允许MDR数据写入存储体。
    - **片选信号（CS）**：在多存储器模块中选择目标模块。

eg.假设CPU执行指令 `LOAD [0x1000]`（读取地址0x1000的数据）：
1. CPU将地址`0x1000`写入MAR。
2. 时序逻辑发出读信号，存储体将地址`0x1000`对应的数据送入MDR。
3. CPU从MDR中读取数据并存入寄存器（如AX）。


CPU通过PC和MAR向存储器发去取指令请求(发送指令地址)并且把读信号送到控制线上，一起告诉存储器要读哪一个地方的信息；
读出来的信息传到MDR，如果是指令则传到IR；如果是数据就送到寄存器，再送到ALU计算，或者直接送到ALU。

==**计算机如何分辨此时取出的是数据还是指令呢？**==
根据==指令周期==的不同阶段判断。
在**取指令**阶段取出的是**指令**，在**执行**指令阶段取出的是**数据**。

## 计算机的基本工作原理
### 计算机硬件组成的细化
#### 加减乘除操作
  - **累加器ACC**，一种**专用寄存器**（非ALU直接部件），用于暂存ALU**前一次运算的结果**或**初始操作数（被加数/被减数/被乘数/乘机高位/被除数/余数）**，在加减法中作为运算的基准值。（例如：执行`A = A + B`时，累加器存放`A`的值）
- **乘商寄存器MQ**：在乘法和除法运算中，存储**乘数/商/乘积低位**。
	- **乘法存储逻辑**：
	  - 乘法结果的位数通常是操作数的两倍（如 8位 × 8位 → 16位），因此需两个寄存器存储。
	  - **ACC存储高位，MQ存储低位**
		例如：`5 (ACC) × 3 (MQ)` → 结果为 `15`，高位 `0`（若为 8位系统）存 `ACC`，低位 `15` 存 `MQ`。
	  - **X存储被乘数**
		在乘法前，`ACC` 的被乘数需暂存至 `X`，以便释放 `ACC` 存储结果高位。
	- **除法存储逻辑**：
	  - **ACC存储余数，MQ存储商**：
		例如：`15 ÷ 4` → 商为 `3`（存 `MQ`），余数 `3`（存 `ACC`）。
	  - **X存储除数**：从主存加载除数到 `X`，保证除法操作的稳定性。
- **操作数寄存器X**：用于临时存储**从主存或指令中获取的第二个操作数（加数/减数/乘数/除数）**

| 寄存器     | 加法      | 减法      | 乘法             | 除法       |
| ------- | ------- | ------- | -------------- | -------- |
| **ACC** | 被加数 → 和 | 被减数 → 差 | 被乘数（操作前）→ 乘积高位 | 被除数 → 余数 |
| **MQ**  | —       | —       | 乘数（操作前）→ 乘积低位  | → 商      |
| **X**   | 加数      | 减数      | 被乘数（从ACC复制）    | 除数       |
M 表示主存储器中某个存储单元的地址
(M)表示地址为M的存储单元中的内容
ACC 表示累加器
(ACC)表示累加器中的内容
MQ 表示乘商寄存器
(MQ)表示乘商寄存器中的内容
X表示操作数寄存器
(X)表示操作数寄存器中的内容
- 加法操作过程
  1. (M)→X：从主存地址 M 取出内容（加数），送入操作数寄存器 X
  2. (ACC)+(X)→ACC：累加器 ACC 中的被加数与 X 中的加数相加，结果（和）存回 ACC。
- 减法操作过程
  1. (M)→ X
  2. (ACC)-(X)→ACC
- 乘法操作过程
  1. (M) → MQ：取出存放在主存中地址为M的存储单元中的内容(M)(乘数)，送到乘商寄存器MQ中
  2. (ACC)→X：将累加器ACC中的内容(ACC)(被乘数)，送到操作数寄存器X中
  3. (X) x (MQ)→ ACC // MQ：将操作数寄存器X中的内容(X)(被乘数)与乘商寄存器MQ中的内容(MQ)(乘数)相乘结果(积)的高位保留在累加器ACC中，低位保留在乘商寄存器MQ中
- 除法操作过程
  1. (M)->X
  2. (ACC) ÷ (X)→ MQ

共同点：取出存放在主存储器中地址为M的存储单元中的内容(M)，送到某个寄存器中

y = a * b + c
a=2,b=3,c=1,y=0
![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327101752137.png)
注：
1. 程序执行前，由于冯诺依曼“存储程序”的思想，先将程序的机器指令序列（操作码+地址码）存放到存储体
2. 程序执行前，先将程序的第一条指令的地址存放到PC中，PC=0，
3. 任何指令的执行都从**取指令**开始，此时 CPU 需要从内存中读取指令。因此，取指令阶段固定为**读操作**
4. 执行阶段由操作码决定读/写
5. **MAR**：仅用于存储地址，不参与数据处理。
6. **MDR**：作为 CPU 与主存间的数据缓冲，所有读写均需经过 MDR。

**执行流程**：
1. 取数 `a` 至 ACC
	- **指令地址**：`0`（PC=0）
	- **步骤**：
	  1. **取指令**：
	     - `(PC=0) → MAR`，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。
	     - `M(MAR) → MDR`，从内存地址 `0` 读取指令 `000001 0000000101`（操作码 `取数`，地址码 `5`）。
	     - `(MDR) → IR`，指令存入指令寄存器。
	     - `(PC) + 1 → PC`，PC 自增为 `1`。![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327105809223.png)
	  2. **分析指令**：
	     - `OP(IR) → CU`，控制单元识别为“取数”指令。
	  3. **执行指令**：
	     - `Ad(IR)=5 → MAR`，将IR中保存的指令地址码送至内存的MAR中，对内存进行寻址，并命令内存做读操作。
	     - `M(MAR) → MDR`，从地址 `5` 读取数据 `a=2`送入MDR。
	     - `(MDR) → ACC`，将 `a=2` 存入累加器 ACC。

2. 乘法 `a * b`，结果存于 ACC
	- **指令地址**：`1`（PC=1）
	- **步骤**：
	  1. **取指令**：
	     - `(PC) → MAR`，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。
	     - `M(MAR) → MDR`，读取指令 `000100 0000000110`（操作码 `乘法`，地址码 `6`）。
	     - `(MDR) → IR`，指令存入指令寄存器。
	     - `(PC) + 1 → PC`，PC 自增为 `2`。
	  2. **分析指令**：
	     - `OP(IR) → CU`，控制单元识别为“乘法”指令。
	  3. **执行指令**：
	     - `Ad(IR)=6 → MAR`，发送地址 `6` 到内存。
	     - `M(MAR) → MDR`，从地址 `6` 读取数据 `b=3`。
	     - `(MDR) → MQ`，将 `b=3` 存入乘商寄存器 MQ。
	     - `(ACC)=2 → X`，将 ACC 的值 `2` 送入 X 寄存器。
	     - `(MQ)*(X) → ACC`，ALU 执行 X * MQ，结果为 `6`，存入 ACC
3. 加法 `a * b + c`，结果存于 ACC
	- **指令地址**：`2`（PC=2）
	- **步骤**：
	  1. **取指令**：
	     - `(PC=2) → MAR`，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。
	     - `M(MAR) → MDR`，读取指令 `000011 0000000111`（操作码 `加法`，地址码 `7`）。
	     - `(MDR) → IR`，指令存入指令寄存器。
	     - `(PC) + 1 → PC`，PC 自增为 `3`。
	  2. **分析指令**：
	     - `OP(IR) → CU`，控制单元识别为“加法”指令。
	  3. **执行指令**：
	     - `Ad(IR)=7 → MAR`，发送地址 `7` 到内存。
	     - `M(MAR) → MDR`，从地址 `7` 读取数据 `c=1`。
	     - `(MDR) → X`，将 `c=1` 送入 X 寄存器。
	     - `(ACC)+(X) → ACC`，ALU 执行 ACC + X，结果为 `6 + 1 = 7`，存入 ACC。
4. 存数 `a * b + c` 至主存单元 `y`
	- **指令地址**：`3`（PC=3）
	- **步骤**：
	  1. **取指令**：
	     - `(PC) → MAR`，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。
	     - `M(MAR) → MDR`，读取指令 `000010 0000001000`（操作码 `存数`，地址码 `8`）。
	     - `(MDR) → IR`，指令存入指令寄存器。
	     - `(PC) + 1 → PC`，PC 自增为 `4`。
	  2. **分析指令**：
	     - `OP(IR) → CU`，控制单元识别为“存数”指令。
	  3. **执行指令**：
	     - `Ad(IR)=8 → MAR`，发送地址 `8` 到内存。
	     - `(ACC)=7 → MDR`，将 ACC 的值 `7` 存入 MDR。
	     - `(MDR) → M(MAR)`，将 `7` 写入内存地址 `8`（存储变量 `y`）。
5. 停机
	- **指令地址**：`4`（PC=4）
	- **步骤**：
	  1. **取指令**：
	     - `(PC=4) → MAR`，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。
	     - `M(MAR) → MDR`，读取指令 `000110 0000000000`（操作码 `停机`）。
	     - `(MDR) → IR`，指令存入指令寄存器。
	     - `(PC) + 1 → PC`，PC 自增为 `5`。
	  2. **分析指令**：
	     - `OP(IR) → CU`，控制单元识别为“停机”指令。
	  3. **执行指令**：
	     - CPU 终止当前进程，结果 `y=7` 已存入内存地址 `8`。

**最终结果**
- **内存地址 `8`**：存储 `y=7`。
- **寄存器状态**：
  - `ACC=7`，`MQ=3`（乘法中间值），`X=1`（加法操作数）。
  - `PC=5`，指向下一条指令地址（已停机）。

![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327110944602.png)
#### **1. 取指令阶段**
**目标**：将下一条指令从主存读取到指令寄存器（IR）。
**步骤**：
1. **PC → MAR**
   - **操作**：将程序计数器（PC）当前存储的指令地址送入内存地址寄存器（MAR）。
   - **说明**：`PC→MAR` 表示 `(PC)`（PC 中存储的值）通过数据通路传递到 MAR。
2. **MAR → 地址线，控制器发送读信号**
   - **操作**：MAR 的内容被送至地址线，控制器向主存发送读信号。
   - **说明**：主存根据地址线上的地址和读信号，定位存储单元。
3. **主存 → 数据线 → MDR**
   - **操作**：主存将指定地址的指令通过数据线传输到内存数据寄存器（MDR）。
4. **MDR → IR**
   - **操作**：MDR 中的指令被送入指令寄存器（IR）。
   - **结果**：IR 中存储当前待执行的指令。
5. **更新 PC**
   - **操作**：`(PC) + 1 → PC`，为取下一条指令准备地址。
   - **注意**：
     - **括号不可省略**：运算时必须写为 `(PC)+1→PC`，表示对 PC 的值进行运算。
     - **数据通路省略**：`PC→MAR` 可简写，但运算表达式需严格保留括号。
#### **2. 分析指令阶段**
**目标**：解码指令并生成控制信号。
**步骤**：
1. **OP(IR) → CU**
   - **操作**：从 IR 中提取操作码（OP），送入控制单元（CU）。
2. **CU 译码与生成控制信号**
   - **操作**：CU 根据操作码生成对应的控制信号，分发到各执行部件。
   - **示例**（取数指令）：
     - CU 生成“读主存”信号，激活总线控制线，准备读取操作数。

#### **3. 执行指令阶段**
**目标**：执行当前指令的操作（以取数指令为例）。
**步骤**：
1. **Ad(IR) → MAR**
   - **操作**：将 IR 中的地址码（操作数地址）送入 MAR。
   - **示例**：若指令为 `取数a至ACC`，地址码指向变量 `a` 的存储地址。
2. **MAR → 地址线，控制器发送读信号**
   - **操作**：主存根据 MAR 中的地址和读信号，定位操作数存储单元。
3. **主存 → 数据线 → MDR**
   - **操作**：主存将操作数通过数据线传输到 MDR。
4. **MDR → ACC**
   - **操作**：MDR 中的操作数被送入累加器（ACC）。
   - **结果**：ACC 中存储了所需的数据（如 `a=2`）。

### 常见指令
`LOAD` 指令是计算机体系结构中的一种**数据传输指令**，其核心功能是**将数据从内存（主存）加载到CPU的寄存器中**。例如，在汇编语言中，`LOAD R1, [0x1000]` 表示将内存地址 `0x1000` 处的数据加载到寄存器 `R1` 中。
`LOAD` 指令的执行遵循经典的 **5 阶段指令周期**：
1. **取指（Fetch）**
   - CPU 根据程序计数器（PC）的值，从内存中读取指令（如 `LOAD R1, [0x1000]`）到指令寄存器（IR）。
   - PC 自动递增，指向下一条指令地址。

2. **译码（Decode）**
   - 控制单元（CU）解析指令的操作码（`LOAD`），确定操作类型。
   - 提取目标寄存器（`R1`）和内存地址（`0x1000`）。

3. **执行（Execute）**
   - 将内存地址 `0x1000` 写入存储器地址寄存器（MAR）。
   - 生成读信号（Read Enable），通知内存准备数据。

4. **访存（Memory Access）**
   - 内存根据 MAR 中的地址定位存储单元，将数据送至存储器数据寄存器（MDR）。

5. **写回（Write Back）**
   - 将 MDR 中的数据写入目标寄存器 `R1`，完成加载操作。
1. **不同寻址方式对 `LOAD` 指令的影响**
`LOAD` 指令的具体行为取决于其使用的**寻址方式**：
- **直接寻址**
  指令中直接包含内存地址（如 `LOAD R1, [0x1000]`）。
  **优点**：简单直观。
  **缺点**：地址固定，灵活性低。

- **间接寻址**
  指令中的地址指向另一个内存地址（如 `LOAD R1, [[R2]]`）。
  **优点**：支持动态地址计算。
  **缺点**：需要多次访存，速度较慢。

- **寄存器间接寻址**
  地址存储在寄存器中（如 `LOAD R1, [R2]`）。
  **优点**：高效灵活，适合循环遍历数组。

- **立即数寻址**
  指令直接包含数据（如 `LOAD R1, #42`）。
  **注**：严格来说，这属于加载立即数到寄存器，而非内存操作。
1. **`LAD X, ACC`（Load Address to ACC）**
   - **功能**：将主存地址 `X` 的内容加载到累加器 ACC。
   - **操作**：
     $R[\text{ACC}] \leftarrow M[X]$
   - **硬件流程**：
     - 将 `X`（地址码）送入 MAR，读取主存数据到 MDR，再传输到 ACC。

2. **`SUB ACC, Z`（Subtract）**
   - **功能**：从 ACC 中减去主存地址 `Z` 的值，结果存回 ACC。
   - **操作**：
     $R[\text{ACC}] \leftarrow R[\text{ACC}] - M[Z]$
   - **硬件流程**：
     - 读取 `Z` 的值到 MDR → 送入 ALU 的 X 寄存器 → ALU 执行减法 → 结果存回 ACC。
**取值周期（Fetch Cycle）**
**目标**：从主存中读取下一条指令到 IR，并更新 PC。
**步骤**：
1. **`PC → BUS → MAR`**
   - 程序计数器（PC）的值通过总线送至内存地址寄存器（MAR）。
2. **`M(MAR) → 数据线 → MDR`**
   - 主存根据 MAR 的地址，通过数据总线将指令送入内存数据寄存器（MDR）。
   - **控制信号**：控制器发送 **读信号（MemRead=1）**。
3. **`MDR → BUS → IR`**
   - MDR 中的指令通过总线送入指令寄存器（IR）。
4. **`(PC) + 1 → PC`**
   - PC 自增，指向下一条指令的地址。

**执行周期（Execute Cycle）**
##### **1. `LAD X, ACC` 的执行流程**
1. **`Ad(IR) → BUS → MAR`**
   - 将 IR 中的地址码 `X` 送入 MAR。
2. **`M(MAR) → 数据线 → MDR`**
   - 主存根据 MAR 的地址，通过数据总线将数据送入 MDR。
   - **控制信号**：控制器发送 **读信号（MemRead=1）**。
3. **`MDR → BUS → ACC`**
   - MDR 中的数据通过总线送入累加器 ACC。

##### **2. `SUB ACC, Z` 的执行流程**
1. **`Ad(IR) → BUS → MAR`**
   - 将 IR 中的地址码 `Z` 送入 MAR。
2. **`M(MAR) → 数据线 → MDR`**
   - 主存根据 MAR 的地址，读取 `Z` 的值到 MDR。
3. **`MDR → X`**
   - MDR 的值送入 ALU 的输入寄存器 X。
4. **`ALU 执行减法运算**
   - ALU 计算 `ACC - X`，结果存回 ACC。


	 - `LAD`、`SUB` 等涉及数据加载的指令 → 读操作（`MemRead=1`）。
     - `STO`（存数指令） → 写操作（`MemWrite=1`）。
2. **总线控制**：
   - 数据总线在取值和执行阶段分别传输指令和数据。
   - 地址总线始终由 MAR 驱动。

##### **1. 操作数的加载是否必须通过主存？**
- **否**：
  - 操作数可直接来自寄存器（如 `ADD R1, R2`），无需访问主存。
  - 若操作数在主存中（如 `ADD [M]`），则需通过 `X` 或 `MQ` 中转。
- **示例对比**：
  - **直接寄存器操作**：`ADD ACC, X`（假设指令支持）。
  - **主存操作**：`ADD [M]` → `(M)→X → (ACC)+(X)→ACC`。

##### **2. 加法实例**
- **指令**：`ADD [0x1000]`
- **步骤**：
  1. 从主存地址 `0x1000` 加载数据到 `X`（如 `X=5`）。
  2. `ACC` 中的值（如 `ACC=10`）与 `X` 相加，结果存回 `ACC`（`ACC=15`）。

##### **3. 乘法实例**
- **指令**：`MUL [0x2000]`
- **步骤**：
  1. 从主存地址 `0x2000` 加载乘数到 `MQ`（如 `MQ=3`）。
  2. 将 `ACC` 中的被乘数（如 `ACC=5`）暂存到 `X`。
  3. 执行乘法：`X=5` × `MQ=3` → 结果高位 `0`（ACC）、低位 `15`（MQ）。

##### **4. 除法实例**
- **指令**：`DIV [0x3000]`
- **步骤**：
  1. 从主存地址 `0x3000` 加载除数到 `X`（如 `X=4`）。
  2. `ACC` 中的被除数（如 `ACC=15`）除以 `X=4` → 商 `3`（MQ），余数 `3`（ACC）。

## 计算机系统的性能指标
计算机系统的性能指标是用来衡量计算机系统在各种操作和任务中的**工作效率、执行速度以及处理能力**的标准。
计算机系统的性能指标可以**帮助人们评估计算机系统**的整体表现，从而更好地了解系统**在不同方面的优势和限制**
计算机系统的性能指标与硬件和软件都有关
- 硬件与计算机系统性能的关系
  - 硬件是构建计算机系统的**物理组件**(例如CPU、内存、外部设备等)。
  - 硬件对于计算机系统的性能有着重要影响，因为它决定了系统的<font color="#ff0000">计算能力、数据传输速率和存储容量</font>。
    - CPU的时钟频率决定了CPU每秒钟可以执行的指令数量。
	- 内存带宽会影响数据的读写速率。

- 软件与计算机系统性能的关系
  - 软件包括用于控制、管理、应用计算机系统的各类系统软件和应用软件。
  - 软件的优化可以显著影响计算机系统的性能，因为**合理的算法和代码**实现可以**更有效地利用硬件资源**。
    - 操作系统的调度算法会影响多任务处理的效率，从而影响系统的响应时间。
    - 在图像处理任务中，优化的软件算法可以减轻CPU和内存的负担，提高图形处理速度。
    - 软件层面的并行计算可以更好地利用多核处理器，提高吞吐量。

- **硬件是性能的上限**，决定了系统的理论能力。
- **软件是性能的下限**，决定了硬件的实际利用率。
- **软硬件协同优化**是提升计算机系统性能的核心路径。
### 计算机硬件相关性能指标
#### 基本性能指标
1. **机器字长**
2. **主存容量**
3. **吞吐量**
4. **响应时间**

#### 与运行速度相关的性能指标
1. **CPU时钟频率和时钟周期**
2. **CPI**
3. **CPU执行时间**
4. **IPC**
5. **MIPS**
6. **MFLOPS**

概念解释：
1. **机器字长（字长）**
   - **定义**：计算机一次能处理的二进制位数（如32位、64位），即b的数量。
     ==机器字长 = 用于整数运算的ALU位数 = 通用寄存器宽度 = 数据总线宽度==
     - 数据总线宽度（数据字长）= 数据总线一次能并行传送信息的位数（如32位总线一次传输4字节）
   - 早期：指令字长（一个指令字中包含的二进制代码的位数）=存储字长（一个存储单元存储的二进制代码的长度）=机器字长
     - 随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。
     - 若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令
     - 若指令字长等于存储字长（如均为32位），单次访存即可取指，此时**取指周期=机器周期**。
   - **影响**：
     - 字长越长，**数的表示范围**就越大、**精度**也越高。
	    - **无符号整数**：0∼2<sup>n</sup>−1（n 为字长）。
	    - **有符号整数**：−2<sup>n−1</sup>∼2<sup>n−1</sup>−1
        - **单精度（32位）**：指数8位，尾数23位，范围约 ±10<sup>38</sup>
		- **双精度（64位）**：指数11位，尾数52位，范围约 ±10<sup>308</sup>
     - 字长越长，**计算精度**也越高
       字长越长，小数部分的位数越多，精度越高。
     - 字长还会影响**计算速度**
     - **数据处理能力**：字长越大，单次处理的数据量越大。
     - **地址空间**：32位系统最大支持4GB内存，64位系统支持更大内存。
     - **硬件复杂度**：字长增加可能提高电路复杂度。

2. **主存容量**
   - **定义**：主存储器（内存）的总存储容量，通常以GB或TB为单位。
   - **公式**：
       **主存容量=N×M**(位，即比特b)
       M：主存中存储单元的总数量。
       N：每个存储单元可存储的二进制位数（如8位、64位）。![image.png|400](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327161644732.png)
   增加主存(内存)容量可以**减少**程序运行期间对**辅存**(外存)的访问，由于访问内存的速度远大于访问外存的速度，因此可以提高程序的**执行速度**，进而提高计算机系统的性能。

3. **吞吐量**
   - **定义**：<font color="#ff0000">单位时间内系统完成的任务量</font>（如每秒处理请求数），系统吞吐量<font color="#f79646">主要取决于主存的存取周期</font>。
   - **影响因素**：
     - CPU的处理能力
     - 内存（主存）的访问速度
     - 外存的访问速度

4. **响应时间**
   - **定义**：从向计算机系统<font color="#ff0000">提交作业开始</font>，到系统<font color="#ff0000">完成作业为止所需要的时间</font>（包括CPU处理、I/O等待等）。
   - 通常把用户感觉到的响应时间分成以下两个时间：
     - CPU时间：运行一个程序所花费的时间
        - **CPU执行时间**：执行用户程序本身所花费的CPU时间（一般基于此对性能评价）
	    - 系统CPU时间：为执行用户程序而花费在操作系统上的时间
     - 其他时间（等待时间）：用户访问内存(主存)、外存(辅存)、其他外部设备所花费的时间
   - 系统性能和CPU性能有一定的区别：
	- 系统性能：系统响应时间，与CPU外的其他部分也有关系
	- CPU性能：用户CPU时间，即CPU执行时间
	  主频、CPI和指令条数是相互制约的

5. **CPU时钟频率与时钟周期**
   - **时钟频率**：CPU每秒的时钟周期数（单位：Hz，如3.0 GHz）
     比喻：每秒敲鼓次数。
      频率越高，CPU“敲鼓”越快，理论上干活速度更快。
   - **时钟周期**：每个**脉冲信号**的时间，单个时钟周期的时间（$T = \frac{1}{\text{频率}}$），如3.0 GHz对应0.333 ns），是==CPU中最小的时间单位==，执行指令的每个动作至少需要1个时钟周期。
     时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成。
     时钟周期以相邻状态单元间组合逻辑电路的最大延迟时间为基准确定。
     时钟周期也以指令流水线的每个流水段的最大延迟时间确定。
     比喻：每次敲鼓的时间间隔，比如鼓手每0.3秒敲一次
     周期越短，每个动作越快完成
   - **作用**：对于同类型的计算机，同一指令执行所需的CPU时钟周期的数量是一样的，因此CPU的时钟频率越高，该指令的执行速度就越快。![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327130641138.png)
6. **CPI（Cycles Per Instruction）**
   [计算机组成原理作业- CPU性能含解答 - 道客巴巴 (doc88.com)](https://www.doc88.com/p-38199244559254.html)
   - **定义**：==执行一条指令所需的平均时钟周期数。==
     不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其 CPI指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，即平均CPI。
     比喻：炒一盘菜平均需要几次操作
     CPI越低效率越高
   - **计算**：
     $\text{CPI} = \frac{\text{总时钟周期数}}{\text{总指令数}}$
     $CPI = \sum_{i=1}^{n} (CPI_i \times P_i)$ Pi是相应指令所占比例
     $总周期 = Σ(指令条数 × CPI)$
   - **优化**：通过流水线、超标量等技术降低CPI。
   -  **系统结构、指令集、计算机组织**都会影响 CPI，而**时钟频率**并不会影响CPI，但缩短每个时钟周期的时间，可加快指令的执行速度。
7. **CPU执行时间**
  即运行一个程序所花费的时间
   - **公式**：
     $\text{执行时间} = \text{总时钟周期数} \times \text{时钟周期}$
     $\text{执行时间} = \text{总指令数} \times \text{CPI} \times \text{时钟周期}$
     比喻：做一桌菜的总时间 = 菜的数量 × 每道菜的步骤 × 每步的时间
   - CPU性能（CPU执行时间）取决于：主频、CPI、指令条数【三者相互制约】
   - **缩短程序执行时间**：
     - 减少指令数（算法优化）
     - 降低CPI（架构优化）
     - 提高频率（硬件升级）
     - 优化数据通路结构，可以有效提高计算机系统的吞吐量
     - 编译优化

5. **IPC**（每个周期能做多少事，衡量指令执行速度）
   - **定义**：每个时钟周期执行的指令数，与CPI互为倒数（$\text{IPC} = \frac{1}{\text{CPI}}$）。
     比喻：每个动作能炒几盘菜
   - **示例**：CPI=0.5 → IPC=2，表示每个周期执行2条指令，高效。IPC越高，效率越高
5. **IPS**（每秒能做多少事，即）
   IPC 表示每个时钟周期可运行的指令的数量，IPS 表示**每秒可运行的指令的数量**，$IPS = 频率 × IPC=频率  / 平均CPI$
   IPS越高，说明CPU处理指令的速度越快

10. **MIPS（Million Instructions Per Second）**
   - **每秒执行百万条指令数**，衡量CPU的**整数运算吞吐量**。
     越大，性能越高
   - **公式**： $\text{MIPS} = \frac{\text{时钟频率} \times \text{IPC}}{10^6} = \frac{\text{总指令数}}{\text{执行时间} \times 10^6}$
   - 用MIPS对不同的机器进行性能比较有时是不准确的主要原因如下。
     - 不同机器的指令集不同，并且指令的功能也不同，在某种机器上的某一条指令的功能可能在另一种机器上需要用多条指令来实现,
     - 不同机器的CPI和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同

10. **MFLOPS（Million Floating-Point Operations Per Second）**
   - **每秒百万次浮点运算**，衡量浮点计算能力。
   - 用于==科学计算的计算机中，是标志系统性能最有用的参数 ==
   - **计算**：$\text{MFLOPS} = \frac{\text{浮点操作总数}}{\text{执行时间} \times 10^6}$
   - MFLOPS不能全面反映计算机系统的性能。MFLOPS仅反映浮点运算速度，其值与所使用的测试程序相关。不同测试程序中包含的浮点运算量不同，测试得到的结果也不相同。
   ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327153330760.png)GTPEZ
采用并行技术是实现高性能计算的重要途径，现今超级计算机均采用多处理器来增强并行处理能力。
### **指标间的关系与权衡**

| **指标**          | **优化策略**         | **实际应用中的权衡**              |
| --------------- | ---------------- | ------------------------- |
| **时钟频率**        | 提高制程工艺、优化散热      | 高频可能导致功耗和发热增加             |
| **CPI/IPC**     | 改进微架构（如流水线、乱序执行） | 复杂架构可能增加设计成本和延迟           |
| **MIPS/MFLOPS** | 优化指令集、并行计算       | MIPS忽略指令类型差异，MFLOPS依赖任务特性 |
| **吞吐量 vs 响应时间** | 负载均衡、异步处理        | 高吞吐量可能牺牲单任务响应速度           |
### 使用基准程序进行性能评估
- 基准程序(Benchmark)是一组特定的程序，专门用于评测计算机的性能。
- 这些程序能够有效地模拟计算机在处理实际任务时的表现。
- 在不同计算机上运行同样的基准程序，通过比较各计算机运行基准程序的时间，从而评测它们各自的性能不同基准程序的评测重点不同，例如CPU性能、图形性能、存储性能、浮点数计算性能、并行计算性能等。目前国际上流行的基准程序主要有SPEC、Linpack、Dhrystone、Whetstone、NPB等。
- 使用基准程序进行计算机性能评测也存在一些缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或编译器开发者可能针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得不到准确的性能评测结果。


衡量计算机系统性能是一项比较复杂的任务，很难仅凭借单一指标进行精确衡量。
上述一些衡量计算机性能的指标之间也不是完全独立的，改变其中一项指标可能会影响到其他指标。

## 第一章错题
1. 2017年公布的全球超级计算机TOP500排名中，我国“神威·太湖之光”超级计算机蝉联第其浮点运算速度为93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为()
   A. 9.3x1013次   B.9.3x1015次   c.9.3千万亿次   D.9.3亿亿次
   d
2. 假定基准程序A在某计算机上的运行时间为100s，其中90s为CPU时间，其余为I/O时间。若CPU速度提高50%，I/0速度不变，则运行基准程序A所耗费的时间是()。A.55s   B. 60s   C.65s   D.70s
   新CPU时间 = 原CPU时间 / 1.5 = 90秒 / 1.5 = 60秒
   新总时间 = 新CPU时间 + I/O时间 = 60秒 + 10秒 = 70秒
3. ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327163149037.png)
4. 有三种不同的处理器A,B和C执行同样的指令集，A的时钟频率为3GHz，CPI为1.5；B的时钟频率为2.5GHz，CPI为1.0；C的时钟频率为4GHz，CPI为2.2.
   （1）以每秒钟执行的指令数目为标准，哪个处理器的性能最高？
   （2）如果每个处理器执行一个程序都需花费10秒的时间，求它们的时钟周期数和指令数。
   （3）我们试图把执行时间减少30%，但这会引起CPI增加20%。问：时钟频率应该是多少才能达到程序执行时间减少30%的目的？
   (1)已知时钟频率和CPI，可以求MIPS反映性能，分别是2，2.5，1.82 GIPs。B最高
   (2)时钟周期数=运行时间×f，时钟周期数分别是3，2.5，4 × 10^10
   CPI=时钟周期数/指令条数，指令数分别是2，2.5，0.18 × 10^10
   (3)原执行时间 ($T = \frac{\text{指令数} \times \text{CPI}}{\text{频率}}$)
   新要求：$0.7T = \frac{\text{指令数} \times 1.2\text{CPI}}{\text{新频率}}$
   解得：$\text{新频率} = \frac{1.2}{0.7} \times \text{原频率} \approx 1.714 \times \text{原频率}$
   新频率需为1.71f

5. CPU 不包括()
   A.地址寄存器   B.地址译码器   C.指令寄存器(IR)   D.通用寄存器
   CPU 主要包括 运算器（ALU、通用寄存器、状态寄存器） 和 控制器（IR、PC、CU）。地址译码器 属于存储器（如主存）的组成部分，用于将地址总线信号转换为对特定存储单元的访问，不属于 CPU 内部结构。
6. 在运算器中，不包含()
   A.状态寄存器   B.数据总线   C. ALU   D.地址寄存器
   数据总线在运算器中用于传输操作数，选d
7. 若一个8位的计算机系统以 16 位来表示地址，则该计算机系统有( )个地址空间
   A.256   B.65535   C.65536   D. 131072
   8 位计算机表明计算机字长为8位，即一次可以处理8位的数据；而 地址空间大小仅由地址位数决定，与数据总线宽度（8位）无关，16 位表示地址码的长度，因此该机器有2^6=65536 个地址空间。
8. ()是程序运行时的存储位置，包括所需的数据。
   A.数据通路   B.主存   C.硬盘   D.操作系统
   b
9. 机器 A 的主频为 800MHz，某程序在 A 上运行需要 12s。现在硬件设计人员想设计机器B,希望该程序在B上的运行时间能缩短为 8s，使用新技术后可使B的主频大幅度提高，但在B上运行该程序所需的时钟周期数为在A上的1.5倍。则机器B的主频至少应为( )。
   时钟周期数=主频×运行时间
   时钟周期数A=800M×12s     时钟周期数B=1.5×800M×12s
   主频B=1.5×800M×12s / 8  = 1.8GHz
10. ![image.png](https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330210323965.png)CPI1=2.5，CPI2=2，MIPS1=500×10^6 / 2.5×10^6=200，MIPS2=500×10^6 / 2×10^6=250；总周期 = Σ(指令条数 × CPI)，总周期1=15，总周期2=10，所以执行时间1=总时钟周期数×时钟周期=15×2ns=30ns，执行时间2=20ns，d
11. 若机器 M的主频为 1.5GHz，在 M 上执行程序P的指令条数为 5x10^5，P的平均 CPI为 1.2，则P在M 上的指令执行速度和用户 CPU 时间分别为( )。
    A.08GIPS,0.4ms       B.08GIPS,0.4us
    C.1.25GIPS,0.4ms    D. 1.25GIPS,0.4us
    IPC指令执行速度=主频/CPI=1.5GHz/1.2=1.25GIPS
    CPU时间=指令数×CPI/主频=5x10^5×1.2/1.5×10^9=0.4ms
































































































































































































































































































