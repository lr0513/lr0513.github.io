<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第 7 章 计算机系统结构</title>
      <link href="/post/g86c4e7a.html"/>
      <url>/post/g86c4e7a.html</url>
      
        <content type="html"><![CDATA[<h2 id="I-O-系统基本概念">I/O 系统基本概念</h2><h2 id="I-O-接口">I/O 接口</h2><h3 id="I-O-接口-2">I/O 接口</h3><h4 id="I-O-接口的定义">I/O 接口的定义</h4><ul><li>也称 <strong>I/O 控制器</strong>，是主机和外设时间的交接界面</li><li>通过接口可以实现主机和外设之间的信息交换<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504155841.png" alt="image.png"></li></ul><h4 id="I-O-接口的功能">I/O 接口的功能</h4><ul><li><strong>进行地址译码和设备选择</strong>：使主机和指定外设交换信息</li><li><strong>实现主机和外设的通信联络控制</strong>：实现主机—I/O 接口—I/O 设备之间的通信</li><li><strong>实现数据缓冲</strong>：通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配</li><li><strong>信号格式的转换</strong>：串-并、并-串、电平、数-模、模-数等格式转换</li><li><strong>传送控制命令和状态信息</strong>：接收从控制总线发来的控制信号、时钟信号；通过状态寄存器反馈设备的各种错误、状态信息，供 CPU 查用<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504160839.png" alt="image.png"></li></ul><h4 id="I-O-接口的基本结构">I/O 接口的基本结构</h4><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504161238.png" alt="image.png"></p><ul><li><strong>外部接口</strong>：通过接口电缆与外设连接，数据传输可能是串行方式，因此 I/O 接口需具有串/并转换功能</li><li><strong>内部接口</strong>：与系统总线相连，实质上是与内存、CPU 相连</li><li><strong>如何确定要操作的设备</strong>：每个设备对应一组寄存器，操作不同的寄存器就是在操作不同的设备</li><li><strong>I/O 指令</strong>：对数据缓冲寄存器、状态/控制寄存器的进行访问操作的指令<ul><li>只能在 OS 内核的底层 I/O 软件中使用</li><li>I/O 指令实现的数据传送通常发生在通用寄存器和 I/O 端口之间</li><li>是一种特权指令</li></ul></li></ul><h4 id="I-O-接口的类型">I/O 接口的类型</h4><ol><li>按<strong>数据传送方式</strong>（外设和接口一侧）分：<ul><li>并行接口：一个字节或一个字所有位同时传送</li><li>串行接口：一位一位地传送</li></ul></li><li>按<strong>主机访问 I/O 设备的控制方式</strong>分：<ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul></li><li>按<strong>功能选择的灵活性</strong>分：<ul><li>可编程接口</li><li>不可编程接口</li></ul></li></ol><h3 id="I-O-端口及其编址">I/O 端口及其编址</h3><h4 id="I-O-端口">I/O 端口</h4><ul><li><strong>I/O 端口</strong>：接口电路中可以被 CPU 直接访问的寄存器，可以进行读/写的寄存器</li><li>接口 = 端口 + 相应的控制逻辑</li><li>I/O 端口想要能被 CPU 访问，则必须对各个端口进行编号，<strong>每个端口对应一个端口地址</strong></li><li>主要的 I/O 端口有：<ul><li><strong>数据端口</strong>：CPU 对数据端口中的数据<strong>执行读写操作</strong></li><li><strong>状态端口</strong>：对状态端口中的外设状态只能<strong>执行读操作</strong></li><li><strong>控制端口</strong>：对控制端口中的各种控制命令只能<strong>执行写操作</strong></li></ul></li></ul><h4 id="I-O-编址">I/O 编址</h4><h5 id="统一编址">统一编址</h5><ul><li><strong>定义</strong>：<ul><li>存储器映射方式</li><li>把 I/O 端口当做<strong>存储器的单元进行地址分配</strong>，CPU <strong>不需要设置专门的 I/O 指令</strong>，用<strong>统一的访存指令</strong>就可以访问 I/O 端口</li></ul></li><li><strong>特点</strong>：依靠<strong>地址码</strong>的不同区分存储单元和 I/O 设备</li><li><strong>优点</strong>：<ul><li>不需要专门的 I/O 指令</li><li>可以使 CPU 访问 I/O 的操作更灵活、更方便</li><li>可以<strong>使端口有较大的编址空间</strong></li></ul></li><li><strong>缺点</strong>：<ul><li>端口占用主存地址空间，使<strong>内存容量变小</strong></li><li><strong>外设寻址时间长</strong>（地址位数多，地址译码速度慢）</li><li>译码电路复杂，<strong>降低了译码速度</strong>【在识别 I/O 端口时全部地址线都需要参加译码】</li></ul></li></ul><h5 id="独立编址">独立编址</h5><ul><li><strong>定义</strong>：<ul><li>I/O 映射方式</li><li>I/O 端口的地址空间与主存地址空间是<strong>两个独立的地址空间</strong></li><li>需要设置<strong>专门的 I/O 指令来访存 I/O 端口</strong></li></ul></li><li><strong>特点</strong>：通过专门的 I/O <strong>指令</strong>来区分存储单元和 I/O 设备【I/O 指令的地址码给出 I/O 端口号】</li><li><strong>优点</strong>：<ul><li>使用专用 I/O 指令，<strong>程序编制清晰</strong></li><li>I/O 端口地址位数少，译码简单，<strong>地址译码速度快</strong></li></ul></li><li><strong>缺点</strong>：<ul><li>I/O 指令少，一般<strong>只能对端口进行传送操作</strong></li><li>需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制逻辑电路的复杂性</li></ul></li></ul><h2 id="I-O-方式">I/O 方式</h2><ul><li><strong>I/O方式</strong>：输入/输出系统实现主机与 I/O 设备之间数据传送的控制方式<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504165925.png" alt="image.png"></li></ul><h3 id="程序查询方式">程序查询方式</h3><ul><li><strong>基本概念</strong>：<ul><li>信息交换的控制完全由 <strong>CPU 执行程序实现</strong></li><li>接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）</li><li>主机进行 I/O 操作时，先发出询问信号，读取设备状态决定下一步操作到底是进行数据传送还是等待</li><li>CPU 一旦启动 I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504170313.png" alt="image.png"></li></ul></li><li><strong>主要特点</strong>：<ul><li>CPU <strong>有“踏步”等待现象</strong></li><li>CPU 与 I/O <strong>串行工作</strong></li></ul></li><li><strong>优点</strong>：<ul><li>接口设计简单，设备量少</li></ul></li><li><strong>缺点</strong>：<ul><li>CPU 在信息传送过程中要花费很多时间来查询和等待</li><li>在一段时间内只能和一台外设交换信息，效率大大降低</li></ul></li><li><strong>独占查询</strong>：一旦设备被启动，CPU 就一直持续查询接口状态，CPU 花费 100% 的时间用于 I/O 操作，此时外设和 CPU 完全串行工作</li><li><strong>定时查询</strong>：CPU 周期第查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序【时间间隔与设备的数据传输速率有关】</li></ul><h3 id="程序中断方式">程序中断方式</h3><h4 id="基本概念">基本概念</h4><ul><li>在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊情求 CPU 暂停中止现行程序而转去对这些异常情况或特殊请求进行处理，处理完毕后再返回到现行程序的断点处，继续执行原程序</li><li>早期的中断技术就是<strong>为了处理数据传送</strong></li><li>中断响应阶段 CPU 进行的操作：关中断，保护断点和程序状态，识别中断源</li><li>多重中断系统在保护被中断进程现场时关中断，执行中断程序时开中断</li><li>CPU 一般在一条指令执行结束的阶段采样中断请求信号，查看是否存在中断请求，然后决定是否响应中断</li><li>中断隐指令的工作：关中断+保存断点+引出中断服务程序</li><li>通用计算器的保护由中断服务程序完成</li><li>中断优先级由屏蔽字决定，而不是根据请求的先后次序</li><li>有中断请求时，如果是关中断的姿态，或新中断请求的优先级较低，则不能响应新的中断请求</li></ul><h4 id="中断技术的主要功能">中断技术的主要功能</h4><ul><li>实现 CPU 和 I/O 设备的<strong>并行工作</strong></li><li><strong>处理硬件故障和软件错误</strong></li><li>实现人机交互，用户干预机器需要用到中断系统</li><li>实现多道程序、分时操作，多道程序的切换需要借助于中断系统</li><li>实时处理需要借助中断系统来实现快速相应</li><li>实现应用程序和操作系统（管态程序）的切换，称为<strong>软中断</strong></li><li>多处理器系统中各处理器之间的信息交流和任务切换</li></ul><h4 id="程序中断方式的主要思想">程序中断方式的主要思想</h4><ul><li>CPU 在程序中安排好在某个时机启动某台外设</li><li>然后 CPU 继续执行当前的程序，不需要像查询方式那样等待外设准备就绪</li><li>一旦外设完成数据传送的准备工作，就主动向 CPU 发出中断请求，请求 CPU 为自己服务</li><li>在可以响应中断的条件下，CPU 暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU 回到原来的程序<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504171507.png" alt="image.png"></li></ul><h4 id="程序中断的基本流程">程序中断的基本流程</h4><h5 id="中断请求">中断请求</h5><ul><li><strong>中断源</strong>是请求 CPU 中断的设备或事件【一台计算机允许有多个】</li><li>中断系统对每个中断源设置<strong>中断请求标记触发器</strong>【1 表示有请求】</li><li>这些触发器组成<strong>中断请求标记寄存器</strong>【可集中在 CPU 中，也可分散在各个中断源中】</li><li><strong>可屏蔽中断</strong>：INTR 线发出，关中断模式下不被响应</li><li><strong>不可屏蔽中断</strong>：NMI 线发出，如时钟中断、电源掉电</li></ul><h5 id="中断响应判优">中断响应判优</h5><ul><li>通过<strong>硬件排队器</strong>实现</li><li>不可屏蔽中断 &gt; 内部异常 &gt; 可屏蔽中断</li><li>内部异常中，硬件故障 &gt; 软件中断</li><li>DMA 中断请求 &gt; I/O 设备传送的中断请求</li><li>在 I/O 传送类中断请求中，高速设备 &gt; 低速设备</li><li>输入设备优先于输出设备，实时设备 &gt; 普通设备</li><li><strong>注意</strong>：中断优先级包括响应优先级和处理优先级<ul><li>响应优先级由硬件线路或查询程序的查询顺序决定，不可动态改变</li><li>处理优先级可有中断屏蔽技术动态调整，以实现多重中断</li></ul></li></ul><h5 id="CPU-响应中断的条件">CPU 响应中断的条件</h5><ul><li>中断源有中断请求</li><li>CPU 允许中断与开中断（异常和不可屏蔽中断不受此影响）</li><li>一条指令执行完毕（异常不受此限制），且没有更紧迫的任务</li><li><strong>注意</strong>：CPU 响应中断的时间是在每条指令执行阶段的结束时刻【仅指 I/O 中断】</li></ul><h5 id="中断响应过程">中断响应过程</h5><ul><li><strong>中断隐指令</strong>：硬件的一系列自动操作，用于执行中断服务程序【并不是指令系统中的一条真正的指令】</li><li>关中断：在保护程序的断点和现场信息过程中，不能响应更高级中断源的中断请求</li><li>保存断点：将原程序的断点保存在栈或特定寄存器中【中断的断点是下一条指令的地址】</li><li>引出中断服务程序：识别中断源，将对应的服务程序入口地址送入 PC</li></ul><h5 id="中断向量">中断向量</h5><ul><li>中断识别分为<strong>向量中断</strong>【硬件向量法】和<strong>非向量中断</strong>【软件查询法】两种</li><li>每个中断源有一个唯一的类型号</li><li>每个中断类型号对应一个中断服务程序</li><li>每个中断服务程序都有一个入口地址，即<strong>中断向量</strong></li><li><strong>中断向量表</strong>：存储系统中的全部中断向量</li><li><strong>中断向量法</strong>【硬件向量法】：CPU 响应中断后，通过识别中断源获得中断类型号然后据此计算出对应中断向量的地址；再根据该地址从中断向量表中取出中断服务程序的入口地址，并送入 PC，以转而执行中断服务程序</li><li>采用中断向量法的中断被称为<strong>向量中断</strong></li><li><strong>注意</strong>：<ul><li>中断请求和响应信号是在 I/O 总线的<strong>控制线</strong>上传送</li><li>CPU 响应某一中断后，就从<strong>数据线</strong>上获取该中断源的中断类型号，并计算对应中断向量在中断向量表中的位置</li></ul></li></ul><h5 id="中断处理过程">中断处理过程</h5><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240504215508.png" alt="image.png"></p><h4 id="多重中断和中断屏蔽技术">多重中断和中断屏蔽技术</h4><h5 id="单重中断和多重中断">单重中断和多重中断</h5><ul><li><strong>单重中断</strong>：若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而<strong>CPU对新的中断请求不予响应</strong></li><li><strong>多重中断</strong>【中断嵌套】：若 CPU 在执行中断服务程序的过程中，又出现了新的<strong>更高优先级的中断请求</strong>，CPU 暂停现行的中断服务程序，转去<strong>处理新的中断请求</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505164030.png" alt="image.png"></li></ul><h5 id="中断屏蔽技术">中断屏蔽技术</h5><ul><li>中断屏蔽技术主要用于多重中断，CPU 要具备多重中断的功能，要满足：<ol><li>在中断服务程序中提前设置开中断指令</li><li>优先级别高的中断源有权中断优先级别低的中断源</li></ol></li><li>每个中断源都有一个<strong>屏蔽触发器</strong>（MASK），1 表示屏蔽该中断源的请求，0 表示可以正常请求</li><li>所用 MASK 组合在一起便构成一个<strong>屏蔽字寄存器</strong>，寄存器的内容称为<strong>屏蔽字</strong></li><li>屏蔽字中 1 越多，优先级越高</li><li>每个屏蔽字中至少有一个 1【至少能屏蔽自身的中断】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505164909.png" alt="image.png"></li></ul><h3 id="DMA-方式">DMA 方式</h3><h4 id="基本概念-2">基本概念</h4><ul><li>一种<strong>完全由硬件</strong>进行成组信息传送的控制方式</li><li>在<strong>数据准备阶段，CPU与外设并行工作</strong>，在外设与内存之间开辟一条“<strong>直接数据通路</strong>”</li><li>信息传送不再经过CPU（也就不需要保护、恢复CPU现场等操作），降低了CPU在传送数据时的开销</li><li>被称为<strong>直接存储器存取方式</strong></li><li>适用于磁盘、显卡、声卡、网卡等<strong>高速设备大批量数据的传送</strong>，硬件开销大</li><li>DMA 方式中，中断的作用仅限于故障和正常传送结束时的处理</li></ul><h4 id="DMA-方式的特点">DMA 方式的特点</h4><ul><li>主存<strong>既可以被 CPU 访问，也可被外设访问</strong></li><li>在数据块传送时，主存地址的确定、传送数据等都由硬件电路直接实现</li><li>主存中<strong>要开辟专用缓冲区</strong>，及时供给和接收外设的数据</li><li>DMA 传送速度快，CPU 和外设并行工作，提高了系统效率</li><li>DMA 在传送<strong>开始前要通过程序进行预处理，结束后要通过中断方式进行后处理</strong></li></ul><h4 id="DMA-控制器">DMA 控制器</h4><h5 id="定义">定义</h5><ul><li>DMAC 又叫 DMA 控制器（DMA 接口），是<strong>对数据传送过程进行控制的硬件</strong></li><li>在 DMA 过程中，DMAC 将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁用</li></ul><h5 id="功能">功能</h5><ol><li>接收外设发出的 DMA 请求，并向 CPU 发出总线请求</li><li>CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期</li><li>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数</li><li>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作</li><li>向 CPU 报告 DMA 操作结束</li></ol><h5 id="组成">组成</h5><ul><li><strong>主存地址计数器</strong>：存放要交换数据的主存地址</li><li><strong>传送长度计数器</strong>：记录传送数据的长度（总字数）。每传送一个字，计数器就减 1，直至计数器为 0，表示该批数据传送完毕</li><li><strong>数据缓冲寄存器</strong>：暂存每次传送的数据【DMA 接口与主存之间的传送单位为字，DMA 与设备之间的传送单位可能为字节或位】</li><li><strong>DMA 请求触发器</strong>：每当 I/O 设备准备好数据后，给出一个控制信号，使 DMA 请求触发器置位</li><li><strong>“控制/状态”逻辑</strong>：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对 DMA 请求信号、CPU 响应信号进行协调和同步</li><li><strong>中断机构</strong>：当一个数据块传送完毕后触发中断机构，向 CPU 提出中断请求<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505165951.png" alt="image.png"></li></ul><h4 id="传送方式">传送方式</h4><h5 id="停止-CPU-访问">停止 CPU 访问</h5><ul><li><strong>定义</strong>：当 I/O 设备有 DMA 请求时，由 DMA 接口向 CPU 发送一个停止信号，使 CPU 放弃总线控制权，停止访问主存，直到 DMA 传送一块数据结束<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505173330.png" alt="image.png"></li><li><strong>优点</strong>：控制简单，适用于数据传输速率很高的 I/O 设备实现成组数据的传送</li><li><strong>缺点</strong>：DMA 访问主存时，CPU 基本上处于不工作状态</li></ul><h5 id="周期挪用">周期挪用</h5><ul><li><strong>定义</strong>：由于 I/O 访存的优先级高于 CPU 访存（I/O 不立即访存就可能丢失数据），因此由 I/O 设备挪用一个存取周期，传送完一个数据字后立即释放总线【单字传送方式】</li><li>I/O 设备有 DMA 请求时，会遇到 3 种情况：<ol><li>此时 CPU 不访存</li><li>CPU 正在访存，待存取周期结束后，CPU 再将总线占有权让出</li><li>I/O 和 CPU 同时请求访存，CPU 要暂时放弃总线占有权<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505173941.png" alt="image.png"></li></ol></li><li><strong>优点</strong>：既实现了 I/O 传送，又较好地发挥了主存与 CPU 的效率</li><li><strong>缺点</strong>：每挪用一个主存周期，DMA 接口都要申请、建立和归还总线控制权</li></ul><h5 id="DMA-与-CPU-交替访问">DMA 与 CPU 交替访问</h5><ul><li><strong>定义</strong>：将 CPU 的工作周期分成两个时间片，一个给 CPU 访存，另一个给 DMA 访存，这样在每个周期内，CPU 和 DMA 就都可以轮流访存</li><li>总线使用权分时控制<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505174336.png" alt="image.png"></li><li><strong>优点</strong>：不需要申请、建立和归还总线控制权，具有很高的传送速率</li><li><strong>缺点</strong>：相应的硬件逻辑变得更复杂</li></ul><h4 id="传送过程">传送过程</h4><ol><li><strong>预处理</strong>：由 CPU 完成一些必要的准备工作<ul><li>首先，初始化 DMA 控制器的有关寄存器、设置传送方向、测试并启动设备等</li><li>然后，CPU 继续执行原程序，直到 I/O 设备准备好发送的数据或接收的数据时，I/O 设备向 DMA 控制器发送 DMA 请求</li><li>DMA 控制器向 CPU 发出总线请求【这两个过程可统称为 <strong>DMA 请求</strong>】</li></ul></li><li><strong>数据传送</strong>：<ul><li>以<strong>数据块</strong>为基本传送单位</li><li>DMA 占用总线后的数据输入/输出操作通过循环实现【DMA 控制器】</li></ul></li><li><strong>后处理</strong>：<ul><li>DMA 控制器 向 CPU <strong>发出中断请求</strong></li><li>CPU 执行中断服务程序做 DMA 结束处理</li><li>后处理包括：<ul><li>校验送入主存的数据是否正确</li><li>测试传送过程中是否出错（错误则转诊断程序）</li><li>决定是否继续使用 DMA 传送其他数据等<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505174851.png" alt="image.png"></li></ul></li></ul></li></ol><h3 id="各种方式的比较">各种方式的比较</h3><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505175726.png" alt="image.png"></p><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240505175731.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统结构基本概念（透明性） </tag>
            
            <tag> 并行处理技术（多核/多机系统） </tag>
            
            <tag> 存储层次优化（局部性原理） </tag>
            
            <tag> 性能评价指标（MIPS/ MFLOPS） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 6 章 输入输出系统</title>
      <link href="/post/f75b3d6f.html"/>
      <url>/post/f75b3d6f.html</url>
      
        <content type="html"><![CDATA[<h2 id="总线概述">总线概述</h2><h3 id="总线的基本概念">总线的基本概念</h3><h4 id="总线的定义">总线的定义</h4><ul><li><strong>总线</strong>：一组能够为多个部件分时和共享的公共信息<strong>传送线路</strong></li><li><strong>目的</strong>：I/O 设备的种类和数量越来越多，设计总线来<strong>解决 I/O 设备与主机之间连接的灵活性</strong></li><li><strong>优点</strong>：便于增减外设，减少信息传输线的条数</li><li><strong>缺点</strong>：降低了信息传输的并行性和信息的传输速度</li></ul><h4 id="总线的特点">总线的特点</h4><ul><li><strong>分时性</strong>：同一时刻只允许有一个部件向总线发送消息，如果系统中有多个部件，则它们只能分时地向总线发送消息</li><li><strong>共享性</strong>：指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，多个部件可同时从总线上接收相同的信息</li></ul><h4 id="总线设备">总线设备</h4><ul><li>按其<strong>对总线有无控制能力</strong>可分为主设备和从设备<ul><li><strong>主设备</strong>：获得总线控制权的设备</li><li><strong>从设备</strong>：被主设备访问的设备，它只能响应从主设备发来的各种总线命令</li></ul></li></ul><h4 id="总线特性">总线特性</h4><ul><li><strong>机械特性</strong>：尺寸，形状</li><li><strong>电气特性</strong>：传输方向和有效电平范围</li><li><strong>功能特性</strong>：每根传输线的功能</li><li><strong>时间特性</strong>：信号和时序的关系</li></ul><h3 id="总线的分类">总线的分类</h3><h4 id="按功能">按功能</h4><ul><li><strong>片内总线</strong>：<ul><li>芯片内部的总线</li><li>是 <strong>CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间</strong>的公共连接线</li></ul></li><li><strong>系统总线</strong>：<ul><li>计算机系统内<strong>各功能部件（CPU、主存、I/O 接口）之间</strong>相互连接的总线</li><li>按系统总线<strong>传输内容</strong>的不同又可分为 3 类<ul><li><strong>数据总线</strong>：<ul><li>传输各功能部件之间的数据信息</li><li>是<strong>双向</strong>传输线</li><li>位数反映一次能传送的数据的位数【与机器字长、存储字长有关】</li></ul></li><li><strong>地址总线</strong>：<ul><li>指出主存和 I/O 设备接口电路的地址</li><li>是<strong>单向</strong>传输线</li><li>位数反映最大的寻址空间【与主存地址空间大小及设备数量有关】</li></ul></li><li><strong>控制总线</strong>：<ul><li>一根控制线传输一个信号</li><li>有出：CPU 送出的控制命令</li><li>有入：主存（或外设）返回 CPU 的控制信号</li></ul></li></ul></li></ul></li><li><strong>I/O 总线</strong>：<ul><li>主要用于连接中低速的 I/O 设备</li><li>通过 I/O 接口与系统总线相连接</li><li>目的是<strong>将低速设备和高速总线分离</strong>，以提升总线的系统性能</li><li>常见的有 USB、PCI 总线</li></ul></li><li><strong>通信总线</strong>：<ul><li>计算机系统之间或计算机系统与其他系统（如远程通信服务、测试设备）之间传送信息的总线</li><li>也称<strong>外部总线</strong></li></ul></li></ul><h4 id="按时序控制方式">按时序控制方式</h4><ul><li><strong>同步总线</strong>：总线上连接的部件或设备通过<strong>统一的时钟</strong>进行同步</li><li><strong>异步总线</strong>：以<strong>信号握手</strong>的方式来协调各部件或设备之间的信息传输，总线操作时序不是固定的</li></ul><h4 id="按数据传输方式">按数据传输方式</h4><ul><li><strong>串行传输</strong>：只有一条双向传输或两条单向传输的数据线，数据按比特位串行顺序传输<ul><li><strong>优点</strong>：<ul><li>成本低廉，广泛应用于<strong>长距离传输</strong></li><li>应用于计算机内部时，可以节省布线空间</li><li>可通过不断提高工作频率来提高传输速度，使其速度最终超越并行总线</li></ul></li><li><strong>缺点</strong>：<ul><li>在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题</li></ul></li></ul></li><li><strong>并行传输</strong>：有多条双向传输的数据线，可以实现多比特位的同时传输<ul><li><strong>优点</strong>：<ul><li>总线的逻辑时序比较简单，电路实现起来比较容易</li></ul></li><li><strong>缺点</strong>：<ul><li>信号线数量多，占用更多的布线空间</li><li>数据线之间相互干扰会造成传输错误，因此适合<strong>近距离传输</strong></li></ul></li></ul></li><li><strong>总线复用方式</strong>：不同信号在同一条信号线上分时传输</li></ul><h3 id="系统总线的结构">系统总线的结构</h3><h4 id="单总线结构">单总线结构</h4><ul><li><strong>结构</strong>：CPU、主存、I/O 设备（通过 I/O 接口）都连接在一组<strong>系统总线</strong>上，允许 I/O 设备之间、I/O 设备和 CPU 之间或 I/O 设备与主存之间直接交换信息<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503164829.png" alt="image.png"></li><li><strong>优点</strong>：结构简单，成本低，易于接入新的设备</li><li><strong>缺点</strong>：带宽低，负载重，多个部件只能征用唯一的总线，且不支持并发传送操作</li></ul><h4 id="双总线结构">双总线结构</h4><ul><li><strong>结构</strong>：双总线结构有两条总线，一条是<strong>主存总线</strong>，用于 CPU、主存和通道之间进行数据传送；另一条是 <strong>I/O 总线</strong>，用于多个外部设备与通道之间进行数据传送<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503165057.png" alt="image.png"></li><li><strong>优点</strong>：将较低速的 I/O 设备从单总线上分离出来，实现存储器总线和 I/O 总线分离</li><li><strong>缺点</strong>：需要增加通道等硬件设备</li></ul><h4 id="三总线结构">三总线结构</h4><ul><li><strong>结构</strong>：三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这 3 条总线分别为<strong>主存总线</strong>、<strong>I/O 总线</strong>和直接内存访问 <strong>DMA 总线</strong></li><li><strong>优点</strong>：提高了 I/O 设备的性能，使其更快地响应命令，提高系统吞吐量</li><li><strong>缺点</strong>：系统工作效率较低</li></ul><h3 id="总线的性能指标">总线的性能指标</h3><ul><li><strong>总线传输周期</strong>【总线周期】：<ul><li>一次总线操作所需的时间，由若干总线时钟周期构成</li><li>包括申请阶段、寻址阶段、传输阶段和结束阶段</li></ul></li><li><strong>总线时钟周期</strong>：<ul><li>机器的时钟周期</li><li>计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制</li><li>现在的计算机中，总线时钟周期也有可能由桥接器提供</li></ul></li><li><strong>总线工作频率</strong>：<ul><li>总线上各种操作的频率，为<strong>总线周期的倒数</strong></li><li>$工作频率=\frac{1}{总线周期}$</li><li>若总线周期 = N 个时钟周期，则总线的 $工作频率=\frac{时钟频率}{N}$</li><li>实际上指<strong>一秒内传送几次数据</strong></li></ul></li><li><strong>总线时钟频率</strong>：<ul><li>机器的时钟频率，为时钟周期的倒数</li><li>$时钟频率=\frac{1}{时钟周期}$</li><li>实际上指<strong>一秒内有多少个时钟周期</strong></li></ul></li><li><strong>总线宽度</strong>【总线位宽】：<ul><li>总线上<strong>同时能传输的数据位数</strong></li><li>通常指<strong>数据总线的根数</strong>，如 32 根称为 32 位（bit）总线</li></ul></li><li><strong>总线带宽</strong>：<ul><li>总线的最大<strong>数据传输率</strong>，即<strong>单位时间内总线上最多可传输数据的位数</strong></li><li>$总线带宽=总线工作频率×\frac{总线位宽}{8}(bit/s)=总线工作频率×（总线带宽/8）（B/s）$</li><li>$总线带宽=\frac{总线宽度}{总线周期}（bit/s）=\frac{总线宽度/8}{总线周期}（B/s）$</li><li>在计算实际的<strong>有效数据传输率</strong>时，要用实际传输的数据量除以耗时</li></ul></li><li><strong>总线复用</strong>：<ul><li>一种信号线在不同的时间传输不同的信息</li><li>可以使用较少的线传输更多的信息，从而节约空间和成本</li></ul></li><li><strong>信号线数</strong>：<ul><li>地址总线、数据总线和控制总线3种总线数的总和称为信号线数</li></ul></li></ul><h3 id="常见的总线标准">常见的总线标准</h3><ul><li>总线标准是国际上公布的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范</li><li>PCI，EISA，ISA是并行总线</li><li>USB，PCI-Expressx16是串行总线</li><li>高速设备采用局部总线连接，可以节省系统的总带宽</li></ul><ol><li>ISA：<ul><li>工业标准体系结构</li><li>非局部总线</li><li>最早出现的微型计算机的系统总线，应用在IBM的AT机上</li></ul></li><li>EISA：扩展的ISA</li><li>VESA：视频电子标准协会</li><li>PCI：<ul><li>外部设备互连</li><li>支持即插即用，局部总线</li></ul></li><li>AGP：加速图形接口，一种视频接口标准</li><li>PCI-E：最新的总线接口标准，它将全面取代线性的PCI和AGP</li><li>RS-232C：<ul><li>由美国电子工业协会推荐的一种串行通信总线</li><li>适用于串行二进制交换的数据终端设备和数据通信设备之间的标准接口</li></ul></li><li>USB：<ul><li>通用串行总线</li><li>即插即用，热插拔，有很强的连接能力，有很好的可扩展性；高速传输</li></ul></li><li>PCMCIA：<ul><li>广泛应用于笔记本电脑的一种接口标准</li><li>是一个用于扩展功能的小型插槽。即插即用</li></ul></li><li>IDE：<ul><li>集成设备电路</li><li>更准确地称为ATA，硬盘和光驱通过IDE接口与主板连接</li></ul></li><li>SCSI：<ul><li>小型计算机系统接口</li><li>是一种用于计算机和智能设备之间（硬盘、软驱）系统级接口的独立处理器标准</li></ul></li><li>SATA：<ul><li>串行高级技术附件</li><li>是一种基于行业标准的串行硬件驱动器接口</li></ul></li></ol><h2 id="总线事务和定时">总线事务和定时</h2><h3 id="总线事务">总线事务</h3><ul><li><strong>定义</strong>：从请求总线到完成总线使用的操作序列【在一个总线周期中发生的一系列活动】</li><li>过程：<ul><li><strong>请求阶段</strong>：主设备（CPU 或 DMA）发出总线传输请求，并且获得总线控制权</li><li><strong>仲裁阶段</strong>：总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者</li><li><strong>寻址阶段</strong>：主设备通过总线给出要访问的从设备地址及有关命令，启动从模块</li><li><strong>传输阶段</strong>：主模块和从模块进行数据交换，可单向或双向进行数据传送（一般只能传输一个字长的数据）</li><li><strong>释放阶段</strong>：主模块的有关信息均从系统总线上撤除，让出总线使用权</li></ul></li><li><strong>总线上的数据传方式</strong>：<ul><li><strong>非突发式</strong>：<ul><li>在每个传送周期内都<strong>先传送地址，再传送数据</strong></li><li>主、从设备之间通常<strong>每次只能传输一个字长</strong>的数据</li></ul></li><li><strong>突发（猝发）式</strong>：<ul><li>发送方在传输完成地址后，连续进行若干次数据的发送，即一<strong>次传输一个地址和一批连续的数据</strong></li><li>能够进行<strong>连续成组数据</strong>的传送；其寻址阶段发送的是连续数据单元的首地址</li><li>可以提高总线数据传输率</li><li>主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据</li></ul></li></ul></li></ul><h3 id="总线定时">总线定时</h3><ul><li><strong>定义</strong>：总线在双方交换数据的过程中需要时间上配合关系的控制【实质是一种协议或者规则】</li></ul><h4 id="同步定时方式">同步定时方式</h4><h5 id="定义">定义</h5><ul><li>由<strong>统一时序控制</strong>的通信方式</li><li>同步通信采用<strong>公共时钟</strong>，有统一的时钟周期，同步时钟信号不由各设备提供</li><li>同步控制既可以<strong>用于 CPU 控制</strong>，又可用于<strong>高速的外部设备控制</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503181107.png" alt="image.png"></li></ul><h5 id="优点">优点</h5><ul><li>传送速度快，具有较高的传输速率</li><li>总线控制逻辑简单</li><li>同步通信<strong>不需要应答信息且总线长度短</strong></li><li>同步通信用一个公共的时钟信号进行同步</li><li>同步通信中，<strong>各部件的存取时间较接近</strong></li></ul><h5 id="缺点">缺点</h5><ul><li>主从设备属于强制性同步</li><li>不能及时进行数据通信的有效性验证</li><li>可靠性较差</li></ul><h5 id="适用场景">适用场景</h5><ul><li>适用于<strong>总线长度较短</strong>及<strong>总线所接部件的存储时间比较接近</strong>的系统</li><li>采用同步控制也可以进行数据的传输，但不能发挥快速设备的高速性能</li></ul><h4 id="异步定时方式">异步定时方式</h4><h5 id="定义-2">定义</h5><ul><li>没有统一的时钟；没有固定的时间间隔【不采用时钟信号，只采用握手】</li><li>完全依靠<strong>传送双方相互制约的“握手”信号</strong>来实现定时控制</li><li>传送操作是由双方按需求分配时间的</li><li>每次握手完成一次通信，但是一次通信往往交换多位数据</li></ul><h5 id="优点-2">优点</h5><ul><li>总线周期长度可变</li><li>能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换</li><li>自动适应时间的配合</li></ul><h5 id="缺点-2">缺点</h5><ul><li>比同步稍复杂一些，速度比同步方式慢</li></ul><h5 id="适用场景-2">适用场景</h5><ul><li>主要用于在不同的设备间进行通信</li></ul><h5 id="分类">分类</h5><ul><li><strong>不互锁方式</strong>：<ul><li>主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号</li><li>从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系</li><li><strong>速度最快，可靠性最差</strong></li></ul></li><li><strong>半互锁方式</strong>：<ul><li>主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系</li><li>从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系</li></ul></li><li><strong>全互锁方式</strong>：<ul><li>主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号</li><li>从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系</li><li><strong>最可靠，速度最慢</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503180936.png" alt="image.png"></li></ul></li></ul><h4 id="半同步定时方式">半同步定时方式</h4><h5 id="定义-3">定义</h5><ul><li>统一时钟的基础上，增加一个 <strong>“等待”响应信号</strong> WAIT</li><li><strong>同步</strong>：<ul><li><strong>发送方</strong>用<strong>系统时钟前沿</strong>发信号</li><li><strong>接收方</strong>用<strong>系统时钟后沿</strong>判断、识别</li></ul></li><li><strong>异步</strong>：允许不同速度的模块和谐工作<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503182027.png" alt="image.png"></li></ul><h5 id="优点-3">优点</h5><ul><li>控制方式比异步定时简单</li><li>各模块在系统时钟的控制下同步工作，可靠性较高</li></ul><h5 id="缺点-3">缺点</h5><ul><li>系统的时钟频率不能要求太高</li><li>整体上看，系统工作的速度不是很高</li></ul><h4 id="分离式定时方式">分离式定时方式</h4><p><em><strong>上述三种通信的共同点：</strong></em><br>一个总线传输周期（以输入数据为例）：</p><ul><li>主模块发地址、命令【使用总线】</li><li>从模块准备数据【总线空闲】</li><li>从模块向主模块发数据【使用总线】</li></ul><h5 id="定义-4">定义</h5><ul><li>将总线事务分解为请求和应答两个子过程<ul><li>子周期 1：<strong>主模块</strong>申请<strong>占用总线</strong>，使用完后<strong>放弃总线</strong>的使用权</li><li>子周期 2：<strong>从模块</strong>申请<strong>占用总线</strong>，将各种信息送至总线上</li></ul></li><li>各模块均有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线利用率提高</li></ul><h5 id="优点-4">优点</h5><ul><li>在不传送数据是释放总线，使总线可接受其他设备的请求，不存在空闲等待时间</li></ul><h5 id="缺点-4">缺点</h5><ul><li>控制复杂，开销较大</li></ul><h1>错题</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O设备分类（块设备/字符设备） </tag>
            
            <tag> I/O控制方式（程序查询/中断/DMA） </tag>
            
            <tag> 中断系统（向量中断/优先级） </tag>
            
            <tag> 设备驱动程序功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 5 章 输入输出管理：设备协同与优化</title>
      <link href="/post/169339cb.html"/>
      <url>/post/169339cb.html</url>
      
        <content type="html"><![CDATA[<h2 id="I-O-管理概述">I/O 管理概述</h2><h3 id="I-O-设备">I/O 设备</h3><h4 id="设备的分类">设备的分类</h4><h5 id="按信息交换的单位">按信息交换的单位</h5><ul><li><strong>块设备</strong>：<ul><li>信息交换以数据块为单位，如磁盘、磁带</li><li>基本特征：传输速率较高、可寻址，即对它可随意地读/写任意一块</li><li>属于有结构设备</li></ul></li><li><strong>字符设备</strong>：<ul><li>信息交换以字符为单位，如交互式终端机、打印机</li><li>基本特征：传输速率低、不可寻址，常采用中断 I/O 方式</li><li>属于无结构设备</li></ul></li></ul><h5 id="按设备的传输速率">按设备的传输速率</h5><ul><li><strong>低速设备</strong>：键盘、鼠标</li><li><strong>中速设备</strong>：激光打印机</li><li><strong>高速设备</strong>：磁盘机、光盘机</li></ul><h5 id="按设备的共享属性">按设备的共享属性</h5><ul><li><strong>独占设备</strong>：<ul><li>一个时刻只能由一个进程占用</li><li>所有字符设备都是独占设备</li><li>速度慢，利用率低</li><li>如输入机、打印机、磁带机</li></ul></li><li><strong>共享设备</strong>：<ul><li>同一时间段内允许多个进程同时访问的设备</li><li>共享设备必须是可寻址和可随机访问的设备</li><li>如软硬盘、磁盘、光盘</li></ul></li><li><strong>虚拟设备</strong>：<ul><li>通过 SPOOLing 技术将独占设备改造为共享设备</li><li>将一个物理设备变为多个逻辑设备，从而可将设备同时分配给多个进程</li><li>实质上还是独占设备</li></ul></li></ul><h5 id="按设备的使用特性">按设备的使用特性</h5><ul><li><strong>存储设备</strong>：<ul><li>存储信息的外部设备</li><li>如磁盘、磁带、光盘</li></ul></li><li><strong>输入/输出设备</strong>：<ul><li>输入设备：向计算机输入外部信息，如键盘、鼠标、扫描仪</li><li>输出设备：计算机向外输出数据信息，如打印机</li><li>交互式设备：集成两种功能，如触控显示器</li></ul></li></ul><h4 id="设备控制器（I-O-接口）">设备控制器（I/O 接口）</h4><h5 id="主要功能">主要功能</h5><ul><li>接受和识别 CPU 发出的命令</li><li>向 CPU 报告设备的状态</li><li>数据交换</li><li>地址识别</li><li>数据缓冲</li><li>差错控制</li></ul><h5 id="组成">组成</h5><ul><li><strong>设备控制器与 CPU 的接口</strong>：<ul><li>用于实现 CPU 与控制器之间的通信，有三类信号线</li><li>数据线：传送的是读/写数据、控制信息和状态信息</li><li>地址线：传送的是要访问 I/O 接口中的寄存器编号</li><li>控制线：传送的是读/写等控制信号</li></ul></li><li><strong>设备控制器与设备的接口</strong>：<ul><li>用于实现控制器和设备之间的通信</li><li>控制器中有一个或多个设备接口</li><li>每个接口都可传输数据、控制和状态三种类型的信号</li></ul></li><li><strong>I/O 逻辑</strong>：<ul><li>用于实现对设备的控制</li><li>通过一组控制线与 CPU 交互，对从 CPU 收到的 I/O 命令进行译码</li><li>CPU 启动设备时，将启动命令发送给控制器，同时通过地址线将地址发送给控制器，由控制器的 I/O 逻辑对地址进行译码，并对所选设备进行控制<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602152701.png" alt="image.png"></li></ul></li></ul><h5 id="类型">类型</h5><ul><li><strong>按数据传送方式</strong>：<ul><li>并行接口</li><li>串行接口</li></ul></li><li><strong>按主机访问 I/O 设备的控制方式</strong>：<ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul></li><li><strong>按功能选择的灵活性</strong>：<ul><li>可编程接口</li><li>不可编程接口</li></ul></li></ul><h4 id="I-O-端口">I/O 端口</h4><h5 id="基本概念">基本概念</h5><ul><li><strong>I/O 端口</strong>：指设备控制器中可被 CPU 直接访问的寄存器，有三种类型<ul><li><strong>数据寄存器</strong>：用于缓存从设备送来的输入数据，或从 CPU 送来的传输数据</li><li><strong>状态寄存器</strong>：保存设备的执行结果或状态信息，以供 CPU 读取</li><li><strong>控制寄存器</strong>：由 CPU 写入，以便启动命令或更改设备模式</li></ul></li><li>I/O 端口要想能够被 CPU 访问，就要对各个端口进行编制，每个端口对应一个端口地址</li></ul><h5 id="寄存器编址方式">寄存器编址方式</h5><ul><li><p><strong>独立编址</strong>：</p><ul><li>指为每个端口分配一个 I/O 端口号</li><li>I/O 端口的地址空间与主存地址空间<strong>独立</strong></li><li>两者范围可以重叠，相同地址可能属于不同的地址空间</li><li>只有 OS 使用特殊的 I/O 指令才能访问端口【普通用户程序不能访问端口】</li><li><strong>优点</strong>：<ul><li>I/O 端口数比主存单元少得多，只需少量地址线，使得 <strong>I/O 端口译码简单，寻址速度更快</strong></li><li>使用专用 I/O 指令，可使<strong>程序更加清晰</strong>，便于理解和检查</li></ul></li><li><strong>缺点</strong>：<ul><li>I/O 指令少，只提供简单的传输操作，所以程序<strong>设计的灵活性较差</strong></li><li>CPU 需要提供两组独立的存储器和设备的读/写控制信号，<strong>增加了控制的复杂性</strong></li></ul></li></ul></li><li><p><strong>统一编址</strong>：</p><ul><li>又称<strong>内存映射 I/O</strong></li><li>指将主存地址空间分出一部分给 I/O 端口进行编址，I/O 端口和主存单元在同一地址空间的<strong>不同分段</strong>中</li><li><strong>根据地址范围</strong>就能区分访问的是 I/O 端口还是主存单元</li><li>用<strong>统一的访存指令</strong>就可访问 I/O 端口</li><li><strong>优点</strong>：<ul><li>不须专门的 I/O 指令，使得 CPU 访问 I/O 的操作<strong>更加灵活方便</strong></li><li>使端口有较大的编址空间</li></ul></li><li><strong>缺点</strong>：<ul><li>端口地址占用了部分主存地址空间，使<strong>主存的可用容量变小</strong></li><li>识别 I/O 端口时全部地址线都需参加译码，使<strong>译码电路更加复杂</strong>，降低寻址速度</li></ul></li></ul></li></ul><h3 id="I-O-控制方式">I/O 控制方式</h3><ul><li><strong>I/O 控制</strong>：指控制设备和主机之间的数据传送<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602171054.png" alt="image.png"></li></ul><h4 id="程序直接控制方式">程序直接控制方式</h4><ul><li>CPU 对 I/O 设备的控制采用轮询的 I/O 方式，又称<strong>程序轮询方式</strong></li><li><strong>CPU 干预的频率</strong>：<ul><li>很频繁，I/O 操作开始之前、完成之后需要 CPU 介入</li><li>在<strong>等待 I/O 完成的过程中 CPU 需要不断地轮询检查</strong></li></ul></li><li>数据的传送单位：每次读/写<strong>一个字</strong></li><li>数据的流向：<ul><li>读操作（数据输入）：I/O 设备 —&gt; CPU 寄存器 —&gt; 内存</li><li>写操作（数据输出）：内存 —&gt; CPU 寄存器 —&gt; I/O 设备</li></ul></li><li><strong>优点</strong>：实现简单</li><li><strong>缺点</strong>：<ul><li><strong>CPU 和 I/O 设备只能串行工作</strong></li><li>CPU 需要一直轮询检查，<strong>长期处于“忙等”状态</strong>，CPU 利用率低<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602163906.png" alt="image.png"></li></ul></li></ul><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602163731.png" alt="image.png"></p><h4 id="中断驱动方式">中断驱动方式</h4><ul><li><strong>基本思想</strong>：允许 I/O 设备主动打断 CPU 的运行并请求服务，从而“解放”CPU，使得其向 I/O 控制器发送读命令后可以继续做其他有用的工作</li><li><strong>CPU 干预的频率</strong>：<ul><li>每次 I/O 操作开始之前、完成之后需要 CPU 介入</li><li>等待 I/O 完成的过程中 CPU 可以切换到别的进程执行</li></ul></li><li>数据的传送单位：每次读/写<strong>一个字</strong></li><li>数据的流向：<ul><li>读操作（数据输入）：I/O 设备 —&gt; CPU 寄存器 —&gt; 内存</li><li>写操作（数据输出）：内存 —&gt; CPU 寄存器 —&gt; I/O 设备</li></ul></li><li><strong>优点</strong>：<ul><li>I/O 控制器会通过中断信号主动报告 I/O 已完成，CPU 不再需要不停地轮询</li><li><strong>CPU 和 I/O 设备可并行工作</strong>，CPU 利用率明显提升</li></ul></li><li><strong>缺点</strong>：<ul><li>每个字在 I/O 设备与内存之间的传输，都需要经过 CPU</li><li>频繁的中断处理会消耗较多的 CPU 时间<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602164525.png" alt="image.png"></li></ul></li></ul><h4 id="DMA-方式">DMA 方式</h4><ul><li><strong>基本思想</strong>：是在 I/O 设备和内存之间开辟直接的数据交换通路，彻底&quot;解放” CPU</li><li><strong>CPU 干预的频率</strong>：<ul><li>仅在传送一个或多个数据块的<strong>开始和结束时</strong>，才需 CPU 干预</li><li>整块数据的传送是在 DMA 控制器的控制下完成的</li></ul></li><li>数据的传送单位：每次读/写<strong>一个或多个块</strong>【连续的】</li><li>数据的流向：<ul><li>读操作（数据输入）：I/O 设备 —&gt; 内存</li><li>写操作（数据输出）：内存  —&gt; I/O 设备</li></ul></li><li><strong>优点</strong>：<ul><li>数据传输以“块”为单位，CPU 介入频率进一步降低</li><li>数据的传输不再需要先经过 CPU 再写入内存，数据传输效率进一步增加</li><li>CPU 和 I/O 设备的并行性得到提升</li></ul></li><li><strong>缺点</strong>：<ul><li>CPU 每发出一条 I/O 指令，只能读/写一个或多个连续的数据块</li><li>如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU 要分别发出多条I/O 指令，进行多次中断处理才能完成<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602165701.png" alt="image.png"></li></ul></li></ul><h4 id="通道控制方式">通道控制方式</h4><ul><li>I/O 通道是一种特殊的处理机，可执行一系列通道指令</li><li>与 CPU 相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与 CPU 共享内存</li><li><strong>CPU 干预的频率</strong>：<ul><li>极低</li><li>通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求 CPU 干预</li></ul></li><li>数据的传送单位：每次读/写<strong>一组数据块</strong></li><li>数据的流向【<strong>在通道的控制下进行</strong>】：<ul><li>读操作（数据输入）：I/O 设备 —&gt; 内存</li><li>写操作（数据输出）：内存  —&gt; I/O 设备</li></ul></li><li><strong>优点</strong>：<ul><li><strong>CPU、通道、I/O 设备可并行工作</strong>，资源利用率很高</li><li>一个通道可以控制<strong>多台设备与内存</strong>的数据交换</li></ul></li><li><strong>缺点</strong>：实现复杂，需要专门的通道硬件支持<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602170531.png" alt="image.png"></li></ul><h3 id="I-O-软件层次结构">I/O 软件层次结构</h3><ul><li>将系统中的设备管理模块分为若干个层次，<strong>每层都利用其下层提供的服务</strong>，完成输入/输功能中的某些子功能，并<strong>屏蔽这些功能的实现细节</strong>，向高层提供服务<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604145317.png" alt="image.png"></li></ul><h4 id="用户层软件">用户层软件</h4><ul><li>用户层软件<strong>实现了与用户交互的接口</strong></li><li>用户可直接使用该层提供的、与 I/O 操作相关的<strong>库函数</strong>对设备进行操作</li><li>用户层软件将用户请求翻译成格式化的 I/O 请求，并通过<strong>系统调用</strong>请求操作系统内核【下三层】的服务</li></ul><h4 id="设备独立性软件">设备独立性软件</h4><ul><li><strong>设备独立性</strong>：又称<strong>设备无关性</strong>，使得应用程序独立于具体使用的物理设备</li><li>为实现设备独立性，引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>两个概念</li><li>使用逻辑设备名的<strong>好处</strong>：<ul><li>增加设备分配的灵活性</li><li>易于实现 I/O 重定向，用于 I/O 操作的设备可以更换 ，而不必改变应用程序</li></ul></li><li>为实现设备独立性，必须在驱动程序之上设置一层<strong>设备独立性软件</strong>，主要功能：<ul><li>向上层提供统一的调用接口（如 read/write 系统调用）</li><li>设备的保护</li><li>差错处理</li><li>设备的分配与回收</li><li>数据缓冲区管理</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序</li></ul></li></ul><h4 id="设备驱动程序">设备驱动程序</h4><ul><li><strong>与硬件直接相关</strong>，负责<strong>具体实现系统对设备发出的操作命令</strong>，驱动 I/O 设备工作的驱动程序</li><li>每类设备设置一个设备驱动程序，它是 I/O 进程与设备控制器之间的通信程序，通常<strong>以进程的形式存在</strong></li><li>设备具体的差别被设备驱动程序所封装，设备驱动程序向上层用户程序提供一组标准接口，用于接收上层软件发来的抽象 I/O 要求（如 read /write 命令），转换为具体要求后，<strong>发送给设备控制器，控制 I/O 设备工作</strong></li><li>它也将由设备控制器发来的信号传送给上层软件，从而为 I/O 内核子系统隐藏设备控制器之间的差异</li></ul><h4 id="中断处理程序">中断处理程序</h4><ul><li>保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604152911.png" alt="image.png"></li></ul><h3 id="应用程序-I-O-接口">应用程序 I/O 接口</h3><h4 id="I-O-接口的分类">I/O 接口的分类</h4><ul><li><strong>字符设备接口</strong>：<ul><li>字符设备：指数据的存取和传输是<strong>以字符为单位</strong>的设备（如键盘、打印机等）</li><li>基本特征：<ul><li>传输速率较低、不可寻址</li><li>I/O 通常采用中断驱动方式</li></ul></li></ul></li><li><strong>块设备接口</strong>：<ul><li>块设备：指数据的存取和传输是<strong>以数据块为单位</strong>的设备（如磁盘）</li><li>基本特征：<ul><li>传输速率高、可寻址</li><li>I/O 通常采用 DMA 方式</li></ul></li></ul></li><li><strong>网络设备接口</strong>：<ul><li>又称网络套接字（socket）接口</li><li>套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的创建的套接字，通过此连接发送和接收数据</li></ul></li></ul><h4 id="阻塞-I-O-和非阻塞-I-O">阻塞 I/O 和非阻塞 I/O</h4><ul><li><strong>阻塞 I/O</strong> ：<ul><li>指当用户进程调用 I/O 操作时，进程就被阻塞，需要等待 I/O 操作完成，进程才被唤醒继续执行</li><li>大多数 OS 提供的 I/O 接口都是采用阻塞 I/O</li><li><strong>优点</strong>：操作简单，实现难度低，适合并发量小的应用开发</li><li><strong>缺点</strong>：I/O 执行阶段进程会一直阻塞下去</li></ul></li><li><strong>非阻塞 I/O</strong> ：<ul><li>指用户进程调用 I/O 操作时，不阻塞该进程，但进程需要通过轮询的方式来查询 I/O 操作是否完成</li><li><strong>优点</strong>：进程在等待 I/O 期间不会被阻塞，可以做其他事情，适合并发量大的应用开发</li><li><strong>缺点</strong>：轮询方式询问 I/O 结果，会占用 CPU 的时间</li></ul></li></ul><h2 id="设备独立性软件-2">设备独立性软件</h2><h3 id="设备独立性软件-3">设备独立性软件</h3><ul><li>与设备无关的软件是 I/O 系统的最高层软件，它的下层是设备驱动程序，其间的界限因操作系统和设备的不同而有所差异</li></ul><h3 id="高速缓存与缓冲区">高速缓存与缓冲区</h3><h4 id="磁盘高速缓存">磁盘高速缓存</h4><ul><li>操作系统中使用磁盘高速缓存技术来提高磁盘的 I/O 速度，对访问高速缓存要比访问原始磁盘数据更为高效</li><li>磁盘高速缓存<strong>逻辑上属于磁盘</strong>，<strong>物理上是驻留在内存中的盘块</strong></li><li>磁盘高速缓存在内存中分为两种形式：<ol><li>在内存中开辟一个独立的空间作为磁盘高速缓存。大小固定</li><li>把未利用内存空间作为一个缓冲池，仅供请求分页系统和磁盘 I/O 时共享</li></ol></li></ul><h4 id="缓冲区">缓冲区</h4><ul><li><strong>引入缓冲区的目的</strong>：<ul><li>缓和 CPU 与 I/O 设备间速度不匹配的矛盾</li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制</li><li>解决基本数据单元大小（即数据粒度）不匹配的问题</li><li>提高 CPU 和 I/O 设备之间的并行性</li></ul></li><li><strong>实现方法</strong>：<ul><li>采用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器</li><li>采用缓冲区（位于内存区域）</li></ul></li><li>根据系统设置<strong>缓冲区的个数</strong>，缓冲技术可以分为：</li></ul><h5 id="单缓冲">单缓冲</h5><ul><li>T时间：数据从磁盘 —&gt; 缓冲区</li><li>M时间：数据从缓冲区 —&gt; 用户</li><li>C 时间：CPU 对一块数据处理的时间<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604162046.png" alt="image.png"></li><li><strong>注意</strong>：<ul><li>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</li><li>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604162941.png" alt="image.png"></li></ul></li><li><strong>结论</strong>：采用单缓冲策略，处理一块数据平均耗时 <strong>Max (C, T)+M</strong></li></ul><h5 id="双缓冲">双缓冲</h5><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604163543.png" alt="image.png"></p><ul><li>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604163708.png" alt="image.png"></li><li><strong>结论</strong>：采用双缓冲策略，处理一个数据块的平均耗时为 <strong>Max (T, C+M)</strong></li></ul><h5 id="循环缓冲">循环缓冲</h5><ul><li>将多个<strong>大小相等</strong>的缓冲区连接成一个<strong>循环队列</strong></li><li>下图中橙色表示已充满数据的缓冲区，绿色表示空缓冲区</li><li>当需要向缓冲区中冲入数据时，只要找到in指针指向的空缓冲区，向其中冲入数据，然后再把in指针指向下一个空缓冲区</li><li>当需要取出满缓冲区的内容时，找到 out 指针执行的满缓冲，读完数据后，将指针指向下一个满缓冲区。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604164039.png" alt="image.png"></li></ul><h5 id="缓冲池">缓冲池</h5><ul><li>缓冲池由系统中共用的缓冲区组成</li><li>缓冲区<strong>按使用状况</strong>可以分为：<ul><li><strong>空缓冲队列</strong></li><li><strong>输入队列</strong>：存储的是从设备发送给内存的数据</li><li><strong>输出队列</strong>：存储的是从内存发送给设备的数据</li></ul></li><li>根据一个缓冲区<strong>在实际运算中扮演的功能</strong>不同分为四种工作缓冲区：<ul><li>用于<strong>收容输入数据</strong>的工作缓冲区（hin）</li><li>用于<strong>提取输入数据</strong>的工作缓冲区（sin）</li><li>用于<strong>收容输出数据</strong>的工作缓冲区（hout）</li><li>用于<strong>提取输出数据</strong>的工作缓冲区（sout）<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604164403.png" alt="image.png"></li></ul></li><li><strong>收容输入</strong>：<ul><li>输入进程需要输入数据时，从空缓冲队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区，然后将数据输入其中，装满后再将它挂到输入队列的队尾</li></ul></li><li><strong>提取输入</strong>：<ul><li>计算进程需要输入数据时，从输入队列的队首取得一个缓冲区，作为提取输入工作缓冲区，从中提取数据，用完该数据后将它挂到空缓冲队列的队尾</li></ul></li><li><strong>收容输出</strong>：<ul><li>计算进程需要输出数据时，从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满数据后，再将它挂到输出队列的队尾</li></ul></li><li><strong>提取输出</strong>：<ul><li>输出进程需要输出数据时，从输出队列的队首取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾</li></ul></li></ul><h4 id="高速缓存与缓冲区的对比">高速缓存与缓冲区的对比</h4><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604165750.png" alt="image.png"></p><h3 id="设备分配与回收">设备分配与回收</h3><ul><li><strong>设备分配</strong>：指根据用户的 I/O 请求分配所需的设备</li></ul><h4 id="设备分配的策略">设备分配的策略</h4><h5 id="设备分配原则">设备分配原则</h5><ul><li><strong>设备固有属性</strong>决定了设备的使用方式（充分发挥设备的使用效率，尽可能让设备忙碌）</li><li><strong>设备独立性</strong>可以提高设备分配的灵活性和设备的利用率（设备独立性是指用户使用设备的透明性，即用户程序与实际使用的物理设备无关）</li><li><strong>设备安全性</strong>可以保证分配设备时不会导致永久阻塞（要避免造成进程死锁）</li></ul><h5 id="设备的固有属性">设备的固有属性</h5><ul><li><strong>独占设备</strong>：将它分配给某个进程后，便由该进程独占，直至进程完成或释放该设备</li><li><strong>共享设备</strong>：可将它同时分配给多个进程，需要合理调度各个进程访问该设备的先后次序</li><li><strong>虚拟设备</strong>：属于可共享设备，可将它同时分配给多个进程使用</li></ul><h5 id="设备分配算法">设备分配算法</h5><ul><li><strong>FCFS 算法</strong>：根据设备提出请求的先后次序</li><li><strong>最高优先级算法</strong>：根据设备的优先级</li></ul><h5 id="设备分配的方式">设备分配的方式</h5><ul><li><strong>静态分配</strong>：<ul><li>主要用于对<strong>独占设备</strong>的分配</li><li>进程运行前为其分配全部所需资源，运行结束后归还资源</li><li>一旦分配，这些设备、控制器就一直为该作业所占用，直到该作业被撤销</li><li><strong>特点</strong>：不会出现死锁，但设备的使用效率低</li></ul></li><li><strong>动态分配</strong>：<ul><li>进程运行过程中通过系统调用命令动态申请设备资源</li><li>一旦用完，便立即释放</li><li><strong>特点</strong>：有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁</li></ul></li></ul><h5 id="设备分配中的安全性">设备分配中的安全性</h5><ul><li><p>设备分配安全性是指设备分配中应防止发生进程死锁</p></li><li><p><strong>安全分配方式</strong>：</p><ul><li>每当进程发出 I/O 请求后，便进入阻塞态，本次 I/O 完成后才将进程唤醒</li><li>在一个时间段内每个进程只能使用一个设备</li><li><strong>优点</strong>：破坏了请求等待条件，不会死锁，设备分配安全</li><li><strong>缺点</strong>：对于一个进程来说，CPU 和 I/O 设备只能串行工作，系统资源利用率低</li></ul></li><li><p><strong>不安全分配方式</strong>：</p><ul><li>进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求，只有某个 I/O 请求得不到满足时才将进程阻塞</li><li>一个进程可以同时使用多个设备</li><li><strong>优点</strong>：进程的计算任务和 I/O 任务可以并行处理，使进程推进</li><li><strong>缺点</strong>：有可能发生死锁</li></ul></li></ul><h4 id="设备分配的数据结构">设备分配的数据结构</h4><ul><li>“设备、控制器、通道”之间的关系：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605151539.png" alt="image.png"></li></ul><h5 id="设备控制表（DCT）">设备控制表（DCT）</h5><ul><li>系统为每个设备配置一张 DCT，用于记录设备情况<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605151817.png" alt="image.png"></li></ul><h5 id="控制器控制表（COCT）">控制器控制表（COCT）</h5><ul><li>每个设备控制器对应一张 COCT</li><li>OS 根据 COCT 的信息对控制器进行操作和管理<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605151934.png" alt="image.png"></li></ul><h5 id="通道控制表（CHCT）">通道控制表（CHCT）</h5><ul><li>每个通道对应一张 CHCT</li><li>OS 根据 CHCT 的信息对通道进行操作和管理<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605152039.png" alt="image.png"></li></ul><h5 id="系统设备表（SDT）">系统设备表（SDT）</h5><ul><li>记录了<strong>系统中全部设备</strong>的情况</li><li>每个设备对应一个表目<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605152145.png" alt="image.png"></li></ul><h4 id="设备分配的步骤">设备分配的步骤</h4><ul><li>以独占设备为例：</li></ul><ol><li><strong>分配设备</strong>：<ul><li>首先根据 I/O 请求中的<strong>物理设备名</strong>，查找 SDT，从中找出该设备的 DCT</li><li>再根据 DCT 中的设备状态字段，可知该设备的状态：<ul><li>若忙，则将该进程 PCB 挂到设备等待队列</li><li>若不忙，则根据一定的策略将该设备分配给该进程</li></ul></li></ul></li><li><strong>分配控制器</strong>：<ul><li>根据 DCT 找到 COCT，查询控制器的状态：<ul><li>若忙，则将该进程 PCB 挂到控制器等待队列</li><li>若不忙，则将控制器分配给该进程</li></ul></li></ul></li><li><strong>分配通道</strong>：<ul><li>根据 COCT 找到 CHCT，查询通道的状态：<ul><li>若忙，则将进程 PCB 挂到通道等待队列</li><li>若不忙，则将通道分配给该进程</li></ul></li></ul></li></ol><ul><li><strong>注意</strong>：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动 I/O设备进行数据传送</li></ul><h4 id="逻辑设备名到物理设备名的映射">逻辑设备名到物理设备名的映射</h4><ul><li><strong>目的</strong>：为了实现设备的独立性，进程中使用逻辑设备名来请求某类设备</li><li><strong>逻辑设备表（LUT）</strong>：<ul><li>用于将逻辑设备名映射为物理设备名</li><li>每个表项包含 3 项内容：<ul><li>逻辑设备名</li><li>物理设备名</li><li>设备驱动程序的入口地址</li></ul></li><li>两种方式：<ol><li><strong>整个系统只设置一张 LUT</strong>：<ul><li>所有进程的设备分配情况都记录在同一张 LUT 中</li><li>要求所有用户不能使用相同的逻辑设备名</li><li>主要适用于单用户系统</li></ul></li><li><strong>为每个用户设置一张 LUT</strong>：<ul><li>同时在多用户系统中都配置系统设备表</li><li>不同用户可以使用相同的逻辑设备名<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606152840.png" alt="image.png"></li></ul></li></ol></li></ul></li></ul><h3 id="4-、SPOOLing-技术（假脱机技术）">4 、SPOOLing 技术（假脱机技术）</h3><h4 id="脱机技术">脱机技术</h4><ul><li>批处理阶段引入了<strong>脱机输入/输出</strong>技术（用磁带完成）</li><li><strong>引入目的</strong>：<ul><li>缓解了 CPU 与慢速 I/O 设备的速度矛盾</li><li>实现预输入、缓输出</li></ul></li><li><strong>组成</strong>：外围控制机 + 更高速的设备（磁带）<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606154710.png" alt="image.png"></li></ul><h4 id="假脱机技术的实现">假脱机技术的实现</h4><ul><li><strong>假脱机技术</strong>：又叫 SPOOLing 技术，用<strong>软件</strong>的方式模拟脱机技术，不需要外围机，是一项将<strong>独占设备改造成共享设备</strong>的软件技术<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606154731.png" alt="image.png"></li></ul><h5 id="输入井和输出井">输入井和输出井</h5><ul><li>在磁盘上开辟出的两个存储区域</li><li><strong>输入井</strong>：模拟脱机输入时的磁盘，用于收容 I/O 设备输入的数据</li><li><strong>输出井</strong>：模拟脱机输出时的磁盘，用于收容用户程序的输出数据</li><li>一个进程的输入（或输出）数据保存为一个文件</li><li>所有进程的数据输入（或输出）文件链接成一个输入（或输出）队列</li></ul><h5 id="输入缓冲区和输出缓冲区">输入缓冲区和输出缓冲区</h5><ul><li>在内存中开辟的两个缓冲区</li><li><strong>输入缓冲区</strong>：暂存由输入设备送来的数据，以后早传送到输入井</li><li><strong>输出缓冲区</strong>：暂存从输出井送来的数据，以后再传送到输出设备</li></ul><h5 id="输入进程和输出进程">输入进程和输出进程</h5><ul><li>用于模拟脱机技术的外围控制机</li><li><strong>输入进程</strong>：<ul><li>将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井中</li><li>CPU 需要输入数据时，直接从输入井中读入内存</li></ul></li><li><strong>输出进程</strong>：<ul><li>将用户要求输入的数据从内存传送到输出井</li><li>待输出设备空闲时，再将输出井中的数据经输出缓冲区输出至输出设备。</li></ul></li></ul><h5 id="井管理程序">井管理程序</h5><ul><li>用于控制作业与磁盘井之间信息的交换</li></ul><h5 id="SPOOLing-系统的特点">SPOOLing 系统的特点</h5><ul><li><strong>提高了IO速度</strong>，将对低速IO设备执行的IO操作演变为对磁盘缓冲区中数据的存取</li><li><strong>将独占设备变为共享设备</strong>，且实际上没有为任何进程分配设备</li><li><strong>提高了独占设备的利用率</strong>，缓和了CPU和低速IO设备之间的速度不匹配的矛盾</li><li><strong>实现了虚拟设备功能</strong>，对每个进程而言，都认为自己独占了一个设备</li><li><strong>以空间换时间</strong>，需要磁盘空间（输入输出井）和内存空间（输入输出缓冲区）</li></ul><h4 id="共享打印机的实现">共享打印机的实现</h4><ul><li><strong>打印机是独占设备</strong>，只允许各个进程串行使用设备，一段时间内只能满足一个进程的请求</li><li>利用用 SPOOLing 技术将其<strong>改造成“共享设备”</strong>，实现原理：<ul><li>当用户进程请求打印输出时，SPOOLing 系统同意打印，但是并不真正立即把打印机分配给该进程，而由假脱机管理进程完成两项任务：<ol><li>在<strong>磁盘缓冲区</strong>中为之申请一个空闲盘块，并将要打印的数据送入其中暂存</li><li>为用户进程申请一张空白的<strong>用户请求打印表</strong>，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列上</li></ol></li><li><strong>当打印机空闲时</strong>，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求打印数据从输出井传送到输出缓冲区，再输出到打印机打印</li></ul></li><li>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于一个逻辑设备）使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606161932.png" alt="image.png"></li></ul><h3 id="设备驱动程序接口">设备驱动程序接口</h3><ul><li>设备驱动程序：是 I/O 系统的上层与设备控制器之间的通信程序</li><li><strong>具有的功能</strong>：<ul><li>接收由上层软件发来的命令和参数，并将抽象要求转换为与设备相关的具体要求【例如，将抽象要求中的盘块号转换为磁盘的盘面号、磁道号及扇区号】</li><li>检查用户 IO 请求的合法性，了解设备的工作状态，传递与设备操作有关的参数，设置设备的工作方式</li><li>发出 I/O 命令，若设备空闲，则立即启动它，完成指定的 I/O 操作；若设备忙，则将请求者的 PCB 挂到设备队列上等待</li><li>及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理</li></ul></li><li>与普通应用/系统程序的<strong>差异</strong>：<ul><li>设备驱动程序将抽象的I/O 请求转换成具体的 I/O 操作后，传送给设备控制器，并将设备控制器中记录的设备状态和 I/O操作的完成情况及时地反馈给请求进程</li><li>设备驱动程序与设备采用的 I/O 控制方式紧密相关，常用的 I/O 控制方式是<strong>中断驱动方式和 DMA 方式</strong></li><li>设备驱动程序与硬件密切相关，对于不同类型的设备，应配置不同的设备驱动程序</li><li>由于设备驱动程序与硬件紧密相关，目前很多设<strong>备驱动程序的基本部分已固化在 ROM</strong></li><li>设备驱动程序应<strong>允许同时多次调用执行</strong></li></ul></li><li>如何使所有的设备驱动程序都有统一的接口：<ul><li>要求每个设备驱动程序与操作系统之间都有相同或相近的接口，便于添加新的设备驱动程序和编制设备驱动程序</li><li>要将抽象的设备名转换为具体的物理设备名，并且进一步找到相应的设备驱动程序入口</li><li>对设备进行保护<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608154956.png" alt="image.png"></li></ul></li><li>对于每种设备类型，例如磁盘，OS 都要定义一组驱动程序必须支持的函数（读、写、格式化等）</li><li>驱动程序包含一张表格，具有针对这些函数指向驱动程序自身的指针</li><li>装载驱动程序时，OS 记录这个函数指针表的地址，当 OS 调用一个函数时，可通过这张表格发出间接调用</li><li>函数指针表定义了驱动程序与操作系统其余部分之间的接口</li></ul><h2 id="磁盘与固态硬盘">磁盘与固态硬盘</h2><h3 id="磁盘">磁盘</h3><h4 id="磁盘、磁道、扇区">磁盘、磁道、扇区</h4><ul><li>磁盘的表面是由一些磁性物质组成，可以用这些磁性物理记录二进制数据</li><li>磁盘表面被划分成多个磁道</li><li>每个磁道被划分为多个扇区，每个扇区就是一个“磁盘块”</li><li>每个扇区的数据量相同（如 1 KB）<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608162835.png" alt="image.png"></li></ul><h4 id="盘面、盘柱">盘面、盘柱</h4><ul><li>磁盘是由多个盘片摞起来的，每个盘片有两个盘面</li><li>每个盘面都对应一个磁头，所有的磁头都连在同一个磁臂上</li><li>磁臂可以沿着盘面作径向运动，从而带动磁头到达不同的磁道来对不同扇区的读写操作</li><li>所有盘面中的相对位置相同的磁道组成了柱面<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608165227.png" alt="image.png"></li></ul><h4 id="在磁盘中读-写数据">在磁盘中读/写数据</h4><ul><li>在磁盘中读写数据，需要借助磁头<ul><li>step 1：<strong>将磁头移动</strong>到想要读/写的<strong>扇区所在的磁道</strong></li><li>step 2：<strong>磁盘会转动</strong>，让<strong>目标扇区从磁头下面划过</strong>，才能完成对扇区的读/写操作</li></ul></li></ul><h4 id="磁盘的物理地址">磁盘的物理地址</h4><ul><li>使用 <strong>（柱面号，盘面号，扇区号）</strong> 来定位任意一个磁盘块</li><li>文件数据存放在外存中的几号块，这里的块号就可以转换为（柱面号，盘面号，扇区号）的地址形式</li><li>根据物理地址读取一个“块”：<ol><li>根据柱面号移动磁臂，让<strong>磁头指向指定柱面</strong></li><li>激活<strong>指定盘面对应的磁头</strong></li><li>磁盘旋转的过程，<strong>指定的扇区</strong>会从磁头下面划过，这样就完成了对指定扇区的读写</li></ol></li></ul><h4 id="磁盘的分类">磁盘的分类</h4><ul><li>根据<strong>磁头是否可以活动</strong>划分：<ul><li>活动头磁盘</li><li>固定头磁盘</li></ul></li><li>根据<strong>盘面是否可以更换</strong>划分：<ul><li>可换磁盘</li><li>固定盘磁盘</li></ul></li></ul><h3 id="磁盘的管理">磁盘的管理</h3><h4 id="磁盘初始化">磁盘初始化</h4><ul><li><strong>低级格式化</strong>【物理格式化】：<ul><li>在磁盘可以存储数据之前，<strong>将它分为扇区</strong>，以便磁盘控制器能够进行读写操作</li><li>每个扇区通常由头部、数据区域（通常为 512 B 大小）和尾部组成</li><li>头部和尾部包含了一些磁盘控制器的使用信息：<ul><li>利用磁道号、磁头号和扇区号标志一个扇区</li><li>利用 CRC 字段对扇区进行校验</li></ul></li></ul></li></ul><h4 id="分区">分区</h4><ul><li>将磁盘<strong>分为由一个或多个柱面组成的分区</strong> (如 C 区，D 区)，每个分区的起始扇区和大小都记在磁盘主引导记录的分区表</li><li><strong>对物理分区进行逻辑格式化</strong>【创建文件系统】，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和己分配的空间以及一个初始为空的目录</li><li><strong>簇</strong>：<ul><li>将多个相邻的扇区组合在一起，提高效率</li><li>一簇只能存放一个文件的内容</li><li>文件所占用的空间只能是<strong>簇的整数倍</strong></li><li>文件大小小于一簇（甚至是 0 字节），也要占用一簇的空间</li></ul></li></ul><h4 id="引导块">引导块</h4><ul><li>计算机启动时需要运行<strong>初始化程序（自举程序）</strong> 来初始化 CPU、寄存器、设备控制器和内存等，接着启动 OS</li><li><strong>ROM 中存放很小的自举装入程序</strong>：避免改变自举代码而需改变 ROM 硬件</li><li>完整的自举程序存放在磁盘的启动块（引导块/启动分区）上，启动块位于磁盘的固定位置</li><li>拥有启动分区的磁盘称为<strong>启动磁盘</strong>或<strong>系统磁盘</strong>（C: 盘）</li><li>计算机开机工作：先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</li></ul><h4 id="坏块的管理">坏块的管理</h4><ul><li>简单的磁盘：逻辑格式化时将坏块标记出来</li><li>复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</li></ul><h3 id="磁盘调度算法">磁盘调度算法</h3><ul><li><strong>磁盘调度算法的目的</strong>：为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的</li><li><strong>寻道的时间是磁盘访问最耗时的部分</strong>，如果请求顺序优化的得当，可以节省一些不必要的寻道时间，从而提高磁盘的访问性能</li><li>绝大数 OS 为改善磁盘访问时间，以簇（一组块）为单位进行空间划分</li></ul><h4 id="一次磁盘读-写操作需要的时间">一次磁盘读/写操作需要的时间</h4><h5 id="寻道时间-Ts">寻道时间 Ts</h5><ul><li>在读/写数据前，需要将磁头移动到指定磁道所花费的时间</li><li>分两步：<ol><li><strong>启动磁头臂</strong>消耗的时间 s</li><li><strong>移动磁头</strong>消耗的时间：假设磁头匀速移动，每跨越一个磁道消耗时间为 m，共跨越 n 条磁道</li></ol></li><li><strong>Ts=s+m×n</strong></li></ul><h5 id="延迟时间-Tr">延迟时间 Tr</h5><ul><li>通过旋转磁盘，使磁头定位到目标扇区所需要的时间</li><li>设磁盘转速 r（单位：转/秒）</li><li><strong>Tr= $\frac{1}{2}*\frac{1}{r}=\frac{1}{2r}$</strong></li><li>1/r 就是转一圈所需的时间，找到目标扇区平均需要转半圈，因此再乘以 1/2</li></ul><h5 id="传输时间-Tt">传输时间 Tt</h5><ul><li>从磁盘读出或向磁盘写入数据所经历的时间</li><li>设磁盘转速 r，此次读/写的字节数为 b，每个磁道上的字节数为 N</li><li><strong>Tt=</strong>$\frac{1}{r}*\frac{b}{N}=\frac{b}{rN}$</li><li>每个磁道可存 N 字节数据，因此 b 字节数据需要 b/N 个磁道【扇区】才能存储</li><li><strong>平均传输时间等于一个扇区划过磁头下方所需要的时间</strong>【2022 大题】</li><li>读/写一个磁道所需的时间刚好是转一圈的时间 1/r</li></ul><h5 id="总的平均时间">总的平均时间</h5><ul><li>T= $T_s+\frac{1}{2r}+\frac{b}{rN}$</li><li>无法通过操作系统优化延迟时间和传输时间，所以只能优化寻道时间</li></ul><h4 id="调度算法">调度算法</h4><ul><li>假设有一个请求序列，每个数字代表磁道的位置：98，183，37，122，14，124，65，67，初始磁头当前的位置是在第 53 磁道</li></ul><h5 id="先来先服务算法-FCFS">先来先服务算法 FCFS</h5><ul><li><strong>思想</strong>：先到来的请求，先被服务</li><li><strong>优点</strong>：<ul><li>公平，简单</li><li>请求访问的磁道比较集中的话算法性能还算可以</li></ul></li><li><strong>缺点</strong>：<ul><li>比较简单粗暴</li><li>如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散</li><li>算法在性能上就会显得很差，因为寻道时间过长</li></ul></li><li><strong>处理顺序</strong>：98，183，37，122，14，124，65，67<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200246.png" alt="image.png"></li></ul><h5 id="最短寻找时间算法-SSTF">最短寻找时间算法 SSTF</h5><ul><li><strong>思想</strong>：优先选择从当前磁头位置所需寻道时间最短的请求</li><li><strong>优点</strong>：<ul><li>是贪心算法的思想，只是选择眼前最优，但是总体未必最优</li><li>比 FCFS 效果好</li></ul></li><li><strong>缺点</strong>：<ul><li>存在饥饿现象</li><li>产生饥饿的原因是<strong>磁头在一小块区域来回移动</strong></li></ul></li><li><strong>处理顺序</strong>：65，67，37，14，98，122，124，183<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200246.png" alt=""></li></ul><h5 id="扫描-电梯算法-SCAN">扫描/电梯算法 SCAN</h5><ul><li><strong>思想</strong>：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向</li><li><strong>优点</strong>：<ul><li>性能较好，寻道时间较短</li><li>不会产生饥饿现象</li></ul></li><li><strong>缺点</strong>：<ul><li>中间部分的磁道会比较占便宜</li><li>中间部分相比其他部分响应的频率会比较多</li><li>也就是说每个磁道的响应频率存在差异</li></ul></li><li><strong>处理顺序</strong>：<ul><li>假设扫描调度算先朝磁道号减少的方向移动</li><li>磁头先响应左边的请求</li><li>直到到达最左端后，才开始反向移动，响应右边的请求</li><li>7，14，0，65，67，98，122，124，183</li></ul></li><li><strong>改进 LOOK 算法</strong>：只要在磁头移动方向上不再有请求，就立即改变磁头方向<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200254.png" alt="image.png"></li></ul><h5 id="循环扫描算法-C-SCAN">循环扫描算法 C-SCAN</h5><ul><li><strong>思想</strong>：<ul><li>只有磁头朝某个特定方向移动时，才处理磁道访问请求</li><li>而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头</li><li>这个过程是很快的，并且返回中途不处理任何请求</li><li><strong>特点：磁道只响应一个方向上的请求</strong></li></ul></li><li><strong>优点</strong>：对于各个位置磁道响应频率很平均</li><li><strong>缺点</strong>：相比于 SCAN 算法，平均寻道时间更长</li><li><strong>处理顺序</strong>：<ul><li>假设循环扫描调度算先朝磁道增加的方向移动</li><li>磁头先响应了右边的请求</li><li>直到碰到了最右端的磁道 199，就立即回到磁盘的开始处</li><li>但这个返回的途中是不响应任何请求的</li><li>直到到达最开始的磁道后，才继续顺序响应右边的请求</li><li>65，67，98，122，124，183，199，0，14，37</li></ul></li><li><strong>改进 C-LOOK 算法</strong>：只要在磁头移动方向上不再有请求，就立即改变磁头方向<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200301.png" alt="image.png"></li></ul><h4 id="减少磁盘延迟时间的方法">减少磁盘延迟时间的方法</h4><ul><li>磁头读入一个扇区数据后需要一小段时间处理</li><li>如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</li></ul><h5 id="交替编号">交替编号</h5><ul><li><strong>思想</strong>：让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608201651.png" alt="image.png"></li><li><strong>思考</strong>：磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</li><li>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以<strong>减少磁头移动消耗的时间</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608201940.png" alt="image.png"></li></ul><h5 id="错位命名">错位命名</h5><ul><li><strong>思想</strong>：让相邻盘面的扇区编号错位<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608202223.png" alt="image.png"></li></ul><h4 id="固态硬盘">固态硬盘</h4>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O 设备分类（块设备 / 字符设备） </tag>
            
            <tag> I/O 控制方式（DMA / 通道） </tag>
            
            <tag> 磁盘调度算法（FCFS/SSTF/SCAN） </tag>
            
            <tag> SPOOLing 技术 </tag>
            
            <tag> 设备分配与回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 5 章 中央处理器</title>
      <link href="/post/d64a2c5e.html"/>
      <url>/post/d64a2c5e.html</url>
      
        <content type="html"><![CDATA[<h2 id="CPU-的功能和基本结构">CPU 的功能和基本结构</h2><h3 id="CPU-的功能">CPU 的功能</h3><ol><li><strong>指令控制</strong>：<ul><li>完成取指令、分析指令和执行指令的操作，即程序的顺序控制</li></ul></li><li><strong>操作控制</strong>：<ul><li>管理并产生由内存取出的每条指令的操作信号</li><li>把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作</li></ul></li><li><strong>时间控制</strong>：<ul><li>严格控制各种操作信号的出现时间、持续时间及出现的时间顺序</li></ul></li><li><strong>数据加工</strong>：<ul><li>对数据进行算术和逻辑运算</li></ul></li><li><strong>中断处理</strong>：<ul><li>对计算机运行过程中出现的异常情况和特殊请求进行处理</li></ul></li></ol><h3 id="CPU-的基本结构">CPU 的基本结构</h3><h4 id="组成部分">组成部分</h4><ol><li>CPU = 运算器 + 控制器<ul><li>运算器：对数据进行加工</li><li>控制器：负责协调并控制计算机各部件执行程序的指令</li></ul></li><li>CPU = 数据通路 + 控制部件<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240428133932.png" alt="image.png"></li></ol><h4 id="CPU-寄存器的分类">CPU 寄存器的分类</h4><p>按汇编语言（或机器语言）程序是否可以访问</p><h5 id="用户可见的寄存器">用户可见的寄存器</h5><ul><li>可对这类寄存器编程</li><li>使用这类寄存器可减少对主存储器的访问次数</li><li>如：**通用寄存器GPRs（含基址 / 变址）、程序状态字寄存器PSW、程序计数器PC、累加寄存器AC、移位寄存器SR **</li></ul><h5 id="用户不可见的寄存器">用户不可见的寄存器</h5><ul><li>对用户透明，不可编程</li><li>被控制部件使用，以控制 CPU 的操作</li><li>保留各种状态信息：溢出标志 OF，符号标志 SF，零标志 ZF，进位标志 CF</li><li>如：<strong>存储器地址寄存器MAR、存储器数据寄存器MDR、指令寄存器IR、暂存寄存器</strong></li></ul><h4 id="运算器基本结构-ALU-PSW-ACC-GPRs-暂-移-计">运算器基本结构(ALU,PSW,ACC,GPRs,暂,移,计)</h4><ul><li>运算器是计算机对数据进行加工处理的中心</li><li>接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理</li></ul><h5 id="组成">组成</h5><ul><li><strong>算术逻辑单元（ALU）</strong>：进行算术 / 逻辑运算</li><li><strong>程序状态字寄存器（PSW）</strong>：<ul><li>PSW 存放<strong>程序状态字</strong>【标志位的组合】，用于保存系统的运行状态</li><li>PSW 包括<strong>状态标志和控制标志</strong></li><li>溢出标志 OF，符号标志 SF，零标志 ZF，进位标志 CF</li><li>中断标志，陷阱标志</li></ul></li><li><strong>累加寄存器（ACC）</strong>：<ul><li>是一个通用寄存器</li><li>暂放 ALU 运算的结果信息，可作为加法运算的输入端</li></ul></li><li><strong>通用寄存器组（GPRS）</strong>：<ul><li>如 AX，BX，CX，DX，SP</li><li>通用寄存器可变成指令多种功能的寄存器</li><li>用于<strong>存放操作数和各种地址信息</strong>，所以<font color="#ff0000">其位数与机器字长相等</font></li><li>SP 是堆栈指针，用于指示栈顶的地址</li></ul></li><li><strong>暂存寄存器</strong>：<ul><li>暂存从数据总线或通用寄存器读来的操作数，为了保护通用寄存器中的原有数据不被破坏</li><li><strong>对应用程序员透明</strong></li></ul></li><li><strong>移位寄存器（SR）</strong>：移位运算包括逻辑移位和算术移位，对操作数或运算结果进行移位运算</li><li><strong>计数器</strong>：在乘法运算中，计数器用于记录重复加法的次数。在除法运算中，计数器可用于记录试商的次数，以及判断除法运算是否完成 。</li></ul><h4 id="控制器基本结构-PC-IR-ID-MAR-MDR">控制器基本结构(PC,IR,ID,MAR,MDR)</h4><ul><li>协调并控制计算机各部件执行程序的指令序列</li><li>基本功能包括<strong>取指令、分析指令、执行指令</strong><ul><li>取指令：自动形成指令地址；自动发出取指令的命令</li><li>分析指令：操作码译码（分析本条指令要完成什么操作），产生操作数的有效地址</li><li>执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作</li></ul></li><li>中断处理：管理总线及输入输出；处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）</li></ul><h5 id="组成-2">组成</h5><ul><li><strong>程序计数器（PC）</strong>：<ul><li>用于<strong>指出下一条指令在主存中的存放地址（PC 总是存放指令地址）</strong></li><li>PC 有<strong>自增功能</strong></li><li>PC 的值会根据 CPU 在执行指令过程中<strong>自增或转移到程序的某处</strong> (跳转指令)</li><li>PC 的<strong>位数等于主存储器地址位数</strong></li></ul></li><li><strong>指令寄存器（IR）</strong>：<ul><li>用于保存<strong>当前正在执行</strong>的那条指令</li><li>IR 的<strong>位数取决于指令字长</strong></li></ul></li><li><strong>指令译码器（ID）</strong>：<ul><li>仅对<strong>操作码字段进行译码</strong>，以确定指令的操作功能</li></ul></li><li><strong>存储器地址寄存器（MAR）</strong>：<ul><li>存放要访问的主存储器单元的地址</li><li>MAR 的位数等于主存储器地址线位数</li></ul></li><li><strong>存储器数据寄存器（MDR）</strong>：<ul><li>存放向主存储器写入的信息或从主存储器读出的信息</li><li>MDR 的位数等于存储字长</li></ul></li><li><strong>时序系统</strong>：用于产生各种时序信号，都由统一时钟 CLOCK 分频得到</li><li><strong>微操作信号发生器</strong>：<ul><li>根据 IR 的内容 (指令)，PSW 的内容 (状态信息) 和时序信号产生控制计算机系统所需的各种控制信号</li><li>有<strong>组合逻辑型和存储逻辑型</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250531203238827.png" alt="image.png"></li></ul></li></ul><p><strong>运算器部分</strong></p><ul><li><strong>算术逻辑单元（ALU）</strong>：核心运算部件，能执行算术运算（如加、减、乘、除 ）和逻辑运算（如与、或、非 ）。它有两个数据输入端 A 和 B ，接收来自其他部件的数据进行运算 。</li><li><strong>通用寄存器组（R0 - R3 ）</strong>：用于存放操作数、中间结果等。每个寄存器都有输入控制信号（如 R0in ）和输出控制信号（如 R0out ） ，控制数据的进出。例如， R0in 信号有效时，数据可存入 R0 寄存器 。</li><li><strong>累加寄存器（ACC）</strong>：可暂存 ALU 运算结果，也能作为加法运算的一个输入端。通过 ACCin 和 ACCout 信号控制其数据的输入和输出 。</li><li><strong>暂存寄存器</strong>：临时存储从主存或其他寄存器读取的操作数，防止破坏原寄存器数据，为运算提供临时数据存储 。</li><li><strong>移位寄存器</strong>：对操作数或运算结果进行移位操作，实现逻辑移位或算术移位，辅助运算器进行特定的数据处理 。</li></ul><p><strong>控制器部分</strong></p><ul><li><strong>程序计数器（PC）</strong>：存放即将执行的下一条指令在主存中的地址。具有自增功能，每执行完一条指令自动加 1 指向下一条指令地址（遇到跳转指令时会改变 ） 。 PCin 和 PCout 控制其数据输入输出 。</li><li><strong>指令寄存器（IR）</strong>：保存当前正在执行的指令，指令分为操作码（OP ）和地址码（Ad ）两部分。 IRin 用于将指令存入 IR ， AdIRout 用于输出地址码部分 。</li><li><strong>CU控制单元：负责协调和管理计算机的操作</strong><ul><li><strong>指令译码器（ID）</strong>：对指令寄存器中操作码字段进行译码，生成特定操作信号，告知控制器各部件如何执行指令 。</li><li><strong>微操作信号发生器</strong>：依据 IR 内容（指令 ）、程序状态字寄存器（PSW ）内容（状态信息 ）及时序信号，产生控制整个计算机系统的各种控制信号，有组合逻辑型和存储逻辑型两种结构 。</li><li><strong>时序系统</strong>：通过对统一时钟（CLOCK ）分频，产生各种时序信号，为各部件操作提供时间基准和协调控制 。</li></ul></li><li><strong>存储器地址寄存器（MAR）</strong>：存储要访问的主存单元地址，通过 MARin 信号控制地址输入 ，用于定位主存中数据或指令的位置 。</li><li><strong>存储器数据寄存器（MDR）</strong>：用于暂存向主存写入或从主存读出的信息。 MDRin 、 MDRinE控制数据写入， MDRout 、 MDRoutE控制数据输出<br>MDRinE指从系统总线输入的端; MDRin 指从CPU内部总线输入的端</li></ul><p><strong>总线部分</strong></p><ul><li><strong>CPU 内部总线</strong>：作为内部各部件之间数据传输的通道，实现运算器和控制器内部以及它们之间的数据交互 。</li><li><strong>数据总线</strong>：用于在 CPU 与主存、I/O 设备等之间传输数据 。</li><li><strong>地址总线</strong>：传输 CPU 要访问的主存单元或 I/O 设备的地址信息 。</li></ul><h4 id="数据通路基本结构">数据通路基本结构</h4><table><thead><tr><th>类别</th><th>元件名称</th><th>功能简述</th></tr></thead><tbody><tr><td><strong>操作元件</strong></td><td>算术逻辑单元（ALU）</td><td>执行算术和逻辑运算</td></tr><tr><td></td><td>译码器</td><td>将指令操作码等转换为控制信号</td></tr><tr><td></td><td>数据选择器（多路选择器）</td><td>依据控制信号从多个输入选一个输出</td></tr><tr><td></td><td>加法器</td><td>实现二进制数相加</td></tr><tr><td><strong>状态元件</strong></td><td>通用寄存器</td><td>暂存操作数、运算结果等</td></tr><tr><td></td><td>程序计数器（PC）</td><td>存储下条指令在主存的地址</td></tr><tr><td></td><td>指令寄存器（IR）</td><td>存放当前执行指令</td></tr><tr><td></td><td>存储器地址寄存器（MAR）</td><td>保存要访问主存单元的地址</td></tr><tr><td></td><td>存储器数据寄存器（MDR）</td><td>暂存主存读出或准备写入的数据</td></tr><tr><td></td><td>移位寄存器</td><td>存储并对数据进行移位操作</td></tr><tr><td></td><td>存储器</td><td>存储数据和程序代码</td></tr><tr><td>一般不包含在数据通路的元件</td><td>控制器部分控制逻辑电路</td><td>负责控制流程和决策</td></tr><tr><td></td><td>电源电路、时钟发生电路等辅助电路</td><td>供电和产生时钟信号</td></tr></tbody></table><h5 id="专用数据通路方式">专用数据通路方式</h5><ul><li>根据指令执行过程中的数据和地址的流动方向安排连线线路<br>比如对于 “从内存读取数据并与寄存器中的数据相加” 这条指令，数据从内存经数据总线到运算器、操作数在寄存器间以及到算术逻辑单元（ALU ）的流动路径，会被专门铺设线路。</li><li>通俗解释：专门为指令的执行设计一条专属通道，避免使用共享的总线，没有冲突</li><li>使用<strong>多路选择器</strong>控制一路的输出</li><li>使用<strong>三态门</strong>控制输出</li><li><strong>优点</strong>：性能较高，基本<strong>不存在数据冲突现象</strong></li><li><strong>缺点</strong>：结构复杂，硬件量大，不易实现，成本高</li></ul><h5 id="CPU-内部单总线方式">CPU 内部单总线方式</h5><ul><li>将所有寄存器的输入端和控制端都连接到一条公共通路上，所有数据都要走这条路来传输数据</li><li>通俗解释：计算机中的所有寄存器的输入输出端都连接到一条公共通路上</li><li><strong>优点</strong>：结构简单，容易实现</li><li><strong>缺点</strong>：传输存在较多冲突现象，性能较低</li></ul><p><strong>管理多条通路</strong>：多路选择器MUX与三态门</p><ul><li><strong>多路选择器 MUX</strong>：在管理多条通路时，MUX 是关键组件。它可以<strong>从多个输入信号中选择一个输出，通过控制信号来决定选择哪一路输入</strong>。例如在具有多条数据通路的系统中，MUX 可根据指令需求，从不同寄存器或数据源的输出中选择合适的数据传输到目标部件，避免数据通路之间的干扰和冲突 。</li><li><strong>三态门</strong>：<strong>三态门用于控制通路的连接与断开</strong>。在多条通路的系统中，通过三态门可以控制每一条通路是否输出数据。当三态门处于高阻态时，该通路与其他部件之间的连接相当于断开，不会对其他通路的数据传输产生影响；当处于导通状态时，数据可以在该通路中正常传输，从而实现对多条通路的有效管理</li></ul><h3 id="CPU-常混淆点">CPU 常混淆点</h3><ul><li><strong>转移指令</strong>时，需要判别转移是否成功，若成功则 PC 修改为转移指令的目标地址，否则下一条指令的地址仍然为 PC 自增后的地址</li><li><strong>计算机分两大部分</strong>：<strong>控制</strong>部件和<strong>执行</strong>部件<ul><li>控制器就是控制部件，<strong>指令寄存器，操作控制器，程序计数器</strong>都是控制部件</li><li>运算器（例如PSW、ALU、通用寄存器），<strong>存储器，外围设备</strong>就是执行部件</li></ul></li><li><strong>各寄存器的位数等于什么？</strong>【和<strong>地址</strong>有关的（PC、MAR）就取决于<strong>机器字长</strong>，和<strong>数据大小</strong>有关的（MDR、GPRs）就取决于<strong>容量</strong>】<ul><li><strong>通用寄存器</strong>：<strong>机器字长</strong></li><li><strong>PC</strong>：<ul><li>按<strong>字节</strong>编址：与<strong>存储器地址的位数</strong>相等，取决于存储器容量</li><li>按<strong>字</strong>编址：位数 = <strong>存储器地址的位数 - $log_2(指令字长的字节数)$</strong> 【指令必须按边界对齐的方式存放】，取决于存储器容量和存储字长</li></ul></li><li><strong>IR：指令字长</strong></li><li><strong>MAR：存储器容量</strong></li><li><strong>MDR：存储字长</strong></li></ul></li></ul><table><thead><tr><th>寄存器</th><th>位数决定因素</th><th>假设存储器 1KB，指令字长 4 字节</th></tr></thead><tbody><tr><td>通用寄存器</td><td>机器字长</td><td>32 位</td></tr><tr><td>PC（字节编址）</td><td>存储器地址位数</td><td>10 位</td></tr><tr><td>PC（字编址）</td><td>存储器地址位数，指令字长</td><td>10 - log2​(4) = 8 位</td></tr><tr><td>IR</td><td>指令字长</td><td>32 位</td></tr><tr><td>MAR</td><td>存储器地址位数</td><td>10 位</td></tr><tr><td>MDR</td><td>存储字长，数据总线的宽度</td><td>8 位（按字节编址）</td></tr></tbody></table><h2 id="指令执行过程">指令执行过程</h2><h3 id="指令周期相关概念">指令周期相关概念</h3><ul><li><p><strong>指令周期</strong>：CPU 从主存中每<strong>取出并执行</strong>一条指令所需的全部时间，一个指令周期由多个机器周期组成<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602193858760.png" alt="image.png"></p></li><li><p>指令周期最多有 4 种机器周期：<strong>取指周期、间址周期、执行周期、中断周期</strong>（都有访问主存的操作）</p></li><li><p>分别对应标志触发器：<strong>FE、IND、EX、INT</strong>（“1”表示有效，如 1–&gt;FE 表示有取值周期）<img src="" alt="Uploading file...o6lc6"><br><a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602194709866.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602194709866.png</a></p></li><li><p>取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p></li></ul><h4 id="易混淆知识点">易混淆知识点</h4><ul><li><p><strong>指令</strong>：</p><ul><li>CPU 区分指令和数据的依据是<strong>指令周期的不同阶段</strong>【<strong>取指周期取指令</strong>，<strong>执行周期取数据</strong>】<br>例：取指阶段，PC 指向指令地址，主存返回指令；执行阶段，指令中的操作数地址指向数据，主存返回数据。</li><li>不同长度的指令，取指操作可能不同（如双字指令，三字指令和单字指令）</li><li>指令长度相同的情况下，指令的取指操作是相同的</li><li><strong>指令总是根据 PC 从主存中读出</strong>（<strong>无条件转移指令</strong>或<strong>中断返回指令</strong>也是如此，最终的结果还是根据 PC 从主存读出）</li></ul></li><li><p><strong>取指</strong>：</p><ul><li>取指操作是控制器固有的功能，<strong>不需要操作码的控制</strong>，由硬件逻辑自动触发（如时钟信号驱动 PC 递增并访存）</li><li>取指操作是<strong>自动进行</strong>的，控制器不需要得到相应的指令<br>控制器在每个指令周期开始时，自动执行 “取指 - 译码 - 执行” 流程，无需额外指令控制取指动作。</li><li>取指周期简单来说是取指，即<strong>从主存中取出指令字</strong>，存入IR，供后续译码使用。</li></ul></li><li><p><strong>字长</strong>：</p><ul><li>为了硬件设计方便，<strong>指令字长一般取存储字长的整数倍</strong></li><li>如果指令字长=存储字长的 2 倍，则取一条指令需要访存 2 次，取指周期是机器周期的 2 倍</li><li><strong>指令字长由指令集设计决定，与机器字长（CPU 一次处理的数据宽度）无直接关联。</strong></li></ul></li><li><p><strong>中断</strong>：</p><ul><li>CPU 在<strong>每条指令执行结束前</strong>发送中断查询信号，检测是否有中断请求。</li><li>中断响应必须在<strong>一条指令执行结束后</strong>，不能在指令执行过程中响应（确保指令原子性）</li></ul></li><li><p><strong>周期</strong>：指令周期 &gt; 机器周期 &gt; 时钟周期，机器周期由存取周期决定</p><ul><li><strong>指令周期</strong>：CPU 从主存中取指并执行一条指令的总时间，一个指令周期由多个机器周期组成</li><li><strong>机器周期（CPU 周期）</strong>：完成一个基本操作（如取指、访存）的时间，由<strong>存取周期</strong>决定（因存取周期最长）</li><li><strong>时钟周期（节拍 / T 周期）</strong>：计算机工作的<strong>最小时间周期</strong>，是 CPU 操作的<strong>基本单位</strong>；一个时钟周期内控制信号不发生改变</li><li><strong>存取周期</strong>：连续两次独立访存操作的最短间隔时间。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250601212657960.png" alt="image.png|300"></li></ul></li><li><p><strong>周期的可变性</strong>：</p><ul><li>不同指令的机器周期数可变（如简单指令 1 个机器周期，复杂指令多个）。</li><li>每个机器周期内的时钟周期数可变（根据操作复杂度调整）。</li><li>DMA（直接内存访问）传输数据时，每传送一个数据需占用一个<strong>存取周期</strong>，此时 CPU 无法访存（总线控制权被 DMA 控制器接管）。</li></ul></li><li><p><strong>其他</strong>：</p><ul><li>若不使用 Cache，每次取指令都需<strong>直接访问主存</strong>（即<strong>每个取指周期必须访存一次</strong>）</li><li>若不采用<strong>指令预取</strong>，<strong>每个指令周期都需从主存取指令</strong>（无法提前缓存下一条指令，可能降低效率）。</li></ul></li></ul><h3 id="不同指令的指令周期举例">不同指令的指令周期举例</h3><ol><li><strong>无条件转移指令 JMP X</strong>：<ul><li>指令周期 = <strong>取指周期+执行周期</strong>，无需访问操作数（因转移地址直接在指令中）</li><li><strong>PC 被修改两次</strong><ul><li><strong>取指周期结束</strong>：PC 自动加 1（指向下一条指令的地址）。</li><li><strong>执行周期</strong>：PC 被修改为目标地址 X（实现程序跳转）。</li><li>eg.假设当前指令地址为 A，取指后 PC=A+1；执行 JMP X 时，PC 被置为 X，下一条指令从 X 地址读取。</li></ul></li><li><strong>特点</strong>：<ul><li>无需访问操作数，执行速度快，常用于流程控制（如循环、条件分支）。</li></ul></li></ul></li><li><strong>间接寻址的指令</strong>：<ul><li>指令周期 = <strong>取指周期 + 间址周期 + 执行周期</strong>，需两次访存（取指令 + 取操作数地址）</li><li>各周期的作用<ul><li><strong>取指周期</strong>：从主存读取指令，PC 自动加 1。</li><li><strong>间址周期</strong>：根据指令中的间接地址（如形式地址 D）访问主存，读取操作数的有效地址 EA（存入 MDR）。<ul><li>间址周期结束时，MDR 中存储的是<strong>操作数的有效地址 EA</strong>，而非操作数本身。</li></ul></li></ul></li><li><strong>执行周期</strong>：根据 EA 访问主存，读取操作数并执行运算。</li></ul></li><li><strong>CPU 采用中断方式实现主机和 I/O 设备的信息交换且有中断请求</strong>：<ul><li>指令周期 = <strong>取指周期 + 间址周期（若有间接寻址） + 执行周期 + 中断周期</strong>，适用于 CPU 响应 I/O 中断的场景。</li><li>CPU 在每条指令执行结束前发送中断查询信号，若检测到中断请求，则进入<strong>中断周期</strong>。</li><li><strong>中断周期进栈操作是将 SP-1</strong>，计算机的堆栈都是向低地址（栈顶）增加，所有进栈操作减 1 而不是加 1</li><li>中断周期的核心操作<ul><li><strong>保存断点</strong>：将当前 PC 值（下一条指令地址）和程序状态字（PSW）压入堆栈。<ul><li>堆栈向低地址增长，因此进栈操作是SP-1（SP 为堆栈指针）：<ul><li>先SP = SP - 1，将 PC 值存入 SP 指向的单元；</li><li>再SP = SP - 1，将 PSW 存入新的 SP 指向的单元。</li></ul></li></ul></li><li><strong>设置中断服务程序入口</strong>：PC 被置为中断向量地址，准备执行中断处理程序。</li></ul></li><li>与普通指令周期的区别<ul><li>中断周期是指令周期的扩展阶段，仅在有中断请求时出现，用于保存现场和切换程序流程。</li></ul></li></ul></li></ol><table><thead><tr><th>指令类型</th><th>周期构成</th><th>访存次数</th><th>PC 修改次数</th><th>核心操作</th></tr></thead><tbody><tr><td><strong>无条件转移</strong>指令</td><td>取指周期 + 执行周期</td><td>1 次（取指令）</td><td>2 次（自动加 1 + 目标地址）</td><td>直接修改 PC 实现跳转，无需操作数</td></tr><tr><td><strong>间接</strong>寻址指令</td><td>取指周期 + 间址周期 + 执行周期</td><td>3 次（取指令 + 取 EA + 取操作数）</td><td>1 次（自动加 1）</td><td>两次访存获取操作数地址，执行周期处理操作数</td></tr><tr><td><strong>中断</strong>响应指令</td><td>取指周期 + 间址周期 + 执行周期 + 中断周期</td><td>取决于是否间接寻址</td><td>2 次（自动加 1 + 中断向量地址）</td><td>执行结束后进入中断周期，保存断点并切换到中断服务程序</td></tr></tbody></table><h3 id="指令周期的数据流">指令周期的数据流</h3><ul><li><strong>数据流</strong>：根据指令要求一次访问的数据序列</li><li>指令执行不同阶段，访问的数据序列不同</li><li>不同的指令，数据流也不同</li></ul><h4 id="取指周期">取指周期</h4><ul><li><strong>任务</strong>：根据 PC 中的内容从主存中<strong>取出指令代码</strong>并放在 IR 中</li><li>取值操作是控制器自动进行的</li><li>在指令字长相同的情况下，所有指令的取值操作是相同的</li><li><strong>数据流向</strong>：PC 中存放的是指令的地址，根据此地址从内存单元中取出的指令，并放在指令寄存器 IR 中，取指同时，PC+1<ol><li>PC—&gt;MAR—&gt;地址总线—&gt;主存</li><li>CU (控制单元) 发出读命令—&gt;控制总线—&gt;主存</li><li>主存—&gt;数据总线 MDR—&gt;IR（存放指令）</li><li>CU 发出控制信号—&gt;PC 内容加 1<br>通俗理解：PC是书的页码，存储下一条指令地址，将该地址告诉MAR（图书管理员），MAR把地址通过地址线传给内存，并找到相应地址的指令，通过数据线传给MDR，CPU从MDR读取指令到IR，存储当前要执行的指令。此时，PC+1，记住下一页的页码<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602202340752.png" alt="image.png"></li></ol></li></ul><h4 id="间址周期">间址周期</h4><ul><li><strong>任务</strong>：取操作数的<strong>有效地址</strong></li><li><strong>数据流向</strong>：以一次间址为例，将指令中的地址码送到 MAR 并送至地址总线，此后 CU 向存储器发出读命令，以获取有效地址并存至 MDR<ol><li>Ad（IR）（或 MDR）—&gt;MAR—&gt;地址总线—&gt;主存</li><li>CU 发出读命令—&gt;控制总线—&gt;内存</li><li>主存—&gt;数据总线—&gt;MDR（存放有效地址）</li><li>MDR有效地址—&gt;指令的地址码字段Ad(IR)【替换原来的间接地址】</li></ol></li><li><strong>Ad（IR）</strong> 表示取出 IR 中存放的指令字的地址字段</li></ul><p>通俗理解：根据IR中的地址告诉MAR数据存在哪里，内存定位并取出给MDR<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602202903293.png" alt="image.png"></p><h4 id="执行周期">执行周期</h4><ul><li><strong>任务</strong>：取操作数，并根据 IR 中的指令字的操作码通过 ALU 操作产出执行结果</li><li><strong>数据流向</strong>：不同指令操作不同，无统一的数据流向</li><li>eg. CLA 指令（clear ACC 指令 ，ACC 清零）<ul><li>执行周期操作：0→AC ，即将累加器 ACC 清零。</li></ul></li><li>eg. LDA X 指令（取数指令，把 X 所指内容取到 ACC ）<ul><li>执行周期操作：<ul><li>Ad(IR) → MAR ：将指令寄存器 IR 中的地址部分送到存储器地址寄存器 MAR 。</li><li>1 → R ：设置读信号</li><li>M(MAR) → MDR ：从存储器中，根据 MAR 中的地址读取数据到存储器数据寄存器 MDR 。</li><li>MDR → AC ：将 MDR 中的数据传送到累加器 ACC 。</li></ul></li></ul></li><li>JMP X 指令（无条件转移 ）<ul><li>执行周期操作：Ad(IR) → PC ，即将指令寄存器 IR 中的地址部分送到程序计数器 PC ，改变程序执行顺序。</li></ul></li><li>BAN X 指令（Branch ACC Negative ，条件转移，当 ACC 为负时转移 ）<ul><li>执行周期操作：$A_0\cdot Ad(IR)+\overline{A_0}\cdot(PC) → PC$ ，其中A_0可能是 ACC 的符号位（负数符号位为 1 ），根据 ACC 符号位及指令地址等情况决定是否转移，若 ACC 为负则将指令中的地址送到 PC，改变程序执行顺序 。</li></ul></li></ul><h4 id="中断周期">中断周期</h4><ul><li><strong>任务</strong>：处理中断请求<br><strong>保存现场与切换任务</strong></li><li><strong>数据流向</strong>：假设程序断点存入堆栈中，并用 SP 指示栈顶指针，而且进栈操作是先修改指针，后存入数据；出栈操作是先删除数据，后修改指针<ol><li>CU 控制将 SP 减 1，SP—&gt;MAR—&gt;地址总线—&gt;主存<br>SP-1后指向新的堆栈单元，SP新值送给MAR暂存即将访问的贮存地址</li><li>CU 发出写命令—&gt;控制总线—&gt;主存</li><li>PC—&gt;MDR—&gt;数据总线—&gt;主存（<strong>程序断点存入主存</strong>）<br>将断点地址存入 SP 指向的单元</li><li>CU（<strong>中断服务程序的入口</strong>）—&gt;PC<br>CU 将中断服务程序的入口地址送入 PC，CPU 下一条指令从该地址读取。记完断点后，执行中断程序</li></ol></li></ul><p>通俗解释：SP指向堆栈当前栈顶，先利用SP-1指向新栈顶，在堆栈腾出一个存储单元，然后将新的SP地址存到MAR，PC指向执行中断的下一条指令地址（断点地址），需要将断电地址保存到主存中堆栈中新SP指向的单元，但主存写操作必须通过MDR进行，因此先将 PC 的值传输到 MDR，再由 MDR 将数据写入主存。CU将中断服务程序的入口地址送入PC，CPU 后续从该地址开始执行中断处理逻辑<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250602202937806.png" alt="image.png"></p><h3 id="指令的执行方案">指令的执行方案</h3><h4 id="单周期处理器">单周期处理器</h4><ul><li><strong>定义</strong>：<ul><li>每条指令都必须在1个时钟周期内完成【CPI = 1】，指令之间<strong>串行执行</strong></li><li>时钟周期长度由 “<strong>最慢指令</strong>” 决定</li></ul></li><li><strong>特点</strong>：<strong>串行</strong>，<strong>相同执行时间</strong></li><li><strong>优点</strong>：设计简单，串行执行，不会出错</li><li><strong>缺点</strong>：效率低</li><li>补充：<strong>单周期CPU</strong>、<strong>基本流水线CPU</strong>、<strong>超流水线技术</strong>的CPI都是1；<strong>多周期CPU</strong>的CPI＞1；<strong>多发射流水线</strong>（超长指令字、超标量流水线）的CPI＜1</li></ul><h4 id="多周期处理器">多周期处理器</h4><ul><li><strong>定义</strong>：<ul><li>指令之间<strong>串行执行</strong></li><li>不同指令按复杂度分配不同周期数</li><li>可以选用不同个数的时钟周期来完成不同指令的执行过程【CPI &gt; 1】</li></ul></li><li><strong>特点</strong>：串行，不同执行时间</li><li><strong>优点</strong>：比单周期灵活，快指令不用 “干等”，CPU 周期利用率更高。</li><li><strong>缺点</strong>：控制逻辑复杂（需判断每条指令该分多少周期），仍未实现指令并行。</li></ul><h4 id="流水线处理器">流水线处理器</h4><ul><li><strong>定义</strong>：<ul><li>将指令执行拆分为多个阶段（如取指、译码、执行、访存、写回），每个阶段在独立单元执行。</li><li>力争在每个时间脉冲周期完成一条指令的执行过程【理想情况下，CPI = 1】，但实际因流水线冲突（如数据依赖）效率会降低。</li><li>尽量<strong>让多条指令同时运行</strong>，但<strong>各自处在不同的执行步骤中</strong></li></ul></li><li><strong>特点</strong>：<strong>并行</strong></li><li><strong>优点</strong>：大幅提升指令吞吐量</li><li><strong>缺点</strong>：硬件复杂（需处理指令冲突），存在 “流水线气泡”（如等待数据时阶段空闲）。</li></ul><table><thead><tr><th>方案</th><th>指令执行方式</th><th>时钟周期长度</th><th>效率特点</th><th>硬件复杂度</th></tr></thead><tbody><tr><td><strong>单周期</strong></td><td>串行，1 周期 / 指令</td><td>由最慢指令决定</td><td>简单但低效，快指令被拖累</td><td>低</td></tr><tr><td><strong>多周期</strong></td><td>串行，可变周期</td><td>每条指令独立配置</td><td>效率提升，仍无并行</td><td>中</td></tr><tr><td><strong>流水线</strong></td><td>并行，重叠执行</td><td>固定短周期</td><td>效率最高，需处理冲突</td><td>高</td></tr></tbody></table><h2 id="数据通路的功能和基本结构">数据通路的功能和基本结构</h2><h3 id="数据通路概述">数据通路概述</h3><ul><li><strong>定义</strong>：<ul><li>数据通路是指令执行时，<strong>数据在 CPU 内部流动的路径</strong>，包括路径上的所有部件（如寄存器、ALU、总线等）</li><li><strong>ALU、通用寄存器、状态寄存器、异常和中断处理逻辑</strong>等都是数据通路的一部分</li><li>它描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里</li></ul></li><li><strong>功能</strong>：实现 CPU 内部的运算器与寄存器及寄存器之间的<strong>数据交换</strong></li><li><strong>易混淆知识点</strong>：</li></ul><ol><li><strong>内部总线 vs 系统总线</strong><ul><li><strong>内部总线</strong>：CPU 内部各部件（如寄存器、ALU）之间的连接线路，类似 “小区内道路”。</li><li><strong>系统总线</strong>：连接 CPU、内存、I/O 设备的总线，类似 “城市主干道”。</li></ul></li><li><strong>单总线的数据冲突案例</strong><ul><li><strong>单总线数据通路</strong>将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只允许一次操作，无法完成指令的所有操作</li><li>若指令需同时从内存读数据到寄存器 A，且将寄存器 B 的数据写入内存，单总线需分两步：<ol><li>先完成读操作（内存→总线→寄存器 A）；</li><li>再完成写操作（寄存器 B→总线→内存）。</li></ol></li><li>多总线可同时进行这两个操作，效率翻倍。</li></ul></li><li><strong>控制信号的作用</strong><ul><li>每个部件有**输入控制信号（in）和输出控制信号（out）</li><li>例：寄存器 A 的 out=1 时，数据才能输出到总线；ALU 的 in=1 时，才能从总线接收数据。</li></ul></li></ol><h3 id="数据通路的基本结构">数据通路的基本结构</h3><h4 id="CPU-内部单总线方式-2">CPU 内部单总线方式</h4><ul><li><strong>定义</strong>：将所用寄存器的输入端与输出端连接到<strong>一条公共通路</strong>上</li><li><strong>特点</strong>：结构比较简单，数据传输存在较多的冲突现象，性能较低<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429184829.png" alt="image.png"></li><li>in 表示该部件的允许输入控制信号；out 表示该部件的允许输出控制信号</li><li>每个时钟周期只能有一次数据传输（如寄存器→总线→ALU），类似单车道同一时间只能有一辆车行驶。</li><li>ALU 的两个输入端不能同时接总线，需通过<strong>暂存器</strong>分两次输入数据（如先从寄存器 A→总线→暂存器，再从暂存器→ALU）。</li><li>ALU输入信号（in）和输出信号（out）必须<strong>在同一时钟周期内同时有效</strong>，才能完成一次完整的运算</li></ul><h4 id="CPU-内部多总线方式">CPU 内部多总线方式</h4><ul><li><strong>定义</strong>：将所用寄存器的输入端与输出端都连接到<strong>多条公共通路</strong>上，可同时进行多组数据传输</li><li><strong>特点</strong>：相较单总线结构，减少冲突，多条指令可并行执行部分操作（如取指和译码同时进行），<strong>效率较高</strong></li></ul><h4 id="专用数据通路方式-2">专用数据通路方式</h4><ul><li><strong>定义</strong>：根据指令类型<strong>专门设计线路</strong>，不同指令走不同路径</li><li><strong>优点</strong>：避免使用共享的总线，数据传输最快，<strong>性能较好</strong></li><li><strong>缺点</strong>：<strong>硬件总量较大</strong>，硬件成本高</li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250603212507341.png" alt="image.png"><br>若取出的指令是ADD，该加法指令指明了某个地址，另一个加法的操作数已经存储到ACC中</p><table><thead><tr><th>步骤</th><th>数据流向</th><th>功能说明</th></tr></thead><tbody><tr><td>1</td><td><code>Ad(IR) → MAR</code></td><td>将指令中的地址码送 MAR</td></tr><tr><td>2</td><td><code>M(MAR) → MDR</code></td><td>从主存读取操作数到 MDR</td></tr><tr><td>3</td><td><code>MDR → ALU</code></td><td>操作数送 ALU 的一个输入端</td></tr><tr><td>4</td><td><code>(ACC) + (MDR) → Z</code></td><td>ACC 与 MDR 相加，结果存入 Z</td></tr><tr><td>5</td><td><code>Z → ACC</code></td><td>将运算结果存入 ACC</td></tr><tr><td>eg. <strong>下图是一个简化了的 CPU 与主存连接结构示意图（图中省略了所有的多路选择器）。其中有一个累加寄存器（ACC）、一个状态数据寄存器和其他 4 个寄存器：主存地址寄存器（MAR）、主存数据寄存器（MDR）、程序寄存器（PC）和指令寄存器（IR），各部件及其之间的连线表示数据通路，箭头表示信息传递方向。</strong></td><td></td><td></td></tr><tr><td>![image.png</td><td>400](<a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250603213415467.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250603213415467.png</a>)</td><td></td></tr></tbody></table><ol><li><strong>请写出图中 a、b、c、d 4 个寄存器的名称</strong><br>a：MDR   b：IR   c：MAR   d：PC</li><li><strong>简述图中取指令的数据通路</strong><br>(PC)→MAR;<br>M(MAR)→MDR<br>(MDR)→IR<br>(PC)+1→PC<br>OP(IR)→微操作信号发生器</li><li><strong>简述数据在运算器和主存之间进行存 / 取访问的数据通路</strong><br>存/取的数据放到ACC中<br>设数据地址已放到MAR<br>取：<br>M(MAR) → MDR<br>(MDR) → ALU → ACC<br>存：<br>(ACC) → MDR<br>(MDR) → M(MAR)</li><li><strong>简述完成指令 LDA X 的数据通路（X 为主存地址，LDA 的功能为 (X)→ACC）</strong><br>X → MAR<br>M(MAR) → MDR<br>(MDR) → ALU → ACC</li><li><strong>简述完成指令 ADD Y 的数据通路（Y 为主存地址，ADD 的功能为 (ACC)+(Y)→ACC）</strong><br>Y → MAR<br>M(MAR) → MDR<br>(MDR) → ALU,(ACC) → ALU<br>ALU  → ACC【只有寄存器加括号，ALU是算数部件，不是寄存器不加()】<br>和<br>Y → MAR<br>M(MAR) → MDR<br>(MDR) → ALU<br>ALU + (ACC) → ACC一样吗</li><li><strong>简述完成指令 STA Z 的数据通路（Z 为主存地址，STA 的功能为 (ACC)→Z）</strong><br>Z → MAR<br>(ACC) → MDR<br>(MDR) → M(MAR)</li></ol><h3 id="数据通路的操作举例">数据通路的操作举例</h3><p>以 CPU 内部单总线数据通路为例：<br>注意：</p><ol><li>需要注明in，out有效</li><li>CU发送读写控制信号不要忘</li><li>ALU的in，out必须<strong>同时有效</strong>，而CPU 内部总线同一时刻只能传送一个输入信号，需暂存器中转</li></ol><h4 id="寄存器之间数据传送">寄存器之间数据传送</h4><p><strong>目标</strong>：将程序计数器（PC）的值传送到内存地址寄存器（MAR），用于指定下一次访存的地址。</p><ul><li>(PC) -&gt; Bus             【PCout 有效，PC 内容送至总线】</li><li>Bus -&gt; MAR            【MARin 有效，总线内容送 MAR】</li></ul><h4 id="主存与-CPU-之间的数据传送">主存与 CPU 之间的数据传送</h4><p><strong>目标</strong>：从主存读取指令到指令寄存器（IR）。</p><ul><li>(PC) -&gt; Bus -&gt; MAR     【PCout 和 MARin 有效，MAR 保存要访问的指令地址（PC 的值）】</li><li>1 -&gt; R                            【CU 发Read 信号通过控制总线发送到主存】</li><li>M (MAR) -&gt; MDR         【MDRin 有效，<strong>读取指令内容</strong>】</li><li>MDR -&gt; Bus -&gt; IR        【MDRout 和 IRin 有效，IR 存储当前待执行的指令（如<code>ADD A, B</code>）】</li></ul><h4 id="执行算术或逻辑运算">执行算术或逻辑运算</h4><p><strong>目标</strong>：执行加法指令<code>ADD A, B</code>，即将寄存器 <code>ACC</code> 的值与内存中变量 <code>B</code> 的值相加，并将结果存回 <code>ACC</code></p><ul><li>Ad (IR) -&gt; Bus -&gt; MAR                 【MDRout 和 MARin 有效或者AdIRout和MARin有效，IR中的地址码字段（即B的地址）通过总线传输的MAR】</li><li>1 -&gt; R                                            【CU 发读命令，指示主存读取 <code>MAR</code> 中指定地址的数据】</li><li>M (MAR) -&gt; 数据线 -&gt; MDR         【MDRin 有效，主存将地址指定处的数据通过数据线传输到 <code>MDR</code>】</li><li>MDR -&gt; Bus -&gt; Y                          【MDRout 和 Yin 有效，<code>MDR</code> 中的值（<code>5</code>）通过总线传输到暂存寄存器 <code>Y</code>】</li><li>(ACC) + (Y) -&gt; Z                            【ACCout 和 ALUin 有效，CU 向 ALU 发送加命令，完成 <code>ACC + B</code> 的运算】</li><li>Z -&gt; ACC                                       【Zout 和 ACCin 有效，结果 -&gt; ACC】</li></ul><p>eg. <code>ADD (R0), R1</code> 基于单总线结构的三个阶段（取指、间址、执行）展开：</p><ul><li><strong>指令功能</strong>：<code>((R0)) + (R1) → (R0)</code><br>含义：以寄存器 <code>R0</code> 的内容为<strong>主存地址</strong>，从主存中读取该地址的数据（被加数），与寄存器 <code>R1</code> 的内容（加数）相加，结果写回 <code>R0</code> 指向的主存地址。</li><li><strong>指令周期</strong>：包含 <strong>取指周期</strong>（获取指令）、<strong>间址周期</strong>（获取主存中的被加数）、<strong>执行周期</strong>（完成加法并写回结果）。<br><strong>取指</strong>：从主存读指令到 IR，PC 指向下一条指令。<br><strong>间址</strong>：从主存读被加数到 Y，地址来自 R0。<br><strong>执行</strong>：R1+Y→Z，结果写回主存（地址仍为 R0 指向的位置）。</li></ul><p>阶段 1：<strong>取指周期</strong>（获取指令本身）<br><strong>目标</strong>：从主存中读取 <code>ADD (R0), R1</code> 指令，存入指令寄存器（IR）</p><table><thead><tr><th>时序</th><th>微操作（数据流向）</th><th>有效控制信号</th></tr></thead><tbody><tr><td>1</td><td><code>(PC) → MAR</code></td><td><code>PCout</code>, <code>MARin</code></td></tr><tr><td>2</td><td><code>M(MAR) → MDR</code></td><td><code>MemR</code>, <code>MARout</code>, <code>MDRinE</code></td></tr><tr><td>3</td><td><code>(MDR) → IR</code></td><td><code>MDRout</code>, <code>IRin</code></td></tr><tr><td>4</td><td>指令译码</td><td>-</td></tr><tr><td>5</td><td><code>(PC)+1 → PC</code></td><td>-</td></tr><tr><td>阶段 2：间址周期（获取主存中的被加数）</td><td></td><td></td></tr><tr><td><strong>目标</strong>：以 <code>R0</code> 的内容为地址，从主存中读取<strong>被加数</strong>，存入暂存寄存器 <code>Y</code>。</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>时序</th><th>微操作（数据流向）</th><th>有效控制信号</th></tr></thead><tbody><tr><td>1</td><td><code>(R0) → MAR</code></td><td><code>R0out</code>, <code>MARin</code></td></tr><tr><td>2</td><td><code>M(MAR) → MDR</code></td><td><code>MemR</code>, <code>MARout</code>, <code>MDRinE</code></td></tr><tr><td>3</td><td><code>(MDR) → Y</code></td><td><code>MDRout</code>, <code>Yin</code></td></tr><tr><td>阶段 3：执行周期（完成加法并写回结果）</td><td></td><td></td></tr><tr><td><strong>目标</strong>：<code>R1</code>（加数）与 <code>Y</code>（被加数）相加，结果写回 <code>R0</code> 指向的主存地址。</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>时序</th><th>微操作（数据流向）</th><th>有效控制信号</th></tr></thead><tbody><tr><td>1</td><td><code>(R1) + (Y) → Z</code></td><td><code>R1out</code>, <code>ALUin</code>, <code>CU发ADD控制信号</code></td></tr><tr><td>2</td><td><code>(Z) → MDR</code></td><td><code>Zout</code>, <code>MDRin</code></td></tr><tr><td>3</td><td><code>(MDR) → M(MAR)</code></td><td><code>MemW</code>, <code>MDRoutE</code>, <code>MARout</code></td></tr></tbody></table><ol><li><strong>间址周期的作用</strong>：<ul><li><code>ADD (R0), R1</code> 中 <code>(R0)</code> 表示 “以 R0 内容为地址”，因此需要<strong>额外访存</strong>（间址周期）获取主存中的被加数，这是 “间址周期” 存在的原因。</li></ul></li><li><strong>暂存寄存器 <code>Y</code> 的必要性</strong>：<ul><li>单总线结构同一时刻只能传一个数据，因此被加数需先存在 <code>Y</code> 中，等待与 <code>R1</code> 相加。</li></ul></li><li><strong>控制信号的含义</strong>：<ul><li><code>MemR</code>/<code>MemW</code>：主存读 / 写控制；</li><li><code>R0out</code>/<code>R1out</code>：寄存器 R0/R1 输出使能；</li><li><code>ALUin</code>/<code>Zout</code>：ALU 输入 / 输出使能；</li><li>控制信号需<strong>按序激活</strong>，确保数据流向正确。</li></ul></li></ol><h2 id="控制器的功能和工作原理">控制器的功能和工作原理</h2><h3 id="硬布线控制器">硬布线控制器</h3><ul><li>根据指令要求、当前时序及内外部状态，按<strong>时间顺序</strong>生成并发送微操作控制信号，协调 CPU 各部件动作。</li><li>由<strong>组合逻辑门电路和触发器</strong>构成，又称 “<strong>组合逻辑控制器</strong>”，通过硬件电路直接产生控制信号。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429191754.png" alt="image.png|400"></li></ul><h4 id="CU-的输入信号来源">CU 的输入信号来源</h4><ol><li><strong>指令译码信息</strong>：指令经译码器解析后的结果。</li><li><strong>时序信号</strong>：时序系统产生的机器周期信号和节拍信号（时钟周期）。</li><li><strong>反馈信号</strong>：执行单元（如 ALU）产生的标志位（如进位、零标志）。</li></ol><p><strong>微操作控制信号</strong>的形成主要与<font color="#c00000">指令译码信号和时钟信号</font>有关</p><h4 id="硬布线控制器的时序系统及微操作">硬布线控制器的时序系统及微操作</h4><ol><li><strong>时钟周期</strong>：最小时序单位，由时钟信号驱动节拍发生器，每个节拍对应一个时钟周期。</li><li><strong>机器周期</strong>：指令执行的基准时间，通常包含若干时钟周期。</li><li><strong>指令周期</strong>：CPU 取出并执行一条指令的总时间，由多个机器周期组成。</li><li><strong>微操作命令分析</strong>：控制单元按指令需求生成操作序列，如 “取指令”“算术运算” 等。</li></ol><h4 id="CPU-的控制方式">CPU 的控制方式</h4><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>同步控制</strong></td><td><strong>统一时钟驱动</strong>，以<strong>最长</strong>微操作序列为基准，所有指令按<strong>固定机器周期</strong>执行。</td><td>优点：<strong>控制电路简单</strong>；缺点：<strong>速度慢</strong>。</td></tr><tr><td><strong>异步控制</strong></td><td>无统一时钟，各部件按<strong>自身速度</strong>工作，通过<strong>应答</strong>信号协调。</td><td>优点：<strong>速度快</strong>；缺点：<strong>控制电路复杂</strong>。</td></tr><tr><td><strong>联合控制</strong></td><td><strong>多数</strong>操作<strong>同步</strong>控制，少数复杂操作异步控制，<strong>折中</strong>两者特性。</td><td>平衡速度与电路复杂度。</td></tr></tbody></table><h5 id="同步控制方式">同步控制方式</h5><ul><li>系统有一个统一的时钟，所有的控制信号都来源于这个统一的时钟信号</li><li>通常以最长的微操作序列和最繁琐的微操作作为标准</li><li>采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令</li><li><strong>优点：控制电路简单</strong></li><li><strong>缺点：运行速度慢</strong></li></ul><h5 id="异步控制方式">异步控制方式</h5><ul><li>不存在基准时标信号，各部件按照自身固有速度工作，通过应答方式进行联络</li><li><strong>优点：运行速度快</strong></li><li><strong>缺点：控制电路较为复杂</strong></li></ul><h5 id="联合控制方式">联合控制方式</h5><ul><li>介于同步、异步之间的一种折中</li><li>对大部分采用同步控制，小部分采用异步控制</li></ul><h4 id="设计步骤">设计步骤</h4><ol><li><strong>分析微操作序列</strong>：<br>明确在取值、间址、执行、中断这四个阶段中，各类指令在不同时刻会涉及的微操作。<br>比如<strong>取值</strong>阶段主要是从内存读取指令，<strong>执行</strong>阶段则依据指令类型进行算术运算、逻辑运算等具体操作 。<br>这一步是为了梳理清楚指令执行过程中各个环节的具体动作，为后续设计奠定基础。</li><li><strong>选择 CPU 控制方式</strong>：<br>需要确定采用<strong>定长</strong>机器周期还是<strong>不定长</strong>机器周期，以及每个机器周期安排<strong>几个节拍</strong>。<br>若采用同步控制方式（定长机器周期 ），就像设定了一个固定的节奏，每个机器周期内的节拍数量固定，例如这里假设一个机器周期内安排 3 个节拍。这种方式能让整个系统的时序较为规整，但可能无法很好地适应不同复杂程度指令的执行需求；<br>而不定长机器周期则更灵活，可根据指令实际情况调整机器周期时长。</li><li><strong>安排微操作时序</strong>：<br>思考如何在给定的节拍数量（如 3 个节拍）内，合理分配并完成一个机器周期内的所有微操作。<br>要考虑微操作的先后顺序、能否并行等因素，确保各操作有条不紊地进行，充分利用每个节拍的时间，实现高效的指令执行流程。</li><li><strong>电路设计</strong>：<br>确定每个微操作命令对应的逻辑表达式，然后通过具体的电路来实现这些逻辑。<br>这是将前面分析规划的内容转化为实际硬件电路的关键步骤，通过逻辑门电路等硬件组件搭建出能够准确产生和发送微操作控制信号的电路，从而使控制器能够按照设计要求工作。</li></ol><h4 id="安排微操作时序的原则">安排微操作时序的原则</h4><ol><li><strong>顺序固定</strong>：微操作先后顺序不可随意更改（如先取指令再译码）。</li><li><strong>并行执行</strong>：不同部件的微操作可在<strong>同一节拍</strong>内并行完成（如寄存器读写与 ALU 运算）。</li><li><strong>时间优化</strong>：<strong>短时微操作</strong>可在同一节拍内按顺序执行，充分利用时钟周期。</li></ol><h5 id="安排微操作时序-取指周期">安排微操作时序 - 取指周期</h5><ul><li><strong>原则</strong>：<ul><li>微操作先后顺序不得随意更改。</li><li>被控对象不同的微操作，尽量安排在一个节拍内完成。</li><li>占用时间较短的微操作，尽量安排在一个节拍内完成，并允许有先后顺序。</li></ul></li><li><strong>微操作</strong>：<ul><li>T0：(1)PC → MAR ；(2)1 → R （存储器空闲即可）</li><li>T1：(3)M (MAR) → MDR （在 (1) 之后）；(6)(PC) + 1 → PC （在 (1) 之后）</li><li>T2：(4)MDR → IR （在 (3) 之后）；(5)OP (IR) → ID （在 (4) 之后）</li></ul></li><li><strong>说明</strong>：M (MAR) → MDR 从主存存取数据，用时较长，需一个时钟周期保证完成；MDR → IR 是 CPU 内部寄存器数据传送，速度快，可在一个时钟周期内紧接着完成OP (IR) → ID ，即可一次同时发出两个微命令。</li></ul><h5 id="安排微操作时序-间址周期">安排微操作时序 - 间址周期</h5><ul><li><strong>原则</strong>：同取指周期原则（微操作先后顺序不得随意更改；被控对象不同的微操作尽量安排在一个节拍内完成；占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序 ）</li><li><strong>微操作</strong>：<ul><li>T0：(1)Ad(IR) → MAR ；(2)1 → R</li><li>T1：(3)M (MAR) → MDR</li><li>T2：(4)MDR → Ad(IR)</li></ul></li></ul><h5 id="安排微操作时序-执行周期">安排微操作时序 - 执行周期</h5><ul><li><strong>非访存指令</strong>：<ul><li><strong>CLA（clear，ACC 清零 ）</strong>：T0、T1、T2：0 → AC</li><li><strong>COM（complement，ACC 取反 ）</strong>：T0、T1、T2：$\overline{AC}$ → AC</li><li><strong>SHR（shift，算术右移 ）</strong>：T0、T1、T2：L (AC) → R (AC) ，AC₀ → AC₀</li><li><strong>CSL（cyclic shift，循环左移 ）</strong>：T0、T1、T2：R (AC) → L (AC) ，AC₀ → ACₙ</li><li><strong>STP（stop，停机 ）</strong>：T0、T1、T2：0 → G</li></ul></li><li><strong>访存指令</strong>：<ul><li><strong>ADD X（加法指令，隐含 ACC ）</strong>：T0：Ad (IR) → MAR ，1 → R ；T1：M (MAR) → MDR ；T2：(AC) + (MDR) → AC</li><li><strong>STA X（存数指令，隐含 ACC ）</strong>：T0：Ad (IR) → MAR ，1 → W ；T1：AC → MDR ；T2：MDR → M (MAR)</li><li><strong>LDA X（取数指令，隐含 ACC ）</strong>：T0：Ad (IR) → MAR ，1 → R ；T1：M (MAR) → MDR ；T2：MDR → AC</li></ul></li><li><strong>转移指令</strong>：<ul><li><strong>JMP X（无条件转移 ）</strong>：T0、T1、T2：Ad (IR) → PC</li><li><strong>BAN X（Branch ACC Negative，条件转移 ）</strong>：T0、T1、T2：$A_0\cdot Ad (IR)+\overline{A_0}\cdot(PC) → PC$</li></ul></li></ul><h3 id="微程序控制器">微程序控制器</h3><ol><li><strong>存储逻辑实现</strong>：将微操作信号编码为 “微指令”，每条机器指令对应一段微程序（每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令），存储在控制存储器（也叫微程序存储器，存放微程序）中。<br>采用存储逻辑实现，即把<strong>微操作信号代码化</strong></li><li>微程序控制器属于控制器类别，属于CPU的一部分</li><li><strong>指令执行流程</strong>：<br>机器指令 → 微程序（控制存储器）→ 微指令 → 微操作命令（控制 CPU 部件）。<ul><li><strong>机器指令</strong>（如 “加法运算”）是 “做番茄炒蛋” 的高级菜谱；</li><li><strong>微程序</strong>是将高级菜谱拆解为 “打蛋→切番茄→倒油→下锅” 等具体步骤；</li><li><strong>微指令</strong>是每个步骤的详细操作（如 “打蛋” 对应 “拿起鸡蛋→敲开→倒入碗中”）；</li><li><strong>微操作</strong>是最基础的动作（如 “敲开鸡蛋” 是不可再分的硬件操作）。</li></ul></li></ol><h4 id="基本概念">基本概念</h4><ul><li><strong>微操作</strong>：执行部件收到微命令后所进行的操作【CPU 中<strong>最基础的动作</strong>，如 “将数据从寄存器 A 传至寄存器 B”“算术逻辑单元（ALU）执行加法”，<strong>不可再分解</strong>】</li><li><strong>微命令</strong>：控制硬件执行微操作的 “指令”，是<strong>控制信号的最小单位</strong>。例如，“寄存器 A 输出使能” 就是一个微命令【需要发出什么控制信号】<ul><li><strong>相容性</strong>微命令：可同时生效，如 “ALU 执行加法” 和 “结果存入寄存器” 可同时触发</li><li><strong>互斥性</strong>微命令：不能同时出现，如 “存储器读” 和 “存储器写” 必须互斥。</li></ul></li></ul><p>硬布线控制器中也有微命令和微操作的概念</p><ul><li><strong>微指令</strong>：<strong>一条微指令包含一组微命令</strong>，用于完成一步完整的硬件操作<br>例如，“从内存取指令” 的微指令可能包含 “PC 寄存器输出地址”“存储器读使能”“指令存入 IR 寄存器” 等微命令。<ul><li><strong>操作控制字段</strong>【微操作码字段】：编码具体的微命令（如 “加法”“读内存”）</li><li><strong>顺序控制字段</strong>【微地址码字段】：指定下一条微指令的地址（类似 “程序计数器”，控制执行流程）</li></ul></li><li><strong>微周期</strong>：读取并执行一条微指令的时间（1 个时钟周期）</li><li><strong>微地址</strong>：存放微指令的控制存储器的单元地址</li><li><strong>主存</strong>：用于存放程序和数据，在 CPU 外部，用 <strong>RAM</strong> 实现</li><li><strong>控制存储器【CM】</strong>： 核心部件，用于存放微程序，在 CPU 内部，用 <strong>ROM</strong> 存储微程序</li><li><strong>程序</strong>：是指令的有序集合，用于完成特定的功能</li><li><strong>微程序</strong>：<br>是微指令的有序集合，一条指令的功能由一段微程序实现<ul><li>一条机器指令（如加法指令 “ADD A,B”）需要分解为多个微操作步骤，每个步骤对应一条微指令，这些微指令按顺序组成 “微程序”。例如：<ol><li>取指令 → 2. 解析操作码 → 3. 从内存取操作数 A → 4. 从内存取操作数 B → 5. ALU 执行加法 → 6. 存储结果。</li></ol></li><li>像程序一样存进控制存储器（CM），通过 “读取微指令→执行微操作” 的方式控制 CPU 动作，属于 “存储逻辑控制”（而非硬布线的 “硬件直接连线控制”）。</li></ul></li><li>一般来说，一条机器指令对应一个微程序</li></ul><p>关系：</p><ol><li><strong>一条机器指令</strong> 对应 <strong>一个微程序</strong></li><li><strong>一个微程序</strong> 对应 <strong>若干条微指令</strong></li><li><strong>一个微指令</strong> 会产生 <strong>若干条微命令</strong></li><li><strong>一个微命令</strong> 对应 <strong>一个微操作</strong></li></ol><h4 id="寄存器分类">寄存器分类</h4><ul><li><strong>地址寄存器</strong>【MAR】：存放主存的读 / 写地址</li><li><strong>微指令地址寄存器</strong>【uPC 或 CMAR】：存放待执行的微指令在控制存储器中的微地址</li><li><strong>指令寄存器</strong>【IR】：存放从主存中读出的指令</li><li><strong>微指令寄存器</strong>【uIR 或 CMDR】：存放从控制存储器中读出的微指令</li></ul><h4 id="基本组成">基本组成</h4><table><thead><tr><th>部件名称</th><th>功能通俗解释</th><th>类比举例</th></tr></thead><tbody><tr><td><strong>指令寄存器（IR）</strong></td><td>存放从主存取出的机器指令（如 “加法指令”）。</td><td></td></tr><tr><td><strong>微地址形成部件</strong></td><td>根据机器指令生成对应微程序的 “菜谱索引”（入口地址），如 “加法指令” 对应 “加法菜谱” 的第一页。</td><td>菜谱的 “目录索引”，根据菜名找对应步骤。</td></tr><tr><td><strong>微地址寄存器/微指令计数器（uPC或CMAR）</strong></td><td>记录下一条微指令的 “菜谱页码”（地址）。</td><td><strong>“下一条去哪”</strong>（预存，执行当前时准备好）</td></tr><tr><td><strong>控制存储器（CM）</strong></td><td>存放所有微程序的 “硬盘”，用 ROM 实现（内容固化）。</td><td>厨房里的 “菜谱大全”，存所有菜的做法。</td></tr><tr><td><strong>微指令寄存器（uIR或CMDR）</strong></td><td>临时存放当前微指令，拆解出 “要做什么”（操作控制字段）和 “下一步去哪”（顺序控制字段）。</td><td><strong>“当前干啥 + 下一条去哪”</strong>（显式写在当前微指令里，让 CMAR 直接用）</td></tr></tbody></table><ul><li><strong>控制存储器（CM）</strong>：核心部件，存所有机器指令对应的微程序，控制存储器可用 ROM 构成</li><li><strong>微指令寄存器</strong>：存放从 CM 中取出的微指令，位数与微指令字长相等</li><li><strong>微地址形成部件</strong>【起始和转移地址形成部件】：根据<font color="#c00000">机器指令操作码</font>生成微程序入口地址，或根据执行结果（如标志位）决定微指令跳转逻辑。</li><li><strong>微地址寄存器（uIR）</strong>：暂存当前微指令，拆分出操作控制信号和下一条微地址<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250618182546692.png" alt="image.png"></li></ul><h4 id="工作过程">工作过程</h4><p>通过 “<strong>取微指令→解析→执行→循环</strong>” 的流程，将<strong>机器指令</strong>拆解为<strong>微操作序列</strong><br>1. <strong>取指微程序的公共操作</strong></p><ul><li><strong>初始启动</strong>：机器通电后，自动将 “取指微程序” 的入口地址（通常为控制存储器 CM 的 0 号单元）送入微地址寄存器（CMAR），从 CM 中读取首条微指令到微指令寄存器（CMDR）。</li><li><strong>核心任务</strong>：执行取指微程序，从主存中取出机器指令，存入指令寄存器（IR）。</li><li><strong>类比</strong>：相当于计算机的 “开机引导程序”，先准备好要执行的指令。</li></ul><p>2. <strong>生成目标微程序入口地址</strong></p><ul><li><strong>关键动作</strong>：根据 IR 中机器指令的操作码字段，通过微地址形成部件生成对应微程序的入口地址，送入 CMAR。</li><li><strong>逻辑示例</strong>：若机器指令是 “加法指令”，操作码经硬件逻辑转换为 “加法微程序” 在 CM 中的起始地址。</li></ul><p>3. <strong>逐条执行微指令</strong></p><ul><li><strong>执行流程</strong>：从 CM 中按地址依次读取微指令，解析操作控制字段的微命令，驱动 CPU 部件（如 ALU、寄存器）执行对应操作。</li><li><strong>示例</strong>：加法微程序可能包含 “取操作数 A”“取操作数 B”“ALU 加法”“存结果” 等微指令，每条微指令控制一个或多个微操作并行执行。</li></ul><p>4. <strong>循环回到取指阶段</strong></p><ul><li><strong>结束与重启</strong>：当一条机器指令的微程序执行完毕后，自动回到取指微程序的入口地址（CM 的 0 号单元），重复步骤 1，等待下一条机器指令。</li><li><strong>循环逻辑</strong>：形成 “取指→译码→执行→再取指” 的闭环，保证计算机持续工作。</li></ul><h4 id="微程序控制器的工作原理">微程序控制器的工作原理</h4><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250618212654581.png" alt="image.png"></p><ul><li><p><strong>取指周期微程序</strong>：是公用的，不管执行什么机器指令，都要先经过取指周期。若指令系统有 n 条机器指令 ，加上公用的取指周期微程序，从微程序段角度看，CM 中微程序段个数至少是 n + 1 个 。也可以从逻辑角度，把取指周期和执行周期等看作一条指令对应的整体微程序 ，微程序的个数只有 n 个（即n 条机器指令对应 n 个微程序）</p></li><li><p><strong>间址周期微程序</strong>：用于处理间接寻址相关操作，早期一些 CPU 可不提供，就无此微程序段。</p></li><li><p><strong>中断周期微程序</strong>：处理中断事务，部分 CPU 可不包含。</p></li><li><p><strong>执行周期微程序</strong>：不同机器指令（如 LDA、STA 指令 ）有各自对应的执行周期微程序，完成指令具体功能。</p></li><li><p>物理上，取指周期、执行周期等微程序段看似分开，但逻辑上一条指令对应一个完整微程序 。</p></li></ul><h4 id="微指令的编码方式【控制方式】">微指令的编码方式【控制方式】</h4><p><strong>目的</strong>：用<strong>最短的指令字长</strong>表示最多的微命令，同时<strong>减少译码延迟</strong></p><h5 id="直接编码方式">直接编码方式</h5><ul><li><strong>核心逻辑</strong>：微指令的每一位直接对应一个微命令，<strong>无需译码器</strong>，1 表示激活，0 表示不激活。</li><li><strong>示例</strong>：若有 100 个微命令（如 “存储器读”“ALU 加法” 等），则微指令的操作控制字段需 100 位，每位独立控制一个硬件动作。<ul><li>第 1 位 = 1 → 激活 “存储器读”；</li><li>第 2 位 = 1 → 激活 “ALU 加法”。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ul><li><strong>并行</strong>性极强：所有微命令可同时激活（如同时执行 “读存储器” 和 “ALU 运算”）。</li><li>执行速度快：无需译码时间，直接按位控制硬件。</li></ul></li><li><strong>缺点</strong>：<ul><li>指令字长极长：100 个微命令需 100 位字段，控制存储器（CM）容量需求大幅增加（如 CM 存储单元字长必须为 100 位）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429202112.png" alt="image.png"></li></ul></li></ul></li></ul><h5 id="字段直接编码方式">字段直接编码方式</h5><ul><li><strong>核心逻辑</strong>：将<strong>互斥</strong>微命令分组到<strong>同一字段</strong>，每组通过译码器生成控制信号（n 位字段最多表示 2ⁿ-1 个互斥命令）。<br>类似 “分组开关”，同一组内的开关（微命令）不能同时按下（互斥），不同组可并行操作。</li><li><strong>分段原则</strong>：<ol><li><strong>互斥性微命令同段，相容性微命令不同段</strong>（如 “读” 与 “写” 互斥，同段；“取指令” 与 “送地址” 相容，不同段）。</li><li><strong>每段信息位不宜过多</strong>（减少译码电路复杂度和时间）。</li><li><strong>每段留一个 “不操作” 状态</strong>（如 3 位段可表示<code>7</code>个互斥命令 +<code>000</code>不操作，共<code>8</code>种状态，需 3 位）。</li></ol></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ul><li>指令字长显著缩短，减少 CM 容量需求。</li></ul></li><li><strong>缺点</strong>：<ul><li>需等待译码器工作，引入延迟（如字段分组后需先译码再执行）；</li><li>同一字段内微命令无法并行（如 “存储器读” 和 “存储器写” 不能同时激活）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429202435.png" alt="image.png"><br>eg. <strong>某计算机控制器采用微程序控制，操作控制字段用字段直接编码法，共 33 个微命令，构成 5 个互斥类，分别含 7、3、12、5、6 个微命令。求操作控制字段至少多少位？</strong></li></ul></li></ul></li></ul><ol><li><strong>每互斥类需表示的状态数</strong>：<ul><li>第 1 类（7 个命令）：需<code>7+1=8</code>种状态（含不操作）→ 3 位（<code>2³=8</code>）。</li><li>第 2 类（3 个命令）：需<code>3+1=4</code>种状态 → 2 位（<code>2²=4</code>）。</li><li>第 3 类（12 个命令）：需<code>12+1=13</code>种状态 → 4 位（<code>2⁴=16≥13</code>）。</li><li>第 4 类（5 个命令）：需<code>5+1=6</code>种状态 → 3 位（<code>2³=8≥6</code>）。</li><li>第 5 类（6 个命令）：需<code>6+1=7</code>种状态 → 3 位（<code>2³=8≥7</code>）。</li></ul></li><li><strong>总位数</strong>：<code>3+2+4+3+3=15</code>位。</li></ol><p><strong>对比</strong>：直接编码需 33 位（每位对应一个命令），字段直接编码大幅压缩字长（15 位 vs 33 位）。</p><h5 id="字段间接编码方式">字段间接编码方式</h5><ul><li><p><strong>核心逻辑</strong>：一个字段的微命令需依赖另一字段的编码才能生效，类似 “二级密码”，需两个条件同时满足才能执行操作。例如：</p><ul><li>字段 A 编码为 “寄存器操作”，字段 B 编码为 “寄存器 A”；</li><li>仅当字段 A 和字段 B 同时生效，才能确定 “对寄存器 A 执行操作”。</li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：进一步压缩字长（如通过字段组合减少总位数）。</li><li><strong>缺点</strong>：微命令需分步解析，<strong>并行性</strong>大幅下降（必须等前一字段译码完成才能处理后一字段）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429202952.png" alt=""><br>示例：</li><li>字段 X（2 位）：表示 “操作类型”（00 = 无操作，01 = 寄存器操作，10 = 存储器操作）；</li><li>字段 Y（2 位）：仅当字段 X=01 时，字段 Y 表示 “寄存器编号”（00 = 寄存器 A，01 = 寄存器 B）。<br>通过字段组合，用 4 位表示原本需要更多位的命令。</li></ul></li></ul><table><thead><tr><th><strong>编码方式</strong></th><th><strong>字长</strong></th><th><strong>执行速度</strong></th><th><strong>并行性</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>直接</strong>编码</td><td>最长</td><td>最快</td><td>最高（全并行）</td><td>对<strong>速度</strong>要求极高的简单控制</td></tr><tr><td><strong>字段直</strong>接编码</td><td>中等</td><td>中等（需译码）</td><td>中等（字段内互斥）</td><td><strong>通用微程序控制器</strong></td></tr><tr><td><strong>字段间</strong>接编码</td><td>最短</td><td>最慢</td><td>最低</td><td>对<strong>存储容量</strong>敏感的场景</td></tr></tbody></table><h4 id="微指令的格式">微指令的格式</h4><p>微指令格式决定了控制器的 “控制粒度” 和 “执行效率”</p><table><thead><tr><th>水平型</th><th>垂直型</th></tr></thead><tbody><tr><td>并行操作能力强、效率高、灵活性强</td><td>相反</td></tr><tr><td>执行一条指令的时间短</td><td>相反</td></tr><tr><td>微指令字较长但微程序短</td><td>相反</td></tr><tr><td>用户难以掌握</td><td>与指令相似，相对容易掌握</td></tr></tbody></table><h5 id="水平型微指令">水平型微指令</h5><ul><li><strong>核心特性</strong>：<strong>一条指令可定义多个并行微操作</strong>，直接控制硬件部件同时工作。<ul><li>例：同时执行 “从寄存器 A 取数”“ALU 加法”“结果存入寄存器 B” 三个操作。</li></ul></li><li><strong>编码方式</strong>：<strong>直接编码、字段直接编码、字段间接编码均属于水平型。</strong></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ul><li>并行性强，一条微指令完成多个操作，<strong>执行速度快</strong>。</li><li><strong>微程序短</strong>（因单条指令功能强），节省控制存储器空间。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>指令字长较长</strong>（需包含所有并行操作的编码）。</li><li><strong>编写难度高</strong>，需精确协调多个微操作的并行逻辑。</li></ul></li></ul></li><li><strong>应用场景</strong>：对<strong>执行速度要求极高</strong>的场景，如高性能处理器的核心控制。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429203656.png" alt="image.png"></li></ul><h5 id="垂直型微指令">垂直型微指令</h5><ul><li><strong>核心特性</strong>：<strong>一条指令仅能定义一个微命令</strong>，类似机器指令的 “顺序执行” 模式<ul><li>例：先执行 “从寄存器 A 取数”，再执行 “ALU 加法”，需两条微指令。</li></ul></li><li><strong>指令结构</strong>：<strong>通过微操作码字段指定功能</strong>，类似机器指令的 “操作码 + 操作数” 格式。<ul><li>例：完成 “取数 + 加法” 需两条微指令：<br>① 操作码=取数，操作数=寄存器A<br>② 操作码=加法，操作数=寄存器B</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ul><li><strong>指令字长短</strong>，格式规整，编写和调试简单。</li><li>对设计者要求低，适合初学者或简单控制逻辑。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>微程序长</strong>（需多条指令完成复杂操作），<strong>执行速度慢</strong>。</li><li><strong>工作效率低</strong>，无法利用硬件并行性。</li></ul></li></ul></li><li><strong>应用场景</strong>：早期微型计算机、控制逻辑简单的嵌入式系统。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429203930.png" alt="image.png"></li></ul><h5 id="混合型微指令">混合型微指令</h5><ul><li><strong>核心特性</strong>：在垂直型指令格式中嵌入少量并行操作字段，实现 “关键操作并行 + 简单操作顺序” 的混合控制</li><li><strong>优势</strong>：<ul><li><strong>指令字长较短</strong>，保持编写便利性。</li><li><strong>微程序长度适中</strong>，执行速度比纯垂直型快。</li></ul></li><li><strong>应用场景</strong>：通用计算机控制器，兼顾开发效率与性能</li></ul><h4 id="微指令的地址形成方式">微指令的地址形成方式</h4><p>微指令地址决定了微程序的执行顺序，常见方式如下：<br>1. <strong>下地址字段直接指定（断定方式）</strong></p><ul><li><strong>原理</strong>：微指令含 “下地址” 字段，执行后直接加载到微地址寄存器（CMAR），又称为<strong>断定方式</strong>。例如，微指令格式为<code>[操作控制][下地址]</code>，<code>下地址</code>直接赋值给 CMAR。<br>通过微指令中指定一个专门字段来控制产生后继微指令地址</li><li><strong>应用</strong>：条件分支（如<code>if ZF=1 → 地址A，else → 地址B</code>）、复杂跳转（中断处理入口）。</li><li><strong>优点</strong>：跳转灵活，支持任意地址；<strong>缺点</strong>：微指令字长增加（需地址字段）。</li></ul><p>2. <strong>操作码映射生成</strong></p><ul><li>机器指令存入 IR 后，操作码经 “微地址形成部件” 转换为对应微程序的入口地址。<ul><li><strong>示例</strong>：加法指令操作码 “001” 对应微程序入口地址 “1000”，减法操作码 “010” 对应 “2000”。</li><li><strong>特点</strong>：实现 “机器指令→微程序” 的映射，是微程序控制器的核心机制。</li></ul></li><li><strong>应用</strong>：指令解码（每条机器指令对应唯一微程序入口）、指令集扩展（新增指令只需更新映射）。</li><li><strong>优点</strong>：模块化，解耦机器指令与微程序；<strong>缺点</strong>：依赖固定映射，灵活性有限。</li></ul><p>3. <strong>增量计数器法（顺序执行）</strong></p><ul><li><strong>原理</strong>：CMAR 类似 PC，执行一条微指令后自动加 1（<code>CMAR += 1</code>）。如地址<code>1000</code>→<code>1001</code>→<code>1010</code>，无需地址字段。</li><li><strong>应用</strong>：顺序执行微程序（如取指流程：取指令→译码→执行，线性无分支）。</li><li><strong>优点</strong>：节省字长（无地址字段），执行速度快（仅加法逻辑）；<strong>缺点</strong>：仅支持顺序，分支需结合其他方式。</li></ul><p>4. <strong>分支转移（条件跳转）</strong></p><ul><li><strong>原理</strong>：根据标志位（CF/ZF/SF）或硬件状态（中断请求）选择微地址。例如，<code>if CF=1 → 地址X，else → 地址Y</code>，通过多路选择器实现。</li><li><strong>应用</strong>：算术逻辑分支（如比较指令根据结果跳转）、异常处理（除法溢出跳转到错误处理）。</li><li><strong>优点</strong>：支持复杂逻辑（循环、分支）；<strong>缺点</strong>：硬件复杂度增加（标志检测电路）。</li></ul><p>5. <strong>测试网络直接生成</strong></p><ul><li><strong>原理</strong>：专用硬件网络（组合逻辑）直接输出微地址，无需计算。例如，中断发生时，测试网络立即生成<code>8000</code>（中断处理入口）。</li><li><strong>应用</strong>：紧急事件（中断、缺页），需纳秒级响应。</li><li><strong>优点</strong>：响应极快；<strong>缺点</strong>：硬件专用性强，扩展性差。</li></ul><p>6. <strong>由硬件产生微程序入口地址</strong></p><ul><li><strong>第一条微程序指令地址</strong> 由 <strong>专门硬件</strong> 产生（用专门的硬件记录取值周期微程序首地址）</li><li><strong>中断周期</strong>由<strong>硬件</strong>产生<strong>中断周期微程序首地址</strong>（用专门的硬件记录）</li></ul><table><thead><tr><th>方式</th><th>字长</th><th>灵活性</th><th>速度</th><th>典型场景</th><th>类比</th></tr></thead><tbody><tr><td>下地址直接指定（<strong>断定方式</strong>）</td><td>高</td><td>高</td><td>中</td><td>条件分支、复杂跳转</td><td>每步贴指示牌</td></tr><tr><td>操作码映射</td><td>低</td><td>中</td><td>中</td><td>指令解码、指令集扩展</td><td>不同任务走不同入口</td></tr><tr><td><strong>增量计数器</strong></td><td>低</td><td>低</td><td>高</td><td>顺序执行（如取指）</td><td>排队</td></tr><tr><td>分支转移</td><td>中</td><td>高</td><td>中</td><td>算术分支、异常处理</td><td>岔路口选路</td></tr><tr><td>测试网络直接生成</td><td>低</td><td>低</td><td>极高</td><td>中断、硬件异常处理</td><td>绿色通道</td></tr><tr><td>eg. <strong>某计算机采用微程序控制器，32 条指令，取指微程序（公共部分） 2 条，每条指令执行微程序 4 条，断定方式下求微指令总数及下地址字段位数。</strong></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><strong>微指令总数</strong>：<br>取指微程序（2 条） + 32 条指令 ×4 条 / 指令 = <strong>130 条</strong>。</li><li><strong>下地址字段位数</strong>：<br>130 条需唯一地址，<code>2⁷=128 &lt; 130</code>，<code>2⁸=256 ≥ 130</code>，故<strong>8 位</strong>。</li></ol><h4 id="微程序控制单元的设计">微程序控制单元的设计</h4><p>从指令拆解到微码生成的全流程：<br><strong>核心目标</strong>：将机器指令（如加法、跳转）分解为最基本的硬件操作步骤，形成有序的微操作序列。<br>拆动作→排时间→设计格式→写代码<br>1. <strong>分析微操作序列</strong>（如取指、执行的原子动作</p><ul><li><strong>目标</strong>：将指令执行过程（取指、译码、执行等）分解为最小硬件操作（微操作），明确各阶段的操作顺序。</li><li><strong>示例</strong>：取指阶段包含<code>PC→MAR</code>、<code>1→R</code>、<code>MDR→IR</code>等微操作，执行阶段根据指令类型（如加法、跳转）有不同操作。</li></ul><p>2. <strong>微操作与节拍安排</strong>（分配节拍，加入控制流微操作）</p><ul><li><strong>2.1 机器指令微操作</strong>：<br>参照硬布线控制器，为每个机器周期（如取指、执行）分配微操作，确保时序正确（如取指周期分 3 个节拍，每个节拍执行 1-2 个微操作）。</li><li><strong>2.2 微程序特有微操作</strong>：<ul><li><strong>取指周期</strong>：<br>每条微指令结束之后都需要进行：<ul><li><code>Ad(CMDR)→CMAR</code>：微指令地址字段送微地址寄存器（CMAR），控制下条微指令读取。</li><li><code>OP(IR)→CMAR</code>：取出指令后，根据指令类型（如 “加法”）直接跳到对应微程序的开头生成微程序入口地址<br>机器指令操作码映射微程序入口<br>机器指令取指阶段固定、自动<br>微程序取指阶段内部流程固定（如顺序 / 跳转逻辑），但入口依赖机器指令、自动</li></ul></li><li><strong>执行周期</strong>：<br>取指完成后，按指令类型（如加法）的微程序执行<ul><li><code>Ad(CMDR)→CMAR</code>：按当前微指令地址字段跳转（支持条件分支或顺序执行）。</li></ul></li></ul></li></ul><p>3. <strong>确定微指令格式</strong>（操作控制 + 地址字段，计算位数）</p><ul><li><strong>3.1 操作控制字段</strong>：<br>根据微操作数量选择编码方式（直接 / 字段编码），计算位数。例如，20 个互斥微命令用字段编码，分 3 组（7+7+6），每组 3 位，共 9 位。</li><li><strong>3.2 顺序控制字段</strong>：<br>由控制存储器（CM）容量决定（如 256 单元需 8 位地址）。</li><li><strong>3.3 微指令字长</strong>：<br>字长 = 操作控制字段位数 + 顺序控制字段位数（如 9+8=17 位）。</li></ul><p>4. <strong>编写微指令码点</strong>（将操作和地址编码存入 CM）</p><ul><li><strong>编码规则</strong>：操作控制字段<code>1</code>表示激活微操作，<code>0</code>表示不激活；顺序控制字段填入下条微指令地址（二进制）。</li><li><strong>示例</strong>：激活 “ALU 加法”（位 3）和 “存结果”（位 5），下地址 15（<code>00001111</code>），码点为<code>...1010... 00001111</code>。</li></ul><h4 id="微程序设计分类">微程序设计分类</h4><ul><li><p><strong>静态</strong>：微程序固化在 <strong>ROM</strong> 中，不可修改，适用于指令集稳定的场景（如传统 CPU）。</p><ul><li><strong>优势</strong>：可靠性高，成本低。</li></ul></li><li><p><strong>动态</strong>：微程序存于 <strong>EPROM</strong>，可动态修改，支持指令集扩展或仿真（如虚拟机模拟不同 CPU 指令集）。</p><ul><li><strong>应用</strong>：高端处理器的微码更新（如修复硬件漏洞）。</li></ul></li><li><p><strong>毫微程序设计（分层控制）</strong></p><ol><li><strong>微程序 vs 毫微程序</strong>：<ul><li>微程序：用微指令 “翻译” 机器指令（如机器指令 “加法”→ 分解为取数、运算、存结果等微操作）。</li><li>毫微程序：用更底层的 “毫微指令” 翻译微指令，形成 “两层控制结构”，类似 “翻译的翻译”。</li></ul></li><li><strong>类比理解</strong>：<ul><li>机器指令（如 “做蛋炒饭”）→ 微程序（分解为 “打蛋→炒饭→加盐”3 步微操作）→ 毫微程序（每步再细分：“打蛋”→“取鸡蛋→敲开→搅匀”3 条毫微指令）。</li></ul></li></ol><ul><li><strong>优势</strong>：<ul><li><strong>简化设计</strong>：上层微程序专注逻辑分解，下层毫微程序专注硬件控制，分工明确，类似 “项目经理（微程序）+ 执行团队（毫微程序）”。</li><li><strong>提高效率</strong>：毫微指令可并行执行（如 “取鸡蛋” 和 “拿锅” 同时做），提升硬件利用率，类似 “流水线分工”。</li></ul></li><li><strong>应用场景</strong>：<ul><li>复杂 CISC 架构处理器（如 x86），通过分层控制简化微程序复杂度，同时优化执行速度。</li></ul></li><li>毫微指令与微指令的关系好比微指令与机器指令的关系</li></ul></li></ul><h3 id="硬布线-VS-微程序">硬布线 VS 微程序</h3><table><thead><tr><th></th><th>微程序控制器</th><th>硬布线控制器</th></tr></thead><tbody><tr><td>工作原理</td><td>把硬件控制步骤（微操作）写成 “微程序” 存到控制存储器（CM），执行时像 “查字典” 读取微指令，解析后控制硬件。</td><td>用门电路（与非门、触发器等）搭建成组合逻辑电路，根据指令码、状态信号直接生成控制信号，像 “按开关直接通电”。</td></tr><tr><td>执行速度</td><td>慢</td><td>快</td></tr><tr><td>规整性</td><td>较规整</td><td>烦琐、不规整</td></tr><tr><td>应用场合</td><td>CISC CPU</td><td>RISC CPU</td></tr><tr><td>易扩充性</td><td>易扩充修改</td><td>困难</td></tr></tbody></table><h2 id="异常和中断机制">异常和中断机制</h2><p>异常和中断在本质上均为计算机系统中处理意外事件的机制，但二者存在显著差异，核心区别体现在<strong>触发场景</strong>和<strong>检测方式</strong>上：</p><table><thead><tr><th>对比维度</th><th>异常（内中断）</th><th>中断（外中断）</th></tr></thead><tbody><tr><td>触发关联</td><td>与<strong>特定指令的执行过程直接相关</strong>（同步事件），如 “缺页” 是指令访问内存时触发</td><td><font color="#c00000">与任何指令均无关联</font>（异步事件），不影响指令完成</td></tr><tr><td>检测方式</td><td>由<strong>CPU 内部自行检测</strong>，<strong>无需外部信号</strong></td><td>需通过<strong>中断请求线</strong>接收外部设备的信号，获取中断源信息</td></tr></tbody></table><h3 id="异常（内中断）">异常（内中断）</h3><p>异常是由<strong>CPU 内部产生的意外事件</strong>，属于与当前执行指令相关的<strong>同步事件</strong>（即事件的发生与指令执行同步）。其核心特性包括：</p><ul><li>触发时机：CPU 执行某条指令时，在内部检测到（与该指令直接相关）；</li><li>检测机制：每个指令周期末尾，CPU 会先检查是否有外中断信号，再处理内部异常；</li><li>本质：是 CPU 内部因硬件或软件问题引发的 “意外”，需特殊处理以保证系统正常运行。</li></ul><h4 id="分类">分类</h4><p>根据异常的触发源头，可分为<strong>硬故障中断</strong>和<strong>程序性异常（软件中断）</strong>：</p><ul><li><strong>硬故障中断</strong>：由计算机硬件（硬连线）出现异常引发的事件，与硬件物理状态直接相关<ul><li>存储器校验错（内存数据读写时校验位不匹配）、总线错误（数据在总线传输中出错）等；</li><li>包括<strong>终止异常</strong>和<strong>外中断</strong>（注意：外中断本质是中断，此处因硬件关联被硬故障中断包含）。</li></ul></li><li><strong>程序性异常</strong>【<strong>软件中断</strong>】：CPU 在执行指令过程中，因软件逻辑或指令本身的问题引发的异常，是 “软件层面” 的意外；<ul><li>整除 0（运算逻辑错误）、溢出（计算结果超出数据类型范围）、断点（调试时的预设停止点）、单步跟踪（调试时逐行执行）、非法指令（CPU 不识别的操作码）、栈溢出（栈空间不足）、地址越界（访问超出允许范围的内存地址）、缺页（所需内存页不在物理内存中）等；</li><li>包括<strong>故障异常</strong>和<strong>自陷异常</strong></li></ul></li></ul><p>根据异常发生的具体原因及处理后的返回逻辑，异常可进一步分为<strong>故障（Fault）</strong>、<strong>自陷（Trap）</strong>、<strong>终止（Abort）</strong> 三类，核心差异体现在 “何时检测”“能否恢复”“返回哪里”：</p><h5 id="故障（Fault）">故障（Fault）</h5><ul><li>概念：在引起故障的指令<strong>启动后、执行结束前</strong>被检测到的异常（即指令未完成时发现问题）；</li><li>典型举例：<ul><li><strong>指令译码时出现 “非法操作码”</strong>（CPU 无法识别该指令，执行前发现）；</li><li><strong>取数据时发生 “缺段” 或 “缺页”</strong>（所需内存段 / 页未加载，执行中发现）；</li><li><strong>除数为零</strong>（运算开始后发现除数无效）；</li><li><strong>地址越界</strong>（访问内存时发现地址超出允许范围）；</li></ul></li><li>关键特性（返回方式）：<ul><li><strong>可恢复的故障</strong>：如 “缺段”“缺页”，异常处理程序会加载所需的段 / 页到内存，处理完成后<strong>回到发生故障的指令重新执行</strong>（断点为该指令）；</li><li><strong>不可恢复的故障</strong>：如 “非法操作码”“除数为 0”，因无法通过处理程序修复（指令本身无效或逻辑错误），必须<strong>终止当前进程</strong>，无法回到原断点。</li></ul></li></ul><h5 id="自陷（Trap，陷阱-陷入）">自陷（Trap，陷阱 / 陷入）</h5><ul><li>概念：预先安排的 “异常事件”，如同程序中预设的 “陷阱”，是<strong>主动触发</strong>的异常（非意外）；</li><li>典型举例：<ul><li>x86 架构中，调试时的 “断点设置”（程序员预设某行代码执行时暂停）和单步跟踪（每执行一条指令就暂停，便于调试）；</li><li><strong>系统调用</strong>（用户程序主动请求操作系统服务，如读取文件，通过自陷指令触发）；</li><li><strong>条件自陷指令</strong>（满足特定条件时触发的自陷，如某变量超过阈值）；</li></ul></li><li>关键特性（返回方式）：自陷是 “预期内” 的事件，处理程序完成后（如系统调用执行完服务），会回到<strong>自陷指令的下一条指令</strong>继续执行（因自陷指令已执行完毕）。</li></ul><h5 id="终止（Abort）">终止（Abort）</h5><ul><li>概念：执行指令过程中发生<strong>严重硬件故障</strong>，导致计算机无法继续运行的异常，是 “致命性” 问题；</li><li>典型举例：<strong>控制器出错</strong>（CPU 内部控制逻辑故障）、<strong>存储器校验错</strong>（内存硬件损坏导致无法修复）等；</li><li>关键特性：<ul><li>非特定指令触发：<strong>随机发生</strong>（与某条指令无直接关联）；</li><li>处理方式：必须终止当前程序执行，通常需要调用中断服务程序重启系统或进入安全状态，<strong>无法返回原程序</strong>（因硬件已无法正常工作）。</li></ul></li></ul><h3 id="中断（外中断）">中断（外中断）</h3><p>中断（外中断）是由<strong>CPU 外部设备</strong>触发的事件，其核心特性如下：</p><ul><li><strong>触发源</strong>：来自 <strong>CPU 外部</strong>（如 I/O 设备、时钟等），与当前正在执行的指令<strong>无直接关联</strong>，属于<strong>异步事件</strong>（事件发生时机不确定，与指令执行不同步）。</li><li><strong>请求方式</strong>：外部 I/O 设备通过<strong>特定的中断请求信号线</strong>向 CPU 发送请求，告知需要处理的事件。</li><li><strong>检测时机</strong>：CPU 在<strong>每执行完一条指令后</strong>，会检查中断请求信号线是否有请求；若有，则进入中断响应阶段。</li><li><strong>核心作用</strong>：实现 CPU 与外部设备的高效交互（无需 CPU 持续轮询设备状态），提升系统资源利用率。</li></ul><h4 id="中断的分类">中断的分类</h4><p>根据 CPU 是否可以屏蔽中断请求，中断可分为<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断</strong>：<br>（1）可屏蔽中断</p><ul><li><strong>概念</strong>：通过<strong>可屏蔽中断请求线（INTR）</strong> 向 CPU 发送的中断请求。</li><li><strong>特点</strong>：CPU 可以通过设置中断控制器中的<strong>屏蔽字</strong>来决定是否响应这类中断。被屏蔽的中断请求不会被 CPU 处理，直到屏蔽解除。</li><li><strong>举例</strong>：大多数 <strong>I/O</strong> 设备中断（如键盘输入、打印机完成打印、磁盘读写完成等），这些事件通常不紧急，可暂时延迟处理。</li></ul><p>（2）不可屏蔽中断</p><ul><li><strong>概念</strong>：通过<strong>不可屏蔽中断请求线（NMI）</strong> 向 CPU 发送的中断请求。</li><li><strong>特点</strong>：CPU<strong>必须立即响应</strong>，无法通过软件屏蔽（因涉及系统致命性问题）。</li><li><strong>举例</strong>：通常是紧急的硬件故障，如<strong>电源掉电、内存校验错误</strong>等，若不及时处理会导致系统崩溃。</li></ul><table><thead><tr><th>中断类型</th><th>产生原因</th><th>特点</th><th>典型例子</th><th>断点</th></tr></thead><tbody><tr><td><strong>故障</strong></td><td><strong>指令执行时</strong>出现可恢复运算异常</td><td>CPU 可恢复，重执行故障指令</td><td><strong>溢出</strong>、非法指令、<strong>缺页</strong>、访问越权</td><td>故障指令的地址</td></tr><tr><td><strong>终止</strong></td><td><strong>硬件 / 软件</strong>严重不可恢复错误</td><td>系统终止，无法继续运行</td><td><strong>主存存储数据校验出错</strong>、CPU 核心部件故障、硬件电路损坏</td><td>随便</td></tr><tr><td><strong>自陷</strong></td><td>程序<strong>主动</strong>触发，预先安排的事件</td><td>用于实现程序特定功能或调试</td><td>单步跟踪、断点、系统调用（执行访管指令）</td><td>自限制令的下条指令地址</td></tr><tr><td><strong>I/O 中断</strong></td><td>I/O 设备请求服务（如数据传输完成、设备就绪）</td><td>协调 CPU 与 I/O 设备数据交互</td><td>硬盘读写完成通知 CPU、打印机准备好接收任务</td><td></td></tr><tr><td><strong>外部中断</strong></td><td>外部设备（键盘、鼠标等）发出的中断请求</td><td>响应外部事件</td><td>键盘按键、鼠标移动产生的中断</td><td>被中断指令的下一条指令的地址</td></tr><tr><td><strong>机器校验中断</strong></td><td><strong>硬件</strong>自身校验出错（如<strong>内存奇偶校验、硬件自检错误</strong>）</td><td>检测硬件自身状态</td><td>内存奇偶校验发现错误、硬件开机自检不通过</td><td></td></tr></tbody></table><h3 id="异常和中断响应过程">异常和中断响应过程</h3><ul><li>从 CPU 检测到异常（内中断）或中断（外中断）事件，到调出相应的处理程序，整个过程称为<strong>异常和中断响应</strong></li><li>响应过程不可被打断，整个中断处理过程是<strong>软 / 硬件协同</strong>实现的</li><li>异常和中断事件都是由<strong>硬件检测</strong>实现的</li></ul><h4 id="关中断">关中断</h4><ul><li>在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即<strong>关中断</strong></li><li>设置<strong>中断允许触发器</strong>（IF）实现【IF = 1 代表开中断，表示允许响应中断】</li></ul><h4 id="保存断点和程序状态">保存断点和程序状态</h4><ul><li><strong>目的</strong>：确保异常或中断处理完成后，能正确返回到被打断的程序继续执行。</li><li><strong>保存内容</strong>：<ul><li><strong>断点</strong>：被打断程序的下一条指令地址（即当前程序计数器 PC 的值），用于处理完成后恢复执行位置。</li><li><strong>程序状态字（PSW）</strong>：记录 CPU 的状态信息（如标志位、中断屏蔽状态等），需在返回时恢复，保证原程序执行环境不变。</li></ul></li><li><strong>保存位置</strong>：通常将断点和 PSW 压入<strong>系统栈</strong>中，栈的特性支持异常 / 中断的嵌套（即处理一个中断时又发生新的中断，可依次入栈保存状态）。</li></ul><h4 id="识别异常和中断并转到相应的处理程序">识别异常和中断并转到相应的处理程序</h4><p>识别的目的是确定事件类型，找到对应的处理程序入口地址。主要有<strong>软件识别</strong>和<strong>硬件识别（向量中断）</strong> 两种方式：</p><ul><li><strong>软件识别</strong>：<ul><li>CPU 检测到异常或中断后，会设置一个<strong>异常状态寄存器</strong>，记录事件的具体原因（如 “缺页”“键盘中断” 等）。</li><li>操作系统执行一个<strong>统一的查询程序</strong>，按优先级顺序读取异常状态寄存器，确定事件类型后，跳转到对应的内核处理程序。</li><li><strong>适用场景</strong>：<strong>异常和部分中断</strong>（尤其是原因复杂、类型较多的情况）。</li></ul></li><li><strong>硬件识别</strong>【<strong>向量中断</strong>】：<ul><li><strong>核心概念</strong>：<ul><li><strong>中断向量</strong>：每个异常或中断处理程序的首地址（入口地址）。</li><li><strong>中断向量表</strong>：所有中断向量集中存储的区域（通常在内存固定位置），相当于 “处理程序地址目录”。</li><li><strong>中断类型号</strong>：每个异常或中断被分配一个唯一编号，作为索引指向中断向量表中的对应入口。</li></ul></li><li><strong>原理</strong>：<ul><li>事件发生时，硬件自动根据事件类型生成中断类型号。</li><li>CPU 通过中断类型号，直接在中断向量表中找到对应的中断向量（处理程序地址），快速跳转到处理程序。</li></ul></li><li><strong>特点</strong>：识别速度快（无需软件查询），效率高，是现代计算机常用的方式。</li><li><strong>适用场景</strong>：大多数中断（如 I/O 设备中断），因类型明确且需要快速响应。</li></ul></li></ul><h2 id="指令流水线">指令流水线</h2><h3 id="流水线的基本概念">流水线的基本概念</h3><h4 id="如何提高处理机的并行性">如何提高处理机的并行性</h4><ul><li>**时间上的并行技术（流水线技术）：<ul><li>将一个任务拆分成几个不同的子阶段</li><li>每个阶段在不同的功能部件上并行执行，即流水线技术</li></ul></li><li><strong>空间上的并行技术（超标量技术）</strong>：<br>在处理器中设置多个功能部件（如多个 ALU），同时执行多条指令，提升单位时间处理能力。</li></ul><h4 id="指令流水线的定义">指令流水线的定义</h4><ul><li>将指令执行过程的各阶段（如取指、译码、取数、执行、写回）视为独立 “流水段”，各段依次衔接形成流水线。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501220002.png" alt="image.png"></li><li><strong>不能缩短单条指令的执行时间</strong>，但对于整个程序来说，执行效率得到大幅提升</li></ul><p>eg. 单条指令执行需 5 个阶段，每阶段 1 周期，总耗时 5 周期</p><ul><li>流水线中第 1 条指令 5 周期完成后，后续每条指令每 1 周期完成 1 条，N 条指令总耗时为 5 + (N-1)×1 周期。</li></ul><h4 id="指令集应具备的特点">指令集应具备的特点</h4><ol><li><strong>指令长度一致</strong>：简化取指阶段的硬件设计，避免因指令长度不同导致流水线停顿。</li><li><strong>格式规整</strong>：源寄存器位置固定，便于在译码阶段提前获取操作数，减少等待时间。</li><li><strong>Load/Store 架构</strong>：将数据访存操作（Load/Store）与运算操作分离，使地址计算和运算步骤在统一周期内完成，优化流水线时序。</li><li><strong>数据对齐存储</strong>：确保数据在内存中按字节对齐，减少访存次数（如一次访存获取完整数据），避免流水线因等待数据而阻塞。</li></ol><h4 id="流水线的表示方法">流水线的表示方法</h4><ul><li>采用时空图描述流水线的执行情况<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501220833.png" alt="image.png"></li></ul><p>超标量流水线时间计算 <strong>核心公式</strong><br>$\boldsymbol{总时间 = T_{首条} + \left( \left\lceil \dfrac{N}{n} \right\rceil - 1 \right) \times T}$</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>$T_{首条}$</td><td>第一条指令的执行时间 = 所有流水段执行时间之和（$T_1 + T_2 + … + T_m$，m为段数）</td></tr><tr><td>n</td><td>超标量度（每周期发射 / 完成的指令数，如度为 4 则每 T 处理 4 条）</td></tr><tr><td>N</td><td>总指令数</td></tr><tr><td>$\left\lceil x \right\rceil$</td><td>向上取整</td></tr><tr><td>T</td><td>流水线周期（T=$T_{max}$，各段时间的最大值）</td></tr></tbody></table><h4 id="流水线的性能指标">流水线的性能指标</h4><h5 id="流水线的吞吐率（TP）-总指令n-总时间Tk">流水线的吞吐率（TP）[总指令n/总时间Tk]</h5><ul><li><strong>定义</strong>：<strong>单位时间</strong>内完成的指令数或任务数。</li><li><strong>公式</strong>：<ul><li>设流水线有 k 段，处理 n 条指令总时间为 $T_k = （k + n-1) \times \Delta t$（$\Delta t$为最长段耗时），则吞吐率：$TP = \frac{n}{T_k} = \frac{n}{(k + n - 1) \times \Delta t}$</li><li><strong>最大吞吐率</strong>：当 n→∞时，$TP_{max} = \frac{1}{\Delta t}$，即每周期完成 1 条指令。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501221430.png" alt="image.png"></li></ul></li><li><strong>注意</strong>：<ul><li>m 段流水线的 CPU 吞吐能力 = m 个并行部件的 CPU 吞吐能力</li><li>m 段流水线在第 m 个时钟周期后，每个时钟周期都可完成一条指令</li><li>m 个并行部件在 m 个时钟周期后能完成全部的 m 条指令，等价于平均每个时钟周期完成一条指令</li></ul></li></ul><h5 id="流水线的加速比（S）-顺序时间-总时间">流水线的加速比（S）[顺序时间/总时间]</h5><ul><li><strong>定义</strong>：流水线比 “顺序执行” 快多少倍。</li><li><strong>公式</strong>：<ul><li>顺序执行 n 条指令时间 $T_0 = n \times k \times \Delta t$，流水线时间 $T_k = (k + n-1) \times \Delta t$，则加速比：$S = \frac{T_0}{T_k} = \frac{n \times k}{k + n - 1}$</li><li><strong>最大加速比</strong>：当 n→∞时，$S_{max} = k$，即流水线段数越多，理论加速比越高。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501222028.png" alt="image.png"></li></ul></li></ul><h5 id="流水线的效率（E）-面积比">流水线的效率（E）[面积比]</h5><ul><li><strong>定义</strong>：流水线各段的平均利用率，时空图中有效面积与总面积的比值，越接近 100% 越好。</li><li><strong>公式</strong>：$E = \frac{T_0}{k \times T_k} = \frac{n}{k + n - 1}$</li><li><strong>直观理解</strong>：流水线效率随指令数增加而趋近于 1（满负荷），但初期因流水线未填满，效率较低。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501223026.png" alt="image.png"><br>理想情况：各个阶段的花费时间相同，每个阶段结束后能立即进入下一个阶段。<br>实际受影响因素影响，很难达到</li></ul><h3 id="流水线的基本实现">流水线的基本实现</h3><h4 id="流水线的数据通路">流水线的数据通路</h4><ul><li><strong>数据通路</strong>：数据在功能部件之间传送的路径<ul><li>包括数据通路上流经的部件（如 PC，ALU，通用寄存器，状态寄存器，异常和中断处理逻辑）</li></ul></li><li><strong>数据通路由控制部件控制</strong>，控制部件根据每条指令功能的不同生成对数据通路的控制信号<ul><li><strong>数据通路不包含生成控制信号的控制部件</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501223439.png" alt="image.png"></li></ul></li></ul><h4 id="流水线的控制信号">流水线的控制信号</h4><table><thead><tr><th>控制信号</th><th>生效位置</th><th>来 源</th><th>功能说明</th></tr></thead><tbody><tr><td>BranchTaken</td><td>IF</td><td>EX</td><td>分支<strong>跳转</strong>信号，为 1 表示跳转，由 EX 段的 Branch 信号与 equal 标志进行逻辑与生成</td></tr><tr><td>RegDst</td><td>ID</td><td>ID</td><td>写入<strong>目的寄存器</strong>选择，为 1 时目的寄存器为 rd 寄存器，为 0 时为 rt 寄存器</td></tr><tr><td>RegWrite</td><td>ID</td><td>WB</td><td>控制寄存器堆<strong>写操作</strong>，为 1 时数据需要写回寄存器堆中的指定寄存器</td></tr><tr><td>AluSrc</td><td>EX</td><td>EX</td><td>ALU 的<strong>第二输入</strong>选择控制，为 0 时输入寄存器 rt，为 1 时输入扩展后的立即数</td></tr><tr><td>AluOp</td><td>EX</td><td>EX</td><td>控制 ALU 进行不同<strong>运算</strong>，具体取值和位宽与 ALU 的设计有关</td></tr><tr><td>MemWrite</td><td>MEM</td><td>EX</td><td>控制<strong>写不写内存</strong>，访问内存时，1 表示往内存写数据（比如保存变量），0 表示从内存读数据（比如取变量值）。</td></tr><tr><td>MemToReg</td><td>WB</td><td>WB</td><td>选<strong>写回的数据来源</strong>，结果是从内存来的（比如加载指令读的内存数据）还是 ALU 运算来的（比如加法结果）？1 表示用内存数据，0 表示用 ALU 结果。</td></tr></tbody></table><ul><li><p><strong>流水寄存器保存的信息</strong></p><ul><li>后面流水段要用到的<strong>所有数据信息</strong><ul><li>包括 PC+4,、指令、立即数、目的寄存器、ALU 运算结果、标志信息等</li><li>它们是前面阶段在数据通路中执行的结果</li></ul></li><li>后面传递过来的后面各流水段要用到的<strong>所有控制信号</strong></li></ul></li><li><p>流水线控制信号的设计逻辑：</p><ul><li>PC 和流水段寄存器 <strong>无写使能信号</strong>（PC 每时钟必更新、流水段寄存器每时钟必写入，硬件时序直接驱动）</li><li>前两个流水段是 <strong>公共段</strong>（指令功能固定，无需动态控制信号）</li><li><strong>控制信号</strong>：仅作用于功能部件（如ALU、MUX），控制它们的操作。</li><li><strong>时钟信号</strong>：作用于所有状态元件（包括PC、流水段寄存器、通用寄存器、存储器等），是全局同步的，确保处理器各部件协调工作。</li></ul></li></ul><h4 id="流水线的执行过程">流水线的执行过程</h4><ul><li><strong>取指（IF）</strong>：从<strong>指令寄存器或 Cache</strong> 中取指令</li><li><strong>译码/读寄存器（ID）</strong>：操作控制器对指令进行<strong>译码</strong>，同时从<strong>寄存器</strong>堆中读取操作数</li><li><strong>执行/计算地址（EX）</strong>：加减法计算</li><li><strong>访存（MEM）</strong>：对<strong>存储器</strong>进行读写操作</li><li><strong>写回（WB）</strong>：将指令执行结果写回<strong>寄存器</strong></li></ul><p>所有的指令都有这5个周期，即使有的指令某几个阶段不执行<br>耗时取最大的<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250801203452374.png" alt="image.png"><br>流水线每个功能段部件后面都要有一个<strong>缓冲寄存器</strong>，或称为<strong>锁存器</strong>，其作用是保存本流水段的执行结果，提供给下一流水段使用</p><table><thead><tr><th>英文术语</th><th>中文翻译</th><th>核心功能（通俗理解）</th><th>关联阶段</th></tr></thead><tbody><tr><td>PC（Program Counter）</td><td>程序计数器</td><td>存放下一条要执行的<strong>指令地址</strong>，是 “指令执行顺序” 的 “指挥棒”（类似 “原料清单的页码”）。</td><td>IF 阶段（取指的 “地址源”）</td></tr><tr><td>Instruction Cache</td><td>指令缓存</td><td>高速缓存<strong>指令</strong>（因为从主存取指令慢，缓存常用指令加速），是 “指令的临时仓库”。</td><td>IF 阶段（取指的 “数据源”）</td></tr><tr><td>Inst. Register（Instruction Register）</td><td>指令寄存器</td><td>临时存储<strong>当前正在处理的指令</strong>，供译码阶段解析（类似 “临时放说明书的架子”）。</td><td>IF→ID 阶段（指令的 “中转站”）</td></tr><tr><td>Registers（Register File）</td><td>寄存器堆</td><td>CPU 内部的<strong>高速存储单元</strong>，存 “操作数” 和 “运算结果”（类似 “车间的零件库”）。</td><td>ID 阶段（读操作数）、WB 阶段（写结果）</td></tr><tr><td>Imm（Immediate）</td><td>立即数</td><td>指令中<strong>直接包含的常数</strong>（比如<code>addi $t0, $t1, 5</code>中的<code>5</code>），无需从寄存器 / 内存读取。</td><td>ID 阶段（与寄存器操作数配合）</td></tr><tr><td>ALU（Arithmetic Logic Unit）</td><td>算术逻辑单元</td><td>执行<strong>算术运算</strong>（加减乘除）和<strong>逻辑运算</strong>（与或非）的 “核心运算器”（类似 “车间的机床”）。</td><td>EX 阶段（运算的 “执行器”）</td></tr><tr><td>Data Cache</td><td>数据缓存</td><td>高速缓存<strong>数据</strong>（因为从主存读写数据慢，缓存常用数据加速），是 “数据的临时仓库”。</td><td>M 阶段（访存的 “数据源 / 目标”）</td></tr></tbody></table><h3 id="流水线的冒险与处理">流水线的冒险与处理</h3><p><strong>流水线冒险</strong>：在流水线中会有一种情况，在下一个时钟周期中下一条指令不能执行，这种情况被叫做流水线冒险<br>根据导致冒险的原因不同分为：结构冒险、数据冒险和控制冒险</p><ul><li><strong>数据冒险</strong>：后面指令用到前面指令结果时，前面指令结果还没产生<ul><li><strong>解决</strong>：<ul><li><strong>停顿 / 插 NOP</strong>：暂停流水线，直至能正确读取寄存器操作数（等待前指令结果写回）；</li><li><strong>编译指令重排</strong>【可部分解决】：编译器调整指令顺序，让不依赖前指令结果的指令先执行，减少数据等待的 stall 周期。</li><li><strong>寄存器堆读写设计</strong>【可部分解决】：通过 <strong>时序拆分</strong> 规避冲突：规定寄存器堆 <strong>前半时钟周期写数据、后半时钟周期读数据</strong>；若同一时钟内，前指令写入的数据正好是后指令读取的数据，因读写时序错开，天然无冒险。</li><li><strong>数据转发（旁路技术）</strong>【可部分解决】：构建专用数据通路，直接传递中间结果：<ul><li>若依赖数据是 <strong>ALU 运算结果</strong>（如加法结果）：可从 ALU 输出端得到的中间结果直接转发至下条指令的 ALU 输入端，无需等待写回寄存器，快速解决 RAW 冲突；</li><li>若依赖数据是 <strong>Load 指令从内存（DM）读出的内容</strong>（Load - use 冒险）：因内存读需 “访存阶段” 完成，转发无法提前获取结果，需 <strong>阻塞 1 个时钟周期或插 NOP</strong>，这类场景是转发的 “例外”。<br>注：Load 指令的数据在<strong>访存阶段</strong>产生，后续指令在<strong>执行阶段</strong>就需该数据，转发技术无法捕获访存阶段的结果，故至少阻塞 1 周期。</li></ul></li></ul></li><li><strong>乱序</strong>执行的流水线中存在三种数据相关：<ul><li>RAW（写后读）：先往盒里放材料（写），再拿出来用（读），但没放好就想拿 —— 比如先装胚，再拿胚抹奶油，胚没装完就拿。</li><li>WAW（写后写）：两次往同一个盒里放材料，第一次还没放完，第二次就想放 —— 比如先往盒里装原味胚，还没装完，又想装巧克力胚，盒子里就乱了。</li><li>WAR（读后写）：先拿材料用，再往盒里放新的，还没拿完就放新的 —— 比如先拿盒里的胚用，还没拿完，就往盒里装新胚，拿的还是旧的。</li></ul></li><li><strong>按序</strong>执行的流水线中，只可能出现 <strong>RAW</strong> 冲突</li></ul></li><li><strong>控制冒险</strong>：也叫分支冒险，决策依赖于一条指令的结果，而其他指令正在执行中，如分支跳转指令需等 ALU 给出结果后才知道跳转地址。【只要不是<strong>顺序执行指令</strong>，都会引发控制冒险】<ul><li><strong>解决</strong>：<ul><li>分支预测（静态：默认不转移；动态：按历史调整）</li><li>延迟槽（分支后插无关指令，避免断流）<ul><li>硬件上阻塞（stall）分支指令后三条指令的执行</li><li>软件上插入三条NOP指令</li></ul></li><li>提前算目标 PC（减少停顿周期）</li></ul></li></ul></li><li><strong>结构冒险</strong>：<font color="#c00000">硬件资源</font><strong>（如存储器、ALU、寄存器）</strong> 冲突，同一个部件同时被不同指令所使用【<strong>烤箱又要烤胚又要热奶油</strong>】<ul><li><strong>解决</strong>：<ul><li>一个部件的每条指令只能使用一次，且固定部件的使用阶段（如：ALU总在第三阶段被用）</li><li>设置多个独立的部件来避免硬件资源冲突<ul><li>将指令Cache和数据Cache分开</li><li>将寄存器读口和写口独立开来</li></ul></li><li>产生空泡，使读写错开进行<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250815033212387.png" alt="image.png"></li></ul></li></ul></li></ul><h4 id="结构冒险">结构冒险</h4><ul><li><strong>定义</strong>：多条指令<strong>同时需要同一硬件资源</strong>（如总线、寄存器端口），导致 “资源竞争”<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501224958.png" alt="image.png"><br><strong>解决方法</strong>：</li><li>前一指令访存时，使后一条指令（以及其后续指令）<strong>暂停一个时钟周期</strong></li><li><strong>设置多个独立的部件</strong>：<ul><li>寄存器访存冲突：将寄存器的读口和写口独立开来</li><li>访存冲突：单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行（<strong>分离结构的 Cache</strong>）</li></ul></li></ul><h4 id="数据冒险">数据冒险</h4><ul><li><p><strong>定义</strong>：后一条指令需要<strong>前一条指令的结果</strong>，但前一条指令的结果还没生成（比如没写回寄存器）</p></li><li><p><strong>乱序</strong>执行的流水线中存在三种数据相关：</p><ul><li><strong>写后读 RAW</strong>：当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据</li><li><strong>读后写 WAR</strong>：当前指令读出数据后，下一条指令才能写入寄存器</li><li><strong>写后写 WAW</strong>：当前指令写入寄存器后，下一条指令才能写入寄存器</li></ul></li><li><p><strong>按序</strong>执行的流水线中，只可能出现 <strong>RAW</strong> 冲突<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502153843.png" alt="image.png"><br><strong>解决方法</strong>：</p></li><li><p><strong>延迟执行相关指令</strong>：把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直至数据相关问题消失后再继续执行，可分为<strong>硬件阻塞（stall）</strong> 和<strong>软件插入空操作 nop</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502154533.png" alt="image.png"></p></li><li><p><strong>转发（旁路）技术</strong>：设置相关转发通路，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而将数据通路中生成的中间数据<strong>直接转发到 ALU 的输入端</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502154556.png" alt="image.png"></p></li><li><p><strong>load-use 数据冒险处理</strong>：load 指令与紧邻的运算类指令存在数据相关问题，可以使用<strong>延迟+转发</strong>技术解决，最好是在<strong>程序编译时进行优化</strong>，通过调整指令顺序避免出现该现象<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502154939.png" alt="image.png"></p></li></ul><h4 id="控制冒险">控制冒险</h4><ul><li><strong>定义</strong>：分支指令（如<code>if...else</code>）的<strong>跳转目标不确定</strong>，导致流水线 “提前取错指令”（比如分支不满足时，已经取了分支满足的指令）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502155758.png" alt="image.png"><br><strong>解决办法</strong></li><li><strong>对转移指令进行分支预测</strong>：<ul><li><strong>静态预测</strong>：默认不跳转或跳转，则按序继续执行分支指令的后续指令</li><li><strong>动态预测</strong>：根据程序执行的历史情况，进行动态调整，有效提高预测准确率</li></ul></li><li>同时<strong>预取</strong> “分支满足” 和 “分支不满足” 的指令，预测正确后直接执行对应路。</li><li><strong>加快和提前形成条件码</strong></li><li><strong>提高转移方向的猜准率</strong></li></ul><table><thead><tr><th>冒险类型</th><th>冲突原因</th><th>典型场景</th><th>解决思路</th></tr></thead><tbody><tr><td>结构冒险</td><td>硬件资源不够用</td><td>抢总线、抢寄存器端口</td><td>加资源（复制）或让指令等</td></tr><tr><td>数据冒险</td><td>数据依赖未满足</td><td>后指令需要前指令结果</td><td>等、转发、编译优化</td></tr><tr><td>控制冒险</td><td>分支目标不确定</td><td>if/else 导致取指错误</td><td>延迟槽、预测、预取双路指令</td></tr></tbody></table><h3 id="流水线的分类">流水线的分类</h3><ul><li><strong>级别分类</strong>：看 “并行的粒度”—— 是 “单个机器零件内部”（部件级）、“一条生产线”（处理机级），还是 “多个工厂接力”（处理机间级）。</li><li><strong>功能分类</strong>：看 “流水线会啥活”—— 是 “只会包饺子”（单功能），还是 “既能包饺子又能做面条”（多功能）。</li><li><strong>连接方式</strong>：看 “同一时间干几件事”—— 是 “同一时间只干一件事”（静态），还是 “同一时间干多件事”（动态）。</li><li><strong>反馈信号</strong>：看 “流水线是不是直的”—— 是 “单行道”（线性），还是 “环形路”（非线性）</li></ul><h4 id="按流水线使用级别分类（谁在并行？——-部件-单-CPU-多-CPU）">按<strong>流水线使用级别</strong>分类（谁在并行？—— 部件 / 单 CPU / 多 CPU）</h4><table><thead><tr><th>分类</th><th>定义</th><th>例子 / 类比</th><th>核心区别</th></tr></thead><tbody><tr><td>部件功能级流水线</td><td>把<strong>单个硬件部件</strong>（如 ALU）拆成更小的子模块，让子模块<strong>并行处理同一指令的子操作</strong>。</td><td>比如加法指令需要 “求阶差→对阶→尾数相加→规格化”4 步，每步由独立子电路并行完成。  <br>类比：包饺子时，剁馅、和面、擀皮、包馅四个工位同时做<strong>同一份饺子</strong>的不同步骤。</td><td>属于 <strong>“指令内并行”</strong>（一个指令拆成子操作并行）。</td></tr><tr><td>处理机级流水线</td><td>把<strong>一条指令的执行过程</strong>拆成多个阶段（如 IF/ID/EX/M/WB），让<strong>不同指令的不同阶段</strong>并行。</td><td>经典 5 阶段指令流水线：指令 1 在 WB，指令 2 在 M，指令 3 在 EX…  <br>类比：工厂流水线，5 个工人分别负责 “取料→切割→组装→质检→包装”，同时处理 5 个产品的不同工序。</td><td>属于 <strong>“指令间并行”</strong>（多条指令的不同阶段并行）。</td></tr><tr><td>处理机间流水线</td><td>多个 ** 处理器（多核 / 多 CPU）** 协作，每个处理器负责指令的一个阶段，接力完成指令。</td><td>比如 CPU1 负责取指，CPU2 负责译码，CPU3 负责执行… 指令在多个处理器间传递。  <br>类比：接力赛，4 个队员分别跑 “起跑→加速→冲刺→交接棒”，共同完成一场比赛。</td><td>属于 <strong>“处理器间并行”</strong>（多个 CPU 分工协作）。</td></tr></tbody></table><h4 id="按能完成的功能分类（流水线会啥技能？——-单一技能-多项技能）">按<strong>能完成的功能</strong>分类（流水线会啥技能？—— 单一技能 / 多项技能）</h4><table><thead><tr><th>分类</th><th>定义</th><th>例子 / 类比</th></tr></thead><tbody><tr><td>单功能流水线</td><td>只能完成<strong>一种固定操作</strong>（如加法、乘法），不能切换功能。</td><td>专门的 “加法流水线”，只能连续做加法运算；  <br>类比：只能包饺子的生产线，不能改包包子。</td></tr><tr><td>多功能流水线</td><td>可以<strong>动态切换功能</strong>，同时支持多种操作（如加法、乘法、逻辑运算）。</td><td>CPU 的 ALU 流水线，既可以做加法，也可以做乘法；  <br>类比：既能包饺子又能做面条的生产线，随时切换模式。</td></tr></tbody></table><h4 id="按连接方式分类（同一时间能做几件事？——-专一-花心）">按<strong>连接方式</strong>分类（同一时间能做几件事？—— 专一 / 花心）</h4><table><thead><tr><th>分类</th><th>定义</th><th>例子 / 类比</th><th>与 “功能分类” 的区别</th></tr></thead><tbody><tr><td>静态流水线</td><td>同一时间<strong>只能执行一种功能</strong>（即使支持多种功能，也只能选一种）。</td><td>多功能流水线在某一时刻只能选 “加法” 或 “乘法”，不能同时做两种；  <br>类比：厨房同一时间只能用烤箱烤面包，不能同时用烤箱烤面包 + 用锅炒菜。</td><td>强调 <strong>“同一时间的专一性”</strong>，与 “是否支持多种功能” 无关（多功能静态流水线也只能同一时间做一件事）。</td></tr><tr><td>动态流水线</td><td>同一时间<strong>可以执行多种功能</strong>（不同子模块并行处理不同操作）。</td><td>同一时刻，加法子模块做加法，乘法子模块做乘法；  <br>类比：厨房同时用烤箱烤面包 + 用锅炒菜，多任务并行。</td><td>强调 <strong>“同一时间的多任务”</strong>，需要硬件支持多个子模块独立工作。</td></tr></tbody></table><h4 id="按是否有反馈信号分类（“流水线是直的还是绕的？”——-单行线-环路）">按<strong>是否有反馈信号</strong>分类（“流水线是直的还是绕的？”—— 单行线 / 环路）</h4><table><thead><tr><th>分类</th><th>定义</th><th>例子 / 类比</th></tr></thead><tbody><tr><td>线性流水线</td><td>指令从 “起点”（IF）到 “终点”（WB）<strong>单向流动</strong>，无反馈或循环。</td><td>经典 5 阶段指令流水线：指令执行完就 “流走”，不会回头；  <br>类比：单行道，车从起点开到终点，不调头。</td></tr><tr><td>非线性流水线</td><td>存在<strong>反馈或循环路径</strong>，指令可能多次经过同一功能段（如乘法用多次加法实现）。</td><td>乘法流水线：用 “加法 + 移位” 循环多次完成乘法；  <br>类比：环形赛道，赛车需要绕圈跑多圈才能完成比赛。</td></tr></tbody></table><h3 id="流水线多发技术">流水线多发技术</h3><p><strong>突破 “单指令 / 单周期” 限制</strong>的核心手段，通过 <strong>空间并行（多部件）</strong> 或 <strong>时间并行（细分阶段）</strong> 提升性能</p><h4 id="超标量流水线技术">超标量流水线技术</h4><ul><li><strong>定义</strong>：每个时钟周期<strong>同时发射多条独立指令</strong>（比如同时发射<code>add</code>和<code>sub</code>），硬件层面动态识别指令间的并行性，自动调度执行，也称<strong>动态多发射技术</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502160930.png" alt="image.png"></li><li>每个时钟周期内可<strong>并发多条独立指令</strong></li><li>并不影响流水线功能段的处理时间</li><li>需要<strong>多个功能部件</strong>（如 2 个 ALU、2 个 Load/Store 单元），用 “硬件资源” 换 “指令吞吐量”</li><li>不能调整指令的<strong>执行顺序</strong>：【注意，乱序发射时硬件会调整指令顺序，优先执行无依赖的指令（比如<code>add</code>和<code>sub</code>不冲突，就同时执行）】</li><li><strong>编译优化辅助</strong>：编译器把 “可能并行的指令” 排在一起，降低硬件调度压力</li></ul><h4 id="超长指令字技术">超长指令字技术</h4><ul><li><strong>定义</strong>：<font color="#c00000">编译阶段</font>把 “多条能并行的指令” 打包成<strong>一条超长指令</strong>（比如包含<code>add</code>、<code>sub</code>、<code>load</code>三个操作），硬件只需按指令顺序执行这些子操作，也称<strong>静态多发射技术</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502161143.png" alt="image.png"></li><li>需要<strong>多个处理部件</strong></li></ul><h4 id="超流水线技术">超流水线技术</h4><ul><li><strong>定义</strong>：把<strong>原有流水线的每个阶段再细分</strong>（比如把 EX 阶段拆成 EX1、EX2），让时钟周期更短，指令 “流动更快”。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502161507.png" alt="image.png"></li><li>在<strong>一个时钟周期</strong>内<strong>再分段</strong>（3段）</li><li>在一个时钟周期内<strong>一个功能部件使用多次</strong>（3次）</li><li><strong>不能调整</strong>指令的<strong>执行顺序</strong></li><li>图中流水线速度时原来速度的3倍</li><li>靠编译程序解决优化问题</li><li>流水线功能段越多，时钟周期越短，<strong>指令吞吐率越高</strong></li><li>通过<strong>提高流水线主频</strong>的方式来提升流水线性能的</li><li>流水线级数越多，用于<strong>流水线寄存器的开销越大</strong></li></ul><p><strong>高级流水线技术</strong> 分为 <strong>超流水线技术</strong> 和 <strong>多发射流水线</strong>，核心是突破 “单周期 1 条指令” 的限制，降低 CPI（或提高 IPC）。</p><ul><li><strong>超流水线</strong>技术<ul><li><strong>核心</strong>：将流水线 <strong>细分为更多阶段</strong>（如 5 段拆为 10 段），压缩单阶段执行时间。</li><li><strong>效果</strong>：每个时钟周期可启动 <strong>多条指令</strong>（通过高频阶段切换提升吞吐），使 <strong>CPI 趋近于 1 甚至更低</strong></li></ul></li><li><strong>多发射流水线</strong><ul><li><strong>核心</strong>：<strong>同时发射多条指令</strong>，并行进入多条子流水线执行（硬件需多个独立执行部件）。</li><li><strong>分类</strong><ul><li><strong>静态多发射</strong><ul><li>调度方式：<strong>编译器静态调度</strong>【注：若认为 “静态多发射无需硬件要求” 则错误。因其属于多发射流水线，前提是硬件需配备多个独立执行部件以支持指令并行执行。】</li><li>依赖条件：软件提前打包多操作指令</li><li>代表 / 特点：<strong>超长指令字</strong>（VLIW）处理器</li></ul></li><li><strong>动态多发射</strong><ul><li>调度方式：<strong>硬件动态调度</strong></li><li>依赖条件：支持<strong>乱序</strong>执行、<strong>寄存器重命名</strong></li><li>代表 / 特点：<strong>超标量处理器</strong>（如 x86 架构）</li><li>细分类型<ul><li>按序发射・按序完成<ul><li>调度方式：发射和完成顺序均严格</li><li>依赖条件：调度简单，并行度低</li><li>代表 / 特点：早期实验架构</li></ul></li><li>按序发射・无序完成<ul><li>调度方式：发射顺序不变，完成乱序</li><li>依赖条件：平衡复杂度与并行度</li><li>代表 / 特点：主流超标量处理器（如 Intel Core）</li></ul></li><li>无序发射・无序完成<ul><li>调度方式：发射和完成均乱序</li><li>依赖条件：硬件最复杂，并行度最高</li><li>代表 / 特点：高端服务器 CPU（如 AMD Zen）</li></ul></li></ul></li></ul></li></ul></li><li>因多指令并行，<strong>CPI 可 &lt; 1</strong>（如 1 周期执行 2 条指令，CPI=0.5），故定义 <strong>IPC（Instructions Per Cycle，即 1/CPI）</strong> 衡量并行效率。</li></ul></li></ul><table><thead><tr><th>技术类型</th><th>核心思想</th><th>发射方式</th><th>并行性来源</th><th>硬件复杂度</th><th>性能提升关键</th><th>类比场景</th></tr></thead><tbody><tr><td><strong>超标量</strong></td><td>同一周期发多条独立指令</td><td>动态发射</td><td>硬件动态调度</td><td>高（多部件）</td><td>空间换时间（多 ALU 等）</td><td>双开生产线，同时做 2 种产品</td></tr><tr><td><strong>超长指令字</strong></td><td>编译时打包并行指令</td><td>静态发射</td><td>编译器静态分析</td><td>低（硬件简单）</td><td>编译优化能力</td><td>菜谱写清 “同时切菜 + 洗菜 + 备料”</td></tr><tr><td><strong>超流水线</strong></td><td>细分阶段，提高主频</td><td>单指令发射</td><td>时间并行（更细粒度）</td><td>中（寄存器多）</td><td>缩短时钟周期</td><td>把工序拆细，加快生产节奏</td></tr></tbody></table><h3 id="五段式指令流水线">五段式指令流水线</h3><p>在理想状态下，每个阶段耗时一个时钟周期，意味着每经过一个时钟周期，处理器就能执行一条新指令。然而实际情况中，数据相关性、分支预测错误等问题会影响流水线性能。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250822194529418.png" alt="image.png"></p><table><thead><tr><th>指令类型</th><th>IF（取指）</th><th>ID（译码）</th><th>EX（执行）</th><th>MEM（访存）</th><th>WB（写回）</th></tr></thead><tbody><tr><td>运算类（如 add）</td><td>取指令至锁存器</td><td>解析操作，读源寄存器</td><td>ALU 执行运算，存结果</td><td>空闲</td><td>结果写回目标寄存器</td></tr><tr><td>LOAD（读内存）</td><td>取指令至锁存器</td><td>解析 LOAD，算有效地址（EA）</td><td>补算 EA</td><td>按 EA 读内存，存数据</td><td>数据写回目标寄存器</td></tr><tr><td>STORE（写内存）</td><td>取指令至锁存器</td><td>解析 STORE，读数据 / 地址寄存器</td><td>算 EA，存待写数据</td><td>按 EA 写内存</td><td>空闲（或更状态）</td></tr><tr><td>条件转移</td><td>取指令至锁存器</td><td>解析分支，读判据寄存器</td><td>判分支条件，算目标 PC</td><td>写目标 PC 到程序计数器</td><td>空闲</td></tr><tr><td>无条件转移</td><td>取指令至锁存器</td><td>解析转移，读目标地址</td><td>算目标 PC，写回程序计数器</td><td>空闲</td><td>空闲</td></tr><tr><td>eg.</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>load Rd,996(Rs)</code>          功能：((Rs)+996)→Rd   ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>store Rs,996(Rd)</code>        功能：Rs→((Rd)+996)   ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm。将要存的数放到B</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>beq Rs, Rt, #偏移量</code>    若(Rs) == (Rt)，则 PC = PC + 指令字长 + 偏移量×指令字长（跳转）；否则 PC = PC + 指令字长（顺序执行）。</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>bne Rs, Rt, #偏移量</code>     若(Rs) != (Rt)，则PC = PC + 指令字长 + 偏移量×指令字长（跳转）；否则 PC = PC + 指令字长（顺序执行）。</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>jmp #偏移量</code>                     功能：(PC)+指令字长+(偏移量x指令字长)→PC</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>eg.</p><ul><li><strong>流水线规则</strong>：按序发射、按序完成，无转发技术，<strong>同一寄存器的读、写不能同时钟周期</strong></li><li><strong>指令序列</strong>：<ul><li><code>I1: LOAD R1, [a]</code>（读内存→写 R1）</li><li><code>I2: LOAD R2, [b]</code>（读内存→写 R2）</li><li><code>I3: ADD R1, R2</code>（读 R1、R2→算和→写 R1）</li><li><code>I4: STORE R2, [x]</code>（读 R2→写内存）</li></ul></li></ul><p>I3 的 ID 段阻塞原因：因为I3与I1和I2都存在数据相关，需等到I1和I2将结果写回寄存器后，I3才能读寄存器内容，所以I3的ID段被阻塞。<br>I4 的 IF 段阻塞原因：I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容</p><h2 id="多处理器的基本概念">多处理器的基本概念</h2><h3 id="SISD、SIMD、SIMD、MIMD-的基本概念">SISD、SIMD、SIMD、MIMD 的基本概念</h3><ul><li>基于<strong>指令流的数量和数据流的数量</strong>，将计算机体系结构分为 SISD，SIMD，MISD 和 MIMD</li><li>常规的<strong>单处理机</strong>属于 <strong>SSID</strong>，常规的<strong>多处理机</strong>属于 <strong>MIMD</strong></li></ul><h4 id="单指令流单数据流结构-SISD">单指令流单数据流结构 (SISD)</h4><ul><li><strong>串行</strong>计算机结构</li><li>通常<strong>只包含一个处理器和一个存储器</strong></li><li>有些使用<strong>流水线</strong>的方式，所以有时会设置多个功能部件，并采用多模块交叉方式组织存储器</li><li><strong>通俗理解</strong>：就像家里炒菜的「单个厨师」—— 先洗锅（1 步）、再倒油（2 步）、再炒鸡蛋（3 步），一步一步按顺序来，全程只炒「一盘菜」。</li></ul><h4 id="单指令流多数据流结构（SIMD）">单指令流多数据流结构（SIMD）</h4><ul><li>一个指令流<strong>同时对多个数据流进行处理</strong>，称为<strong>数据级并行技术</strong></li><li>由<strong>一个指令控制部件、多个处理单元组成</strong></li><li>每个处理单元虽然执行的都是同一条指令, 但每个单元都有自己的地址寄存器，就有了不同的数据地址</li><li>一个顺序应用程序被编译之后, 可能按照 SISD 组织并运行于串行硬件上，也可能按 SIMD 组织并运行于并行硬件上</li><li><strong>for 循环效率高</strong>，但 switch 或 case 时效率低</li><li><strong>向量处理器</strong>也是 SIMD 的变体，是一种实现了直接操作一维数组（向量）指令集的 CPU<br>分<strong>向量流水处理机</strong>和<strong>阵列处理机</strong>两类</li><li><strong>通俗理解</strong>：烤面包时，一个烤箱按 “180 度烤 10 分钟” 的同一步骤，同时烤 12 个面包。</li></ul><h4 id="多指令流单数据流结构（MISD）">多指令流单数据流结构（MISD）</h4><ul><li>同时执行多条指令，处理同一个数据</li><li>实际上不存在这样的计算机</li><li><strong>通俗理解</strong>：就像「五个厨师围着一盘菜干活」—— 一个厨师切菜、一个厨师加盐、一个厨师翻炒、一个厨师调火、一个厨师准备盛盘，同时对这一盘菜做不同步骤。但这根本不现实：菜还没切，怎么翻炒？盐还没加，怎么盛盘？</li></ul><h4 id="多指令流多数据流结构（MIMD）">多指令流多数据流结构（MIMD）</h4><ul><li><strong>同时执行多条指令，处理多个不同的数据</strong></li><li>分为多计算机系统和多处理器系统<ul><li><strong>多计算机系统</strong>：<ul><li>每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间</li><li>不能通过存取指令来访问不同节点的私有存储器</li><li>而要通过消息传递进行数据传送，也称为<strong>消息传递 MIMD</strong></li><li><strong>通俗理解</strong>：相当于每个厨师有自己的食材柜，要传数据得靠 “发消息”（比如厨师 A 要借酱油，得打电话让厨师 B 送过来）</li></ul></li><li><strong>多处理器系统</strong>：<ul><li>共享存储多处理器（SMP）系统的简称</li><li>它具有共享的单一地址空间，通过访存指令来访问系统中的所有存储器，也称<strong>共享存储 MIMD</strong></li><li><strong>通俗理解</strong>：相当于所有厨师共用一个食材架，要数据直接拿（不用发消息，效率更高）。</li></ul></li></ul></li><li><strong>通俗理解</strong>：就像「餐厅里的多个厨师各做各的」—— 厨师 A 按 “炒番茄炒蛋” 的步骤（指令）处理鸡蛋和番茄（数据），厨师 B 按 “炖红烧肉” 的步骤（指令）处理五花肉（数据），厨师 C 按 “做沙拉” 的步骤（指令）处理蔬菜（数据），大家同时干活，互不干扰。</li></ul><h4 id="联系与区别">联系与区别</h4><ul><li><strong>SISD</strong>：一个人干一件事，按步骤来<ul><li><strong>1个处理机+1个主存储器</strong></li><li>各指令序列只能并发，<strong>不能并行</strong>，每条指令处理一两个数据</li><li>不是 数据集并行技术</li><li>若采用指令流水线，需设置多个功能部件，采用多模块交叉存储</li><li>eg.标量流水线处理机</li></ul></li><li><strong>SIMD</strong>：一个步骤干多件相同的事，批量高效<ul><li><strong>1个指令控制部件（CU）+多个处理单元/执行单元（如ALU）+多个局部存储器+1个主存储器</strong></li><li>各指令序列只能并发，<strong>不能并行</strong>，但每条指令可同时处理多个具有<strong>相同特征的</strong>数据</li><li><strong>数据级并行</strong></li><li>每个执行单元有各自的寄存器组、局部存储器、地址寄存器</li><li>不同执行单元执行同一条指令，处理不同的数据</li><li>eg.并行处理机、阵列处理机、向量处理机</li></ul></li><li><strong>MISD</strong>：多条指令并行处理同一个数据。实际不存在</li><li><strong>MIMD</strong>：多个人干多件不同的事，并行度最高，现在的多任务电脑全靠它<ul><li>指令 + 数据都并行</li><li>按<strong>地址空间的访问方式</strong>划分<ul><li><strong>多处理机</strong>：有<strong>共享</strong>的单一地址空间<ul><li>各处理器之间，可以通过LOAD/STORE指令，访问同一个主存储器，可通过主存相互传送数据</li><li>一台计算机内，包含<strong>多个处理器+1个主存储器</strong></li><li>多个处理器<strong>共享</strong>单一的物理地址空间</li></ul></li><li><strong>多计算机</strong>：有多个私有地址空间<ul><li>各计算机之间，不能通过LOAD/STORE指令直接访问对方的存储器，只能通过“<strong>消息传递</strong>”相互传送数据</li><li>由多台计算机组成，因此拥有<strong>多个处理器+多个主存储器</strong></li><li>每台计算机拥有各自的私有存储器，物理地址空间相互独立</li></ul></li></ul></li><li>按<strong>存储访问时间是否一致</strong>划分<ul><li><strong>一致性</strong>内存访问 (UMA) 结构：处理器对所有存储单元的访问时间一致</li><li><strong>非一致性</strong>内存访问 (NUMA) 结构：处理器对不同的存储单元的访问时间可能不一致</li></ul></li><li>按<strong>处理单元的位置及其互联方式</strong>划分<ul><li><strong>多核芯片</strong>：在一个 CPU 芯片中包含多个处理单元，称为<strong>片级多处理器</strong></li><li><strong>对称多处理器</strong>：指将多个相同类型的 CPU 通过总线互连，属于 <strong>UMA 结构多处理器</strong></li></ul></li><li><strong>硬件多线程</strong>：在线程阻塞时处理器可切换到另一线程的实现</li></ul></li><li><strong>向量处理机</strong>（<strong>SIMD思想的进阶应用</strong>）<ul><li>一条指令的处理对象是“向量”</li><li>擅长对<strong>向量型数据并行计算、浮点数运算</strong>，常被用于<strong>超级计算机</strong>中，处理科学研究中巨大运算量</li><li><strong>多个处理单元+多组“向量寄存器&quot;</strong></li><li>主存储器应采用“多个端口同时读取”的交叉多模块存储器</li><li><strong>主存储器大小</strong>限定了机器的解题规模，因此要有大容量的、集中式的主存储器</li></ul></li></ul><h3 id="多核处理器">多核处理器</h3><ul><li><p>将<strong>多个处理单元集成到单个 CPU</strong> 中，每个处理单元称为一个<strong>核（core）</strong></p></li><li><p><strong>多核处理机 = 多处理机系统 = 共享内存多处理机</strong></p></li><li><p>多个处理器共享一个主存储器</p></li><li><p>多个处理器共享单一的地址空间，都可以通过LOAD、STORE指令访问共享的主存储器</p></li><li><p>每个核可以<strong>有自己的 Cache，也可以共享一个 Cache</strong></p></li><li><p>所有核一般都是对称的，并且共享主存，因此<strong>多核属于共享存储的对称多处理器</strong></p></li><li><p>在多核计算机系统中，若要充分发挥硬件的性能，必须采用<strong>多线程执行</strong>，使每个核在<strong>同一时刻都有线程在执行</strong>，这是真正的并行执行</p></li><li><p><strong>通俗理解</strong>：以前 CPU 是 “一个厨房一个厨师”（单核），现在是 “一个厨房塞多个厨师”（多核）—— 比如 4 核 CPU 就是 4 个厨师挤在同一个 CPU 里，每个厨师（核）都能独立干活。</p></li><li><p><strong>关键细节</strong>：</p><ol><li><strong>每个厨师有 “专属小食材柜”</strong>：每个核可以有自己的 Cache（高速缓存，像厨师手边的小抽屉，放常用的盐、油），也能和其他厨师共用一个 “大食材柜”（共享 Cache，比如厨房中间的调料台）。</li><li><strong>所有厨师共用 “大仓库”</strong>：不管有多少核，都共享电脑的主存（相当于餐厅的食材仓库），要拿不常用的食材（比如面粉），都去同一个仓库取。</li><li><strong>必须 “多线程” 才不浪费</strong>：要是只让一个厨师忙（单线程，比如只开一个游戏），其他厨师闲着，多核就白买了！得让每个厨师都有活干（多线程，比如同时开游戏、微信、浏览器），才能真正 “并行干活”（比如厨师 A 炒游戏的 “数据菜”，厨师 B 切微信的 “消息菜”）。</li></ol></li></ul><h3 id="共享内存处理器（SMP）">共享内存处理器（SMP）</h3><ul><li><strong>定义</strong>：具有共享的<strong>单一物理地址空间</strong>的多处理器</li><li>处理器通过存储器中的共享变量相互通信，所有处理器都能通过存取指令访存任何存储器的位置</li><li>即使这些系统共享同一个物理地址空间，它们仍然可以在自己的虚拟地址空间中单独地运行程序</li><li><strong>通俗理解</strong>：不管有多少个处理器（厨师），大家都用 “同一个物理地址的食材架”（共享主存）—— 比如 3 个处理器要拿 “番茄”，不用问对方 “你家番茄在哪”，直接去 “主存第 123 号位置” 拿，地址都一样。</li><li><strong>怎么干活</strong>：厨师们靠 “共享食材架上的纸条”（共享变量）沟通 —— 比如厨师 A 炒完菜，在食材架贴张纸条 “红烧肉好了”，厨师 B 看到纸条就知道 “该盛盘了”，不用喊来喊去。</li><li>单一地址空间的多处理器分类<ul><li><strong>统一存储访问（UMA）多处理器</strong>：<ul><li>根据处理器与共享存储器之间的连接方式分为基于<strong>总线</strong>、基于<strong>交叉开关网络</strong>和基于<strong>多级交换网络</strong>连不管有多少个处理器（厨师），大家都用 “同一个物理地址的食材架”（共享主存）—— 比如 3 个处理器要拿 “番茄”，不用问对方 “你家番茄在哪”，直接去 “主存第 123 号位置” 拿，地址都一样。接等几种处理器</li><li>每个处理器对所有存储单元的<strong>访问时间都是大致相同</strong>的</li><li><strong>通俗理解</strong>：厨房中间放一个超大食材架，不管厨师 A 站左边、厨师 B 站右边，伸手拿食材的时间都差不多（比如都要 1 秒）。</li></ul></li><li><strong>非统一存储访问（NUMA）多处理器</strong>：<ul><li>某些存储器的访存速度较快，具体取决于哪个处理器退出访问请求及访问哪个字【由于主存被分割给了不同的处理器】<ul><li><strong>通俗理解</strong>：厨房被分成 3 块区域，每个厨师旁边都有一个 “小食材架”（本地内存），厨师 A 拿自己旁边的鸡蛋只要 0.5 秒；但要拿厨师 B 旁边的牛肉，得走过去，要 2 秒 —— 访存速度取决于 “哪个厨师去拿” 和 “拿哪个区域的食材”。</li></ul></li><li>处理器中<strong>不带高速缓存</strong>时，被称为 <strong>NC-NUMA</strong><ul><li><strong>通俗理解</strong>：厨师没带 “随身小抽屉”（没有 Cache），要拿食材必须去区域小食材架或大仓库，慢得很。</li></ul></li><li>处理器中带有<strong>一致性高速缓存</strong>时，被称为 <strong>CC-NUMA</strong>（某些访问请求要比其他的快）<ul><li><strong>通俗理解</strong>：厨师带了 “随身小抽屉”（有 Cache），常用的食材放抽屉里，不用总跑大仓库；而且抽屉里的食材和其他厨师的抽屉 “同步”（比如厨师 A 抽屉里的盐用完了，会自动从大仓库补，不会和厨师 B 的盐不一样），所以大部分时候拿食材都快。</li></ul></li></ul></li></ul></li></ul><h3 id="硬件多线程">硬件多线程</h3><ul><li>引入硬件多线程的<strong>目的</strong>：<strong>为了减少开销</strong></li><li>硬件多线程中必须为<strong>每个线程提供单独的通用寄存器组、单独的程序计数器</strong>等</li><li>线程的激活只<strong>需要激活选中的寄存器</strong>，从而省略了与存储器数据交换的环节，节省了开销</li><li><strong>通俗理解</strong>：硬件多线程让 <strong>CPU 同时 “假装” 运行多个线程</strong>（比如游戏、微信、浏览器同时跑），但 CPU 物理核心有限。为了让 CPU 不闲着，给每个线程配独立 “工具包”（通用寄存器、程序计数器），切换时只需 “换工具包”，不用把数据存到内存（省时间）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502171515.png" alt="image.png"></li></ul><h4 id="细粒度多线程">细粒度多线程</h4><ul><li>多个线程之间<strong>轮流交叉执行指令</strong>，多个线程之间的指令是互不相关的</li><li>可以<strong>乱序并行</strong>执行</li><li>该方式下，处理器能在每个时钟周期切换线程</li><li>实现<strong>指令级并行</strong></li><li><strong>通俗理解</strong>：厨房（CPU）里，厨师 A 炒 1 分钟菜，立刻换厨师 B 炒 1 分钟，再换厨师 C… 哪怕 A 的菜还没炒完，也强行换班</li><li><strong>核心特点</strong>：<ul><li><strong>切换频率高</strong>：每个时钟周期（比如 1 纳秒）就换线程，像 “轮班制”；</li><li><strong>切换代价低</strong>：只需要换 “工具包”（寄存器），不用清理灶台（流水线）；</li><li><strong>指令执行</strong>：多个线程的指令<strong>轮流交叉执行</strong>（示例图 a：i 周期跑 A，i+1 跑 B，i+2 又跑 A），让 CPU 一直忙。</li></ul></li></ul><h4 id="粗粒度多线程">粗粒度多线程</h4><ul><li><p><strong>连续几个时钟周期</strong>都执行<strong>同一线程</strong>的指令序列</p></li><li><p>仅在<strong>一个线程出现较大开销的阻塞</strong>时，才切换线程；如 Cache 缺失</p></li><li><p>当发生流水线阻塞的时候，必须清除被阻塞的流水线</p></li><li><p>新线程的指令开始执行前需要重载流水线，<strong>开销较上一种较大</strong></p></li><li><p>实现<strong>指令级并行</strong></p></li><li><p><strong>通俗理解</strong>：：厨师 A 在厨房炒红烧肉，突然发现没酱油了（Cache 缺失，大阻塞），才让厨师 B 进来炒青菜。换班时得把 A 的锅碗瓢盆全清走（重载流水线），特别麻烦，所以尽量不换。</p></li><li><p><strong>核心特点</strong>：</p><ul><li><strong>切换频率低</strong>：只有线程<strong>卡壳（如 Cache miss、长延迟操作）</strong> 时才换；</li><li><strong>切换代价高</strong>：要清空流水线、重新加载新线程的指令，像 “大扫除后再开工”；</li><li><strong>指令执行</strong>：同一线程连续跑多个周期（示例图 b：A 跑 i、i+1 周期，直到 i+1 发现 Cache miss 才换 B）。</li></ul></li></ul><h4 id="同时多线程（SMT）">同时多线程（SMT）</h4><ul><li><p>又叫做<strong>超线程技术 HT</strong></p></li><li><p>在实现指令级并行的同时，实现<strong>线程级并行</strong></p></li><li><p><strong>通俗理解</strong>：：厨房有两个灶台、两个炒锅、两个切菜板… 厨师 A 用灶台 1 炒鸡蛋，同时厨师 B 用灶台 2 煎牛排，甚至厨师 C 还能用电饭煲焖饭，<strong>同一时间多个线程一起干活</strong></p></li><li><p><strong>核心特点</strong>：</p><ul><li><strong>并行发射</strong>：同一时钟周期内，<strong>多个线程的指令同时发射</strong>（示例图 c：i 周期，A 的 j、j+1 和 B 的 k、k+1 同时执行）；</li><li><strong>硬件利用满</strong>：CPU 里的多个功能部件（如 ALU、乘法器）被不同线程同时占用，既让单个线程内的指令并行（指令级并行），又让多个线程同时跑（线程级并行）；</li><li><strong>切换？不需要</strong>：因为本来就同时跑，不用切换，直接 “边等边干”。</li></ul></li></ul><table><thead><tr><th><strong>硬件多线程维度</strong></th><th>细粒度多线程</th><th>粗粒度多线程</th><th>同时多线程（SMT）</th></tr></thead><tbody><tr><td>指令发射</td><td>轮流发射各线程指令（每时钟周期发射一个线程）</td><td>连续多周期发射同一线程指令，流水线阻塞时切换线程</td><td>单时钟周期内同时发射多线程指令</td></tr><tr><td>线程切换频率</td><td>每时钟周期切换一次</td><td>仅流水线阻塞时切换</td><td>NULL</td></tr><tr><td>线程切换代价</td><td>低</td><td>高（需重载流水线）</td><td>NULL</td></tr><tr><td>并行性</td><td><strong>指令级并行</strong>，线程间不并行</td><td><strong>指令级并行</strong>，线程间不并行</td><td><strong>指令级 + 线程级并行</strong></td></tr></tbody></table><ul><li>细粒度：<strong>高频轮班，不让 CPU 闲</strong>；</li><li>粗粒度：<strong>卡壳才换，换一次超麻烦</strong>；</li><li>SMT同时多线程/超线程技术：<strong>多线程同干，硬件榨干性能</strong>。</li><li>它们的物理资源（ALU、Cache、访存端口）<strong>共享</strong>（多线程同时占用）；每个线程的通用寄存器组、PC<strong>独立</strong></li><li>都属于单个物理CPU</li><li>补充：双核CPU：在<strong>同一块 CPU 芯片中，集成两个独立的 “处理核心（物理核）”</strong>。每个核心都像一个迷你 CPU，能独立执行指令、运算数据，相当于 “把两个 CPU 打包进一个芯片里”。<br>特点：并行干活；共享物理内存；每个核心有自己的<strong>寄存器组、程序计数器（PC）、L1 Cache</strong>；缓存一致性</li></ul><table><thead><tr><th>对比项</th><th>双核 CPU（物理双核）</th><th>超线程（SMT，逻辑双核）</th></tr></thead><tbody><tr><td>本质</td><td>真・两个物理核心</td><td>一个物理核心<strong>模拟</strong>两个逻辑核心</td></tr><tr><td>资源独立性</td><td>每个核心独立 ALU、寄存器等</td><td>共享物理核心的 ALU、Cache 等资源</td></tr><tr><td>多任务冲突</td><td>物理核独立，冲突少</td><td>逻辑核共享资源，高负载时易 “抢资源”</td></tr></tbody></table><h2 id="错题">错题</h2><ol><li><p><strong>条件转移指令执行时所依据的条件来自()<br>A.指令寄存器   B.标志寄存器   C.程序计数器   D.地址寄存器</strong><br>B</p></li><li><p><strong>指令（ ）从主存储器中读出。<br>A. 总是根据程序计数器<br>B. 有时根据程序计数器，有时根据转移指令<br>C. 根据地址寄存器<br>D. 有时根据程序计数器，有时根据地址寄存器</strong><br>程序计数器（PC）的作用是存放下一条要执行指令在主存中的地址 。在指令执行过程中，正常顺序执行时，PC 自动递增指向下一条指令地址；遇到转移类指令（如跳转指令）时，会将转移目标地址送入 PC 。但不管哪种情况，最终都是依据 PC 中存储的地址从主存储器中读出指令，所以指令总是根据程序计数器从主存储器中读出，A 正确<br>地址寄存器主要用于在数据传输过程中暂存地址，和指令从主存读出的依据关系不大 。</p></li><li><p><strong>程序计数器（PC）可以使用字节地址或字地址，其位数取决于（ ）。 I. 存储器的容量 II. 机器字长 III. 指令字长 A. I B. I 和 III C. II 和 III D. I、II 和 III</strong><br>当 PC 使用字节地址时，其位数取决于存储器的容量，因为要能表示存储器中所有字节单元的地址；当使用字地址时，指令需按边界对齐存放，PC 位数 = 存储器地址的位数 - log2(指令字长的字节数)，所以和指令字长有关。而机器字长与 PC 位数并无直接决定关系 。所以 PC 位数取决于存储器的容量和指令字长，选 B。</p></li><li><p><strong>下列关于程序计数器（PC）的叙述中，错误的是（ ）。<br>A. 机器指令中不能显式地使用 PC<br>B. 指令顺序执行时，PC 值总是自动加 1<br>C. 调用指令执行后，PC 值一定是被调用过程的入口地址<br>D. 无条件转移指令执行后，PC 值一定是转移目标地址</strong><br><strong>A 选项</strong>：机器指令中一般不会直接显式使用 PC，该选项正确。<br><strong>B 选项</strong>：指令顺序执行时，PC 值加的不一定是 1。若指令按字节编址，且指令长度为n字节，那么 PC 要加n；若按字编址，PC 增量也不是简单加 1 ，所以该选项错误。<br><strong>C 选项</strong>：调用指令执行后，通常会将被调用过程的入口地址送入 PC，使程序转向被调用过程执行，该选项正确。<br><strong>D 选项</strong>：无条件转移指令执行后，会将转移目标地址送入 PC，从而使程序跳转到目标地址执行，该选项正确。</p></li><li><p><strong>指令译码是指对()进行译码<br>A.整条指令   B.指令的操作码字段   C.指令的地址码字段   D.指令的地址</strong><br>B</p></li><li><p><strong>间址周期结束后，CPU内寄存器 MDR中的内容为()<br>A.指令   B.操作数地址   C.操作数   D.无法确定</strong><br>B   间址周期是为了获取操作数的有效地址。在间接寻址方式中，指令中的地址字段给出的是操作数地址的地址 ，需要通过访存来得到真正的操作数地址。</p></li><li><p><strong>某计算机的主存储器空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是（ ）<br>A. 30, 30 B. 30, 32 C. 32, 30 D. 32, 32</strong><br>主存容量 4GB，按字节编址，4GB=2^32字节，地址空间为2^32个字节单元。但指令按字边界对齐存放，指令字长 32 位即 4 字节，所以地址只需表示到字单元，字单元数量为2^32÷4=2^30 ，因此 PC 宽度至少 30 位。IR位数等于指令字长。选B</p></li><li><p><strong>下列关于指令执行的叙述中，错误的是（ ）。<br>A. 指令周期的第一个操作是取指令<br>B. 为了进行取指操作，控制器需要得到相应的指令<br>C. 取指操作是控制器自动进行的<br>D. 指令执行时有些操作是相同或相似的</strong><br>控制器是依据程序计数器（PC）提供的地址去取指令，而不是先得到相应指令才进行取指操作，逻辑错误，B错误。</p></li><li><p><strong>下列关于 CPU 时钟信号的叙述中，错误的是（ ）。<br>A. 处理器总是每来一个时钟信号就开始执行一条新的指令<br>B. 边沿触发指状态单元总在时钟上升沿或下降沿开始改变状态<br>C. 时钟周期以相邻状态单元之间最长组合逻辑延迟为基准确定<br>D. 每个时钟周期称为一个节拍，机器的主频就是时钟周期的倒数</strong><br>A 选项：处理器执行指令的过程包括取指、译码、执行等阶段，并不是每来一个时钟信号就开始执行一条新指令，一条指令的执行可能跨越多个时钟周期，该选项错误。<br>B 选项：边沿触发的状态单元确实在时钟上升沿或下降沿改变状态，该选项正确。<br>C 选项：为保证电路正常工作，时钟周期要以相邻状态单元之间最长组合逻辑延迟为基准确定，该选项正确。<br>D 选项：时钟周期也叫节拍，主频是时钟周期的倒数，该选项正确。</p></li><li><p><strong>下列关于多周期 CPU 的说法中，合理的是（ ）。<br>A. 执行各条指令的时钟周期数相同，各时钟周期的长度均匀<br>B. 执行各条指令的时钟周期数相同，各时钟周期的长度可变<br>C. 执行各条指令的时钟周期数可变，各时钟周期的长度均匀<br>D. 执行各条指令的时钟周期数可变，各时钟周期的长度可变</strong><br>多周期 CPU 把指令的执行分为多个阶段来实现，每个阶段在一个时钟周期内完成，时钟周期以最复杂的阶段所花的时间为准，阶段的划分原则是：将一条指令的执行过程尽量分成大致相等的若干阶段。不同的指令(根据指令的复杂程度)所含的时钟周期数可以不同。</p></li><li><p><strong>下列有关数据通路的叙述中，错误的是（ ）。<br>A. 数据通路由若干组合逻辑元件和时序逻辑元件连接而成<br>B. 数据通路的功能由控制部件送出的控制信号决定<br>C. ALU 属于操作元件，包含在数据通路中<br>D. 通用寄存器属于状态元件，但不包含在数据通路中<br>A 选项</strong>：数据通路是由组合逻辑元件（如 ALU 等）和时序逻辑元件（如寄存器等）连接组成的，用于实现数据的传输和处理，该选项正确。<br><strong>B 选项</strong>：控制部件发出的控制信号决定数据通路中各个部件的操作和数据流动方向等，从而决定数据通路的功能，该选项正确。<br><strong>C 选项</strong>：算术逻辑单元（ALU）用于进行算术和逻辑运算，是数据通路中的操作元件，该选项正确。<br><strong>D 选项</strong>：通用寄存器用于暂存数据，是状态元件，并且包含在数据通路中，用于数据的暂存和传输等操作，该选项错误。</p></li><li><p><strong>数据通路是由操作元件和状态元件通过总线或分散方式连接而成的进行数据存储、处理和传送的路径，下列部件中属于状态元件的是（ ）。</strong><br><strong>I. 算术逻辑部件 II. 译码器 III. 移位寄存器 IV. 存储器数据寄存器</strong><br><strong>A. I、III B. II、III、V C. III、IV D. I、IV</strong><br><strong>状态元件特点</strong>：状态元件用于存储数据，具有记忆功能，能够保存当前的状态信息 。<br><strong>I. 算术逻辑部件（ALU）</strong>：主要功能是进行算术运算和逻辑运算，属于操作元件，用于对数据进行处理，而非存储数据，所以 I 不属于状态元件。<br><strong>II. 译码器</strong>：功能是对输入的代码进行翻译，得到对应的控制信号或操作信号，属于操作元件，不是用于存储数据的，所以 II 不属于状态元件。<br><strong>III. 移位寄存器</strong>：可以存储数据，并且能够对存储的数据进行移位操作，具有存储数据的功能，属于状态元件。<br><strong>IV. 存储器数据寄存器（MDR）</strong> ：用于暂存从存储器中读出的数据或者准备写入存储器的数据，起到数据存储的作用，属于状态元件。</p></li><li><p><strong>下列关于采用单总线方式的 CPU 的说法中，正确的是（ ）。</strong><br><strong>A. ALU 的两个输入端及输出端都可与总线相连</strong><br><strong>B. ALU 的两个输入端可以与总线相连，但输出端需通过暂存器与总线相连</strong><br><strong>C. ALU 的一个输入端可以与总线相连，其输出端也可与总线相连</strong><br><strong>D. ALU 只能有一个输入端可以与总线相连，另一输入端需通过暂存器与总线相连</strong><br>在单总线结构的 CPU 中，为避免数据冲突，同一时刻总线上只能有一路数据传输。ALU 进行运算时，若两个输入端都直接连总线，会导致数据冲突。通常一个输入端与总线相连获取数据，另一个输入端通过暂存器获取经总线暂存的数据 ，所以 D 正确</p></li><li><p><strong>CPU 内部若多个部件共享一条总线，则每个部件与总线之间需设置一个常用的器件，CPU 控制该器件的状态，实现某个部件与总线的连接或断开。该器件是（ ）。</strong><br><strong>A. 触发器</strong><br><strong>B. 多路选择器</strong><br><strong>C. 三态门</strong><br><strong>D. 与非门</strong><br>C。三态门可视为一种控制开关，由控制端决定信号线的通断，能输出到内部总线的部件均通过个三态门与内部总线相连，用于控制该部件与内部总线之问数据通路的连接与断开。</p></li><li><p><strong>CPU 内部电路通常采用总线连接方式，总线上信号流动的原则是（ ）。</strong><br><strong>I. 每个时刻只有一个器件发送信息</strong><br><strong>II. 每个时刻有一个或多个器件发出信息</strong><br><strong>III. 每个时刻只有一个器件接收信息</strong><br><strong>IV. 每个时刻有一个或多个器件接收信息</strong><br><strong>A. I、III</strong><br><strong>B. I、IV</strong><br><strong>C. II、III</strong><br><strong>D. II、IV</strong><br>在单总线结构中，同一时刻只能有一个器件向总线发送信息，否则信号会冲突；但可以有一个或多个器件接收总线上的信息 ，所以 I、IV 正确，答案为 B。</p></li><li><p><strong>下列关于单周期数据通路和多周期数据通路的说法中，正确的是（ ）。<br>A. 单周期 CPU 的 CPI 总比多周期 CPU 的 CPI 大<br>B. 单周期 CPU 的时钟周期通常比多周期 CPU 的时钟周期短<br>C. 在一条指令执行过程中，单周期 CPU 中的每个控制信号取值一直不变，而多周期 CPU 中的控制信号可能发生改变<br>D. 在一条指令执行过程中，单周期数据通路和多周期数据通路中的每个部件都可使用多次<br>A 选项</strong>：CPI（执行一条指令所需的时钟周期数），单周期 CPU 中一条指令在一个时钟周期内完成，CPI = 1 ；多周期 CPU 中一条指令由多个时钟周期完成，CPI ＞ 1 ，所以单周期 CPU 的 CPI 比多周期 CPU 的 CPI 小 ，A 错误。<br><strong>B 选项</strong>：单周期 CPU 中，时钟周期要满足最复杂指令的执行时间，通常较长；多周期 CPU 中不同指令阶段可采用不同时长时钟周期，整体时钟周期相对较短，B 错误。<br><strong>C 选项</strong>：单周期 CPU 在一个时钟周期内完成指令执行，控制信号在指令执行期间无需改变；多周期 CPU 指令分多个阶段执行，不同阶段可能需要不同控制信号，控制信号会发生改变 ，C 正确。<br><strong>D 选项</strong>：单周期数据通路中，每个部件在一个时钟周期内按固定顺序使用一次；多周期数据通路中，部件可在不同周期按需多次使用 ，D 错误。</p></li><li><p><strong>采用 CPU 内部总线的数据通路与不采用 CPU 内部总线的数据通路相比，（ ）。</strong><br><strong>A. 前者性能较高</strong><br><strong>B. 后者的数据冲突问题较严重</strong><br><strong>C. 前者的硬件量大，实现难度高</strong><br><strong>D. 以上说法都不对</strong><br>D。采用 CPU 内部总线的数据通路，结构相对简单、硬件量小，但存在数据冲突等问题，性能不一定高；不采用内部总线的数据通路，硬件量大、实现复杂，数据冲突问题相对不突出。A、B、C 说法均错误，所以选 D。</p></li><li><p><strong>【2016 统考真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是（ ）。</strong><br><strong>A. 可以采用单总线结构数据通路</strong><br><strong>B. 处理器时钟频率较低</strong><br><strong>C. 在指令执行过程中控制信号不变</strong><br><strong>D. 每条指令的 CPI 为 1</strong><br>单周期处理器中，所有指令在一个时钟周期内完成，CPI = 1 ，可采用单总线结构数据通路，指令执行过程控制信号不变。为保证最复杂指令能在一个时钟周期内完成，时钟周期较长，对应的时钟频率较高，B 说法错误。</p></li><li><p><strong>【2021 统考真题】下列关于数据通路的叙述中，错误的是（ ）。</strong><br><strong>A. 数据通路包含 ALU 等组合逻辑（操作）元件</strong><br><strong>B. 数据通路包含寄存器等时序逻辑（状态）元件</strong><br><strong>C. 数据通路不包含用于异常事件检测及响应的电路</strong><br><strong>D. 数据通路中的数据流动路径由控制信号进行控制</strong><br>数据通路包含 ALU 等组合逻辑元件、寄存器等时序逻辑元件 ，数据流动路径由控制信号控制。同时，数据通路也包含用于异常事件检测及响应的电路，C 说法错误</p></li><li><p><strong>取指令操作（ ）。</strong><br><strong>A. 受到上一条指令的操作码控制</strong><br><strong>B. 受到当前指令的操作码控制</strong><br><strong>C. 受到下一条指令的操作码控制</strong><br><strong>D. 是控制器固有的功能，不需要在操作码控制下进行</strong><br>D。取指令是控制器公共流程（如 PC 取指、更新），与指令操作码无关（操作码用于执行阶段译码），属于固有功能，无需操作码控制。</p></li><li><p><strong>在组合逻辑控制器中，微操作控制信号的形成主要与（ ）信号有关。</strong><br><strong>A. 指令操作码和地址码</strong><br><strong>B. 指令译码信号和时钟</strong><br><strong>C. 操作码和条件码</strong><br><strong>D. 状态信息和条件</strong><br>B。组合逻辑（硬布线）通过指令译码（解析操作码，生成译码信号）和时钟节拍（时序控制）生成控制信号，地址码（A）用于寻址，条件码（C、D）非核心，故 B 正确。</p></li><li><p><strong>在微程序控制器中，形成微程序入口地址的是（ ）。</strong><br><strong>A. 机器指令的地址码字段</strong><br><strong>B. 微指令的微地址码字段</strong><br><strong>C. 机器指令的操作码字段</strong><br><strong>D. 微指令的微操作码字段</strong><br>C。微程序入口由机器指令操作码（OP）映射（如<code>OP(IR)→CMAR</code>）<br>地址码（A）用于<strong>数据寻址</strong><br>微地址码（B）是微指令内的下地址，控制微程序内部跳转<br>微操作码（D）对应微命令，控制硬件操作（如激活寄存器传输、运算单元，通过编码生成控制信号）</p></li><li><p><strong>下列不属于微指令结构设计所追求目标的是（ ）。</strong><br>A. 提高微程序的执行速度<br>B. 提供微程序设计的灵活性<br>C. 缩短微指令的长度<br>D. 增大控制存储器的容量<br>D。微指令设计追求速度、灵活、短字长（减少 CM 容量），而非增大 CM 容量。</p></li><li><p><strong>下列关于微指令的说法中，错误的是（ ）。</strong><br><strong>I. 字段直接编码方式可用较少的二进制位数表示较多的微操作命令。若有两组互斥的微命令，每组微命令的个数分别为 4 和 9，则分别只需要 2 位和 4 位即可</strong><br><strong>II. 直接编码方式不用进行译码操作，微指令字段中的每一位都代表一个微命令</strong><br><strong>III. 垂直型微指令用较长的微程序结构换取较短的微指令结构，所以在执行效率和灵活性两方面都高于水平型微指令</strong><br><strong>IV. 在字段间接编码方式中，某个字段的译码输出需要依靠另外某个字段的输出</strong><br><strong>A. II</strong><br><strong>B. I、II</strong><br><strong>C. I、III</strong><br><strong>D. II、III、IV</strong></p><ul><li><strong>I 错误</strong>：字段直接编码中，4 个微命令需 3 位（含不操作，2³≥5），而非 2 位。</li><li><strong>II 正确</strong>：直接编码每位代表微命令，无需译码。</li><li><strong>III 错误</strong>：垂直型微指令执行效率（微程序长、速度慢）和灵活性（功能单一，不如水平型灵活）均低于水平型。</li><li><strong>IV 正确</strong>：字段间接编码中，字段译码依赖另一字段。</li></ul></li><li><p><strong>微程序控制存储器属于（ ）的一部分。</strong><br><strong>A. 主存</strong><br><strong>B. 外存</strong><br><strong>C. CPU</strong><br><strong>D. 缓存</strong><br>C。微程序控制存储器用于存放微程序，而微程序控制器是 CPU 的重要组成部分 ，所以微程序控制存储器属于 CPU。主存主要用于存放正在运行的程序和数据；外存用于长期存储大量数据；缓存是为了解决 CPU 和主存速度不匹配问题，用于暂存 CPU 近期可能会频繁访问的数据和指令。</p></li><li><p><strong>下列说法中，正确的是（ ）。</strong><br><strong>A. 采用微程序控制器是为了提高速度</strong><br><strong>B. 控制存储器由高速 RAM 电路组成</strong><br><strong>C. 微指令计数器决定指令执行顺序</strong><br><strong>D. 一条微指令存放在控制器的一个控制存储器单元中</strong></p><ul><li><strong>A 错</strong>：微程序控制器简化设计，非提速（硬布线更快）。</li><li><strong>B 错</strong>：控存用 ROM（非易失，固化微程序），非 RAM（易失）。</li><li><strong>C 错</strong>：μPC 控制微指令顺序（微程序内），指令顺序由 PC（机器指令）控制。</li><li><strong>D 对</strong>：控存每个单元存一条微指令，与主存单元存机器指令类似。</li></ul></li><li><p><strong>在微程序控制器中，控制部件向执行部件发出的某个控制信号称为（ ）。</strong><br><strong>A. 微程序</strong><br><strong>B. 微指令</strong><br><strong>C. 微操作</strong><br><strong>D. 微命令</strong><br>微命令是控制部件发出的单个控制信号（D 对）；微程序是微指令序列（A 错），微指令包含多微命令（B 错），微操作是执行部件动作（C 错）。</p></li><li><p><strong>垂直型微指令的特点是（ ）。</strong><br><strong>A. 控制信号经过编码产生</strong><br><strong>B. 强调并行控制功能</strong><br><strong>C. 采用微操作码</strong><br><strong>D. 微指令格式垂直表示</strong></p><ul><li><strong>A 错</strong>：编码产生控制信号是字段编码特性，非垂直型微指令特点（垂直型多直接给出信号）。</li><li><strong>B 错</strong>：并行控制是<strong>水平型</strong>微指令特点（多字段并行操作），垂直型并行性差。</li><li><strong>C 对</strong>：垂直型微指令类似机器指令，每条含<strong>微操作码</strong>（对应单一基本操作，功能简单，微程序长）。</li><li><strong>D 错</strong>：“格式垂直表示” 表述无意义，垂直型核心是<strong>功能单一（微操作码对应基本操作）</strong>。</li></ul></li><li><p><strong>下列说法中，正确的是（ ）。</strong><br><strong>I. 微程序控制方式和硬布线方式相比较，前者可以使指令的执行速度更快</strong><br><strong>II. 若采用微程序控制方式，则可用 μPC 取代 PC</strong><br><strong>III. 控制存储器可以用 ROM 实现</strong><br><strong>IV. 指令周期也称 CPU 时钟周期</strong><br><strong>A. I、III</strong><br><strong>B. II、III</strong><br><strong>C. 只有 III</strong><br><strong>D. I、III、IV</strong></p><ul><li><strong>I 错</strong>：硬布线速度更快（无控存访问延迟），微程序控制慢。</li><li><strong>II 错</strong>：μPC 控微指令，PC 控机器指令，功能不同，不可取代。微程序控制方式中需要用到PC</li><li><strong>III 对</strong>：控存（如 ROM）存储微程序，常见实现。</li><li><strong>IV 错</strong>：指令周期≠CPU 时钟周期（前者含多个后者）。</li></ul></li><li><p><strong>下图是某微程序控制器的基本结构，μPC 是一个 8 位寄存器，μIR 是一个 32 位寄存器，一条机器指令平均由 4 条不同的微指令组成（不含取指部分），则下列描述中错误的是（ ）。</strong><br><strong>A. 微指令地址用增量法</strong><br><strong>B. 条件码来自标志寄存器</strong><br><strong>C. 最多 64 条机器指令</strong><br><strong>D. 控存容量 1KB</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250630211321102.png" alt="image.png|400"></p><ul><li><strong>A 对</strong>：微指令地址的产生方法有增量（计数）法、断定（下址字段）法，途中有μPC+1，是增量法生成微地址。</li><li><strong>B 对</strong>：条件码用于转移，通常来自标志寄存器（运算状态）</li><li><strong>C 错</strong>：μPC 8 位，能够指向256 微指令地址，其中包含若干取指微指令，因此机器指令的条数小于256/4=64</li><li><strong>D 对</strong>：容量=单元数×每条微指令位数=2^8×32bit=1024B=1KB，控存容量计算正确。</li></ul></li><li><p><strong>【2014 统考真题】某计算机采用微程序控制器，共有 32 条指令，公共的取指令微程序包含 2 条微指令，各指令对应的微程序平均由 4 条微指令组成，采用断定法（后继地址字段法）确定下条微指令地址，则微指令中后继地址字段的位数至少是（ ）。</strong><br><strong>A. 5</strong><br><strong>B. 6</strong><br><strong>C. 8</strong><br><strong>D. 9</strong><br>先算总微指令数，32 条指令对应微指令数为 32×4 = 128 条，再加上公共取指令微程序的 2 条，共 128 + 2 = 130 条。要表示这些微指令地址，需满足 2^n≥130（n 为地址字段位数），2^7 = 128 不够，2^8 = 256 满足，所以 n 至少为 8。</p></li><li><p><strong>【2017 统考真题】下列关于主存储器（MM）和控制存储器（CS）的叙述，错误的是（ ）。</strong><br><strong>A. MM 在 CPU 外，CS 在 CPU 内</strong><br><strong>B. MM 按地址访问，CS 按内容访问</strong><br><strong>C. MM 存储指令和数据，CS 存储微指令</strong><br><strong>D. MM 用 RAM 和 ROM 实现，CS 用 ROM 实现</strong><br>主存储器（MM）在 CPU 外部，按地址访问，存储指令和数据，可由 RAM 和 ROM 实现；控制存储器（CS）在 CPU 内部，按地址访问（并非按内容访问 ），用于存储微指令，常用 ROM 实现。所以 B 选项错误，按照内容的是相联存储器。</p></li><li><p><strong>【2019 统考真题】下列有关处理器时钟信号的叙述中，错误的是（ ）。</strong><br><strong>A. 时钟信号由机器脉冲源发出的脉冲信号经整形和分频后形成</strong><br><strong>B. 时钟信号的宽度称为时钟周期，时钟周期的倒数为机器主频</strong><br><strong>C. 时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定</strong><br><strong>D. 处理器总是在每来一个时钟信号时就开始执行一条新的指令</strong><br>时钟信号由机器脉冲源发出的脉冲信号经整形和分频后得到，时钟信号宽度即时钟周期，其倒数是机器主频，时钟周期依据相邻状态单元间组合逻辑电路的最大延迟确定。而处理器执行新指令并非每来一个时钟信号就开始，要根据指令周期等情况，比如指令流水线中，不同阶段在不同时钟周期执行，所以 D 选项错误。</p></li><li><p><strong>【2019 统考真题】某指令的功能为 R [r2]←R [r1]+M [R [r0]]，其两个源操作数分别采用寄存器、寄存器间接寻址方式。对于下列给定部件，该指令在取数及执行过程中需要用到的是（ ）。</strong><br><strong>I. 通用寄存器组（GPRs）</strong><br><strong>II. 算术逻辑单元（ALU）</strong><br><strong>III. 存储器（Memory）</strong><br><strong>IV. 指令译码器（ID）</strong><br><strong>A. 仅 I、II  B. 仅 I、II、III  C. 仅 II、III、IV  D. 仅 I、III、IV</strong><br>该指令的两个源操作数分别采用寄存器、寄存器间接寻址方式，取数阶段需用到通用寄存器组（GPRs）和存储器（Memory）；执行阶段，源操作数相加需用到算术逻辑单元（ALU）。按照将指令执行分为取值、译码、间址、取数、执行的流程，指令译码器（IV）在译码阶段已完成使命，取数及执行阶段不再用到。所以该指令在取数及执行过程中用到的是 I、II、III。</p></li><li><p><strong>【2021 统考真题】下列寄存器中，汇编语言程序员可见的是（ ）。</strong><br><strong>I. 指令寄存器</strong><br><strong>II. 微指令寄存器</strong><br><strong>III. 基址寄存器</strong><br><strong>IV. 标志 / 状态寄存器</strong></p><ul><li><strong>解析</strong>：指令寄存器用于存放当前指令，对汇编语言程序员透明；微指令寄存器存放微指令，也对其透明；基址寄存器可用于地址计算等，汇编语言程序员可见；标志 / 状态寄存器记录运算状态，汇编语言程序员可使用。所以 III、IV 对汇编语言程序员可见。</li><li><strong>答案</strong>：D</li></ul></li><li><p><strong>【2021 统考真题】通常情况下，将汇编语言程序中实现特定功能的指令序列定义成一条伪指令（pseudo - instruction）。在下列选项中，CPU 能理解并直接执行的是（ ）。</strong><br><strong>I. 伪指令</strong><br><strong>II. 微指令</strong><br><strong>III. 机器指令</strong><br><strong>IV. 汇编指令</strong><br>A. 仅 I、IV  B. 仅 II、III  C. 仅 III、IV  D. 仅 I、III、IV<br>B。高级语言程序、汇编语言程序需经翻译生成机器语言程序才能被 CPU 执行。机器指令能被 CPU 理解并直接执行。<br>微指令是 CPU 控制单元用于实现机器指令的更底层指令，在微程序控制的 CPU 中，一条机器指令对应一个微程序（微指令有序序列），用来控制 CPU 实现机器指令的过程，微指令也能被 CPU 理解并直接执行。<br>伪指令是汇编语言中为方便编程设置的指令，需经汇编程序处理，不能被 CPU 直接执行；汇编指令也需汇编成机器指令后才能被 CPU 执行。</p></li><li><p><strong>指令执行结果出现异常而引起的中断是（ ）。</strong><br><strong>A. I/O 中断  B. 机器校验中断  C. 故障  D. 外部中断</strong><br>C。故障中断是指在指令执行过程中，因指令执行结果出现异常情况（如运算溢出、除数为零等）而引发的中断。I/O 中断是与输入输出设备相关操作引起的；机器校验中断更多是硬件本身校验出错（如内存奇偶校验错等硬件层面）；外部中断是由外部设备（如键盘、鼠标等）产生的非指令执行异常相关的中断请求。</p></li><li><p><strong>访问主存时发生的校验错误属于（ ）。</strong><br><strong>A. 故障  B. 自陷  C. 终止  D. 外中断</strong><br>C。访问主存时发生校验错误属于终止中断。终止中断通常是由于出现严重的、不可恢复的错误导致，主存校验错误属于硬件层面较为严重的错误情况。故障中断虽然也是错误相关，但一般是指令执行过程中的异常；自陷是程序主动触发（如系统调用等）；外中断是外部设备（非主存相关硬件错误）引发的。</p></li><li><p><strong>下列给出的事件中，无须异常处理程序进行处理的是（ ）。</strong><br><strong>A. 缺页故障  B. Cache 缺失  C. 地址越界  D. 除数为 0</strong><br>B。缺页故障需操作系统的缺页处理程序将页面从外存调入主存，需异常处理。Cache 缺失由硬件自动从主存读取，无需软件层面异常处理程序干预。地址越界属非法访问内存，需操作系统异常处理机制介入。除数为 0 是运算异常，需异常处理程序处理。</p></li><li><p><strong>下列关于异常 / 中断机制与进程上下文切换机制的叙述中，错误的是（ ）。</strong><br><strong>A. 进程上下文切换和异常 / 中断响应两者都会产生异常控制流。</strong><br><strong>B. 进程上下文切换后，CPU 执行的是另一个进程的代码。</strong><br><strong>C. 响应异常 / 中断请求后，CPU 执行的是内核程序的代码。</strong><br><strong>D. 进程上下文切换和异常 / 中断响应处理都通过执行内核程序实现。</strong><br>D。解析：进程上下文切换由内核程序实现（正确），但异常 / 中断响应的<strong>触发是硬件机制</strong>（如 CPU 的异常检测模块），并非完全通过内核程序实现（硬件先检测，再转交内核处理）。因此 D 中 “都通过执行内核程序实现” 表述错误。A（均产生异常控制流，正确，见补充知识）、B（切换后执行另一进程代码，正确）、C（异常处理在内核态，正确）均无误。<br>补充知识：进程上下文切换虽为系统正常调度机制，但从<strong>进程执行的局部视角</strong>，其<strong>控制流的突变（被内核强制中断和转移）</strong> 符合异常控制流的核心特征（非程序自身逻辑驱动的执行流改变，响应系统事件）。因此，进程上下文切换会产生异常控制流。</p></li><li><p><strong>异常或中断处理结束后，返回到被中断原程序继续执行的指令地址称为 “断点”，下列关于 “断点” 的说法中，错误的是（ ）。</strong><br><strong>A. “陷阱” 类异常的断点为陷阱指令下一条指令的地址</strong><br><strong>B. “故障” 类异常的断点为当前发生异常的指令的地址</strong><br><strong>C. 外部中断的断点总是当前刚执行完的指令的地址</strong><br><strong>D. “终止” 类异常的断点可以是当前指令或下一条指令的地址</strong><br><strong>C</strong>。解析：外部中断检测在<strong>一条指令执行完后、取下一条指令前</strong>，故响应后返回<strong>下一条指令地址</strong>（而非 “刚执行完的指令”）。A（陷阱后执行下一条，正确）、B（故障需重执行当前指令，断点为当前地址，正确）、D（终止类不返回，断点无意义，描述合理，正确）。C 错误。</p></li><li><p><strong>下列关于流水 CPU 基本概念的描述中，正确的是（ ）。</strong><br><strong>A. 流水 CPU 是以空间并行性为原理构造的处理器</strong><br><strong>B. 流水 CPU 一定是 RISC 机器</strong><br><strong>C. 流水 CPU 一定是多媒体 CPU</strong><br><strong>D. 流水 CPU 是一种非常经济而实用的时间并行技术</strong><br><strong>D</strong>。解析：流水线通过 “时间重叠” 让指令阶段并行（时间并行），非空间并行（A 错）；CISC 架构（如 x86）也可实现流水线（B 错）；流水线是执行效率优化，与多媒体指令集无关（C 错）；流水线复用硬件，成本低且高效，属时间并行技术（D 对）。</p></li><li><p><strong>流水 CPU 是由一系列称为 “段” 的处理电路组成的。一个 m 段流水线稳定时的 CPU 的吞吐能力，与 m 个并行部件的 CPU 的吞吐能力相比，( )。</strong><br><strong>A. 具有同等水平的吞吐能力</strong><br><strong>B. 不具备同等水平的吞吐能力</strong><br><strong>C. 吞吐能力大于前者的吞吐能力</strong><br><strong>D. 吞吐能力小于前者的吞吐能力</strong><br><strong>A</strong>。解析：流水线稳定后，<strong>每个时钟周期完成 1 条指令</strong>；m 个并行部件（空间并行）理想下也可<strong>每个时钟周期完成 1 条指令</strong>（并行部件同步，效率与时间并行等价），故吞吐能力相当（A 对）。</p></li><li><p><strong>设指令由取指、分析、执行 3 个子部件完成，并且每个子部件的时间均为 Δt，若采用度为 4 的超标量流水线处理机，连续执行 20 条指令，只需（ ）。</strong><br><strong>A. 3Δt B. 5Δt C. 7Δt D. 9Δt</strong><br><strong>C</strong>。解析：超标量度 4（每周期发 4 条），首 3Δt 建流水线，剩余 16 条需 4Δt，总 3+4=7Δt。<br>相当于度为1，执行5条指令<br>若执行21条指令：度为 4 的超标量流水线每周期可发射 4 条指令。前 3Δt 为流水线建立时间（首 4 条指令完成），剩余 21-4=17 条，需 5 个周期（4×4=16 条，最后 1 条需 1 个周期），总 3+5=8Δt。</p></li><li><p><strong>设指令流水线把一条指令分为取指、分析、执行 3 部分，3 部分执行时间不等长，且 3 部分的时间分别是 t₍取指₎=2ns，t₍分析₎=2ns，t₍执行₎=1ns，则 100 条指令全部执行完毕需（ ）。</strong><br><strong>A. 163ns B. 183ns C. 193ns D. 203ns</strong><br><strong>C</strong>。解析：流水线周期 T=2ns，总时间 = 5 + (100-1)×2 -1=193ns（首条 5ns，后续 99 条每周期 2ns，执行段少 1ns 补差）。</p></li><li><p><strong>下列关于流水段寄存器的叙述中，正确的是（ ）。</strong><br><strong>A. 指令译码得到的控制信号需通过流水段寄存器传递到下一个流水段</strong><br><strong>B. 每个流水段之间的流水段寄存器位数一定相同</strong><br><strong>C. 每个流水段之间的流水段寄存器存放的信息一定相同</strong><br><strong>D. 用户程序可以通过指令指定访问哪个流水段寄存器</strong><br><strong>A</strong>。解析：流水段寄存器用于暂存当前段数据 / 控制信号，译码控制信号需经其传至下一段（A 对）；不同段寄存器<strong>位数（B，如取指存指令、执行存运算结果，位数可不同）、存放信息（C，取指存指令 vs 分析存操作数，信息不同）</strong> 均不一定相同；流水段寄存器是硬件内部结构，<strong>用户无法访问（D 错）</strong>。</p></li><li><p><strong>下列关于流水线数据通路的描述中，错误的是（ ）。</strong><br><strong>A. 每个流水段由执行指令子功能的功能部件和流水段寄存器组成</strong><br><strong>B. 控制信号仅作用在功能部件上，时钟信号仅作用在流水段寄存器上</strong><br><strong>C. 在没有阻塞的情况下，PC 的值在每个时钟周期都会改变</strong><br><strong>D. 取指令阶段和指令译码阶段不需要控制信号的控制</strong><br>A正确，流水段标准结构为 “功能部件（如取指单元）+ 流水段寄存器（暂存段间数据）”；B错，控制信号决定<strong>数据流向</strong>和<strong>操作类型</strong>，仅作用在功能部件上是对的，时钟信号是全局同步的，作用域所有状态元件（PC、寄存器、存储器等）；C对，PC自增。补充 PC 和流水段寄存器无写使能信号（因为PC每个时钟周期必然更新，流水段寄存器每个时钟周期必然锁存当前段数据，传递到下一段，所以无需写使能，即硬件逻辑强制每时钟写入）；D对，因为<strong>取指、译码</strong>的操作对 <strong>所有指令都相同</strong>，所以前两个流水段无需控制信号。</p></li><li><p><strong>下列关于结构冒险的叙述中，正确的是（ ）。</strong><br><strong>Ⅰ. 结构冒险是指同时有多条指令使用同一个资源</strong><br><strong>Ⅱ. 避免结构冒险的基本做法是使每个指令在相同流水段中使用相同的部件</strong><br><strong>Ⅲ. 重复设置功能部件可以避免结构冒险</strong><br>A. Ⅰ、Ⅱ、Ⅳ B. Ⅰ、Ⅱ、Ⅲ C. Ⅰ、Ⅲ、Ⅳ D. Ⅰ、Ⅱ、Ⅲ 和 Ⅳ<br>Ⅰ 符合结构冒险 “多指令同时争用同一硬件资源” 的定义；Ⅱ 对应教材结论 “一个部件每条指令只能使用一次，且只能在特定阶段使用（即指令在相同流水段用相同部件），可避免部分结构冒险”；Ⅲ“重复设置功能部件”、Ⅳ“分离指令 / 数据 Cache” 均属于 “通过设置多个独立部件规避硬件冲突” 的策略，选 D。</p></li><li><p><strong>指令流水线中出现数据相关时流水线将受阻，（ ）可解决数据相关问题。</strong><br><strong>A. 增加硬件资源</strong> <strong>B. 采用旁路技术</strong> <strong>C. 采用分支预测技术</strong> <strong>D. 以上都可以</strong><br><strong>B</strong>。解析：A 错误，<strong>结构冒险</strong>（硬件不足）；B 正确，旁路技术通过硬件直接传递运算结果，打破数据依赖的时间差（如解决 RAW 冒险）；C 错误，<strong>控制冒险</strong>（分支跳转的流程不确定）D 错误</p></li><li><p><strong>下列关于数据冒险和转发技术的叙述中，正确的是（ ）。</strong><br><strong>Ⅰ. 并非所有数据冒险都能通过转发技术解决</strong><br><strong>Ⅱ. 五段流水线中 load-use 数据冒险会引起至少一个时钟周期的阻塞</strong><br><strong>Ⅲ. 前面的分支指令和后面的 ALU 运算指令之间肯定不会发生数据冒险</strong><br>A. Ⅰ、Ⅱ B. Ⅰ、Ⅲ C. Ⅱ、Ⅲ D. Ⅰ、Ⅱ、Ⅲ<br><strong>A</strong>。解析：Ⅰ 正确，因为转发技术无法解决所有数据冒险，例如 load-use 冒险中，数据来自内存读取，转发无法提前获取；Ⅱ 正确，五段流水线中，load 指令需在访存阶段才能得到数据，而后续指令在执行阶段就需要该数据，因此至少会阻塞 1 个时钟周期；Ⅲ 错误，若分支指令写入某个寄存器，后续 ALU 指令读取该寄存器时，可能因数据未写回而发生数据冒险，并非 “肯定不会”。注：如果是按序发射，是对的</p></li><li><p><strong>下列关于数据冒险的叙述中，正确的是（ ）。</strong><br><strong>Ⅰ. 数据冒险是指后面指令用到的数据还未来得及由前面的指令产生</strong><br><strong>Ⅱ. 在发生数据冒险的指令之间插入空操作指令能避免数据冒险</strong><br><strong>Ⅲ. 采用转发（旁路）技术可以解决一部分数据冒险现象</strong><br><strong>Ⅳ. 通过编译器调整指令顺序可解决部分数据冒险</strong><br>A. Ⅰ、Ⅱ、Ⅳ B. Ⅰ、Ⅱ、Ⅲ C. Ⅰ、Ⅲ、Ⅳ D. Ⅰ、Ⅱ、Ⅲ 和 Ⅳ<br><strong>C</strong>。解析：Ⅰ 正确，符合数据冒险 “数据依赖未满足” 的定义；Ⅱ 错误，插入空操作只是让流水线停顿等待数据，并未 “避免” 冒险本身，数据依赖仍然存在；Ⅲ 正确，转发技术可直接传递 ALU 运算结果，解决部分数据冒险（如 RAW 中运算结果的依赖）；Ⅳ 正确，编译器通过调整指令顺序，让无关指令填充等待周期，可减少部分数据冒险的影响。</p></li><li><p><strong>下列指令序列中，指令 I1 和 I3、I2 和 I3 之间发生数据相关。假定采用 “取指、译码 / 取数、执行、访存、写回” 五段流水线方式，那么在采用转发技术时，需要在指令 I3 之前加入（ ）条空操作指令才能使这段程序不发生数据冒险。</strong><br><strong>I1: add r1, r0, r0 # (r1)←(r0)+(r0)</strong><br><strong>I2: load r3, [2(r2)] # (r3)←M[(r2)+2]</strong><br><strong>I3: add r5, r3, r1 # (r5)←(r3)+(r1)</strong><br>A. 3 B. 2 C. 0 D. 1<br><strong>D</strong>。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250824184401869.png" alt="image.png|300"></p></li><li><p><strong>下面关于控制冒险的描述中，错误的是（ ）。</strong><br><strong>Ⅰ. 无条件转移指令不会发生控制冒险</strong><br><strong>Ⅱ. 在分支指令加入若干空操作可以避免控制冒险</strong><br><strong>Ⅲ. 采用转发（旁路）技术，可以解决部分控制冒险</strong><br><strong>Ⅳ. 中断或异常也会引起控制冒险</strong><br><strong>Ⅴ. 流水线的段数与控制冒险引发的开销无关</strong><br>A. Ⅰ、Ⅳ 、V B. Ⅲ、Ⅴ C. Ⅰ、Ⅲ、Ⅳ D. Ⅰ、Ⅲ、V<br><strong>D</strong>。解析：Ⅰ 错误，若无条件转移指令的目标地址在执行阶段才确定，仍会引发控制冒险，只要不是顺序执行指令，都会引发控制冒险；Ⅱ 正确，加入空操作可让流水线等待分支结果，减少控制冒险影响；Ⅲ 错误，转发技术用于解决数据冒险，与控制冒险无关；Ⅳ 正确，中断或异常会改变程序流向，引发控制冒险；Ⅴ 错误，流水线段数越多，分支结果确定前取出的错误指令越多，开销越大，因此与段数相关。综上，错误的是 Ⅰ、Ⅲ、Ⅴ。</p></li><li><p><strong>【2013 统考真题】某 CPU 主频为 1.03GHz，采用 4 级指令流水线，每个流水段的执行需要 1 个时钟周期。假定 CPU 执行了 100 条指令，在其执行过程中，没有发生任何流水线阻塞，此时流水线的吞吐率为（ ）。</strong><br>A. 0.25×10⁹条指令 / 秒 B. 0.97×10⁹条指令 / 秒 C. 1.0×10⁹条指令 / 秒 D. 1.03×10⁹条指令 / 秒<br><strong>C</strong> t=(m+k−1)⋅Δt=103×(1/1.03×10⁹)=10⁻⁷秒，吞吐率 = 100÷10⁻⁷=1.0×10⁹条 / 秒</p></li><li><p><strong>【2017 统考真题】下列关于指令流水线数据通路的叙述中，错误的是（ ）。</strong><br><strong>A. 包含生成控制信号的控制部件</strong><br><strong>B. 包含算术逻辑运算部件（ALU）</strong><br><strong>C. 包含通用寄存器组和取指部件</strong><br><strong>D. 由组合逻辑电路和时序逻辑电路组合而成</strong><br><strong>A</strong>。解析：数据通路是<strong>数据传输 / 运算的硬件路径</strong>（如寄存器、ALU、取指部件），<strong>控制部件是独立模块（生成控制信号指挥数据通路）</strong>，故数据通路不包含控制部件；B、C、D 均符合数据通路的组成（ALU 是运算核心，寄存器组 / 取指部件是数据载体，组合逻辑 + 时序逻辑是硬件实现基础）。</p></li><li><p><strong>【2023 统考真题】在采用 “取指、译码 / 取数、执行、访存、写回”5 段流水线的 RISC 处理器中，执行如下指令序列（第一列为指令序号），其中 s0、s1、s2、s3 和 t2 表示寄存器编号。</strong><br><strong>I1 add s2, s1, s0  // R[s2]←R[s1]+R[s0]</strong><br><strong>I2 load s3, 0(s2)  // R[s3]←M[R[s2]+0]</strong><br><strong>I3 beq t2, s3, L1  // if R[t2]=R[s3] jump to L1</strong><br><strong>I4 addi t2, t2, 20  // R[t2]←R[t2]+20</strong><br><strong>若采用转发（旁路）技术处理数据冒险，采用硬件阻塞方式处理控制冒险，则在指令 I1～I4 的执行过程中，发生流水线阻塞的指令有（ ）。</strong><br><strong>A. 仅 I3 B. 仅 I2、I4 C. 仅 I3、I4 D. 仅 I2、I3、I4</strong><br><strong>C</strong>。解析：I1 的 s2 在 EX 阶段产生，可通过转发（Ex/Mem 寄存器）供给 I2 的 EX 阶段（计算访存地址），I2 无阻塞；I2 是 load 指令，s3 在 MEM 阶段产生，I3 的 EX 阶段需比较 s3，转发无法提前获取 MEM 阶段数据（load - use 冒险），I3 需阻塞；I3 是分支指令，在 MEM 阶段才确定是否跳转，I4 已提前取指，因<strong>控制冒险</strong>需阻塞；故仅 I3、I4 阻塞，I2 因转发无阻塞。</p></li></ol><table><thead><tr><th>指令</th><th>操作</th><th>五段流水线阶段细节</th></tr></thead><tbody><tr><td>I1</td><td><code>add s2, s1, s0</code></td><td>IF（取指）→ ID（译码 + 读 s0/s1）→ EX（计算 s1+s0）→ MEM（跳过）→ WR（写回 s2）</td></tr><tr><td>I2</td><td><code>load s3, 0(s2)</code></td><td>IF（取指）→ ID（译码 + 读 s2）→ EX（计算 s2+0）→ MEM（访存 M (s2+0)）→ WR（写回 s3）</td></tr><tr><td>I3</td><td><code>beq t2, s3, L1</code></td><td>IF（取指）→ ID（译码 + 读 t2/s3）→ EX（计算 t2-s3）→ MEM（判 ZF 改 PC）→ WR（跳过）</td></tr><tr><td>I4</td><td><code>addi t2, t2, 20</code></td><td>IF（取指）→ ID（译码 + 读 t2）→ EX（计算 t2+20）→ MEM（跳过）→ WR（写回 t2）</td></tr></tbody></table><table><thead><tr><th>周期</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>I1</td><td>取指</td><td>译码（读 s0、s1）</td><td>执行（算 s1+s0）</td><td>访存（跳过）</td><td>写回（写 s2）</td><td></td><td></td><td></td><td></td></tr><tr><td>I2</td><td>-</td><td>取指</td><td>译码（读 s2）</td><td>执行（算 s2+0）</td><td>访存（读 M (s2+0)）</td><td>写回（写 s3）</td><td></td><td></td><td></td></tr><tr><td>stall</td><td></td><td></td><td>取指（阻塞气泡）</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td><td></td></tr><tr><td>I3</td><td></td><td></td><td></td><td>取指</td><td>译码（读 t2、s3）</td><td>执行（算 t2-s3）</td><td>访存（改 PC 到 L1）</td><td>写回（跳过）</td><td></td></tr><tr><td>I4</td><td></td><td></td><td></td><td></td><td>取指（红标，原提前取指需阻塞）</td><td>译码（读 t2，阻塞后）</td><td>执行（算 t2+20）</td><td>访存（跳过）</td><td>写回（写 t2）</td></tr><tr><td>因为I3的访存阶段可能会修改PC的值，而I4的取指阶段读取PC的值，可能造成控制冒险</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol start="57"><li><p><strong>下列关于超线程（HT）技术的描述中，正确的是（ ）。</strong><br><strong>A. 超线程技术可以让四核的 Intel Core i7 处理器变成八核</strong><br><strong>B. 超线程是一项硬件技术，能使系统性能大幅提升，与操作系统和应用软件无关</strong><br><strong>C. 含有超线程技术的 CPU 需要芯片组的支持才能发挥技术优势</strong><br><strong>D. 超线程模拟出的每个 CPU 核都具有独立的资源，各自工作互不干扰</strong><br><strong>C</strong>。解析：A 错误，超线程是 “单物理核模拟多逻辑核”（如四核变八核是逻辑核，物理核仍为 4），并非真正物理核数量翻倍；B 错误，超线程性能依赖操作系统（线程调度）和应用软件（多线程优化），并非与软件无关；C 正确，超线程需芯片组、操作系统、软件协同（如芯片组调度资源），才能充分发挥优势；D 错误，超线程的逻辑核<strong>共享物理资源</strong>（如 ALU、Cache），遇资源竞争会阻塞，并非 “独立资源、互不干扰”。</p></li><li><p><strong>双核 CPU 和超线程 CPU 的共同点是（ ）。</strong><br><strong>A. 都有两个内核 B. 都能同时执行两个运算 C. 都包含两个 CPU D. 都不会出现争抢资源的现象</strong><br><strong>B</strong>。解析：A 错误（超线程是 “逻辑双核”，物理核数为 1）；C 错误（均为单 CPU，双核是单 CPU 内集成两物理核，超线程是单 CPU 模拟两逻辑核）；D 错误（超线程共享物理资源、双核也可能共享 Cache，均会争抢资源）；B 正确（双核两物理核同时运算，超线程单物理核内两逻辑线程并行运算，均实现 “同时执行两个运算”）。</p></li><li><p><strong>下列有关多核 CPU 和单核 CPU 的描述中，错误的是（ ）。</strong><br><strong>A. 双核的频率为 2.4GHZ，那么其中每个核心的频率也是 2.4GHZ</strong><br><strong>B. 同等性能下，采用双核 CPU 可以降低计算机系统的功耗和体积</strong><br><strong>C. 多核 CPU 共用一组内存，数据共享</strong><br><strong>D. 所有程序在多核 CPU 上运行速度都快</strong><br><strong>D</strong>。解析：A 正确（多核同频设计下，各核心频率一致）；B 正确（多核通过并行替代高频单核，降低功耗与体积）；C 正确（多核属共享内存架构，共用主存并通过缓存一致性共享数据）；D 错误（单线程程序无法利用多核并行，甚至因缓存竞争等开销无法提速，仅多线程程序能发挥多核优势）。</p></li><li><p><strong>下列关于多核 CPU 的描述中，正确的是（ ）。</strong><br><strong>A. 各核心完全对称，拥有各自的 Cache</strong><br><strong>B. 任何程序都可以同时在多个核心上运行</strong><br><strong>C. 一颗 CPU 中集成了多个完整的执行内核，可同时进行多个运算</strong><br><strong>D. 只有使用了多核 CPU 的计算机，才支持多任务操作系统</strong><br><strong>C</strong>。解析：A 错误，多核核心可不对称（如大小核），且 Cache 可独可共享；B 错误，单线程程序无法多核心并行；C 正确，多核集成多个独立执行内核（含运算、控制单元），支持并行运算；D 错误，单核 CPU 通过分时复用也支持多任务（宏观并行、微观串行）。</p></li><li><p><strong>下列关于多处理器的说法中，正确的是（ ）。</strong><br><strong>Ⅰ. 通常采用偶数路 CPU，如 2 路、4 路、6 路等</strong><br><strong>Ⅱ. NUMA 构架比 UMA 构架的运算扩展性要强</strong><br><strong>Ⅲ. UMA 构架需要解决的重要问题是 Cache 一致性</strong><br><strong>A. Ⅰ B. Ⅰ 和 Ⅱ C. Ⅰ 和 Ⅲ D. Ⅰ、Ⅱ 和 Ⅲ</strong><br><strong>D</strong>。解析：Ⅰ 正确，SMP（对称多处理器）常用偶数路 CPU 均衡调度；Ⅱ 正确，UMA 共享内存易冲突，NUMA 分区内存支持更灵活扩展；Ⅲ 正确，UMA 多 CPU 共享内存，Cache 副本需通过协议保障一致性；故三者均对。</p></li><li><p><strong>下列关于多核处理器的说法中，不正确的是（ ）。</strong><br><strong>A. 多核处理器并不能使单线程程序的执行速度加快</strong><br><strong>B. 多核处理器在 Flynn 分类法中属于 MIMD 系统</strong><br><strong>C. 多核处理器实际上就是在一个 CPU 上集成了多个控制核心</strong><br><strong>D. 多核处理器通常比单核处理器的能耗更高</strong><br><strong>C</strong>。解析：A 正确，单线程程序仅占一个核心，多核无法并行加速；B 正确，多核多核心同时执行不同指令、处理不同数据，符合 MIMD；C 错误，多核集成的是 “运算核心”（含运算、存储等完整单元），而非 “控制核心”；D 正确，多核同时运行任务，总能耗通常更高。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU功能组成（控制器/运算器） </tag>
            
            <tag> 时序系统（节拍/周期） </tag>
            
            <tag> 微程序控制与硬布线控制 </tag>
            
            <tag> 流水线技术（时空图/冲突处理） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 4 章 文件管理：存储与访问机制</title>
      <link href="/post/790dfc8c.html"/>
      <url>/post/790dfc8c.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件">文件</h2><h3 id="基本概念">基本概念</h3><h4 id="定义">定义</h4><ul><li><strong>文件</strong>：<ul><li>是以硬盘为载体的存储在计算机上的信息集合，可以是文本文档、图片、程序等</li><li>用户进行的输入、输出操作中，以文件为基本单位</li></ul></li><li><strong>文件的结构</strong>【自底向上进行定义】：<ul><li><strong>数据项</strong>：文件系统中最低级的数据组织方式，分为：<ul><li>基本数据项：描述一个对象的某种属性的一个值，是数据中的最小逻辑单位</li><li>组合数据项：由多个基本数据项组成</li></ul></li><li><strong>记录</strong>：一组相关的数据项的集合，用于描述一个对象在某方面的属性</li><li><strong>文件</strong>：由创建者所定义的、具有文件名的一组相关元素的集合，分为：<ul><li>有结构文件：文件由若干个相似的记录组成【如数据库表】</li><li>无结构文件：文件被视为一个字节流【如二进制文件或字符文件】</li></ul></li></ul></li></ul><h4 id="属性">属性</h4><ul><li><strong>文件名</strong>：由创建文件的用户决定，为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong></li><li><strong>类型</strong>：被支持不同类型的文件系统所使用</li><li><strong>创建者</strong>：文件创建者的 ID</li><li><strong>所有者</strong>：文件当前所有者的 ID</li><li><strong>位置</strong>：指向设备和设备上文件的指针</li><li><strong>大小</strong>：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值</li><li><strong>保护</strong>：对文件进行保护的访问控制信息</li><li><strong>创建时间、最后一次修改时间、最后一次存取时间</strong>：用于保护和跟踪文件</li></ul><h3 id="文件的数据结构">文件的数据结构</h3><h4 id="文件控制块-FCB">文件控制块 FCB</h4><ul><li><strong>文件控制块</strong>：用来存放控制文件需要的各种信息的数据结构，以实现<strong>按名存取</strong></li><li><strong>文件目录</strong>：FCB 的有序集合【文件与 FCB 一一对应，一个 FCB 就是一个<strong>文件目录项</strong>】</li><li><strong>目录文件</strong>：一个文件目录也被视为一个文件</li><li>每当创建一个新文件，系统就要为其建立一个 FCB，用来记录文件的各种属性<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240519145726.png" alt="image.png"></li><li>FCB 主要包含以下信息：<ul><li><strong>基本信息</strong>：文件名、文件的物理位置、文件的逻辑结构、文件的物理结构</li><li><strong>存取控制信息</strong>：文件主的存取权限、核准用户的存取权限以及一般用户的存取权限</li><li><strong>使用信息</strong>：文件的建立时间、上次修改时间等</li></ul></li></ul><h4 id="索引节点">索引节点</h4><ul><li><strong>索引节点</strong>：包含了<strong>除文件名之外</strong>的所有信息，每个文件对应一个索引节点</li><li>文件目录的目录项中仅由<strong>文件名</strong>和相应的<strong>索引节点号</strong>（或索引节点指针）构成</li><li><strong>优点</strong>：使用索引节点，目录项长度减小，因此每个磁盘块可以存放更多个目录项，减少了索引文件时磁盘 I/O 的次数</li><li><strong>分类</strong>：<ul><li><strong>磁盘索引节点</strong>：<ul><li>指存放在磁盘上的索引节点【<strong>外存中</strong>】</li><li>每个文件有一个唯一的磁盘索引节点</li><li>包含：文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件链接计数、文件存取时间</li></ul></li><li><strong>内存索引节点</strong>：<ul><li>指存放在<strong>内存中</strong>的索引节点</li><li>文件被打开时，将磁盘索引节点复制到内存的索引节点，便于以后使用</li><li>新增：索引节点号、状态、访问计数、逻辑设备号、链接指针</li></ul></li></ul></li></ul><h3 id="文件的操作">文件的操作</h3><h4 id="创建文件（create-系统调用）">创建文件（create 系统调用）</h4><ul><li>需要提供的<strong>主要参数</strong>：<ul><li>所需的外存空间大小（如：一个盘块，即 1 KB）</li><li>文件存放路径（“D:/Demo”）</li><li>文件名（这个地方默认为“新建文本文档.txt”）</li></ul></li><li>OS 的<strong>处理过程</strong>：<ul><li><strong>在外存中找到文件所需的空间</strong></li><li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中<strong>创建该文件对应的目录项</strong></li></ul></li></ul><h4 id="删除文件（delete-系统调用）">删除文件（delete 系统调用）</h4><ul><li>需要提供的<strong>主要参数</strong>：<ul><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt”）</li></ul></li><li>OS 的<strong>处理过程</strong>：<ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong></li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong></li><li>从目录表中<strong>删除文件对应的目录项</strong></li></ul></li></ul><h4 id="打开文件（open-系统调用）">打开文件（open 系统调用）</h4><ul><li>需要提供的<strong>主要参数</strong>：<ul><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test. Txt”）</li><li>要对文件的操作类型（如：r 只读；rw 读写等）</li></ul></li><li>OS 的<strong>处理过程</strong>：<ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的的目录项</strong>，并检查该用户是否有指定的操作权限</li><li><strong>将目录项从外存复制到内存中的“打开文件表”</strong> 的一个表目中，并将该表目的索引号（也称<strong>文件描述符</strong>）返回给用户</li></ul></li><li><strong>注意</strong>：<ul><li>只要完成了 open 系统调用，之后对文件的操作（read，write，Lseek，close 等）均<strong>使用文件描述符</strong>，这样可以加快文件的访问速度</li><li><strong>打开文件表整个系统只有一张</strong></li><li>对于访问打开文件表的索引号，UNIX 称之为文件描述符，Windows 称之为文件句柄</li></ul></li><li><strong>打开文件所具有的关联信息</strong>：<ul><li><strong>文件指针</strong>：<ul><li>系统跟踪<strong>上次的读写位置</strong>作为当前文件位置的指针</li><li>这种指针<strong>对打开文件的某个进程来说是唯一的</strong>，因此必须与磁盘文件属性分开保存</li></ul></li><li><strong>文件打开计数</strong>：<ul><li>计数器跟踪<strong>当前文件打开和关闭的数量</strong></li><li>因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件</li></ul></li><li><strong>文件磁盘位置</strong>：<ul><li>大多数文件操作要求系统修改文件数据</li><li><strong>查找磁盘上的文件所需的信息保存在内存中</strong>，以便系统不必为每个操作都从磁盘上读取该信息</li></ul></li><li><strong>访问权限</strong>：<ul><li>每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）</li><li>该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的 I/O 请求</li></ul></li></ul></li></ul><h4 id="关闭文件（close-系统调用）">关闭文件（close 系统调用）</h4><ul><li>OS 的<strong>处理过程</strong>：<ul><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器 count 减 1，若 count =0，则删除对应表项</li></ul></li><li>内存中<strong>文件的系统结构</strong>：<ul><li>在多个不同进程可以同时打开文件的操作系统中，通常采用<strong>两级表</strong>：<ul><li><strong>整个系统的打开文件表</strong>：包含与进程无关的信息，如文件在磁盘上的位置、访问日期和文件大小</li><li><strong>每个进程的打开文件表</strong>：保存的是进程对文件的使用信息，如文件的当前读写指针、文件访问权限，并包含指向系统表中适应条目的指针</li></ul></li><li>一旦有进程打开了一个文件，系统表就包含该文件的条目</li><li>当另一个进程执行调用 open 时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目</li><li>通常，系统打开文件表为每个文件关联一个<strong>打开计数器</strong>（Open Count）, 以记录多少进程打开了该文件</li><li>每个关闭操作 close 使 count 递减，当打开计数器为 0 时，表示该文件不再被使用，并且可从系统打开文件表中删除相应条目<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240519155554.png" alt="image.png"></li></ul></li></ul><h4 id="读文件（read-系统调用）">读文件（read 系统调用）</h4><ul><li>根据文件名查找目录【open 之后通过文件描述符】，找到指定文件的目录项后，再利用目录项中的读指针进行读操作</li><li>从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域</li><li><strong>外存 —&gt; 内存</strong></li></ul><h4 id="写文件（write-系统调用）">写文件（write 系统调用）</h4><ul><li>根据文件名查找目录【open 之后通过文件描述符】，找到指定文件的目录项后，再利用目录项中的写指针进行写操作</li><li>从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</li><li><strong>内存 —&gt; 外存</strong></li></ul><h3 id="文件保护">文件保护</h3><h4 id="基本概念-2">基本概念</h4><ul><li><strong>保护的目的</strong>：解决对文件的读、写、执行的许可问题</li><li>一个文件的访问常由<strong>用户访问权限和文件属性</strong>（包括保存在 FCB 中对文件访问的控制信息）共同设置</li></ul><h4 id="非访问控制方法">非访问控制方法</h4><ul><li>都是防止用户文件被他人存取或窃取，并没有控制用户对文件的访问类型</li></ul><h5 id="口令保护">口令保护</h5><ul><li><strong>定义</strong>：用户建立一个文件时需要提供口令【附在 FCB 上】，用户请求访问时必须提供相应口令</li><li><strong>优点</strong>：时间和空间开销不多</li><li><strong>缺点</strong>：口令直接存在系统内部，不安全</li></ul><h5 id="加密保护">加密保护</h5><ul><li><strong>定义</strong>：对文件进行加密，被访问时需要使用秘钥</li><li><strong>优点</strong>：保密性强，节省了存储空间</li><li><strong>缺点</strong>：编码和译码需要时间</li></ul><h4 id="访问控制方法">访问控制方法</h4><ul><li><strong>访问类型</strong>：读、写、执行、添加、删除、列表清单</li><li><strong>方法</strong>：<ul><li>根据<strong>用户身份</strong>进行访问控制</li><li>为每个文件和目录增加一个<strong>访问控制表 ACL</strong>，以规定每个用户名及其所允许的访问类型</li><li><strong>优点</strong>：可以使用复杂的访问方法</li><li><strong>缺点</strong>：长度无法预计并且可能导致复杂的空间管理</li></ul></li><li><strong>注意</strong>：<ul><li>上述的文件保护可以只在低层提供</li><li>对文件的<strong>重命名、复制、粘贴</strong>等控制方式【高层功能】，可通过系统程序调用低层系统调用实现</li></ul></li><li><strong>精简的访问控制列表</strong>：<ul><li>解决 ACL 的问题，包含三种用户类型：<ul><li><strong>拥有者</strong>：创建文件的用户</li><li><strong>组</strong>：一组需要共享文件且具有类似访问的用户</li><li><strong>其他</strong>：系统内的所有其他用户<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240519163103.png" alt="image.png"></li></ul></li><li><strong>每项占用一个二进制位</strong>，只需 3 * 4 位的矩阵即可描述三类用户的权限</li><li>创建文件时，系统将文件拥有者的名字、所属组名记录在该文件的 FCB 中</li></ul></li></ul><h3 id="文件的逻辑结构">文件的逻辑结构</h3><ul><li>指从<strong>用户角度</strong>出发所看到的文件的组织形式</li></ul><h4 id="无结构文件">无结构文件</h4><ul><li><strong>基本概念</strong>：<ul><li>最简单的文件组织形式</li><li>文件内部的数据就是一系列<strong>二进制流或字符流</strong>，又称<strong>流式文件</strong></li><li>其长度<strong>以字节为单位</strong></li><li>如：系统中运行的大量源程序、可执行文件、库函数等</li></ul></li><li><strong>访问方式</strong>：<ul><li>通过<strong>读/写指针</strong>来指出下一个要访问的字节</li><li>没有结构，因此<strong>对记录的访问</strong>只能通过<strong>穷举搜索</strong>的方式</li></ul></li></ul><h4 id="有结构文件">有结构文件</h4><ul><li><p><strong>基本概念</strong>：</p><ul><li>指由一个以上的记录构成的文件，又称<strong>记录式文件</strong></li><li>各记录由相同或不相同的数据项组成</li></ul></li><li><p>根据各记录的<strong>长度是否相等</strong>，可分为：</p><ul><li><strong>定长记录</strong>：<ul><li>文件中所有记录的长度相同</li><li>各数据项都在记录中的相同位置，具有相同的长度</li><li><strong>特点</strong>：检索记录的速度快，方便用户对文件进行处理，广泛用于数据处理中</li></ul></li><li><strong>变长记录</strong>：<ul><li>文件中各记录的长度不一定相同</li><li>记录中所包含的数据项数目可能不同，数据项本身的长度可能不同</li><li><strong>特点</strong>：检索记录只能顺序查找，速度慢</li></ul></li></ul></li><li><p>根据记录的<strong>组织形式</strong>，可分为：</p></li></ul><h5 id="顺序文件">顺序文件</h5><ul><li>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的</li><li>各个记录在<strong>物理上</strong>有两种存储方式：<ul><li><strong>顺序存储</strong>：<ul><li>逻辑上相邻的记录物理上也相邻</li><li><strong>可变长记录</strong>：<strong>无法实现随机存取</strong>，每次只能从第一个记录开始依次往后查找</li><li><strong>定长记录</strong>：<ul><li><strong>可以实现随机存取</strong></li><li>若采用串结构，无法快速找到某关键字对应的记录</li><li>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）</li></ul></li></ul></li><li><strong>链式存储</strong>：<ul><li>逻辑上相邻的记录物理上不一定相邻（类似于链表）</li><li>无论是定长/可变长记录，都无法实现随机存取</li></ul></li></ul></li><li>顺序文件中记录的排列有两种结构：<ul><li><strong>串结构</strong>：各记录之间的顺序与关键字无关</li><li><strong>顺序结构</strong>：记录之间的顺序按关键字顺序排列</li></ul></li><li><strong>注意</strong>：<ul><li>对记录进行<strong>批量操作</strong>，即每次要读或写一大批记录时，顺序文件的<strong>效率</strong>是所有逻辑文件中<strong>最高</strong>的</li><li>对于顺序存储设备（如磁盘），只有顺序文件才能被存储并能有效地工作</li><li>在需要经常增删改查单个记录的场合，性能较差</li></ul></li></ul><h5 id="索引文件">索引文件</h5><ul><li>建立一张<strong>索引表</strong>，为主文件的<strong>每个记录</strong>在索引表中分别<strong>设置一个索引表项</strong>，其中包含<strong>指向记录的指针</strong>和<strong>记录长度</strong></li><li>索引表按关键字排序，其本身也<strong>是一个定长记录的顺序文件</strong></li><li>将<strong>对变长记录顺序文件</strong>的检索转变成对记录索引文件的随机检索，从而<strong>加快了记录的检索速度</strong></li><li>主要用于对信息处理的及时性要求比较高的场合<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525155737.png" alt="image.png"></li></ul><h5 id="索引顺序文件">索引顺序文件</h5><ul><li>是索引文件和顺序文件思想的结合</li><li>先将变长记录顺序文件中的所有记录分为若干组，然后为文件建立一张索引表</li><li>为<strong>每组中的第一个记录建立一个索引项</strong>，包含该记录的<strong>关键字</strong>和<strong>指向该记录的指针</strong></li><li>同一组内的关键字可以无序，组与组之间的关键字必须有序<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525160520.png" alt="image.png"></li><li>检索效率分析：<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525160652.png" alt="image.png"></li></ul><h5 id="直接文件或散列文件（Hash-File）">直接文件或散列文件（Hash File）</h5><ul><li>给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址</li><li>这种映射结构不同于顺序文件或索引文件，<strong>没有顺序的特性</strong></li><li>散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同</li></ul><h3 id="文件的物理结构">文件的物理结构</h3><ul><li>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？</li><li>（逻辑块号，块内地址）—&gt;（物理块号，块内地址）【只需转换块号就行，块内地址保<br>持不变】</li></ul><h4 id="连续分配">连续分配</h4><ul><li>文件的目录项记录<strong>起始块号</strong>和<strong>所占用的块数</strong></li><li>要求<strong>每个文件在磁盘上占有一组连续的块</strong></li><li>磁盘地址定义了磁盘上的一个线性排序，使作业访问磁盘时需要的寻道数和寻到时间最小</li><li><strong>优点</strong>：<ul><li>支持顺序访问和直接访问（即随机访问）</li><li>连续分配的文件在顺序访问时速度最快</li></ul></li><li><strong>缺点</strong>：<ul><li>文件长度不宜动态增加</li><li>存储空间利用率低，反复增删文件后会产生外部碎片</li><li>很难确定一个文件需要的空间大小，因此只适用于长度固定的文件<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525170229.png" alt="image.png"></li></ul></li></ul><h4 id="链接分配">链接分配</h4><h5 id="隐式链接">隐式链接</h5><ul><li>目录项中记录了文件存放的<strong>起始块号</strong>和<strong>结束块号</strong></li><li>每个文件对应一个磁盘块的链表，磁盘块分布在磁盘的任何地方</li><li>除最后一个盘块外，每个盘块都含有指向文件下一个盘块的指针，这些<strong>指针对用户是透明的</strong></li><li><strong>优点</strong>：<ul><li>方便文件拓展，不会有碎片问题，外存利用率高</li></ul></li><li><strong>缺点</strong>：<ul><li>只适合顺序访问，不支持随机访问，查找效率低</li><li>稳定性问题，文件盘块中的任何一个指针出问题，都会导致文件数据的丢失</li><li>指向下一个盘块的指针也要耗费一定的存储空间</li></ul></li><li>为了提高查找速度和减小指针所占空间，可以将几个盘块组成一个簇，按簇分配，可以大幅减少查找时间，但增加了内部碎片<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525170710.png" alt="image.png"></li></ul><h5 id="显式链接">显式链接</h5><ul><li>指把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显式地存放在内存的一张链接表</li><li>该表在<strong>整个磁盘中仅设置一张</strong>，称为<strong>文件分配表 FAT</strong></li><li>开机时文件分配表放入内存，并<strong>常驻内存</strong></li><li>文件目录中只需记录<strong>文件的起始块号</strong>，后续块号可通过查 FAT</li><li><strong>优点</strong>：<ul><li>很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问</li><li>相比于隐式链接来说，<strong>地址转换时不需要访问磁盘，因此文件的访问效率更高</strong></li></ul></li><li><strong>缺点</strong>：<ul><li>文件分配表的需要占用一定的存储空间<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525171646.png" alt="image.png"></li></ul></li></ul><h4 id="索引分配">索引分配</h4><h5 id="单级索引分配">单级索引分配</h5><ul><li>将每个文件所有的盘块号集中地放在一起，当访问到某个文件时，将该文件对应的盘块号一起调入内存</li><li>为<strong>每个文件分配一个索引块（表）</strong>，存放分配给<strong>该文件的所有盘块号</strong></li><li>假如盘块大小为 4 KB，每个盘块号占 4 B，则一个索引块中可放 1024 个盘块号，支持最大文件为 1024 * 4 KB = 4 MB</li><li><strong>优点</strong>：<ul><li>支持直接访问</li><li>不会产生外部碎片</li></ul></li><li><strong>缺点</strong>：<ul><li>索引块增加了额外的存储空间开销</li><li>当文件很小时，比如只有数个盘块，此时索引块的利用率很低</li><li>当文件很大时，若其盘块号占用若干索引块，可通过链指针将各索引块按序链接起来，但是很查找效率低下<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525173851.png" alt="image.png"></li></ul></li></ul><h5 id="多级索引分配">多级索引分配</h5><ul><li>文件太大而索引块太多时，为这些索引块再建立一级索引，称为<strong>主索引</strong></li><li>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块需要 K+1 次读磁盘操作</li><li>假如盘块大小为 4 KB，每个盘块号占 4 B，则一个索引块中可放 1024 个盘块号，支持最大文件为 1024 * 1024 * 4 KB = 4 GB</li><li><strong>优点</strong>：极大加快了对大型文件的查找速度</li><li><strong>缺点</strong>：当访问一个盘块时，其所要启动磁盘的次数随着索引级数的增加而增多<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525174427.png" alt="image.png"></li></ul><h5 id="混合索引分配">混合索引分配</h5><ul><li>全面照顾到小型、中星、大型和特大型文件</li><li><strong>直接地址</strong>：<ul><li>地址项 0~9 存放直接地址，即文件数据块的盘块号</li><li>假如每个盘块大小为 4 KB，适用于不大于 40 KB 的文件</li><li>提高了对小文件的检索速度</li></ul></li><li><strong>一次间接地址</strong>：<ul><li>地址项 10 提供，即采用一级索引分配</li><li>一次间接地址中记录了文件的一次间址块号，一次间址块就是索引块，记录了文件数据块的盘块号</li><li>一次间址块中可存放 1024 个盘块号，允许最大文件长度 4 MB + 40 KB</li></ul></li><li><strong>多次间接地址</strong>：<ul><li>地址项 11 提供二次间接地址，即采用两级索引分配</li><li>允许最大文件长度 4 GB + 4 MB + 40 KB<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240525175037.png" alt="image.png"></li></ul></li></ul><h2 id="目录">目录</h2><h3 id="文件目录的实现">文件目录的实现</h3><ul><li>一个文件对应一个 FCB，一个 FCB 就是一个目录项，多个 FCB 组成文件目录</li><li>对目录的操作：搜索、创建文件、删除文件、显示文件、修改文件</li><li>目录管理的基本要求：<ul><li>从用户角度，实现“按名存取”</li><li>提高对目录的检索速度</li><li>多用户系统中，提供用于控制访问文件的信息，允许文件共享</li><li>允许不同用户对不同文件采用相同的名字</li></ul></li></ul><h3 id="目录结构">目录结构</h3><h4 id="单级目录结构">单级目录结构</h4><ul><li><strong>定义</strong>：<ul><li>整个文件系统只建立一张目录表</li><li>每个文件占一个目录项</li></ul></li><li><strong>优点</strong>：实现了 “按名存取”</li><li><strong>缺点</strong>：<ul><li>查找速度慢、文件不允许重名、不便于文件共享</li><li>对于多用户的操作系统不适用<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526160628.png" alt="image.png"></li></ul></li></ul><h4 id="两级目录结构">两级目录结构</h4><ul><li><strong>定义</strong>：<ul><li>文件目录分为<strong>主文件目录 MDF</strong> 和<strong>用户文件目录 UFD</strong></li><li>MDF 记录用户名及相应 UFD 所在的存储位置</li><li>UFD 记录用户所有文件的 FCB</li></ul></li><li><strong>优点</strong>：<ul><li>解决了多用户之间的文件重名问题</li><li>文件系统可以在目录上实现访问限制</li></ul></li><li><strong>缺点</strong>：<ul><li>缺乏灵活性，不能对文件分类</li></ul></li></ul><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526160843.png" alt="image.png"></p><h4 id="树形目录结构">树形目录结构</h4><ul><li><strong>定义</strong>：<ul><li>当用户要访问某个文件时，用文件的路径名标识文件，<strong>文件路径名是个字符串</strong>，由从根目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成</li><li>从根目录出发的路径称为<strong>绝对路径</strong></li><li>当层次较多时，每次从根目录查询会浪费时间，于是加入了<strong>当前目录</strong>（又称<strong>工作目录</strong>），进程对各文件的访问都是相对于当前目录进行的</li><li>当用户要访问某个文件时，使用<strong>相对路径</strong>标识文件</li><li>不同的用户的文件，文件名可相同可不同</li><li>大多 OS 采用这种目录结构</li></ul></li><li><strong>优点</strong>：<ul><li>可以很方便的对文件进行分类</li><li>能够有效地进行文件的管理和保护</li></ul></li><li><strong>缺点</strong>：<ul><li>不便于实现文件共享</li><li>查找文件增加了磁盘访问次数，会影响查询速度</li></ul></li><li>下图是 Linux 操作系统的目录结构，&quot;/dev/hda” 就是一个绝对路径</li><li>若当前目录为 “/bin”，则 &quot;./Is” 就是一个相对路径，其中符号 “.” 表示当前工作目录<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526163436.png" alt="image.png"></li></ul><h4 id="无环图目录结构">无环图目录结构</h4><ul><li><strong>定义</strong>：<ul><li>在树形目录结构上，增加一些指向同一节点的有向边，使整个目录成为一个<strong>有向无环图</strong></li><li>可以<strong>用不同的文件名指向同一个文件</strong>，甚至可以指向<strong>同一个目录</strong>【共享同一目录下的所有内容】</li><li>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点</li><li>用户提出删除结点的请求时，只是删除该用户的 FCB、并使<strong>共享计数器减 1</strong>，并不会直接删除共享结点</li><li>只有共享计数器减为 0 时，才删除结点</li></ul></li><li><strong>优点</strong>：实现了文件共享</li><li><strong>缺点</strong>：使得系统管理变得更加复杂<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526164150.png" alt="image.png"></li></ul><h3 id="索引节点-2">索引节点</h3><ul><li>除了文件名之外的所有信息都放到索引节点中，每个文件对应一个索引节点</li><li>目录项中只包含文件名、索引节点指针，因此每个目录项的长度大幅减小</li><li>每个磁盘块可以存放更多个目录项，因此线索文件时磁盘 I/O 的次数就少了很多</li></ul><h3 id="文件共享">文件共享</h3><ul><li>文件共享使多个用户共享同一个文件，<strong>系统只需保留该文件的一个副本</strong></li></ul><h4 id="基于索引节点的共享方式（硬链接）">基于索引节点的共享方式（硬链接）</h4><ul><li><strong>定义</strong>：<ul><li>硬链接就是多个指针指向一个索引节点</li><li>文件的物理地址和其他文件属性信息放在索引节点中</li><li>索引节点中需要有链接计数 count</li><li>某用户想删除文件时，只是删除该用户的目录项，count–</li><li>只有 count == 0 时才能真正删除文件数据和索引节点，否则会导致指针悬空</li></ul></li><li><strong>特点</strong>：<ul><li>不可用于跨文件系统</li><li>查找速度比软链接快<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526170945.png" alt="image.png"></li></ul></li></ul><h4 id="基于符号链的共享方式（软链接）">基于符号链的共享方式（软链接）</h4><ul><li><strong>定义</strong>：<ul><li>在一个 Link 型的文件中记录共享文件的存放路径（类似于 Windows 系统中的快捷方式）</li><li>OS 根据路径一层层查找目录，最终找到共享文件</li><li>只有文件主才拥有指向索引节点的指针</li><li>共享文件的其他用户只有该文件的路径名，并不拥有指向其索引节点的指针</li></ul></li><li><strong>特点</strong>：<ul><li>访问共享文件时可能多次地读磁盘，增加了访问文件的开销</li><li>实现网络文件共享时，只需提供该文件所在机器的网络地址及文件路径名<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526171604.png" alt="image.png"></li></ul></li></ul><h2 id="文件系统">文件系统</h2><h3 id="文件系统的基本概念">文件系统的基本概念</h3><ul><li><strong>概念</strong>：<ul><li>文件系统是 OS 中负责管理持久数据的子系统</li><li>文件系统 = 与文件管理有关的软件 + 被管理的文件 + 试试文件管理所需的数据结构</li><li>文件系统需先挂在到某个目录才可正常使用</li><li>文件的基本操作单位就是数据块</li></ul></li><li><strong>目标</strong>：<ul><li><strong>用户角度</strong>：实现对文件的基本操作，如按名存储和查找文件 + 组织成合适的结构 + 文件共享 + 文件保护</li><li><strong>OS 角度</strong>：<ul><li>管理与磁盘的信息交换 + 完成逻辑结构和物理结构的变换</li><li>组织文件在磁盘上的存放 + 采取好的文件排放顺序和磁盘调度方法</li></ul></li></ul></li><li><strong>分类</strong>：<ul><li><strong>磁盘的文件系统</strong>：<ul><li>它是直接把数据存储在磁盘中，比如 Ext 2/3/XFS 等都是这类文件系统</li></ul></li><li><strong>内存的文件系统</strong>：<ul><li>这类文件系统的数据不是存储在硬盘的，而是占用内存空间</li><li>我们经常用到的 /proc 和 /sys 文件系统都属于这一类</li><li>读写这类文件，实际上是读写内核中相关的数据</li></ul></li><li><strong>网络的文件系统</strong>：<ul><li>用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等</li></ul></li></ul></li></ul><h3 id="文件系统结构">文件系统结构</h3><h4 id="王道-ppt-版">王道 ppt 版</h4><ul><li>假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后 100 条记录：</li><li><strong>用户接口</strong>：用户需要通过操作系统提供的接口发出上述请求</li><li><strong>文件目录系统</strong>：由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项</li><li><strong>存取控制模块（存取控制验证层）</strong>：不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限</li><li><strong>逻辑文件系统与文件信息缓冲区</strong>：验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址</li><li><strong>物理文件系统</strong>：知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址</li><li><strong>设备管理程序模块</strong>： 要删除这条记录，必定要对磁盘设备发出请求</li><li><strong>辅助分配模块</strong>：删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526173040.png" alt="image.png"></li></ul><h4 id="王道书版">王道书版</h4><ul><li><strong>I/O 控制</strong>：<ul><li>设备驱动程序：将输入的命令翻译成底层硬件的特定指令</li><li>中断处理程序：利用指令使 IO 设备与系统交互</li></ul></li><li><strong>基本文件系统</strong>：<ul><li>向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块</li><li>管理内存缓冲区，保存各种文件系统，目录和数据块的缓冲</li></ul></li><li><strong>文件组织模块</strong>：<ul><li>组织文件及其逻辑块和物理块</li><li>可以将逻辑地址转换为物理地址</li><li>有空闲空间管理器，以跟踪未分配的块，根据需要提供给文件组织模块</li></ul></li><li><strong>逻辑文件系统</strong>：<ul><li>用于管理元数据信息（包括文件系统的所有结构，不包括文件内容）</li><li>管理目录结构</li><li>通过 FCB 维护文件结构</li><li>负责文件保护<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240526175805.png" alt="image.png"></li></ul></li></ul><h3 id="文件系统布局">文件系统布局</h3><h4 id="文件系统在磁盘中的结构">文件系统在磁盘中的结构</h4><ul><li>文件系统存放在磁盘上，多数磁盘划分为一个或多个分区</li><li>每个分区中有一个独立的文件系统</li><li>文件系统可能包含如下信息：<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527192819.png" alt="image.png"></li><li><strong>主引导记录（MBR）</strong>：<ul><li>位于磁盘的 0 号区，用来引导计算机</li><li>MBR 后面是分区表，给出每个分区的起始和结束地址</li><li>表中的第一个分区被标记为活动分区，当计算机启动时，计算机读入并执行 MBR</li><li>MBR 做的第一件事就是确定 1 活动分区，读入它的第一块，即引导块</li></ul></li><li><strong>引导块</strong>：<ul><li>Windows 系统称之为分区引导扇区</li><li>MBR 执行引导块中的程序后，该程序负责启动该分区中的操作系统</li><li>每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统</li><li>除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的</li></ul></li><li><strong>超级块</strong>：<ul><li>包含文件系统的所有关键信息</li><li>比如：分区的块的数量、块的大小、空闲块的数量和指针、空闲的 FCB 数量和 FCB 指针等</li><li>在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存</li></ul></li><li><strong>文件系统中空闲块的信息</strong>：使用位示图或指针链接的形式给出</li><li><strong>i 节点</strong>：每个文件对应一个 i 节点，说明了文件的方方面面</li><li><strong>根目录</strong>：存放文件系统目录树的根部</li><li>最后，磁盘的其他部分存放了其他所有的<strong>目录和文件</strong></li></ul><h4 id="文件系统在内存中的结构">文件系统在内存中的结构</h4><ul><li>内存中的信息用于管理文件系统并通过缓存来提高信息</li><li>这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃</li><li>这些结构的类型可能包括：<ul><li>内存中的<strong>安装表</strong>：包含每个已安装文件系统分区的有关信息</li><li>内存中的<strong>目录结构的缓存</strong>：包含最近访问目录的信息</li><li>整个系统的打开文件表</li><li>每个进程的打开文件表</li></ul></li></ul><h3 id="外存空闲空间管理">外存空闲空间管理</h3><ul><li>一个磁盘可以划分为多个分区，每个分区够可以有单独的文件系统</li><li><strong>卷</strong>：<ul><li>包含文件系统的分区【可以是磁盘的一部分/整个磁盘/多个磁盘组成的 RAID 集】</li><li><strong>文件区</strong>：存放文件数据的空间</li><li><strong>目录区</strong>：FCB 的空间</li><li>卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527201721.png" alt="image.png"></li></ul></li><li>文件存储设备分成许多大小相同的物理块，并<strong>以块为单位交换信息</strong></li><li>文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题</li></ul><h4 id="空闲表法">空闲表法</h4><ul><li>属于<strong>连续分配方式</strong>，为每个分区文件分配一块连续的存储空间</li><li>在外存上为所有空闲区建立<strong>一张空闲表</strong></li><li>每个空闲区对应一个<strong>空闲表项</strong>，包括：<ul><li>表项序号</li><li>该空闲区的第一个空闲盘块号</li><li>该空闲区的空闲盘块数</li></ul></li><li>按起始盘块号递增的次序对空闲区排列<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527201856.png" alt="image.png"></li><li><strong>如何分配磁盘块</strong>：<ul><li>与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间</li><li>同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间</li></ul></li><li><strong>如何回收磁盘块</strong>：<ul><li>与内存管理中的动态分区分配很类似，有四种情况</li><li>回收时需要<strong>注意表项的合并问题</strong></li></ul></li></ul><h4 id="空闲链表法">空闲链表法</h4><h5 id="空闲盘块链">空闲盘块链</h5><ul><li>将磁盘上的所有空闲空间以盘块为单位拉成一条链</li><li>每个盘块都有指向下一个空闲盘块的指针</li><li>当用户请求分配存储空间时：系统从链首开始，依次摘下适当数目的空闲盘块分配给用户</li><li>当用户释放存储空间时：系统将回收的盘块依次插入空闲盘块链的末尾</li><li><strong>优点</strong>：<ul><li>分配和回收一个盘块的过程非常简单</li><li>适用于离散分配的物理结构</li></ul></li><li><strong>缺点</strong>：<ul><li>在为一个文件分配盘块时可能要重复操作多次，效率较低</li><li>以盘块为单位，链会很长<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527202717.png" alt="image.png"></li></ul></li></ul><h5 id="空闲盘区链">空闲盘区链</h5><ul><li>指将磁盘上的所有空闲盘区拉成一条链，每个盘区包含若干相邻的盘块</li><li>每个盘区含有下一个空闲盘区的指针和本盘区的盘块数</li><li>分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法</li><li>回收盘区时，同样也要将回收区与相邻接的空闲盘区合并</li><li><strong>优点</strong>：是分配与回收的效率较高，且空闲盘区链较短</li><li><strong>缺点</strong>：是分配与回收的过程比较复杂<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527203008.png" alt="image.png"></li></ul><h4 id="位示图法">位示图法</h4><ul><li>利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应【0 代表盘块空闲，1 代表盘块已分配】</li><li><strong>盘块的分配</strong>：<ol><li>顺序扫描位示图，从中找出一个或一组其值为 “0” 的二进制位</li><li>将找到的一个或一组二进制位，转换成与之对应的盘块号 b = n (i -  + j</li><li>修改位示图 0 --&gt; 1</li></ol></li><li><strong>盘块的回收</strong>：<ul><li>将回收盘块的盘块号转换成位示图中的行号和列号：<ul><li>i = (b -  DIV n + 1</li><li>j = (b -  MOD n + 1</li></ul></li><li>修改位示图 1 --&gt; 0</li></ul></li><li><strong>优点</strong>：<ul><li>很容易在位示图中找到一个或一组相邻接的空闲盘块</li><li>占用空间少，可将其保存在内存中，节省磁盘启动的开销</li></ul></li><li><strong>缺点</strong>：<ul><li>位示图大小会随着磁盘容量的增加而增大，故常用于小型计算机<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527203347.png" alt="image.png"></li></ul></li></ul><h4 id="成组链接法">成组链接法</h4><ul><li><strong>基本思想</strong>：<ul><li>将空闲盘块分成若干个组，<strong>每组的第一个盘块记录下一组的空闲盘块总数和空闲盘块号</strong></li><li>由各组的第一个盘块可以链接成一条链</li><li>第一组的空闲盘块总数和空闲盘块号保存在<strong>内存</strong>的专用栈中，称为<strong>空闲盘块号栈</strong></li></ul></li><li><strong>盘块的分配</strong>：<ul><li>根据空闲盘块号栈的指针，将与之对应的盘块分配给用户，同时移动指针</li><li>若该指针指向的是栈底的盘块号，则由于该盘块号对应的盘块中保存的是下一组空闲盘块号，因此要将该盘块的内容读入栈中，作为新的空闲盘块号栈的内容，并将原栈底盘块号对应的盘块分配出去 ( 其中有用的数据已读入栈中)</li><li>最后，将栈中的空闲盘块数减 1</li></ul></li><li><strong>盘块的回收</strong>：<ul><li>将回收的盘块号存入空闲盘块号栈的顶部，同时移动指针，并将栈中的空闲盘块数加 1</li><li>当栈中的空闲盘块数已达 100 时，表示栈已满，将现有栈中的 100 个空闲盘块号存入新回收的盘块，并将新回收的盘块号作为新栈底，再将栈中的空闲盘块数置为 1<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527212600.png" alt="image.png"></li></ul></li></ul><h3 id="虚拟文件系统">虚拟文件系统</h3><ul><li><strong>虚拟文件系统（VFS）</strong>：屏蔽了不同文件系统的差异和操作细节，向上为用户提供了文件操作的同一调用接口<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527214116.png" alt="image.png"></li><li><strong>特点</strong>：<ul><li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li><li>VFS 要求下层的文件系统必须实现某些规定的函数功能（open/read/write）</li><li>一个新的文件系统想要在某 OS 上被使用，则必须满足 VFS 的要求</li><li>每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统【vnode 的功能指针指向具体文件系统的函数功能】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240527214800.png" alt="image.png"></li></ul></li></ul><h3 id="文件系统挂载">文件系统挂载</h3><ul><li><strong>文件系统挂载（mounting）</strong>：文件系统在进程使用之前必须先挂载到某个目录，此后便可通过这个目录来访问设备上的文件</li><li><strong>注意</strong>：这里的设备是<strong>逻辑上</strong>的设备，如一个磁盘上的不同分区都可视为不同的设备</li><li><strong>挂载过程</strong>：<ol><li>在 VFS 中注册新挂载的文件系统，<strong>内存中的挂载表</strong>包含每个文件系统的相关信息，包括文件系统类型、容量大小等</li><li>新挂载的文件系统，要向 VFS 提供一个<strong>函数地址列表</strong></li><li>将新文件系统加到<strong>挂载点</strong>，也就是将新文件系统挂载到某个父目录下</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件逻辑结构（流式 / 记录式） </tag>
            
            <tag> 文件物理结构（连续 / 链接 / 索引） </tag>
            
            <tag> 目录结构（树形 / 无环图） </tag>
            
            <tag> 索引节点（i节点） </tag>
            
            <tag> 外存空闲管理（位示图 / 成组链接） </tag>
            
            <tag> 文件共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 4 章 指令系统</title>
      <link href="/post/b93e5f6d.html"/>
      <url>/post/b93e5f6d.html</url>
      
        <content type="html"><![CDATA[<h2 id="指令系统">指令系统</h2><h3 id="指令集体系结构">指令集体系结构</h3><ul><li><p><strong>指令【机器指令】</strong>：指示计算机执行某种操作的命令，是计算机运行的<strong>最小功能单位</strong><br>操作码OP【一个】+指令码A【几个】</p></li><li><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码</p></li><li><p>一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令</p></li><li><p><strong>指令集</strong>：一台计算机能执行的<strong>机器指令</strong>的集合称为该机的<strong>指令系统</strong>，也称为<strong>指令集</strong><br>由于冯诺依曼架构，指令与数据共存于主存，按顺序执行，默认每执行一条指令后 PC +1 ；分支 / 调用指令可显式修改 PC 值。<br>所以机器指令需要显式或隐式的表示：</p><ul><li>操作码（+ , - , * , / ,移位等）</li><li>源操作数/地址：指定参与运算数据位置</li><li>结果地址：指定运算结果存放处</li><li>下一条指令地址：多由 PC 隐式管理，显式跳转指令可指定新地址<br>操作码必显式；地址字段依指令类型显式编码。<br>PC 自动递增；部分指令有默认寄存器；堆栈操作隐含栈顶地址。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424203342250.png" alt="image.png"></li></ul></li><li><p>指令系统是<strong>指令集体系结构（ISA)</strong> 中最核心的部分</p></li><li><p>ISA 规定的内容主要包括：</p><ul><li><strong>指令格式</strong>，<strong>指令寻址方式</strong>，<strong>操作类型</strong>，以及每种<strong>操作对应的操作数</strong>的相应规定</li><li><strong>操作数的类型</strong>，<strong>操作数寻址方式</strong>，以及是按<strong>大端方式</strong>还是按<strong>小端方式</strong>存放</li><li>程序可访问的<strong>寄存器编号、个数和位数</strong>，<strong>存储空间的大小和编址方式</strong></li><li>指令执行过程的<strong>控制方式</strong>等，包括<strong>程序计数器</strong>、<strong>条件码定义</strong>等</li></ul></li></ul><p>1A-32系统（如 Intel x86 架构的 32 位系统）中，指令的 <strong>地址码（Address Field）</strong> 的位数可以 <strong>没有、1 位 或 2 位</strong>，这主要取决于 <strong>指令的寻址方式</strong> 和 <strong>操作数的来源</strong>。</p><h3 id="指令格式">指令格式</h3><h4 id="基本指令结构">基本指令结构</h4><ul><li>一条指令通常要包括操作码字段和地址码字段</li><li><strong>操作码</strong>：指出该指令应执行什么操作以及具有何种功能【用户要干什么】|<br>长度取决于指令系统中的指令条数<br>eg.操作码占7位，则该机器最多包含2^7=128条指令。</li><li><strong>地址码</strong>：用来描述该指令的操作对象，或者直接给出操作数，或者指出操作数的<mark>存储器地址</mark>或<mark>寄存器地址</mark>(即寄存器名)。【对谁操作】<br>提供地址码的方式：<ul><li>显地址方式：指令中明显指明地址（直接或间接给出）</li><li>隐地址方式：地址隐含约定，不出现在指令中<br>使用隐地址可以减少指令中的地址数，简化地址结构</li></ul></li><li>指令的地址由程序计数器给出<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240422215027.png" alt="image.png"></li></ul><h4 id="指令的分类">指令的分类</h4><ol><li>按指令长度分类<br>指令字长指一条指令包含的二进制位数，由 <strong>操作码长度、地址码长度、地址码个数</strong> 共同决定</li></ol><p>半字长、单字长、双字长指令指的是指令长度是机器字长的多少倍<br>指令字长会影响取指令所需时间。eg.机器字长=存储字长=16bit，则取一条双字长指令需要两次访存</p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>单字长指令</strong></td><td>指令长度 = 机器字长（如 32 位机器中指令占 32 位）</td><td>1 次访存即可完整取出指令，效率高。</td></tr><tr><td><strong>双字长指令</strong></td><td>指令长度 = 2 个机器字长（如 32 位机器中指令占 64 位）</td><td>需 2 次访存，耗时较长，用于复杂操作（如长立即数或大范围地址）。</td></tr><tr><td><strong>半字长指令</strong></td><td>指令长度 = 半个机器字长（如 32 位机器中指令占 16 位）</td><td>节省存储空间，但需对齐处理（主存按字节编址时需补足为完整字长）。</td></tr></tbody></table><ol start="2"><li>按是否定长分类<ul><li><strong>定长指令字结构</strong>：所有指令的长度都是相等的，执行速度快，控制简单</li><li><strong>变长指令字结构</strong>：指令的长度随功能而异<br>主存一般按字节编制，所以<strong>指令字长多为字节的整数倍</strong></li></ul></li></ol><h4 id="具体指令结构">具体指令结构</h4><ul><li>下图指令字长 32 位：<ul><li>【操作码 (OP) 8 位】+【地址码 (A) 共 4 个，每个 6 位】</li></ul></li><li>指令访问内存的过程：<ul><li>首先 000000 这个位置上存放着操作指令</li><li>$A_1$，$A_2$ 上存着两串数</li><li>他们在 000000 指令的执行下，要进行加法操作，将结果填入到 $A_3$ 中</li><li>$A_3$ 中的数据就是 $A_1$ + $A_2$ 的和</li><li>最后再去 $A_4$ 读取出指令，开始下一轮工作</li></ul></li><li>内存中既有操作码，又有地址码，这样把他们放在一起并不好可以优化他们<ul><li>把操作码放一起，地址码放一块</li><li>通过程序计数器使操作码 +1 顺序执行</li></ul></li><li>优化后的好处：<ul><li>将操作码放一块，我们可以让程序执行完一步就自动执行下一句指令</li><li>这样我们的指令就不用存放下一条指令的位置了</li><li>这样访存的次数少了一次，速度也会快点</li><li>如无例外（如跳转指令），执行完就直接下一条继续，也就是顺序执行</li></ul></li></ul><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240422220641.png" alt="image.png"></p><h4 id="指令地址码">指令地址码</h4><h5 id="零地址指令">零地址指令</h5><p>只给出操作码 OP，没有显示地址，操作数来源隐含。<br>访存次数：1 次（仅取指令）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423175431.png" alt="image.png"></p><ol><li>不需要操作数的指令：<strong>空操作</strong>指令，<strong>停机</strong>指令，<strong>关中断</strong>指令<br><code>NOP</code>（空操作）：无操作数，地址码为 0 位。</li><li>堆栈计算机，两个操作数来自<strong>堆栈</strong>的<font color="#ff0000">栈顶和次栈顶单元</font>【基于后缀表达式】<br><code>RET</code>（从子程序返回）：操作数隐含在栈顶，无需显式地址码<br>堆栈指令的访存次数，取决于采用的是软堆栈还是硬堆栈。<br>若是<strong>软堆栈</strong>(堆栈区由<strong>内存</strong>实现)，则对于双目运算需要访问<strong>4次</strong>内存：取指令、取源数 取源数2、存结果。<br>若是<strong>硬堆栈</strong>(堆栈区由<strong>寄存器</strong>实现)，则只需在取指令时访问<strong>1次</strong>内存。</li></ol><h5 id="一地址指令">一地址指令</h5><p>含 1 个地址码，操作数可能是<strong>寄存器、立即数或隐含位置</strong>。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423180024.png" alt="image.png"></p><ol><li>只有目的操作数的<strong>单操作数</strong>指令：<ul><li>OP ($A_1$) -&gt; $A_1$<br>注：$A_1$指某个主存地址，$(A_1)$指$A_1$所指向的地址中的内容</li><li>eg.自增、自减、取反、求补</li><li>若地址码字段均为主存地址，完成一条指令需要 3 次访存（取指 -&gt; 读 $A_1$ -&gt; 写 $A_1$）<br>如 <code>INC [A1]</code>：3 次（取指令 → 读 <code>A1</code> → 写 <code>A1</code>）</li></ul></li><li><strong>隐含</strong>约定目的地址的<strong>双操作数</strong>指令<ul><li>(ACC) OP ($A_1$) -&gt; ACC</li><li>另一个操作数由 ACC（累加器）提供</li><li>完成一条指令需要 2 次访存（取指 -&gt; 读 $A_1$）<br><code>ADD ACC, [A1]</code>：2 次（取指令 → 读 <code>A1</code>，结果存 <code>ACC</code>【存回ACC不需要访存】）。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INC [0x1000]   ; 内存地址 0x1000 的值加 1</span><br><span class="line">ADD ACC, [0x2000] ; ACC = ACC + [0x2000]</span><br></pre></td></tr></table></figure><h5 id="二地址指令">二地址指令</h5><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423175953.png" alt="image.png"></p><ul><li>($A_1$) OP ($A_2$) -&gt; $A_1$</li><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>完成一条指令需要 4 次访存（取指 -&gt; 读 $A_1$ -&gt; 读 $A_2$ -&gt; 写 $A_1$）</li></ul><h5 id="三地址指令">三地址指令</h5><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423175606.png" alt="image.png"></p><ul><li>常用于需要两个操作数的算术运算、逻辑运算相关指令</li><li>($A_1$) OP ($A_2$) -&gt; $A_3$</li><li>完成一条指令需要 4 次访存（取指 -&gt; 读 $A_1$ -&gt; 读 $A_2$ -&gt; 写 $A_3$）</li></ul><h5 id="四地址指令">四地址指令</h5><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423180042.png" alt="image.png"></p><ul><li>($A_1$) OP ($A_2$) -&gt; $A_3$，$A_4$ =下一条将要执行指令的地址</li><li>正常情况下：取指令之后 PC + 1，指向下一条指令</li><li>四地址指令：执行指令后，将 PC 的值修改为 $A_4$ 所指地址</li><li>完成一条指令需要 4 次访存（取指 -&gt; 读 $A_1$ -&gt; 读 $A_2$ -&gt; 写 $A_3$）</li></ul><table><thead><tr><th><strong>类型</strong></th><th><strong>格式</strong></th><th><strong>访存次数</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>二地址指令</strong></td><td><code>OP A1, A2</code></td><td>4 次</td><td>算术运算（如 <code>ADD A1, A2</code> → <code>A1 = A1 + A2</code>）</td></tr><tr><td><strong>三地址指令</strong></td><td><code>OP A1, A2, A3</code></td><td>4 次</td><td>结果存独立地址（如 <code>A3 = A1 + A2</code>）</td></tr><tr><td><strong>四地址指令</strong></td><td><code>OP A1, A2, A3, A4</code></td><td>4 次</td><td>跳转指令（如 <code>A4</code> 指定下一条指令地址）</td></tr></tbody></table><ul><li><strong>访存过程</strong>：<ul><li><strong>二地址</strong>：取指令 → 读 <code>A1</code> → 读 <code>A2</code> → 写 <code>A1</code>。</li><li><strong>四地址</strong>：执行后直接跳转至 <code>A4</code>，无需 <code>PC+1</code>。<br>正常情况下，取指令后PC+1，指向下一条指令</li></ul></li></ul><p><strong>地址码位数的影响</strong>：</p><ul><li><strong>直接寻址范围</strong>：$\text{寻址范围} = 2^{\text{地址码位数}}$<ul><li>若地址码为 <code>n</code> 位，可寻址 <code>2^n</code> 个存储单元。</li></ul></li><li><strong>指令总长固定时的权衡</strong>：<ul><li>地址码数量↑ =&gt; 单个地址码位数↓ =&gt; 寻址能力↓。</li><li>例如：32 位定长指令中，二地址指令每个地址占 12 位（寻址 4KB），三地址指令每个地址占 8 位（寻址 256B）。</li></ul></li></ul><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th><th><strong>示例/说明</strong></th></tr></thead><tbody><tr><td><strong>指令字长</strong></td><td>一条指令的总位数（如 x86 指令可为 1~15 字节）</td><td><strong>变长</strong>设计提高灵活性。</td></tr><tr><td><strong>机器字长</strong></td><td>CPU 一次整数运算处理的位数（如 64 位 CPU）</td><td>字长不变。决定<strong>寄存器大小和 ALU 宽度</strong>。</td></tr><tr><td><strong>存储字长</strong></td><td>一个存储单元的位数（如 64 位内存条的存储字长为 64 位）</td><td>与 <strong>MDR</strong>（内存数据寄存器）位数一致。</td></tr><tr><td><strong>机器指令</strong></td><td>CPU 直接执行的二进制编码（如 <code>B8 01 00 00 00</code> 表示 <code>MOV EAX, 1</code>）。</td><td>硬件与软件的接口。</td></tr><tr><td><strong>汇编指令</strong></td><td>机器指令的助记符形式（如 <code>MOV EAX, 1</code>）</td><td>与机器指令一一对应，依赖具体架构。</td></tr><tr><td><strong>机器</strong>指令和<strong>汇编</strong>指令都是机器级指令</td><td></td><td></td></tr></tbody></table><h4 id="指令操作码">指令操作码</h4><h5 id="定长操作码">定长操作码</h5><ul><li>在指令字的最高部分分配固定的若干位（定长）表示操作码</li><li>一般取 n 位操作码字段的指令系统最大能表示 $2^n$ 条指令</li><li>优点：简化计算机硬件的设计，提高指令译码和识别速度</li><li>缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限</li></ul><h5 id="可变长度操作码">可变长度操作码</h5><ul><li>全部指令的<strong>操作码字段的位数不固定</strong>，且分散地放在指令字的不同位置上</li><li>最常见的变长操作码方法是<strong>扩展操作码</strong>，使<strong>操作码的长度随地址码的减少而增加</strong>，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地<strong>缩短指令字长</strong><br>目的：<strong>保持指令长度不变而增加指令的数量</strong></li><li>优点：在指令字长有限的前提下扔保持比较丰富的指令种类</li><li>缺点：增加了指令译码和分析的难度，使控制器的设计复杂化</li></ul><h6 id="扩展操作码计算">扩展操作码计算</h6><p>核心设计原则：</p><ol><li><strong>禁止短码作为长码前缀</strong>：短操作码不能与长操作码的前缀相同，避免解码冲突。</li><li><strong>操作码唯一性</strong>：各指令的操作码必须互不重复。</li><li><strong>分层扩展机制</strong>：通过保留特定编码（如全 <code>1</code>）触发下一级扩展，逐级释放操作码空间。</li><li><strong>频率优化</strong>：高频指令分配短操作码（如三地址指令），低频指令分配长操作码（如零地址指令）<br><strong>指令字长固定为 16 位</strong>，划分为 <strong>4 位操作码（OP）</strong> 和 **3 个 4 位地址字段（A₁、<br>A₂、A₃）</li></ol><table><thead><tr><th><strong>指令类型</strong></th><th><strong>操作码字段</strong></th><th><strong>地址字段</strong></th><th><strong>指令数量</strong></th><th><strong>保留扩展码</strong></th></tr></thead><tbody><tr><td>三地址指令</td><td>OP（4 位）</td><td>A1,A2​, A3​</td><td>15 条</td><td>OP = <code>1111</code></td></tr><tr><td>二地址指令</td><td>OP + A1​（8 位）</td><td>A2​, A3​</td><td>15 条</td><td>OP + A1​ = <code>1111 1111</code></td></tr><tr><td>一地址指令</td><td>OP + A1​ + A2​（12 位）</td><td>A3​</td><td>15 条</td><td>OP + A1 + A2 = <code>1111 1111 1111</code></td></tr><tr><td>零地址指令</td><td>OP + A1​ + A2​ + A3​（16 位）</td><td>无</td><td>16 条</td><td>无</td></tr></tbody></table><ol><li>三地址指令<br>操作码字段：OP（4 位）<br>可用编码：0000 ~ 1110（共 15 条）<br>保留编码：1111 用于扩展至二地址指令。</li><li>二地址指令<br>触发条件：OP = 1111<br>操作码字段：A₁（4 位）<br>可用编码：0000 ~ 1110（共 15 条）<br>保留编码：1111 用于扩展至一地址指令。</li><li>一地址指令<br>触发条件：OP + A₁ = 1111 1111<br>操作码字段：A₂（4 位）<br>可用编码：0000 ~ 1110（共 15 条）<br>保留编码：1111 用于扩展至零地址指令。</li><li>零地址指令<br>触发条件：OP + A₁ + A₂ = 1111 1111 1111<br>操作码字段：A₃（4 位）<br>可用编码：0000 ~ 1111（共 16 条），无保留码。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240423182012.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424193133113.png" alt="image.png|400"></li></ol><ul><li>拓展操作码<strong>不一定只能有一条</strong>，也就是说不一定只有 1111 作拓展操作码</li><li>地址长度为 n，上一层留出 m 条指令，下一层可扩展出 $m×2^n$ 条指令</li></ul><p>eg.<br><strong>假设指令字长为 16 位，操作数的地址码为 6 位，指令有零地址、一地址、二地址 3 种格式。</strong><br><strong>1）设操作码固定，若零地址指令有 M 种，一地址指令有 N 种，则二地址指令最多有几种？</strong><br><strong>2）采用扩展操作码技术，二地址指令最多有几种？</strong><br><strong>3）采用扩展操作码技术，若二地址指令有 P 条，零地址指令有 Q 条，则一地址指令最多有几种？</strong></p><ol><li>一个操作码，两个地址码，所以操作码占4位，因为操作码的位数反映了机器允许的指令条数，最多包含2^4=16条。二地址指令数 = 总指令数 - 零地址指令 - 一地址指令 = <code>16 - M - N</code>。</li><li><ul><li>前 4 位操作码需保留 <code>1111</code> 用于扩展。2^4-1=15种</li></ul></li><li>二地址指令操作码 4 位，可有 $2^4$ 种编码。 二地址指令有 $p$ 条，则留出 $2^4 - p$ 种编码用于 一地址指令的扩展。 一地址指令操作码字段可有 $2^6×(2^4 - p)$ 种 编码，假设留出 $n$ 种用于零地址的扩展，则 $2^6×n = Q$ $\Rightarrow n = Q / 2^6 \Rightarrow$ 一地址最多有 $(2^4 - p)×2^6 - Q / 2^6$ 种。</li></ol><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424195604061.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424203306695.png" alt="image.png"></p><h2 id="指令的寻址方式">指令的寻址方式</h2><h3 id="指令寻址">指令寻址</h3><ul><li>确定<strong>下一条</strong>要执行的指令的存放地址</li><li>由<strong>程序计数器</strong> PC 指明<ul><li>程序计数器是指让程序执行完一步就自动执行下一句指令的<strong>物理硬件</strong></li><li>若机器按字寻址，PC 给出下一条指令字的访存地址 (指令在内存中的地址)，因此 <strong>PC 的位数取决于存储器的字数</strong></li><li>若机器按字寻址，指令寄存器 IR 用于接收取得的指令，因此 <strong>IR 的位数取决于指令字长</strong>|<br>每一条指令的执行都需要“取指令”，“执行指令”两个阶段</li></ul></li></ul><h4 id="种类">种类</h4><ol><li><strong>顺序寻址</strong>：通过程序计数器 PC + 1，自动形成下一条指令的地址<ul><li>“1” 理解为指令字长，实际加的值会因指令长度、编址方式而不同</li><li>现代计算机通常是按字节编址的，若指今字长为 16 位则 PC 自增为(PC)+2；若指令字长为 32 位，则 PC 自增为(PC)+4.</li></ul></li><li><strong>跳跃寻址</strong>：通过转移类指令（如相对寻址）实现，可用来实现程序的条件或无条件转移<ul><li><strong>跳跃</strong>：指下条指令的地址不由 PC 自动给出，而由本条指令给出下条指令地址的计算方式</li><li>跳跃的方式分为<strong>绝对转移</strong>【地址码直接指出转移目标地址】和<strong>相对转移</strong>【地址码指出转移目的地址相对于当前 PC 值的偏移量】</li><li>跳跃的结果是当前指令修改 PC 值，下一条指令仍然通过 PC 给出，<strong>CPU 总是根据 PC 的内容去主存取指令</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425203000698.png" alt="image.png"></li></ul></li></ol><h3 id="数据寻址">数据寻址</h3><ul><li>确定<strong>本条指令</strong>的地址码指明的真实地址</li><li>表示的是<strong>操作数的地址</strong></li></ul><h4 id="地址码的组成">地址码的组成</h4><ul><li>地址码 = 寻址特征 + 形式地址<ul><li><strong>寻址特征</strong>：指明属于那种寻址方式（其位数决定了寻址方式的种类）</li><li><strong>形式地址 A</strong>：不代表操作数的真实地址，需要根据寻址特征的要求转换为对应存储器的地址</li><li><strong>有效地址 EA</strong>：通过寻址方式和形式地址计算出操作数在存储器中的真实地址<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426162040.png" alt="image.png"></li></ul></li><li><strong>A</strong> 既可以是寄存器编号，又可以是内存地址，<strong>(A)</strong> 表示地址为 A 的数值</li><li><strong>EA=A</strong> 表示形式地址 A 就是真实地址 EA</li><li><strong>EA=(A)</strong> 表示形式地址 A 的内容就是真实地址 EA<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425203654408.png" alt="image.png"></li></ul><h4 id="常见的数据寻址方式">常见的数据寻址方式</h4><p>数据存放在存储器，寄存器<br>指令在代码段</p><p>MOV 目标， 源<br>DST目标操作数：通用寄存器、段寄存器、存储单元、立即数<br>SRC源操作数：通用寄存器、段寄存器、存储单元<br>MOV指令中的源和目的操作数中至少要有一个是寄存器。</p><p><strong>访问主存空间的：</strong></p><h5 id="隐含寻址">隐含寻址</h5><ul><li><strong>定义</strong>：不直接给出操作数的地址，而是在指令中就隐含操作数的地址</li><li><strong>寻址过程</strong>：<ul><li>形式地址 A 取出对应的一个操作数</li><li>另一个操作数通过隐含寻址方式的指令设置，隐含在 ACC 中</li></ul></li><li><strong>有效地址</strong>：由程序指定<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204734489.png" alt="image.png"></li><li><strong>优点</strong>：有利于缩短指令字长</li><li><strong>缺点</strong>：需增加存储操作数或隐含地址的硬件</li></ul><h5 id="立即寻址【操作数在指令中】">立即寻址【操作数在指令中】</h5><p>MOV AL,07H<br>MOV AL,’A’<br>MOV AX,1A2BH</p><ul><li><strong>定义</strong>：把我们实际要操作的数，<strong>直接存放</strong>在形式地址中</li><li><strong>寻址过程</strong>：<ul><li>寻址特征为 <strong>#</strong>，代表立即寻址的意思</li><li>形式地址写的是操作数 3 的<strong>补码</strong>（011）</li></ul></li><li><strong>有效地址</strong>： A 就是操作数，也称<strong>立即数</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425205022682.png" alt="image.png"></li><li><strong>优点</strong>：指令在执行阶段<strong>不访存</strong>，指令执行速度最快</li><li><strong>缺点</strong>：A 的位数限制了立即数的范围</li></ul><p>注：</p><ol><li>立即数只能做源操作数。MOV 3,AL ×</li><li>源、目的操作数的<strong>字长必须一致</strong>。MOV AH（8位），3064H（16位） ×</li><li>汇编程序在进行汇编时，会将不同进制的立即数一律汇编为等值的二进制数，负数则用其<strong>补码</strong>形式表示。<br>MOV BL,‘A’ ;指令执行后(BL)=41H，指令等同于MOV BL,41H</li></ol><h5 id="直接寻址-地址">直接寻址 <code>[地址]</code></h5><ul><li><strong>定义</strong>：指令的地址码直接给出操作数所在的存储单元地址</li><li><strong>寻址过程</strong>：根据这个有效位置去内存中寻找操作数</li><li><strong>有效地址</strong>：EA = A<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204856174.png" alt="image.png"></li><li><strong>优点</strong>：简单，不需要专门计算操作数的地址，指令在执行阶段仅需<strong>访存 1 次</strong></li><li><strong>缺点</strong>：形式地址 A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改<br>注：</li></ul><ol><li>默认段是DS</li><li></li></ol><h5 id="间接寻址">间接寻址</h5><ul><li><strong>定义</strong>：A为操作数地址的地址</li><li><strong>寻址过程</strong>：去该主存单元取操作数的地址，再去找操作数</li><li><strong>有效地址</strong>：EA = (A)<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204339483.png" alt="image.png"></li><li><strong>优点</strong>：可<strong>扩大寻址范围</strong>【EA 的位数大于 A 的位数】，多次间接寻址便于<strong>编制程序</strong>【方便完成子程序的返回】</li><li><strong>缺点</strong>：指令在执行阶段要多次访存（<strong>1 次间址 2 次访存</strong>），<strong>执行速度较慢</strong></li></ul><p><strong>访问寄存器的：</strong></p><h5 id="寄存器寻址【操作数在寄存器中】">寄存器寻址【操作数在寄存器中】</h5><ul><li><strong>定义</strong>：地址字段给出的是<strong>操作数所在寄存器的编号</strong></li><li><strong>寻址过程</strong>：访问该寄存器，取出操作数</li><li><strong>有效地址</strong>：EA = $R_i$<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204613673.png" alt="image.png|400"></li><li><strong>优点</strong>：指令在执行阶段<strong>不用访存</strong>，只访问寄存器，执行速度快，指令字长较短【寄存器数量远小于内存单元数，地址码位数较少】</li><li><strong>缺点</strong>：寄存器价格昂贵，CPU 的寄存器数量有限</li><li>注：<ol><li>两个操作数不能同为<strong>段寄存器</strong>（如 <code>MOV ES, DS</code> ）。</li><li><strong>目的</strong>操作数不能是代码<strong>段寄存器</strong>（如<code>CS</code> ），但可作为<strong>源</strong>操作数。</li><li>两个操作数不能同时为存储单元 <code>eg.mov [0x1345] [0x1321]</code></li><li>立即数不能作为⽬的操作数，如mov 110H,AX</li><li><strong>立即数</strong>不能直接传给<strong>段寄存器</strong>，如mov DS,110H // 翻译成机器码很长</li><li>不允许 存储器-&gt;存储器</li><li>必须采用<strong>同样长度</strong>的寄存器</li></ol></li></ul><h5 id="寄存器间接寻址">寄存器间接寻址</h5><ul><li><strong>定义</strong>：地址字段给出的是操作数所在的寄存器的地址</li><li><strong>寻址过程</strong>：根据该地址去寄存器中找到操作数的有效地址</li><li><strong>有效地址</strong>：EA = $(R_i)$<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425204700981.png" alt="image.png"></li><li><strong>优点</strong>：相比间接寻址，既扩大了寻址范围，又减少了访存次数（执行阶段仅访存 1 次）</li><li><strong>缺点</strong>：相比寄存器访存，执行阶段需要访存（操作数在主存中）</li></ul><p>注：</p><ol><li>源和目的操作数不能同时为存储器操作数（如 <code>MOV [BX], [SI]</code>）</li><li>不允许使用 <strong>AX、CX、DX、SP 存放 EA</strong> ，例如 <code>MOV AX,[CX]</code> 是错误指令<br><strong>源</strong>操作数不能是AX、CX、DX、SP</li><li>立即数和存储器寻址方式同时使用时应明示数据类型 ，如 <code>MOV [BX],20H</code> 写法错误，应明确数据类型（如字节型 <code>BYTE PTR [BX],20H</code> 、字型 <code>WORD PTR [BX],20H</code> 等 ）</li><li>有【】间接，无【】寄存器寻址</li><li>可以用于间接寻址的寄存器有基址寄存器BX、BP 和变址寄存器 SI、DI。</li><li>$PA（物理地址） = \begin{cases} (DS) \ (SS) \ \vdots \end{cases} \times 16 + \begin{cases} (SI) \ (DI) \ (BX) \ (BP) \end{cases}$<br>$PA=SS×10H+BP$<br>有效地址EA由寄存器(BX，BP，SI，DI)间接给出：<br>当EA=(BX)/(SI)/(DI)时：PA=(DS)x16+EA<br>当EA=(BP)时：PA=(SS)x16+EA</li><li><strong>MOV BL, [1200H]</strong><br>这是存储器寻址指令。默认使用数据段寄存器 <code>DS</code> ，根据 <code>DS</code> 中的段地址和偏移地址 <code>1200H</code> 计算出物理地址，然后从该物理地址对应的内存单元中取出 8 位数据，传送到寄存器 <code>BL</code> 中 。假设 <code>DS = 3000H</code> ，物理地址就是 <code>3000H×16 + 1200H = 31200H</code> ，从 <code>31200H</code> 地址单元取数据给 <code>BL</code><br><strong>MOV BL, ES:[1200H]</strong><br>与上一条类似，但明确指定使用附加段寄存器 <code>ES</code> 。根据 <code>ES</code> 中的段地址和偏移地址 <code>1200H</code> 计算物理地址，再从对应内存单元取 8 位数据传至 <code>BL</code> 。比如 <code>ES = 4000H</code> ，物理地址就是 <code>4000H×16 + 1200H = 41200H</code> ，从这里取数据给 <code>BL</code> 。<br><strong>MOV AX, [SI]</strong><br>已知 <code>SI = 1200H</code> ，这是寄存器间接寻址。使用默认的数据段寄存器 <code>DS</code> ，结合 <code>DS</code> 的段地址和 <code>SI</code> 中的偏移地址 <code>1200H</code> 算出物理地址，从该地址对应内存单元取出 16 位数据传至 <code>AX</code> 。<br><strong>MOV AX,[BX]</strong>：源操作数在数据段，EA（有效地址，偏移量） = BX，PA = DS×16 + EA 。表示从数据段中，以 BX 寄存器的值为有效地址，计算出物理地址后，将对应存储单元的内容传送给 AX 寄存器。<br><strong>MOV [BP],DI</strong>：目的操作数在堆栈段，EA = BP，PA = SS×16 + EA 。即将 DI 寄存器中的内容传送到堆栈段中，以 BP 寄存器的值为有效地址对应的存储单元。</li><li></li></ol><table><thead><tr><th><strong>寄存器</strong></th><th><strong>主要限制</strong></th><th><strong>错误用法</strong></th><th><strong>正确用法</strong></th></tr></thead><tbody><tr><td><code>AX</code>/<code>CX</code>/<code>DX</code></td><td>不能用于基址/变址寻址</td><td><code>MOV [AX + SI], BX</code></td><td><code>MOV [BX + SI], AX</code></td></tr><tr><td><code>SP</code></td><td>不能用于基址寻址或通用计算</td><td><code>LEA SP, [BX+DI]</code></td><td><code>LEA BP, [BX+DI]</code></td></tr><tr><td>所有通用寄存器</td><td>不能替换字符串指令的隐式寄存器</td><td><code>STOSB DX</code></td><td><code>STOSB</code>（隐式用 AX）</td></tr><tr><td><strong>偏移寻址：</strong></td><td></td><td></td><td></td></tr></tbody></table><h5 id="基址寻址">基址寻址</h5><ul><li><strong>定义</strong>：CPU 中基址寄存器（BR）的内容【首地址】 + 形式地址 A【偏移量】 = 操作数的有效地址<br>以程序的其实存放地址作为起点</li><li><strong>寻址过程</strong>：程序运行前，CPU 将 BR 的值修改为程序的起始地址（存放在操作系统 PCB 中 ）</li><li><strong>有效地址</strong>：EA = (BR) + A</li><li><strong>基址寄存器</strong>：<ul><li>可采用专用寄存器，可指定某个通用寄存器</li><li><strong>面向操作系统</strong>，内容由操作系统或管理程序确定，用于解决程序逻辑空间与存储器物理空间的无关性</li><li>程序执行过程中，<strong>基址寄存器内容不变</strong>（作为基地址），<strong>形式地址可变</strong>（作为偏移量）</li><li>采用<strong>通用寄存器时</strong>，可由用户决定哪个寄存器，但其内容仍由<strong>操作系统</strong>确定【不可修改】<ul><li>若系统有 N 个通用寄存器可用作基址寄存器，则需 log₂​N 位二进制编码唯一标识每个寄存器。<ul><li><strong>8个通用寄存器</strong>（如x86的EAX、EBX等）：需 <strong>3位</strong>（23=823=8）。</li><li><strong>16个通用寄存器</strong>（如ARM的R0~R15）：需 <strong>4位</strong>（24=1624=16）</li></ul></li><li>**指令格式的各部分占位：<ul><li><strong>操作码位数</strong>：由指令条数决定，取 ⌈log⁡2(指令数)⌉。</li></ul></li><li><strong>寻址方式位数</strong>：由支持的寻址方式数量决定，取 ⌈log⁡2(寻址方式数)⌉。</li><li><strong>寄存器编号位数</strong>：由通用寄存器数量决定，如 16 个寄存器需 log⁡2(16)=4位。</li><li><strong>剩余位数</strong>：用于地址码或偏移量。</li><li><strong>计算地址/偏移量范围</strong>：</li><li><strong>直接寻址</strong>：地址码位数为 n，范围为 $0∼2^n−1$（无符号）【注：内存地址是无符号数】</li><li><strong>补码偏移量</strong>：位数为 m，范围为 $−2^{m−1}∼+2^{m−1}-1$。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426183205.png" alt="image.png"></li></ul></li></ul></li><li><strong>优点</strong>：<ul><li>可以扩大寻址范围（基址寄存器的位数大于 A 的位数）</li><li>用户不必考虑自己的程序存于主存的具体位置，<strong>有利于多道程序设计</strong></li><li>可用于<strong>编制浮动程序</strong></li></ul></li><li><strong>缺点</strong>：偏移量（A）的位数较短</li></ul><h5 id="变址寻址">变址寻址</h5><ul><li><p><strong>定义</strong>：变址寄存器（IX）的内容【偏移量】 + 形式地址 A【首地址】= 操作数的有效地址<br>由程序员自己决定从哪里作为起点<br>其中IX可为变址寄存器(专用)，也可用通用寄存器作为变址寄存器</p></li><li><p><strong>有效地址</strong>：EA = (IX) + A</p></li><li><p><strong>变址寄存器</strong>：</p><ul><li><strong>面向用户</strong>，程序执行过程中，内容可由<strong>用户</strong>改变（作为偏移量）【可以修改】</li><li>形式地址 A 不变（作为基地址）<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426183710.png" alt="image.png|400"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250426190946841.png" alt="image.png"></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>可以<strong>扩大寻址范围</strong>（变址寄存器的位数大于 A 的位数）</li><li>在<strong>数组处理</strong>过程中，可设定 A 为数组的首地址，不断改变 IX 的内容，便可很容易形成数组中任意一个数据的地址，适合<strong>编制循环程序</strong></li><li>偏移量的位数足以表示<strong>整个存储空间</strong></li></ul></li><li><p><strong>基址寻址 VS 变址寻址</strong></p><ul><li><strong>变址寻址</strong>适合处理<strong>数据串、数组</strong>。在处理数组时，可通过<strong>修改</strong>变址寄存器的值，以顺序或跳跃方式访问数组元素，提高程序处理数组数据的灵活性和效率<br>变址寄存器内容由用户程序根据需要设定，在程序执行过程中可<strong>灵活改变</strong> ，常用于实现<strong>循环</strong>访问数据结构，可简化程序设计</li><li><strong>基址寻址</strong>适用于<strong>多用户的计算机系统</strong>，把每个用户的基地址存于基址寄存器，便于将用户的逻辑地址转换为物理地址，实现程序的重定位 ；也适用于程序中数据区位置相对固定，但偏移量可变的情况<br>基址寄存器内容由操作系统或管理程序设置，一般在程序执行过程中<strong>保持不变</strong>，形式地址 A 是用户编程时确定的<strong>相对地址</strong> ，便于实现程序的<strong>动态重定位</strong></li></ul></li></ul><h5 id="基址变址寻址">基址变址寻址</h5><ul><li>32位有效地址的组成<ul><li>基址寄存器 + 变址寄存器×比例+位移量<br>$\begin{cases} EAX \ EBX \ ECX \ EDX \ EBP \ ESP \ ESI \ EDI \end{cases} + \begin{cases} EAX \ EBX \ ECX \ EDX \ EBP \ ESI \ EDI \end{cases} \times \begin{cases} 1 \ 2 \ 4 \ 8 \end{cases} + \begin{cases} 8位位移量 \ 32位位移量 \end{cases}$</li></ul></li><li>16位有效地址的组成<ul><li>基址寄存器 + 变址寄存器+位移量<br>$\begin{cases} BX \ BP \end{cases} + \begin{cases} SI \ DI \end{cases} + \begin{cases} 8位位移量 \ 16位位移量 \end{cases}$ 组合成多种存储器寻址方式<br>当基址寄存器为BX时：PA=(DS)x16+EA<br>当基址寄存器为BP时：PA=(SS)x16+EA<br>有效地址EA：基址寄存器(BX，BP) + 变址寄存器(SI，DI)</li></ul></li></ul><p>基址寄存器：存放在基址寄存器中的内容，常用来指向数据段中数组或字符串的<strong>首地址</strong><br>变址寄存器：存放在变址寄存器中的内容，常用来访问数组中的某个元素或字符串中的<strong>某个字符</strong><br>偏移地址：存放在指令中的一个8位、16或32位的数，但它不是立即数，而是一个地址</p><ol><li><code>MOV [BX + DI], AX</code>：此指令中目的操作数在数据段。 EA = (BX) + (DI) ，PA = (DS)×16 + EA</li><li><code>MOV DX, [BX][SI]</code>：该指令里源操作数在数据段。EA = (BX) + (SI) ， PA = (DS)×16 + EA</li><li><code>MOV [BP][DI], BX</code>：这条指令中目的操作数在堆栈段。即 EA = (BP) + (DI) ， PA = (SS)×16 + EA<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250427200202792.png" alt="image.png"><br>DS是数据段寄存器，SS是堆栈段寄存器，有BP/EBP（栈帧基址）的默认段寄存器是SS【数据存于堆栈段】，其他都是DS【数据存于数据段】</li></ol><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250426191153246.png" alt="image.png"></p><h5 id="带比例变址寻址">带比例变址寻址</h5><p>比例因子只能是1，2，4，8</p><h5 id="相对寻址">相对寻址</h5><ul><li><strong>定义</strong>：PC 的内容 + 形式地址 A【相对偏移量】 = 操作数的有效地址<br>以PC所指地址作为起点</li><li><strong>有效地址</strong>：EA = (PC) + A【补码表示，可正可负】</li><li>A 是相对于 PC 所指地址（下一条指令地址）的偏移量，可正可负，<strong>补码表示</strong></li><li>A 的位数决定操作数的寻址范围<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426185023.png" alt="image.png"></li><li><strong>优点</strong>：<ul><li>操作数的地址不是固定的，随 PC 值的变化而变化，与指令地址之间总是相差一个固定的偏移量，因此<strong>便于程序浮动</strong>（一段代码在程序内部的浮动）</li><li>广泛应用于<strong>转移指令</strong></li></ul></li></ul><p><strong>其他寻址：</strong></p><h5 id="堆栈寻址">堆栈寻址</h5><ul><li><strong>定义</strong>：操作数存放在堆栈中，隐含使用<strong>堆栈指针（SP）</strong> 作为<strong>操作数地址</strong><br>用SS段寄存器记录其段地址，用SP段寄存器记录其段地址，用SP始终指向堆栈的顶部。<ul><li>入栈push：SP/ESP👇🏼高→低【从高地址向低地址存数据】<ul><li><strong>先减后压</strong>【<strong>先减指针，再存数据</strong>（向低地址增长）】</li><li>SP = SP - 2 或 ESP = ESP - 4</li><li>SS : [SP] ← src 或 SS : [ESP] ← src<br>src可以是16/32位立即数、16/32位内部寄存器、段寄存器、16/32位存储器操作数</li><li><strong>操作单位</strong>：<ul><li>16 位模式：以 <strong>字（2 字节）</strong> 为单位，SP 减 2。</li><li>32/64 位模式：以 <strong>双字（4 字节）</strong> 为单位，ESP 减 4。</li></ul></li><li>PUSH EAX</li><li>PUSH DWORD PTR [EBX]</li><li>SS=2004H，ESP=1000H，EBX=12345678H，执行 PUSH EBX 指令后，ESP的内容为OFFCH，内存分布（小端方式）：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250504190607408.png" alt="image.png"></li></ul></li><li>出栈pop：SP/ESP🖕🏼低→高<ul><li><strong>先弹后加</strong>【<strong>先取数据，再加指针</strong>（向高地址收缩）】</li><li>操作单位：<ul><li>16 位模式：SP 加 2。</li><li>32/64 位模式：ESP 加 4。</li></ul></li><li>执行的操作：<ul><li>dest←SS:[SP] 或 dest ← SS:[ESP]</li><li>SP=(SP)+2 或 ESP=(ESP)+4<br>dest可以是16位/32位内部寄存器、段寄存器、16位或32位存储器操作数。</li></ul></li><li>以字或双字为单位操作<ul><li>出栈字数据时，ESP加2</li><li>出栈双字数据时，ESP加4</li></ul></li><li>POP EAX;R[EAX]←SS:M[R[ESP]</li><li>POP DWORD PTR [EBX]; DS:M[R[EBX]←SS:M[R[ESP]<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250504192744048.png" alt="image.png"></li></ul></li></ul></li></ul><p>PUSH EBP:<br>R[ESP]←R[ESP]-4,M[R[ESP]]←R[EBP]<br>POP EBP<br>R[EBP]←M[R[ESP]],R[ESP]←R[ESP]+4</p><ul><li><strong>堆栈</strong>：<ul><li>存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）“原则管理的存储区</li><li>该存储区中被读 / 写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）</li><li>硬件自动完成 SP 的加减操作</li><li><strong>硬堆栈</strong>：<strong>寄存器</strong>堆栈，速度快，成本较高，不需要访存，不适合做大容量堆栈</li><li><strong>软堆栈</strong>：从<strong>主存</strong>中划出一段区域，执行阶段访存 1 次</li><li>堆栈可用于<strong>函数调用</strong>时保存当前函数的相关信息</li></ul></li><li><strong>有效地址</strong>：入栈 / 出栈时 EA 的确定方式不同<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250426193739470.png" alt="image.png"></li><li>堆栈操作的应用<ul><li>子程序调用和返回<ul><li><strong>CALL 指令</strong>：将返回地址压入堆栈，再跳转到子程序。</li><li><strong>RET 指令</strong>：从堆栈弹出返回地址，跳回主程序。</li></ul></li></ul></li><li>中断处理<ul><li><strong>INT 指令</strong>：压入标志寄存器、CS 和 IP，转入中断服务程序。</li><li><strong>IRET 指令</strong>：弹出 IP、CS 和标志寄存器，恢复原程序。</li></ul></li><li>参数传递与寄存器保护<ul><li><strong>传递参数</strong>：通过堆栈向子程序传递参数。</li><li><strong>保护现场</strong>：在子程序开头压入需保护的寄存器，结尾弹出。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 子程序入口</span><br><span class="line">push ebp          ; 保护 EBP</span><br><span class="line">push eax          ; 保护 EAX</span><br><span class="line">; 子程序内容</span><br><span class="line">pop eax           ; 恢复 EAX</span><br><span class="line">pop ebp           ; 恢复 EBP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><ul><li>随机访问堆栈数据<ul><li><strong>通过 EBP 访问参数</strong>：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ebp, esp        ; EBP 指向当前栈顶</span><br><span class="line">mov eax, [ebp + 8]  ; 访问栈中第 3 个双字参数（假设 32 位模式）</span><br></pre></td></tr></table></figure><ul><li>注：<ul><li><strong>入栈与出栈必须成对</strong>，避免栈指针错位</li></ul></li></ul><h4 id="对比">对比</h4><ul><li>速度方面：<strong>立即寻址 &gt; 寄存器寻址 &gt; 直接寻址 &gt; 寄存器间接寻址 &gt; 间接寻址</strong></li></ul><table><thead><tr><th>寻址方式</th><th>有效地址</th><th>例子</th><th>访存次数（指令执行期间）</th></tr></thead><tbody><tr><td><strong>隐含</strong>寻址</td><td>程序指定</td><td></td><td>0</td></tr><tr><td><strong>立即</strong>寻址</td><td>A 即是操作数</td><td><code>MOV AX, 100</code></td><td>0</td></tr><tr><td><strong>直接</strong>寻址</td><td>EA = A</td><td><code>MOV AX, [2000H]</code></td><td>1</td></tr><tr><td><strong>一次间接</strong>寻址</td><td>EA = (A)</td><td><code>MOV AX, [[3000H]]</code></td><td>2</td></tr><tr><td><strong>寄存器</strong>寻址</td><td>EA = Ri​</td><td><code>ADD AX, BX</code></td><td>0</td></tr><tr><td><strong>寄存器间接一次</strong>寻址</td><td>EA = (Ri​)</td><td><code>MOV AX, [BX]</code></td><td>1</td></tr><tr><td>转移指令 - <strong>相对</strong>寻址</td><td>EA = (PC) + A</td><td>PC为基准跳转</td><td>1</td></tr><tr><td>多道程序 - <strong>基址</strong>寻址</td><td>EA = (BR) + A</td><td>BR做起点偏移</td><td>1</td></tr><tr><td><strong>循环</strong>程序、<strong>数组</strong>问题 - <strong>变址</strong>寻址</td><td>EA = (IX) + A</td><td></td><td>1</td></tr><tr><td><strong>堆栈</strong>寻址</td><td>入栈 / 出栈时 EA 的确定方式不同，硬堆栈不访存，软堆栈访存 1 次</td><td>硬：寄；软：内</td><td></td></tr><tr><td><strong>立即寻址</strong>：操作数获取便捷，通常用于给寄存器赋初值。</td><td></td><td></td><td></td></tr><tr><td><strong>直接寻址</strong>：相对于立即寻址，<strong>缩短了指令长度</strong>。</td><td></td><td></td><td></td></tr><tr><td><strong>间接寻址</strong>：<strong>扩大了寻址范围</strong>，便于编制程序，易于完成<strong>子程序返回</strong>。</td><td></td><td></td><td></td></tr><tr><td><strong>寄存器寻址</strong>的<strong>指令字较短</strong>，指令<strong>执行速度较快</strong>。</td><td></td><td></td><td></td></tr><tr><td><strong>寄存器间接寻址</strong> <strong>扩大了寻址范围</strong>。</td><td></td><td></td><td></td></tr><tr><td><strong>基址寻址</strong> <strong>扩大了操作数寻址范围</strong>，适用于<strong>多道程序设计</strong>，常用于为程序或数据分配存储空间。</td><td></td><td></td><td></td></tr><tr><td><strong>变址寻址</strong>主要用于处理<strong>数组</strong>问题，适合编制<strong>循环</strong>程序。</td><td></td><td></td><td></td></tr><tr><td><strong>相对寻址</strong>用于控制程序的执行<strong>顺序、转移</strong>等。</td><td></td><td></td><td></td></tr><tr><td>基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。即：</td><td></td><td></td><td></td></tr><tr><td><strong>基址寻址</strong>：(BR)+A</td><td></td><td></td><td></td></tr><tr><td>BR基址寄存器的内容由操作系统控制，程序员可操作偏移地址A。</td><td></td><td></td><td></td></tr><tr><td><strong>变址寻址</strong>：(IX)+A</td><td></td><td></td><td></td></tr><tr><td>偏移地址A不变，程序员可操作的是变址寄存器IX。</td><td></td><td></td><td></td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425211646242.png" alt="image.png"></td><td></td><td></td><td></td></tr></tbody></table><h5 id="（MOV）操作数限制总结">（MOV）操作数限制总结</h5><p><strong>1. 段寄存器（CS/DS/ES/SS/FS/GS）的限制</strong></p><ul><li><strong>两个段寄存器不能直接传送</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV ES, DS   ;  错误：不能 MOV 段寄存器 → 段寄存器</span><br></pre></td></tr></table></figure><ul><li><strong>立即数不能直接传给段寄存器</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS, 1000H   ;  错误：不能 MOV 立即数 → 段寄存器</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>（需通过通用寄存器中转）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, 1000H</span><br><span class="line">MOV DS, AX      ;  正确</span><br></pre></td></tr></table></figure><ul><li><strong>AX、CX、DX、SP 不能作为目标操作数</strong>（但可作为源操作数）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV CS, AX   ;  错误：CS 不可修改</span><br><span class="line">MOV AX, CS   ;  正确：CS 可作为源</span><br></pre></td></tr></table></figure><p><strong>2. 立即数的限制</strong></p><ul><li><strong>立即数不能作为目标操作数</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV 110H, AX   ;  错误：立即数不能是目标</span><br></pre></td></tr></table></figure><ul><li><strong>立即数不能直接传给存储器操作数（需指定数据类型）</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV [BX], 9      ;  错误：未指明字节/字/双字</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>（使用 <code>BYTE PTR</code>/<code>WORD PTR</code> 等）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV BYTE PTR [BX], 9   ;  字节传送</span><br><span class="line">MOV WORD PTR [BX], 9   ;  字传送</span><br></pre></td></tr></table></figure><p><strong>3. 存储器操作数的限制</strong></p><ul><li><strong>两个操作数不能同时为存储器操作数（不能同时带 <code>[ ]</code>）</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV [2000H], [BX]   ;  错误：不能 内存 → 内存</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>（通过寄存器中转）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [BX]</span><br><span class="line">MOV [2000H], AX   ;  正确</span><br></pre></td></tr></table></figure><ul><li><strong>存储器操作数类型必须明确</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD [SI], 20H        ;  错误：未指明字节/字</span><br><span class="line">MOV [1200H], 23H     ;  错误：未指明数据类型</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD BYTE PTR [SI], 20H   ;  字节操作</span><br><span class="line">MOV WORD PTR [1200H], 23H ;  字操作</span><br></pre></td></tr></table></figure><p><strong>4. 寄存器组合的限制</strong></p><ul><li><strong>基址/变址寄存器组合无效</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [SI+DI]        ;  错误：不能两个变址寄存器（SI+DI）</span><br><span class="line">MOV AX, [BX+BP]        ;  错误：不能两个基址寄存器（BX+BP）</span><br><span class="line">MOV AX, [BX+BP+100H]   ;  错误：BX 和 BP 冲突</span><br></pre></td></tr></table></figure><p><strong>合法组合</strong>（基址 + 变址）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, [BX+SI]        ;  正确：BX（基址） + SI（变址）</span><br><span class="line">MOV AX, [BP+DI+10H]    ;  正确：BP（基址） + DI（变址）</span><br></pre></td></tr></table></figure><ul><li><strong>ESP 不能用于基址变址寻址</strong>（ESP能否作为基址）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV DX, [ESP+EDI+2000H]   ;  错误：ESP 不能参与变址</span><br><span class="line">MOV EAX, [EBX + ESP*2]   ;  错误：ESP 不能作为变址寄存器</span><br><span class="line">MOV ECX, [ESP + ESI]     ;  错误：ESP 不能与变址寄存器组合</span><br></pre></td></tr></table></figure><p><strong>可用 <code>ESI</code>/<code>EDI</code> 代替 <code>ESP</code></strong>：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, [EBX + ESI*2]   ;正确：ESI 是合法变址寄存器</span><br></pre></td></tr></table></figure><p><strong>如果必须用 <code>ESP</code>，先将其值复制到通用寄存器</strong>：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EDX, ESP             ; 将 ESP 的值暂存到 EDX</span><br><span class="line">MOV EAX, [EBX + EDX*1]   ;间接使用</span><br></pre></td></tr></table></figure><p><strong>5. 数据类型一致性</strong></p><ul><li><strong>操作数类型不匹配</strong></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL, 1000H      ;  错误：1000H（16位）→ AL（8位）</span><br><span class="line">MOV AX, BL         ;  错误：BL（8位）→ AX（16位）</span><br><span class="line">MOV [SI], 35H      ;  错误：未指明字节/字</span><br><span class="line">MOV AL, 512        ;  错误：512 超出 8 位范围（AL 最大 255）</span><br><span class="line">MOV AH, BX         ;  错误：AH（8位）← BX（16位）</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AL, 10H        ;  8 位立即数 → AL</span><br><span class="line">MOV AX, BX         ;  16 位寄存器 → 寄存器</span><br><span class="line">MOV WORD PTR [SI], 35H  ;  字操作</span><br></pre></td></tr></table></figure><ol><li><strong>单次 MOV 只能涉及一个内存操作数</strong>（寄存器 ↔ 内存，不能内存 ↔ 内存）。</li><li><strong>段寄存器操作需通过通用寄存器中转</strong>。</li></ol><p>说明程序功能，寻址方式，判断对错并改正</p><ul><li><strong>MOV [2000H], BX</strong><br>将 <code>BX</code> 的值存入内存地址 <code>2000H</code>，直接寻址，√</li><li><strong>MOV ESI, BL</strong><br>将 <code>BL</code>（8 位）的值存入 <code>ESI</code>（32 位），寄存器寻址，×（操作数大小不匹配）</li><li><strong>MOV [EAX], 2000H</strong><br>将立即数 <code>2000H</code> 存入 <code>[EAX]</code> 指向的内存，寄存器间接寻址，×（未指定操作数大小）</li><li><em><em>MOV CX, [ESP+EDI</em> 6]</em>*<br>从 <code>[ESP + EDI*6]</code> 读取 16 位数据到 <code>CX</code>，基址变址寻址，×（比例因子只能是 1/2/4/8）</li><li><strong>MOV ECX, SS:[405000H]</strong><br>从 <code>SS</code> 段地址 <code>405000H</code> 读取 32 位数据到 <code>ECX</code>，直接寻址，√</li><li><strong>MOV [EBX+ESP+ARY], EAX</strong><br>将 <code>EAX</code> 存入 <code>[EBX + ESP + ARY]</code> 指向的内存，基址变址寻址，×（<code>ESP</code> 不能作为变址寄存器）</li><li><strong>MOV BL, [EBP+10H]</strong><br>从 <code>[EBP + 10H]</code> 读取 8 位数据到 <code>BL</code>，基址寻址，√（默认段为 <code>SS</code>）</li><li><strong>MOV DX, [ESP+EDI+2000H]</strong><br>从 <code>[ESP + EDI + 2000H]</code> 读取 16 位数据到 <code>DX</code>，基址变址寻址，×（<code>ESP</code> 不能作为基址与变址同时出现）</li><li><strong>MOV [EBP+ESI+20H], EBX</strong><br>将 <code>EBX</code> 存入 <code>[EBP + ESI + 20H]</code> 指向的内存，基址变址寻址，√</li><li><strong>MOV AL, ES:[2000H]</strong><br>从 <code>ES</code> 段地址 <code>2000H</code> 读取 8 位数据到 <code>AL</code>，直接寻址，√</li><li><em><em>MOV [EBX+ESI</em> 4-4], EDX</em>*<br>将 <code>EDX</code> 存入 <code>[EBX + ESI*4 - 4]</code> 指向的内存，基址变址寻址，√</li><li><em><em>MOV AX,[ESI</em> 2+80H]</em>*<br>从 <code>[ESI*2 + 80H]</code> 读取 16 位数据到 <code>AX</code>，变址寻址，√<br>改正：<em><em>MOV AX, [EBX + ESI</em> 2 + 80H]</em>* 添加基址寄存器 EBX</li></ul><ol><li>直接寻址示例<ul><li><strong>指令</strong>：MOV BX,[1234H]</li><li><strong>执行条件</strong>：(DS)=2000H，内存单元 21234H 的值为 5213H</li><li><strong>计算过程</strong>：直接地址 1234H 紧跟指令操作码后，物理地址 = DS 的值 + 偏移量 1234H = 2000H* 16 + 1234H = 21234H 。</li><li><strong>执行效果</strong>：取单元 21234H 的值 5213H，按 “高高低低” 原则存入寄存器 BX，执行后 BX 的值为 5213H 。</li></ul></li><li>寄存器间接寻址示例<ul><li><strong>指令</strong>：MOV BX,[DI]</li><li><strong>执行条件</strong>：(DS)=1000H，(DI)=2345H，存储单元 12345H 的内容是 4354H</li><li><strong>计算过程</strong>：根据寄存器间接寻址规则，操作数物理地址 PA=(DS)* 16+DI = 1000H* 16 + 2345H = 12345H 。</li><li><strong>执行效果</strong>：把物理地址 12345H 开始的一个字的值（4354H）传送给 BX 。</li></ul></li><li>寄存器相对寻址示例<ul><li><strong>指令</strong>：MOV BX,[SI+100H]</li><li><strong>执行条件</strong>：(DS)=1000H，(SI)=2345H，内存单元 12445H 的内容为 2715H</li><li><strong>计算过程</strong>：源操作数有效地址 EA=(SI)+100H = 2345H + 100H = 2445H ；物理地址 PA=(DS)* 16+EA = 1000H* 16 + 2445H = 12445H 。</li><li><strong>执行效果</strong>：把物理地址 12445H 开始的一个字的值（2715H）传送给 BX 。</li></ul></li><li>基址加变址寻址示例<ul><li><strong>指令</strong>：MOV BX,[BX+SI]</li><li><strong>执行条件</strong>：(DS)=1000H，(BX)=2100H，(SI)=0011H，内存单元 12111H 的内容为 1234H</li><li><strong>计算过程</strong>：源操作数有效地址 EA=(BX)+(SI)=2100H + 0011H = 2111H ；物理地址 PA=(DS)* 16+EA = 1000H* 16 + 2111H = 12111H 。</li><li><strong>执行效果</strong>：把物理地址 12111H 开始的一个字的值（1234H）传送给 BX 。</li></ul></li></ol><h2 id="程序的机器级代码表示">程序的机器级代码表示</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250427192020070.png" alt="image.png"></p><h3 id="指令操作类型">指令操作类型</h3><h5 id="数据传送类">数据传送类</h5><ul><li>进行 <strong>CPU 和主存</strong>之间的数据传送</li><li><strong>LOAD</strong>：把存储器中的数据放到寄存器中【存储器→寄存器】</li><li><strong>STORE</strong>：把寄存器中的数据放到存储器中【寄存器→存储器】</li></ul><h5 id="运算类">运算类</h5><ul><li><strong>算术</strong>：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算</li></ul><table><thead><tr><th>功能</th><th>英文</th><th>汇编指令</th><th>注释</th></tr></thead><tbody><tr><td>加</td><td>add</td><td>add d,s</td><td>计算 d + s，结果存入 d</td></tr><tr><td>减</td><td>subtract</td><td>sub d,s</td><td>计算 d - s，结果存入 d</td></tr><tr><td>乘</td><td>multiply</td><td>mul d,s  <br>imul d,s</td><td>无符号数 d * s，乘积存入 d  <br>有符号数 d * s，乘积存入 d</td></tr><tr><td>除</td><td>divide</td><td>div s  <br>idiv s</td><td>无符号数除法 edx:eax /s，商存入 eax，余数存入 edx  <br>有符号数除法 edx:eax /s，商存入 eax，余数存入 edx</td></tr><tr><td>取负数</td><td>negative</td><td>neg d</td><td>将 d 取负数，结果存入 d</td></tr><tr><td>自增 ++</td><td>increase</td><td>inc d</td><td>将 d++，结果存入 d</td></tr><tr><td>自减 –</td><td>decrease</td><td>dec d</td><td>将 d–，结果存入 d</td></tr><tr><td><code>edx:eax</code>组合起来表示一个 64 位的数据，其中<code>edx</code>存放高 32 位，<code>eax</code>存放低 32 位 。在除法运算中（如<code>div</code>和<code>idiv</code>指令），被除数是<code>edx:eax</code>表示的 64 位数，除以源操作数<code>s</code>后，商存到<code>eax</code>，余数存到<code>edx</code></td><td></td><td></td><td></td></tr></tbody></table><ul><li><strong>逻辑</strong>：与、或、非、异或、位操作、位测试、位清除、位求反</li></ul><table><thead><tr><th>功能</th><th>英文</th><th>汇编指令</th><th>注释</th></tr></thead><tbody><tr><td>与</td><td>and</td><td>and d,s</td><td>将 d、s 逐位相与，结果放回 d</td></tr><tr><td>或</td><td>or</td><td>or d,s</td><td>将 d、s 逐位相或，结果放回 d</td></tr><tr><td>非</td><td>not</td><td>not d</td><td>将 d 逐位取反，结果放回 d</td></tr><tr><td>异或</td><td>exclusive or</td><td>xor d,s</td><td>将 d、s 逐位异或，结果放回 d</td></tr><tr><td>左移</td><td>shift left</td><td>shl d,s</td><td>将 d 逻辑左移 s 位，结果放回 d（通常 s 是常量）</td></tr><tr><td>右移</td><td>shift right</td><td>shr d,s</td><td>将 d 逻辑右移 s 位，结果放回 d（通常 s 是常量）</td></tr></tbody></table><ul><li><strong>移位操作</strong>：算术移位、逻辑移位、循环移位（带进位和不带进位）</li></ul><h5 id="程序控制类">程序控制类</h5><ul><li>改变<strong>程序执行的顺序</strong></li><li><strong>无条件</strong>转移 JMP</li><li><strong>条件</strong>转移 JZ：结果<strong>为0</strong>；JO：结果<strong>溢出</strong>；JC：结果有<strong>进位</strong></li><li>调用 CALL、返回 RETURN、陷阱 Trap</li><li><strong>调用指令和转移指令的区别</strong>：前者必须保存下一条指令的地址，当子程序执行结束时，根据返回地址返回到主程序继续执行，后者不需要返回</li><li>转移指令，子程序调用与返回指令用于解决变动程序中<strong>指令执行次序</strong>的需求，而不是数据调用次序的需求</li><li>其他指令：<ul><li>用于实现分支结构、循环结构的指令：cmp、test、jmp、jxxx</li><li>用于实现函数调用的指令：push、pop、call、ret</li><li>用于实现数据转移的指令：mov</li></ul></li></ul><h5 id="输入输出类">输入输出类</h5><ul><li>进行 CPU 和 I/O 设备之间的数据传送</li><li>传送控制命令和状态信息</li></ul><h3 id="寄存器组织">寄存器组织</h3><p>寄存器是 CPU 内部的高速存储单元，用于临时存放 <strong>操作数、操作数地址、中间结果</strong> 等数据。<br>IA-32 架构的寄存器分为 <strong>通用寄存器</strong>、<strong>专用寄存器</strong> 和 <strong>段寄存器</strong> 三类。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424211310351.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250424213209986.png" alt="image.png"><br>32位寄存器：E开头<br>专用寄存器：EIP、EFLAGS<br>16位寄存器：最后一位是X、P、S、I【性癖沙漏】<br>8位寄存器：ABCD+H、L<br>段寄存器：CDEFG+S，S+S</p><h4 id="通用寄存器">通用寄存器</h4><p>通用寄存器主要用于<strong>整数运算、地址操作和数据暂存</strong>，包括 <strong>8 个 32 位寄存器</strong>，其低 16 位和 8 位可独立使用：</p><table><thead><tr><th><strong>32 位寄存器</strong></th><th><strong>16 位寄存器</strong></th><th><strong>8 位寄存器</strong></th><th><strong>主要用途</strong></th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH/AL</td><td><strong>累加器</strong>，存放运算结果或函数返回值</td></tr><tr><td>EBX</td><td>BX</td><td>BH/BL</td><td><strong>基址寄存器</strong>，用于<strong>内存寻址</strong></td></tr><tr><td>ECX</td><td>CX</td><td>CH/CL</td><td><strong>计数器</strong>，用于<strong>循环控制</strong></td></tr><tr><td>EDX</td><td>DX</td><td>DH/DL</td><td><strong>数据寄存器</strong>，<strong>辅助运算</strong>或 <strong>I/O 操作</strong></td></tr><tr><td>ESI</td><td>SI</td><td>-</td><td><strong>源变址寄存器</strong>，用于<strong>字符串/数组</strong>操作</td></tr><tr><td>EDI</td><td>DI</td><td>-</td><td><strong>目的变址寄存器</strong>，用于<strong>字符串/数组操作</strong></td></tr><tr><td>EBP</td><td>BP</td><td>-</td><td><strong>基址指针</strong>，指向<strong>栈帧基地址</strong></td></tr><tr><td>ESP</td><td>SP</td><td>-</td><td><strong>栈指针</strong>，指向<strong>栈顶位置</strong></td></tr><tr><td>32 位寄存器、16 位寄存器和 8 位寄存器属于同一组相关寄存器，只是数据存储宽度不同。16 位寄存器是 32 位寄存器的低 16 位 ，例如 <code>EAX</code> 是 32 位，<code>AX</code> 是其低 16 位；8 位寄存器是 16 位寄存器进一步拆分的结果，比如 <code>AX</code> 又可拆分为高 8 位的 <code>AH</code> 和低 8 位的 <code>AL</code> 。</td><td></td><td></td><td></td></tr><tr><td>前四个用于存放操作数，后四个用于存放变址值/指针</td><td></td><td></td><td></td></tr><tr><td><strong>用途优先级</strong>：</td><td></td><td></td><td></td></tr><tr><td>数据首选存储于<strong>内存</strong>，再 <strong>EAX</strong>，接着考虑 <strong>EDX</strong> 等<strong>通用寄存器</strong>，最后考虑其他寄存器。</td><td></td><td></td><td></td></tr></tbody></table><h4 id="专用寄存器">专用寄存器</h4><h4 id="指令指针寄存器-EIP">指令指针寄存器 (EIP)</h4><ul><li><strong>功能</strong>：存放下一条要执行指令的 <strong>有效地址（偏移地址）</strong>。</li><li><strong>特性</strong>：<ul><li><strong>不可直接修改</strong>，由 <strong>控制转移指令（如 JMP、CALL）</strong> 或<strong>中断/异常</strong>自动更新。</li><li>在<strong>实模式</strong>下为 16 位（IP），<strong>保护模式</strong>下为 32 位（EIP）。<ul><li>实模式：<ul><li>操作系统与用户/程序拥有同等的权利，也就是说操作系统可以做的，普通用户也可以自己做。</li><li>所使用的地址都是真实的物理地址</li></ul></li><li>保护模式：<ul><li>通过分段和分页机制实现虚拟地址到物理地址的映射。</li><li>32 位处理器可访问 4GB 内存，支持虚拟内存，段大小可动态分配，分页提高内存管理灵活性。</li></ul></li></ul></li></ul></li></ul><h5 id="标志寄存器-EFLAGS">标志寄存器 (EFLAGS)</h5><ul><li><strong>功能</strong>：反映指令<strong>执行结果</strong>或<strong>控制 CPU 操作模式</strong>。<ul><li><strong>状态标志</strong>：记录算术/逻辑运算结果特征。</li><li><strong>控制标志</strong>：控制 CPU 行为（如中断、方向）。</li><li><strong>系统标志</strong>：操作系统级控制（如虚拟化、权限）。</li><li>关注的不是整体数据，而是每一位的含义</li></ul></li></ul><h6 id="状态标志位">状态标志位</h6><ol><li><strong>高级语言视角</strong>：在高级语言中，通过类似 “if (a&gt; b) {… } else {… }” 的语句结构进行条件判断，直接以逻辑表达式（如a &gt; b ）来决定执行不同分支的代码。</li><li><strong>硬件视角</strong><ul><li><strong>比较操作</strong>：通过 “cmp 指令”（如 cmp a, b ）来比较a和b，其本质是计算a - b 。</li><li><strong>结果存储</strong>：相减得到的结果相关信息会记录在程序状态字寄存器（PSW）中 。</li><li><strong>条件判断依据</strong>：依据 PSW 中的标志位进行条件判断，以决定程序是否转移。PSW 中几个关键标志位含义如下：</li></ul></li></ol><table><thead><tr><th><strong>标志位</strong></th><th><strong>名称</strong></th><th><strong>触发条件</strong></th></tr></thead><tbody><tr><td>CF</td><td><strong>进位</strong>标志</td><td><strong>无符号</strong>数运算产生<strong>进位/借位</strong>时置 1</td></tr><tr><td>PF</td><td><strong>奇偶</strong>标志</td><td>运算结果<strong>低 8 位中 1 的个数</strong>为<strong>偶数</strong>时置 1</td></tr><tr><td>AF</td><td><strong>辅助进位</strong>标志</td><td>运算中<strong>低四位向高四位产生进位/借位</strong>时置 1（用于 BCD 码调整）</td></tr><tr><td>ZF</td><td><strong>零</strong>标志</td><td>运算<strong>结果为 0</strong> 时置 1</td></tr><tr><td>SF</td><td><strong>符号</strong>标志</td><td>运算结果<strong>最高位为 1</strong> 时置 1（有符号数为负数）</td></tr><tr><td>OF</td><td><strong>溢出</strong>标志</td><td><strong>有符号</strong>数运算结果<strong>超出范围</strong>时置 1</td></tr><tr><td>DF</td><td><strong>方向</strong>标志</td><td>控制字符串<strong>操作地址增减方向</strong>（0=递增，1=递减）</td></tr><tr><td>IF</td><td><strong>中断允许</strong>标志</td><td>控制是否响应<strong>可屏蔽中断</strong>（1=允许）</td></tr><tr><td>TF</td><td><strong>陷阱</strong>标志</td><td>置 1 时进入<strong>单步调试</strong>模式（每条指令后触发中断）</td></tr><tr><td>溢出标志OF=1【<mark>有符号</mark>】 看<mark>符号位</mark>的一列是否符合规律 +±/—+；看变形补码是否是01，10，自然丢失的不考虑。溢出的根本原因是计算机的字长有限 <strong><mark>最高位与次高位进位异或</mark></strong> 一个有进位一个没有进位,则他们的状态异或得1,则结果就有溢出</td><td></td><td></td></tr><tr><td>进位标志CF=1 【<mark>无符号</mark>】 <mark>最高位进位Cout和Cinsub(减法=1，加法=0)异或</mark></td><td></td><td></td></tr><tr><td>状态标志：6个( OF、SF、ZF、CF、AF、PF )记录指令执行结果的辅助信息</td><td></td><td></td></tr><tr><td>控制标志：3个( DF、IF、TF )用来控制CPU的操作</td><td></td><td></td></tr><tr><td>系统标志：控操作系统或核心管理程序的操作方式</td><td></td><td></td></tr><tr><td>汇编语言中，条件跳转指令有很多种，如je2表示当比较结果为 a=b 时跳转到2jg2表示当比较结果为a&gt;b时跳转到2</td><td></td><td></td></tr><tr><td>无条件转移指令jmp2，就不会管PSW的各种标志位</td><td></td><td></td></tr><tr><td>eg.  10010001B+01110100B=00000101B</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10010001</span><br><span class="line">+ 01110100</span><br><span class="line">──────────</span><br><span class="line">  00000101  （进位 1）</span><br></pre></td></tr></table></figure><ol><li><strong>进位标志 CF</strong>：CF = 1，因为运算产生了进位。</li><li><strong>辅助进位标志 AF</strong>：AF = 0，半字节无进位。</li><li><strong>符号标志 SF</strong>：SF = 0，结果最高位为0，结果为正。</li><li><strong>零标志 ZF</strong>：ZF = 0，结果不为0。</li><li><strong>奇偶标志 PF</strong>：PF = 1，结果中1的个数为偶数个。</li><li><strong>溢出标志 OF</strong>：OF = 0，将两个操作数作为有符号数，10010001B = -6FH，01110100B = +74H，(-6FH)+(+74H)= +05H，由于不是同号相加，结果无溢出（加法OF溢出判断规则：同号相加，结果相异；OF为1，否则OF为0）。</li></ol><p>eg.01110001B - 10001011B = 11100110B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  01110001</span><br><span class="line">- 10001011</span><br><span class="line">──────────</span><br><span class="line">  11100110  （借位 1）</span><br></pre></td></tr></table></figure><ol><li><strong>进位标志 CF</strong>：CF = 1，因为运算产生了借位。</li><li><strong>辅助进位标志 AF</strong>：AF = 1，半字节产生了进位。</li><li><strong>符号标志 SF</strong>：SF = 1，结果最高位为1，结果为负。</li><li><strong>零标志 ZF</strong>：ZF = 0，结果不为0。</li><li><strong>奇偶标志 PF</strong>：PF = 0，结果中1的个数为奇数个。</li><li><strong>溢出标志 OF</strong>：OF = 1，将两个操作数作为有符号数，01110001B = +71H，10001011B = -75H，(+71H)-(-75)=-1AH ，由于是异号相减，差的符号与被减数相异（减法OF溢出判断规则：异号相减，差的符号与被减数相异，OF为1；否则OF为0），所以产生了溢出。</li></ol><h6 id="条件转移指令的比较规则">条件转移指令的比较规则</h6><p>①<strong>无符号整数比较（bgt）</strong>：仅依赖 <strong>CF（借位）</strong> 判断大小，ZF 用于排除相等情况</p><ul><li><p><strong>判断条件</strong>：A &gt; B（无符号）</p></li><li><p><strong>标志位逻辑</strong>：</p><ul><li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li><li><strong>CF=0</strong>：无借位（A ≥ B）。</li></ul></li><li><p><strong>转移条件</strong>：CF=0 且 ZF=0 → <strong>$\overline{CF + ZF} = 1$</strong></p></li><li><p><strong>判断条件</strong>：A ＜ B（无符号）</p></li><li><p><strong>标志位逻辑</strong>：</p><ul><li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li><li><strong>CF=1</strong>：有借位（A ≤ B）。</li></ul></li><li><p><strong>转移条件</strong>：CF=0 且 ZF=0→$CF ∧ ¬ZF$</p></li></ul><p>②<strong>有符号整数比较（如 bgt.s）</strong>：需结合 <strong>SF（符号）</strong> 和 <strong>OF（溢出）</strong>，确保结果符号的正确性</p><ul><li><strong>判断条件</strong>：A &gt; B（有符号）</li><li><strong>标志位逻辑</strong>：<ul><li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li><li><strong>SF=OF</strong>：符号标志与溢出标志一致（结果为正且未溢出，或为负但溢出）。</li></ul></li><li><strong>转移条件</strong>：<strong>ZF=0 且 SF=OF</strong>（如 $\overline{SF \oplus OF} \cdot \overline{ZF} = 1$）。</li><li><strong>判断条件</strong>：A ＜ B（有符号）</li><li><strong>标志位逻辑</strong>：<ul><li><strong>ZF=0</strong>：结果非零（A ≠ B）。</li><li><strong>SF≠OF</strong>：符号标志与溢出标志不同，表示结果无效需反转</li></ul></li><li><strong>转移条件</strong>：(SF⊕OF)=1且ZF=0（如 $(SF ⊕ OF) ∧ ¬ZF$）。</li></ul><h4 id="段寄存器">段寄存器</h4><p>段寄存器用于 <strong>内存分段管理</strong>，与偏移地址共同构成 <strong>逻辑地址</strong>：</p><table><thead><tr><th><strong>段寄存器</strong></th><th><strong>名称</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>CS</td><td><strong>代码段</strong>寄存器</td><td>指向<strong>当前代码段</strong>，<strong>EIP</strong> 保存<strong>段内偏移地址</strong></td></tr><tr><td>SS</td><td><strong>堆栈段</strong>寄存器</td><td>指向<strong>当前堆栈段</strong>，<strong>ESP</strong> 保存<strong>栈顶偏移地址</strong></td></tr><tr><td>DS</td><td><strong>数据段</strong>寄存器</td><td><strong>默认数据</strong>段，用于<strong>一般数据</strong>访问</td></tr><tr><td>ES</td><td><strong>附加段</strong>寄存器</td><td><strong>辅助数据</strong>段，常用于<strong>字符串</strong>操作的目标段</td></tr><tr><td>FS/GS</td><td><strong>附加段</strong>寄存器</td><td><strong>扩展数据</strong>段，<strong>操作系统或程序</strong>可自由使用</td></tr><tr><td><strong>逻辑地址格式</strong>：<code>段基址:偏移地址</code> → 需转换为 <strong>物理地址</strong> 访问内存。</td><td></td><td></td></tr></tbody></table><h4 id="存储器组织">存储器组织</h4><h5 id="物理地址与逻辑地址">物理地址与逻辑地址</h5><ul><li><strong>物理地址</strong>：内存单元的<strong>实际地址</strong>，<strong>唯一</strong>且<strong>连续</strong>（如 IA-32 支持 4GB 空间：<code>00000000H~FFFFFFFFH</code>）。</li><li><strong>逻辑地址</strong>：<strong>程序员</strong>使用的地址，格式为 <code>段基址:偏移地址</code>。<ul><li><strong>转换规则</strong>：物理地址 = 段基址 × 16【后面加一个0】（实模式）或通过段描述符（保护模式） + 偏移地址。</li><li><strong>多逻辑地址映射</strong>：同一物理地址可由不同逻辑地址表示（如 <code>1000H:2000H</code> 和 <code>2000H:1000H</code> 均指向 <code>12000H</code>）。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250425201252771.png" alt="image.png"><ul><li><code>1460H × 10H + 0100H = 14600H + 0100H = 14700H</code></li><li><code>1380H × 10H + 0F00H = 13800H + 0F00H = 14700H</code><br>从物理地址 <code>14700H</code> 开始的内存内容为：<br>14700H: 43H, 14701H: 42H`（低字节在前，高字节在后）。<br><strong>取16位数据</strong>：</li></ul></li><li><strong>小端方式</strong>：低地址存低位字节 → 数据为 <code>4243H</code>。</li></ul></li></ul><h5 id="存储模型">存储模型</h5><p>IA-32 支持三种存储模型，用于程序访问存储器：</p><table><thead><tr><th><strong>模型</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>平展模型</strong></td><td>单一<strong>连续</strong>地址空间（0~4GB），段寄存器指向<strong>同一基址</strong>（0）</td><td>现代操作系统（如 Windows）</td></tr><tr><td><strong>段式模型</strong></td><td>代码、数据、堆栈分段管理，每段最大 4GB</td><td>增强程序安全性与模块化</td></tr><tr><td><strong>实地址模型</strong></td><td>兼容 8086，段最大 64KB，物理地址 = 段基址 × 16 + 偏移地址</td><td>实模式程序或引导代码</td></tr></tbody></table><h5 id="工作模式">工作模式</h5><table><thead><tr><th><strong>模式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>保护模式</strong></td><td>支持段页式存储管理、多任务与权限控制，全面发挥 32 位性能</td></tr><tr><td><strong>实地址模式</strong></td><td>兼容 8086，仅支持 1MB 内存，段最大 64KB</td></tr><tr><td><strong>虚拟 8086 模式</strong></td><td>在保护模式下运行 8086 程序，支持多任务</td></tr></tbody></table><h4 id="段选择器与段描述符">段选择器与段描述符</h4><ul><li><strong>段选择器</strong>：16 位段寄存器值，指向全局描述符表 (GDT) 或局部描述符表 (LDT) 中的条目。</li><li><strong>段描述符</strong>：64 位数据结构，包含段基址、段限长、访问权限等信息。<ul><li><strong>基址</strong>：32 位，定义段起始物理地址。</li><li><strong>限长</strong>：20 位，定义段大小（单位由粒度位决定，4KB 或 1B）。</li><li><strong>权限</strong>：定义段的特权级（0~3）和访问类型（代码/数据/系统段）。</li></ul></li></ul><h4 id="基本段类型">基本段类型</h4><p>编写应用程序时，涉及三类<strong>基本段</strong>:</p><ul><li><strong>代码段</strong>  :<font color="#ff0000">CS:EIP</font><ul><li>存放<strong>指令代码</strong> 程序的指令代码<strong>必须</strong>安排在代码段</li><li><strong>段基地址</strong>：代码段寄存器<strong>CS</strong>指示</li><li><strong>偏移地址</strong>：指令指针寄存器<strong>EIP</strong>或<strong>IP</strong>保存，指向下一条要执行的指令。</li><li>代码段是<strong>只读</strong>的，防止程序意外修改指令</li><li>跳转/调用指令会修改<code>EIP</code>的值。</li></ul></li><li><strong>数据段</strong> :<font color="#ff0000">DS:偏移地址</font><ul><li>存放数据 程序的数据默认存放在数据段，数据也可放在其他段【保存程序的全局变量、静态数据等】</li><li><strong>段基地址</strong>：数据段寄存器<strong>DS</strong>指示<br>有时也用附加段寄存器<strong>ES</strong>，段寄存器<strong>FS</strong>和<strong>GS</strong>指示，但需显式指定段前缀<br>例如：<code>MOV EAX, ES:[EBX]</code>表示从附加段<code>ES</code>而非默认<code>DS</code>读取数据</li><li><strong>偏移地址</strong>：各种存储器寻址方式计算出来</li></ul></li><li><strong>堆栈段</strong>  : <font color="#ff0000">SS:ESP</font><ul><li>堆栈区域 程序使用的堆栈操作（如<code>PUSH</code>、<code>POP</code>、<code>CALL</code>）<strong>一定</strong>在堆栈段【存储<strong>函数调用时的返回地址、局部变量、参数</strong>等】</li><li><strong>段基地址</strong>：堆栈段寄存器<strong>SS</strong>指示</li><li><strong>偏移地址</strong>：堆栈指针寄存器<strong>ESP</strong>或<strong>SP</strong>保存</li><li>堆栈向<strong>低地址</strong>方向增长（如<code>PUSH EAX</code>会先<code>ESP-4</code>再写入数据）</li><li><code>EBP</code>通常用作栈帧基址，访问局部变量时默认基于<code>SS</code>段（如<code>[EBP-8]</code>）</li></ul></li></ul><table><thead><tr><th><strong>操作类型</strong></th><th><strong>默认段寄存器</strong></th><th><strong>可覆盖的段寄存器</strong></th><th><strong>规则</strong></th></tr></thead><tbody><tr><td>取指令</td><td>CS</td><td><strong>不可覆盖</strong></td><td>永远从<code>CS:EIP</code>取指令</td></tr><tr><td>堆栈操作（PUSH/POP）</td><td>SS</td><td><strong>不可覆盖</strong></td><td>永远使用<code>SS:ESP</code></td></tr><tr><td>一般数据访问</td><td>DS</td><td>CS/ES/SS/FS/GS</td><td>如<code>MOV EAX, FS:[EBX]</code></td></tr><tr><td>以<code>EBP/ESP</code>为基址的寻址</td><td>SS</td><td>CS/ES/DS/FS/GS</td><td>有效地址（如<code>[EBP-如</code>MOV EAX, DS:[EBP-4]<code>4]</code>）</td></tr><tr><td>串操作的源操作数</td><td>DS</td><td>CS/ES/SS/FS/GS</td><td>必须用<code>ES:ESI</code></td></tr><tr><td>串操作的目的操作数</td><td>ES</td><td><strong>不可覆盖</strong></td><td>必须用<code>ES:EDI</code></td></tr><tr><td>在x86架构中，<strong>段覆盖</strong>是指<strong>显式指定一个非默认的段寄存器</strong>来访问内存数据。</td><td></td><td></td><td></td></tr><tr><td><strong>覆盖目的</strong>：临时突破默认规则，访问其他段的数据（如跨段读取或写入）</td><td></td><td></td><td></td></tr><tr><td>段覆盖语法：<code>段寄存器:[偏移地址]</code></td><td></td><td></td><td></td></tr><tr><td><strong>1. 代码段访问</strong></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU自动从 CS:EIP 取指令执行</span><br><span class="line">MOV EAX, [EBX]   ; 默认从 DS:[EBX] 读取数据</span><br><span class="line">MOV EAX, ES:[EBX]; 显式从 ES:[EBX] 读取</span><br><span class="line">JMP 0x1000       ; 修改 EIP，跳转到 CS:0x1000</span><br></pre></td></tr></table></figure><p><strong>2. 数据段覆盖</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, [ESI]          ; 默认 DS:[ESI]</span><br><span class="line">MOV EAX, ES:[ESI]       ; 显式指定 ES:[ESI]</span><br><span class="line">MOV EAX, FS:[0x30]      ; 读取Windows TEB（线程环境块）</span><br></pre></td></tr></table></figure><p><strong>3. 堆栈操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH EAX        ; 将EAX压入 SS:ESP-4</span><br><span class="line">POP EBX         ; 从 SS:ESP 弹出数据到EBX</span><br><span class="line">CALL func       ; 将返回地址压入堆栈（SS:ESP-4）</span><br></pre></td></tr></table></figure><p><strong>4. 串操作（需注意段规则）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV ESI, DS:[src_addr]  ; 源地址（可省略DS）</span><br><span class="line">MOV EDI, ES:[dst_addr]  ; 目标地址（必须用ES）</span><br><span class="line">MOVSB                   ; 复制 DS:[ESI] -&gt; ES:[EDI]</span><br></pre></td></tr></table></figure><ol><li><p><strong>误区</strong>：<code>CS</code>可以被显式修改（如<code>MOV CS, AX</code>）。<br><strong>事实</strong>：<code>CS</code>只能通过控制转移指令（如<code>JMP</code>、<code>CALL</code>）间接修改，直接写入会引发异常。</p></li><li><p><strong>误区</strong>：堆栈段可以用其他段寄存器覆盖。<br><strong>事实</strong>：堆栈操作（如<code>PUSH</code>、<code>POP</code>）强制使用<code>SS</code>，不可覆盖。</p></li><li><p><strong>误区</strong>：<code>EIP</code>可以像通用寄存器一样自由修改。<br><strong>事实</strong>：<code>EIP</code>只能通过跳转、中断等指令隐式修改，不支持<code>MOV EIP, EAX</code>这类操作。</p></li></ol><h4 id="常用指令">常用指令</h4><h5 id="数据传送指令">数据传送指令</h5><ul><li><strong>MOV</strong>：通用数据传送（如 <code>MOV EAX, [0x1000]</code>）。</li><li><strong>XCHG</strong>：交换两操作数值（至少一个为寄存器，如 <code>XCHG EAX, EBX</code>）。<br>此指令不影响标准寄存器的值</li></ul><h5 id="堆栈操作指令">堆栈操作指令</h5><ul><li><strong>PUSH</strong>：将操作数压入栈顶（如 <code>PUSH EAX</code>）。</li><li><strong>POP</strong>：从栈顶弹出数据到目标（如 <code>POP EBX</code>）。</li></ul><h5 id="地址操作指令">地址操作指令</h5><ul><li><strong>LEA</strong>：加载有效地址到寄存器（如 <code>LEA ESI, [EBX+4]</code>）。<br>LEA REG，SRC<br>把源操作数SRC的地址偏移量传送至寄存器REG<br>mov传送操作数的内容，LEA传送操作数的地址。<br>eg.已知R[eax]=0100h，R[edx]=1000h，M[1400H]=08H，M[1100H]=02H，在平展存储模型下，说明下列指令的功能及各指令执行后eax的值。<br>(1) <code>mov eax,[edx][eax]</code><br>功能：R[eax]←M[R[edx]+R[eax]] ，R[eax]=02H<br>(2) <code>mov eax,[edx+eax*4]</code><br>功能：R[eax]←M[R[edx]+R[eax]∗4] ，R[eax]=08H<br>(3) <code>lea eax,[edx+eax*4]</code><br>功能：R[eax]←R[edx]+R[eax]∗4 ，R[eax]=1400H</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEA BX,BUFFER;将内存单元BUFFER的偏移地址送BX</span><br><span class="line">MOV AL,[BX];取出BUFFER的第一个数据送AL</span><br><span class="line">MOV AH,[BX+1];取出BUFFER的第二个数据送AH</span><br></pre></td></tr></table></figure><h5 id="输入输出指令">输入输出指令</h5><ul><li><strong>IN/OUT</strong>：与 I/O 端口通信（如 <code>IN AL, 60H</code> 读取键盘输入）。<br><strong>输入</strong>指令：输入指令IN用于从I/O端口读数据到累加器<strong>AL、AX或EAX</strong>（没有AH）中<br><strong>输出</strong>指令：输出指令OUT用于把累加器<strong>AL、AX或EAX</strong>的内容写到I/O端口<br><strong>注意</strong> 输入输出指令中，只有累加器AL、AX或EAX才能与I/O端口进行数据传送，所以又称为累加器专用指令。<br>IN指令：从端口输入一个字节到AL或输入一个字到AX中<br>OUT指令：从端口输入一个字到AL或输入一个字到AX中</li><li>port 0~64KB</li><li><strong>I/O直接寻址</strong>：port为<strong>8位</strong>立即数表示的<strong>端口地址</strong>。寻址范围00H~FFH，即256个端口。</li><li><strong>I/O寄存器间接寻址</strong>：<strong>16位</strong>端口地址，<strong>DX</strong>为<strong>间接寄存器</strong>。寻址范围0000H~FFFH，即64个端口</li><li>最低的256 个端口可以用直接寻址或间接寻址</li><li>高于256的端口只能用间接寻址。</li></ul><p>输入指令：</p><table><thead><tr><th>指令格式</th><th>数据宽度</th><th>功能</th></tr></thead><tbody><tr><td><code>IN AL, port</code></td><td>8</td><td>从<code>port</code>端口读 1 个字节到<code>AL</code>中</td></tr><tr><td><code>IN AX, port</code></td><td>16</td><td>从<code>port</code>端口读 1 个字到<code>AX</code>中</td></tr><tr><td><code>IN EAX, port</code></td><td>32</td><td>从<code>port</code>端口读 1 个双字到<code>EAX</code>中</td></tr><tr><td><code>IN AL, DX</code></td><td>8</td><td>从<code>DX</code>所指示的端口读 1 个字节到<code>AL</code>中</td></tr><tr><td><code>IN AX, DX</code></td><td>16</td><td>从<code>DX</code>所指示的端口读 1 个字到<code>AX</code>中</td></tr><tr><td><code>IN EAX, DX</code></td><td>32</td><td>从<code>DX</code>所指示的端口读 1 个双字到<code>EAX</code>中</td></tr><tr><td>输出指令：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>指令格式</th><th>数据宽度</th><th>功能</th></tr></thead><tbody><tr><td><code>OUT port, AL</code></td><td>8</td><td>将<code>AL</code>中的 1 个字节数据输出到<code>port</code>端口</td></tr><tr><td><code>OUT port, AX</code></td><td>16</td><td>将<code>AX</code>中的 1 个字数据输出到<code>port</code>端口</td></tr><tr><td><code>OUT port, EAX</code></td><td>32</td><td>将<code>EAX</code>中的 1 个双字数据输出到<code>port</code>端口</td></tr><tr><td><code>OUT DX, AL</code></td><td>8</td><td>将<code>AL</code>中的 1 个字节数据输出到<code>DX</code>所指示的端口</td></tr><tr><td><code>OUT DX, AX</code></td><td>16</td><td>将<code>AX</code>中的 1 个字数据输出到<code>DX</code>所指示的端口</td></tr><tr><td><code>OUT DX, EAX</code></td><td>32</td><td>将<code>EAX</code>中的 1 个双字数据输出到<code>DX</code>所指示的端口</td></tr><tr><td>将端口 20H 地址开始的 16 位数据取反，指令序列分别为：</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IN AX,20H</span><br><span class="line">NOT AX</span><br><span class="line">OUT 20H,AX</span><br></pre></td></tr></table></figure><h6 id="I-O寻址方式-VS-存储器寻址方式"><strong>I/O寻址方式 VS 存储器寻址方式</strong></h6><p><strong>存储器寻址方式</strong></p><ol><li><p><strong>立即寻址</strong></p><ul><li><strong>示例</strong>: <code>MOV DX, 03B0H</code><ul><li><code>03B0H</code> 是立即数，由指令直接给出。</li><li><strong>功能</strong>: 将立即数 <code>03B0H</code> 直接存入寄存器 <code>DX</code>。</li></ul></li></ul></li><li><p><strong>直接寻址</strong></p><ul><li><strong>示例</strong>: <code>MOV DX, [03B0H]</code><ul><li><code>[03B0H]</code> 表示内存偏移地址 <code>03B0H</code> 处的内容。</li><li><strong>功能</strong>: 从内存地址 <code>DS:03B0H</code> 读取数据到 <code>DX</code>。</li></ul></li></ul></li><li><p><strong>寄存器寻址</strong></p><ul><li><strong>示例</strong>: <code>MOV DX, AX</code><ul><li><code>AX</code> 是源寄存器，<code>DX</code> 是目标寄存器。</li><li><strong>功能</strong>: 将 <code>AX</code> 的值复制到 <code>DX</code>。</li></ul></li></ul></li><li><p><strong>寄存器间接寻址</strong></p><ul><li><strong>示例</strong>: <code>MOV DX, [AX]</code><ul><li><code>[AX]</code> 表示以 <code>AX</code> 的值为内存偏移地址。</li><li><strong>功能</strong>: 从内存地址 <code>DS:AX</code> 读取数据到 <code>DX</code>。</li></ul></li></ul></li></ol><p><strong>I/O寻址方式</strong></p><ol><li><p><strong>直接寻址</strong></p><ul><li><strong>示例</strong>: <code>IN AL, 3FH</code><ul><li><code>3FH</code> 是端口号，作为立即数直接给出。</li><li><strong>功能</strong>: 从端口 <code>3FH</code> 读取数据到 <code>AL</code>。</li></ul></li></ul></li><li><p><strong>寄存器间接寻址</strong></p><ul><li><strong>示例</strong>: <code>OUT DX, AL</code><ul><li><code>DX</code> 寄存器存储端口号。</li><li><strong>功能</strong>: 将 <code>AL</code> 的值写入 <code>DX</code> 指定的端口。</li><li><strong>注意</strong>: I/O 间接寻址<strong>只能用 <code>DX</code> 作为地址寄存器</strong>。</li></ul></li></ul></li></ol><table><thead><tr><th><strong>特性</strong></th><th><strong>存储器寻址</strong></th><th><strong>I/O寻址</strong></th></tr></thead><tbody><tr><td><strong>地址范围</strong></td><td>访问内存单元（如 <code>DS:03B0H</code>）</td><td>访问I/O端口（如端口号 <code>3FH</code>）</td></tr><tr><td><strong>间接寻址寄存器</strong></td><td>任意通用寄存器（如 <code>AX</code>）</td><td><strong>仅限 <code>DX</code></strong></td></tr><tr><td><strong>语法</strong></td><td>使用 <code>[ ]</code> 表示内存地址</td><td>无 <code>[ ]</code>，直接写端口号或寄存器</td></tr><tr><td><strong>关键指令详解</strong></td><td></td><td></td></tr><tr><td><strong>1. <code>SUB</code>（减法）</strong></td><td></td><td></td></tr></tbody></table><ul><li><strong>语法</strong>: <code>SUB destination, source</code></li><li><strong>功能</strong>: <code>destination = destination - source</code></li><li><strong>示例</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB AX, BX   ; AX = AX - BX</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. <code>CMP</code>（比较）</strong></p><ul><li><strong>语法</strong>: <code>CMP operand1, operand2</code></li><li><strong>功能</strong>: 计算 <code>operand1 - operand2</code>，<strong>仅影响标志位</strong>，不修改操作数。</li><li><strong>用途</strong>: 配合条件跳转指令（如 <code>JE</code>, <code>JNZ</code>）使用。</li><li><strong>示例</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP AX, 100   ; 比较 AX 和 100，设置标志位</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. <code>INC</code>（自增）</strong></p><ul><li><strong>语法</strong>: <code>INC operand</code></li><li><strong>功能</strong>: <code>operand = operand + 1</code></li><li><strong>示例</strong>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC CX   ; CX = CX + 1</span><br></pre></td></tr></table></figure></li></ul><p>eg.<br><strong>栈指针变化</strong>：</p><ol><li><strong>题目</strong>：假设当前R[esp]=3412FFB0h，下面指令连续执行后，说明每条指令执行后 esp 的内容？其中：dword-- 双字类型，32 位；word-- 字类型，16 位<ul><li>push dx ；R[esp]= [填空 1]</li><li>push eax ；R[esp]= [填空 2]</li><li>push dword ptr 0f79h ；R[esp]= [填空 3]</li><li>pop eax ；R[esp]= [填空 4]</li><li>pop word ptr [bx] ；R[esp]= [填空 5]</li><li>pop ebx ；R[esp]= [填空 6]</li></ul></li><li><strong>答案</strong>：3412FFAEH；3412FFAAH；3412FFA6H；3412FFAAH；3412FFACH；3412FFBОH</li></ol><p><strong>寄存器操作</strong>：<br><strong>屏蔽</strong> <font color="#e36c09">AND 1111变0  </font><br>eg.AND AX 1111 1110 0111 1111B AX第7、8位屏蔽<br><strong>置1</strong> <font color="#e36c09">OR 0000变1  </font><br>eg.OR CL,0011 0000B CL中第4、5位置1<br><strong>取反</strong> <font color="#e36c09">XOR 0000变1  </font><br>eg.XOR DH,1000 1000B DH中第3、7位取反</p><ol><li><strong>题目</strong><ul><li>(1) MOV AL，45H;XOR AL，31H 指令执行后，R[AL]= [填空 1]</li><li>(2) 已知 MOV AX，2345H 屏蔽 AX 寄存器的高 8 位，编写的指令为 [填空 2], 指令执行后，R[AX]= [填空 3]</li><li>(3) 已知 MOV EAX，12345678H 将 EAX 寄存器的高 16 位置 1, 编写的指令为 [填空 1]。指令执行后，R[EAX]= [填空 2]</li><li>(4) 已知 MOV AX，7890H 将 AH 寄存器的第 6 位和第 7 位取反其余位保持不变。编写的指令为 [填空 3]。指令执行后，R[AX]= [填空 4]</li></ul></li><li><strong>答案</strong><ul><li>(1) 74H<br>45H (01000101B) XOR 31H (00110001B) = 74H (01110100B)</li><li>(2) AND AX,00FFH；0045H</li><li>(3) OR EAX,FFFF0000H；FFFF5678H</li><li>(4) XOR AX,C000H/XOR AH,C0H；B890H</li></ul></li></ol><p><strong>add 函数汇编代码</strong>：</p><ol><li><strong>题目</strong>：以 add 函数汇编代码为例<ol><li>PUSH EBP</li><li>MOV EBP ESP</li><li>SUB ESP,40H</li><li>PUSH EBX</li><li>PUSH ESI</li><li>PUSH EDI</li><li>MOV EAX,DWORD PTR SS:[EBP+8]</li><li>ADD EAX,DWORD PTR SS:[EBP+0CH]</li><li>POP EDI</li><li>POP ESI</li><li>POP EBX</li><li>MOV ESP,EBP</li><li>POP EBP</li></ol><ul><li>根据要求填写指令序号<ul><li>形成栈底的指令是 填空 1</li><li>现场保护的指令是 填空 2</li><li>恢复现场的指令是 填空 3</li><li>开辟堆栈空间的指令是 [填空 4]</li><li>SS:[EBP+8] 这个地址的数据是 [填空 5]</li><li>SS:[EBP+0CH] 这个地址的数据是 [填空 6]</li></ul></li></ul></li><li><strong>答案</strong>：1 2；4 5 6；9 10 11；3；7DH/125；50H/80</li></ol><ul><li><strong>形成栈底的指令</strong>：<code>1 2</code><ul><li><code>PUSH EBP</code> + <code>MOV EBP, ESP</code> 建立栈帧基址。</li></ul></li><li><strong>现场保护的指令</strong>：<code>4 5 6</code><ul><li><code>PUSH EBX/ESI/EDI</code> 保存调用者寄存器。</li></ul></li><li><strong>恢复现场的指令</strong>：<code>9 10 11</code><ul><li><code>POP EDI/ESI/EBX</code> 恢复寄存器。</li></ul></li><li><strong>开辟堆栈空间的指令</strong>：<code>3</code><ul><li><code>SUB ESP, 40H</code> 分配局部变量空间。</li></ul></li><li><strong><code>SS:[EBP+8]</code>的数据</strong>：<code>7DH</code>（十进制125）<ul><li>假设第一个参数为125。</li></ul></li><li><strong><code>SS:[EBP+0CH]</code>的数据</strong>：<code>50H</code>（十进制80）<ul><li>假设第二个参数为80。</li></ul></li></ul><p>eg.<strong>寄存器赋值</strong><br>已知：<code>EAX = AABBCCDDH</code>, <code>EBX = 11223344H</code>, <code>ECX = 66778899H</code></p><table><thead><tr><th><strong>指令</strong></th><th><strong>结果</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><code>MOV EAX, 5678H</code></td><td>EAX = <strong>00005678H</strong></td><td>32位寄存器赋值，立即数零扩展至32位。</td></tr><tr><td><code>MOV CX, 2000H</code></td><td>ECX = <strong>66772000H</strong></td><td>仅修改CX（ECX低16位），高16位不变。</td></tr><tr><td><code>MOV AH, 55H</code></td><td>EAX = <strong>AABB55DDH</strong></td><td>修改AH（EAX高8位），其余位不变。</td></tr><tr><td><code>MOV AL, 77H</code></td><td>EAX = <strong>AABBCC77H</strong></td><td>修改AL（EAX低8位），其余位不变。</td></tr><tr><td><code>MOV BH, AL</code></td><td>EBX = <strong>1122DD44H</strong></td><td>将AL的值（DDH）写入BH（EBX第15~8位）。</td></tr><tr><td>eg. <strong>内存操作与数据访问</strong></td><td></td><td></td></tr><tr><td><code>(AX)=1122H,(BX)=2002H</code></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>地址</strong></th><th>2000H</th><th>2001H</th><th>2002H</th><th>2003H</th><th>2004H</th><th>2005H</th><th>2006H</th><th>2007H</th></tr></thead><tbody><tr><td><strong>数据</strong></td><td>10H</td><td>20H</td><td>30H</td><td>40H</td><td>50H</td><td>60H</td><td>70H</td><td>80H</td></tr></tbody></table><table><thead><tr><th><strong>指令</strong></th><th><strong>结果</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><code>MOV BX, [2004H]</code></td><td>BX = <strong>6050H</strong></td><td>从2004H取2字节（50H,60H），小端组合。</td></tr><tr><td><code>MOV AX, BX</code></td><td>AX = <strong>2002H</strong></td><td>将BX的值2002H复制到AX。</td></tr><tr><td><code>MOV AX, [BX]</code></td><td>AX = <strong>4030H</strong></td><td>BX=2002H，取[2002H]的30H和40H。</td></tr><tr><td><code>MOV [AX], 2000H</code></td><td>AX 值不变</td><td>将2000H写入[AX]指向的内存（AX仍为1122H）。</td></tr><tr><td><code>MOV BL, 78H</code></td><td>BX = <strong>2078H</strong></td><td>修改BL（BX低8位），BH保持20H不变。</td></tr></tbody></table><h4 id="关键总结">关键总结</h4><ol><li><strong>寄存器层级</strong>：<strong>通用寄存器 &gt; 专用寄存器 &gt; 段寄存器</strong>，分工明确，支持高效运算与内存管理。</li><li><strong>地址转换</strong>：<strong>逻辑地址</strong>通过<strong>分段机制</strong>转换为<strong>物理地址</strong>，<strong>保护模式</strong>下需借助<strong>段描述符</strong>。</li><li><strong>标志位控制</strong>：EFLAGS 反映 <strong>CPU 状态</strong>，<strong>直接影响条件跳转指令</strong>（如 JZ、JC）。</li><li><strong>段式管理</strong>：增强程序模块化与安全性，但增加地址转换开销。</li></ol><h5 id="AT-T格式-VS-Intel格式">AT&amp;T格式 VS Intel格式</h5><table><thead><tr><th>对比项目</th><th>AT&amp;T 格式</th><th>Intel 格式</th></tr></thead><tbody><tr><td>目的操作数 d、源操作数 s</td><td><strong>op s, d</strong> <br>源操作数在左，目的操作数在右</td><td><strong>op d, s</strong> <br>源操作数在右，目的操作数在左</td></tr><tr><td>寄存器的表示</td><td>mov %ebx, %eax <br>寄存器名之前必须加 “%”</td><td>mov eax, ebx<br>直接写寄存器名即可</td></tr><tr><td>立即数的表示</td><td>mov <strong>$985</strong>, %eax<br>立即数之前必须加 $</td><td>mov eax, 985 <br>直接写数字即可</td></tr><tr><td>主存地址的表示</td><td>mov %eax, <strong>(af996h)</strong> <br>用 “小括号”</td><td>mov [af996h], eax <br>用 “中括号”</td></tr><tr><td>读写长度的表示</td><td>movb $5, (af996h) <br>movw $5, (af996h) <br>movl $5, (af996h) <br>addb $4, (af996h) <br>指令后加b、w、l 分别表示读写长度为 byte、word、dword，默认32bit</td><td>mov byte ptr [af996h], 5 <br>mov word ptr [af996h], 5 <br>mov dword ptr [af996h], 5 <br>add byte ptr [af996h], 4 <br>在主存地址前说明读写长度 byte、word、dword，默认32bit</td></tr><tr><td>主存地址偏移量的表示</td><td>movl -8(%ebx), %eax<br>偏移量 (基址) <br>movl 4(%ebx, %ecx, 32), %eax <br>偏移量 (基址，变址，比例因子)</td><td>mov eax, [ebx - 8] <br>[基址 + 偏移量] <br>mov eax, [ebx + ecx_32 + 4] <br>[基址 + 变址* 比例因子 + 偏移量]</td></tr></tbody></table><h4 id="选择语句的机器级表示">选择语句的机器级表示</h4><p>程序计数器PC也用IP表示</p><ul><li>jmp&lt;地址&gt;：使PC无条件转移至&lt;地址&gt;</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmp 128   &lt;地址&gt;可以用常数给出</span><br><span class="line">jmp eax   &lt;地址&gt;可以来自于寄存器</span><br><span class="line">jmp [999]   &lt;地址&gt;可以来自于主存</span><br><span class="line">jmp NEXT   &lt;地址&gt;可以用“标号”锚定，在代码中，需要在目标跳转地址处写上 `NEXT:` 来标识该位置，标号的名字可根据实际需求自行设定。</span><br><span class="line">写汇编语言代码时，一般会以函数名作为“标号”，标注该函数指令的起始地址</span><br></pre></td></tr></table></figure><ul><li>jxxx条件转移指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je &lt;地址&gt;    # jump when equal，若 a==b 则跳转</span><br><span class="line">jne &lt;地址&gt;   # jump when not equal，若 a!=b 则跳转</span><br><span class="line">jg &lt;地址&gt;    # jump when greater than，若 a&gt;b 则跳转</span><br><span class="line">jge &lt;地址&gt;   # jump when greater than or equal to，若 a&gt;=b 则跳转</span><br><span class="line">jl &lt;地址&gt;    # jump when less than，若 a&lt;b 则跳转</span><br><span class="line">jle &lt;地址&gt;   # jump when less than or equal to，若 a&lt;=b 则跳转</span><br></pre></td></tr></table></figure></li><li>cmp条件转移指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b     # 比较a和b两个数【ab可以来自寄存器/主存/常量】</span><br><span class="line"></span><br><span class="line">条件转移指令一般要和cmp指令一起使用</span><br><span class="line">cmp eax,ebx # 比较寄存器 eax 和 ebx 里的值</span><br><span class="line">jg NEXT     # 若 eax &gt; ebx，则跳转到 NEXT:</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (a&gt;b) &#123;</span><br><span class="line">   c=a;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   c=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>mov eax,7</code> ：假设变量 a = 7，存入 eax</li><li><code>mov ebx,6</code> ：假设变量 b = 6，存入 ebx</li><li><code>cmp eax,ebx</code> ：比较变量 a 和 b</li><li><code>jg NEXT</code> ：若 a&gt;b，转移到 NEXT</li><li><code>mov ecx,ebx</code> ：假设用 ecx 存储变量 c，令 c = b</li><li><code>jmp END</code> ：无条件转移到 END</li><li><code>NEXT:</code></li><li><code>mov ecx,eax</code> ：假设用 ecx 存储变量 c，令 c = a</li><li><code>END:</code></li></ol><h4 id="循环语句的机器级表示">循环语句的机器级表示</h4><p><strong>for 循环实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">    result +=i;</span><br><span class="line">&#125; <span class="comment">//求 1+2+3+...+100</span></span><br></pre></td></tr></table></figure><p><strong>while 循环实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">    result +=i;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="comment">//求 1+2+3+...+100</span></span><br></pre></td></tr></table></figure><p><strong>汇编语言实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0    #用 eax 保存 result，初值为0</span><br><span class="line">mov edx,1    #用 edx 保存 i，初始值为1</span><br><span class="line">cmp edx,100  #比较 i和100</span><br><span class="line">jg L2        #若i&gt;100，转跳到 L2 执行</span><br><span class="line">L1:          #循环主体</span><br><span class="line">add eax,edx  #实现 result +=i</span><br><span class="line">inc edx      #inc 自增指令，实现 i++</span><br><span class="line">cmp edx,100  #i和100</span><br><span class="line">jle L1       #若 i&lt;=100，转跳到 L1 执行</span><br><span class="line">L2:          #跳出循环主体</span><br></pre></td></tr></table></figure><p><strong>loop指令实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">500</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">    做某些处理;</span><br><span class="line">&#125; <span class="comment">// 循环500轮</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, 500      # 用ecx作为循环计数器【注意：循环计数器固定用ecx】</span><br><span class="line">Looptop:</span><br><span class="line">    ...</span><br><span class="line">    做某些处理</span><br><span class="line">    ...</span><br><span class="line">loop Looptop       # ecx--，若ecx!=0，跳转到Looptop</span><br><span class="line"> 等价于</span><br><span class="line"> dec ecx</span><br><span class="line"> cmp ecx, 0</span><br><span class="line"> jne Looptop</span><br></pre></td></tr></table></figure><ul><li><code>loopx</code> 指令如 <code>loopnz</code>, <code>loopz</code><ul><li><code>loopnz</code> — 当 <code>ecx!=0 &amp;&amp; ZF==0</code> 时，继续循环</li><li><code>loopz</code> — 当 <code>ecx!=0 &amp;&amp; ZF==1</code> 时，继续循环</li></ul></li></ul><h4 id="栈帧的机器级表示">栈帧的机器级表示</h4><h5 id="Call和ret指令-函数调用的机器级表示">Call和ret指令(函数调用的机器级表示)</h5><p>函数的栈帧：保存函数大括号内定义的局部变量、保存函数调用相关的信息<br>函数调用过程（caller 到 add）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">    push ebp            ; 保存上一层函数的栈帧基址（ebp旧值）</span><br><span class="line">    mov ebp, esp        ; 设置当前函数的栈帧基址（ebp新值）【这两条指令完成栈帧切换】</span><br><span class="line">    sub esp, <span class="number">24</span>         ; 分配局部变量空间</span><br><span class="line">    mov [ebp<span class="number">-12</span>], <span class="number">125</span>   ; 初始化局部变量</span><br><span class="line">    mov [ebp<span class="number">-8</span>], <span class="number">80</span>     ; 初始化局部变量</span><br><span class="line">    mov eax, [ebp<span class="number">-8</span>]    ; 准备参数</span><br><span class="line">    mov [esp+<span class="number">4</span>], eax    ; 将参数压栈（假设调用约定需要）</span><br><span class="line">    mov eax, [ebp<span class="number">-12</span>]   ; 其他操作</span><br><span class="line">    mov esp, eax        ; 调整栈指针</span><br><span class="line">    call add            ; 调用add函数</span><br><span class="line">    mov [ebp<span class="number">-4</span>], eax    ; 处理返回值</span><br><span class="line">    mov eax, [ebp<span class="number">-4</span>]    ; 使用返回值</span><br><span class="line">    leave               ; 恢复esp和e</span><br><span class="line">bp</span><br><span class="line">    ret                 ; 返回到上一级</span><br><span class="line"></span><br><span class="line">add:</span><br><span class="line">    push ebp            ; 保存上一层函数的栈帧基址（ebp旧值）</span><br><span class="line">    mov ebp, esp        ; 设置当前函数的栈帧基址（ebp新值）【这两条指令完成栈帧切换】</span><br><span class="line">    mov eax, [ebp+<span class="number">12</span>]   ; 获取参数<span class="number">1</span></span><br><span class="line">    mov edx, [ebp+<span class="number">8</span>]    ; 获取参数<span class="number">2</span></span><br><span class="line">    add eax, edx        ; 执行加法</span><br><span class="line">    leave               ; 恢复esp和ebp</span><br><span class="line">    ret                 ; 返回到caller</span><br></pre></td></tr></table></figure><p>栈帧结构<br>±-----------------+<br>| 返回地址（IP旧值）| &lt;—— 栈顶（call时压入）<br>±-----------------+<br>| caller的栈帧     |<br>±-----------------+<br>| add函数的栈帧    |<br>±-----------------+<br>| main函数的栈帧   |<br>±-----------------+<br>| …其他栈帧…   |<br>±-----------------+</p><ul><li><p><strong>call 指令的作用</strong></p><ol><li>将 IP旧值压栈保存（保存在函数的栈帧顶部）</li><li>设置 IP新值，无条件转移至被调用函数的第一条指令</li></ol></li><li><p><strong>ret 指令的作用</strong><br>从函数的栈帧顶部找到 IP 旧值，将其出栈并恢复 IP寄存器</p></li></ul><p>栈底（高地址）<br>栈顶（低地址）<br>通常以4字节为单位操作栈帧</p><h5 id="如何访问栈帧">如何访问栈帧</h5><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505202835812.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505203252548.png" alt="image.png"></p><p>方法一：</p><ul><li><strong>Push 指令</strong>：使栈指针（esp）先减4，然后将指定的操作数压入栈。操作数可以是立即数、寄存器或内存地址。<br>push xxx可以是立即数/寄存器/主存地址</li><li><strong>Pop 指令</strong>：将栈顶元素弹出到指定的操作数，然后esp加4。操作数可以是寄存器或内存地址。<br>pop xxx可以是寄存器/主存地址</li></ul><p>方法二：</p><ul><li>使用 <code>mov</code> 指令结合 <code>esp</code> 或 <code>ebp</code> 来访问栈帧中的数据。</li><li>也可利用 <code>sub</code> 或 <code>add</code> 指令修改栈指针（esp）的值，以此调整栈顶的位置。</li></ul><h5 id="如何切换栈帧">如何切换栈帧</h5><p>标记栈帧的范围：EBP、ESP寄存器<br>每个函数的开头都有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp            ; 保存上一层函数的栈帧基址（ebp旧值）</span><br><span class="line">mov ebp, esp        ; 设置当前函数的栈帧基址（ebp新值）【这两条指令完成栈帧切换】</span><br></pre></td></tr></table></figure><p>这两条指令也可用<code>enter</code>代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move esp,ebp   # 让esp指向当前栈帧底部</span><br><span class="line">pop ebp        # 将esp所指元素出栈，写入寄存器ebp</span><br></pre></td></tr></table></figure><p>这两条指令也可用<code>leave</code>代替</p><h5 id="一个栈帧包含的内容">一个栈帧包含的内容</h5><p>每个函数的栈帧底部存储<strong>上一层函数的基址</strong>（ebp旧值）<br>每个函数的栈帧顶部存储<strong>返回地址</strong>（当前函数的栈帧除外）<br>通常将<strong>局部变量</strong>集中存储在<strong>栈帧底部区域</strong><br>c语言中越靠前定义的局部变量越靠近<strong>栈顶</strong><br>通常将<strong>调用参数</strong>集中存储在<strong>栈帧顶部区域</strong><br>gcc编译器将每个栈帧大小设置为<strong>16B的整数倍</strong>（当前函数的栈帧除外），因此栈帧内可能出现<strong>空闲</strong>未使用的区域。<br>访问当前函数的局部变量：[ebp-4]、[ebp-8]…<br>访问上一层函数传过来的参数：[ebp+8]、[ebp+12].<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505211134466.png" alt="image.png"><br><strong>栈帧结构</strong>（栈底→栈顶）<br>①上一层栈帧的基地址(ebp旧值);②若干个局部变量;③未使用区;④部分寄存器值;⑤若干个调用参数;⑥返回地址(IP旧值)</p><ol><li><p><strong>IP(返回地址)</strong></p><ul><li>一定存在。用于恢复上一层函数的栈帧。</li></ul></li><li><p><strong>上一层栈帧基址</strong></p><ul><li>每个函数开头都要执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure></li><li>一定存在。用于恢复上一层函数的栈帧。</li></ul></li><li><p><strong>若干个局部变量</strong></p><ul><li>局部变量。C语言中越靠前定义的局部变量越靠近栈顶。</li><li>不一定存在。有些函数可能不定义局部变量。</li></ul></li><li><p><strong>未使用的区域</strong></p><ul><li>栈帧大小为16B整数倍，因此可能产生未使用区域。</li><li>不一定存在。如果其他部分刚好是16B整数倍，则不会留下“零头”。</li></ul></li><li><p><strong>若干个调用参数</strong></p><ul><li>调用参数。参数列表中越靠前的参数越靠近栈顶。</li><li>不一定存在。有些函数调用不需要传参数。</li></ul></li><li><p><strong>IP(返回地址) 上一层栈帧基址</strong></p><ul><li>函数调用时，call指令将IP寄存器值（返回地址）压栈保存。</li><li>一定存在（发生调用时）。但凡调用其他函数，就必须记录返回地址。</li></ul></li></ol><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250505213804398.png" alt="image.png"></p><h2 id="CISC-和-RISC">CISC 和 RISC</h2><h3 id="复杂指令系统计算机（CISC）">复杂指令系统计算机（CISC）</h3><ul><li><strong>设计思路</strong>：一条指令完成一个复杂的基本功能</li><li><strong>代表</strong>：x86 架构，主要用于笔记本、台式机等</li><li><strong>指令系统</strong>：复杂庞大</li><li><strong>指令数目</strong>：一般大于 200 条</li><li><strong>指令字长</strong>：不固定，指令格式多，寻址方式多</li><li><strong>可访存指令</strong>：不加限制</li><li><strong>各种指令执行时间</strong>：相差较大，大多数指令需要多个时钟周期才能完成</li><li><strong>各种指令使用频度</strong>：相差很大</li><li><strong>通用寄存器数量</strong>：较少</li><li><strong>目标代码</strong>：难以用优化编译生成高效的目标代码程序</li><li><strong>控制方式</strong>：绝大多数为微程序控制</li><li><strong>指令流水线</strong>：可通过一定方式实现</li><li><strong>兼容性</strong>：可兼容很多不同的高级语言和软件</li></ul><h3 id="精简指令系统计算机（RISC）">精简指令系统计算机（RISC）</h3><ul><li><strong>设计思路</strong>：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能</li><li><strong>代表</strong>：ARM 架构，主要用于手机、平板等</li><li><strong>指令系统</strong>：简单精简</li><li><strong>指令数目</strong>：一般小于 100 条</li><li><strong>指令字长</strong>：定长，指令种类少，寻址方式种类少</li><li><strong>可访存指令</strong>：只有 Load / Store 指令</li><li><strong>各种指令执行时间</strong>：绝大多数在一个周期内完成</li><li><strong>各种指令使用频度</strong>：都比较常用</li><li><strong>通用寄存器数量</strong>：多</li><li><strong>目标代码</strong>：采用优化的编译程序，生成代码较为高效</li><li><strong>控制方式</strong>：绝大多数为组合逻辑控制，硬布线</li><li><strong>指令流水线</strong>：必须实现</li><li><strong>兼容性</strong>：较差</li></ul><p>和 CISC 相比，RISC 的优点体现在：</p><ul><li><p>RISC 更能充分利用 VLSI（超大规模集成电路）芯片的面积</p></li><li><p>RISC 更能提高运算速度</p></li><li><p>RISC 便于设计，可降低成本，提高可靠性</p></li><li><p>RISC 有利于编译程序代码优化</p></li><li><p>优先选取使用<mark>频率高</mark>的简单指令，<mark>指令条数少，<mark>采用</mark>等长</mark>指令</p></li><li><p>指令长度固定，指令格式<mark>种类</mark>较<mark>少</mark></p></li><li><p>以<mark>控制</mark>逻辑为主，不用或少用微码控制</p></li><li><p>寻址方式种类较<mark>少</mark></p></li><li><p>有<mark>大量</mark>通用寄存器</p></li><li><p>并行处理能力强</p></li><li><p>访存指令只有load和store两种</p></li></ul><p><mark>CISC</mark>是<mark>复杂</mark>指令系统，兼容性强，指令繁多，长度可变，由<mark>微程序</mark>实现。<br><mark>RISC</mark>是<mark>精简</mark>指令系统，指令少，使用频率接近，主要依靠<mark>硬件</mark>实现（通用寄存器，硬布线逻辑控制），<mark>寄存器多</mark>且支持==流水线</p><table><thead><tr><th>对比项目</th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>设计思路</td><td>一条指令完成一个复杂的基本功能</td><td>一条指令完成一个基本 “动作”，多条指令组合完成复杂基本功能</td></tr><tr><td>代表</td><td>x86 架构，用于笔记本、台式机等</td><td>ARM 架构，用于手机、平板等</td></tr><tr><td>指令系统</td><td>复杂，庞大</td><td>简单，精简</td></tr><tr><td>指令数目</td><td>一般大于 200 条</td><td>一般小于 100 条</td></tr><tr><td>指令字长</td><td>不固定，指令格式多，寻址方式多</td><td>定长，指令种类少，寻址方式种类少</td></tr><tr><td>可访存指令</td><td>不加限制</td><td>只有 Load/Store 指令</td></tr><tr><td>各种指令执行时间</td><td>相差较大，多数需多个时钟周期</td><td>绝大多数在一个周期内完成</td></tr><tr><td>各种指令使用频度</td><td>相差很大</td><td>都比较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以用优化编译生成高效目标代码程序</td><td>采用优化编译程序，生成代码较为高效</td></tr><tr><td>控制方式</td><td>绝大多数为微程序控制</td><td>绝大多数为组合逻辑控制（硬布线）</td></tr><tr><td>指令流水线</td><td>可以通过一定方式实现</td><td>必须实现</td></tr><tr><td>兼容性</td><td>可兼容很多不同的高级语言和软件</td><td>较差</td></tr><tr><td>芯片面积利用</td><td>难以充分利用 VLSI 芯片面积</td><td>更能充分利用 VLSI 芯片面积</td></tr><tr><td>运算速度</td><td>相对较慢</td><td>更能提高运算速度</td></tr><tr><td>设计成本与可靠性</td><td>设计相对复杂，成本较高，可靠性较难保障</td><td>便于设计，可降低成本，提高可靠性</td></tr><tr><td>编译程序优化</td><td>不利于编译程序代码优化</td><td>有利于编译程序代码优化</td></tr><tr><td>指令选取原则</td><td>/</td><td>优先选取使用频率高的简单指令，指令条数少</td></tr><tr><td>并行处理能力</td><td>相对较弱</td><td>并行处理能力强</td></tr></tbody></table><h1>错题</h1><ol><li><p><strong>下列关于指令集体系结构和指令系统的说法中，错误的是()。<br>A.指令集体系结构位于计算机软/硬件的交界面上<br>B.指令集体系结构是指低级语言程序员所看到的概念结构和功能特性<br>C.任何程序运行前都要先转换为机器语言程序<br>D.指令系统和机器语言是无关的</strong><br>指令集体系结构(ISA)完整定义了软件和硬件之间的接口；低级语言（如汇编语言）程序员直接使用 ISA 提供的指令、寄存器等资源编写程序，ISA 是其编程时看到的功能特性；<strong>指令系统</strong>是机器指令的集合，<strong>机器语言</strong>是由这些指令的二进制编码构成的语言。二者直接相关：指令系统决定了机器语言的功能和格式，机器语言是指令系统的具体实现形式。D</p></li><li><p><strong>下列有关指令集体系结构(ISA)的叙述中，错误的是()。<br>A.ISA 规定了执行每条指令时所包含的控制信号<br>B.ISA 规定了指令获取操作数的方式，即寻址方式<br>C.ISA 规定了所有指令的集合，包括指令格式和操作类型<br>D.ISA 规定了程序可访问的寄存器个数、存储空间大小、编址方式和大端/小端方式</strong><br>指令集体系结构(ISA)是软件和硬件之间接口的一个完整定义，包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断和异常处理及外部 IO。ISA 规定了执行每条指令时所需要的操作码、操作数、寻址方式等信息，以及指令的功能和效果。控制信号是由控制单元根据ISA 生成的，它属于微架构层面的实现细节，而不是ISA 层面的抽象定义。</p></li><li><p><strong>在CPU执行指令的过程中，指令的地址由()给出。<br>A.程序计数器(PC)   B.操作系统   C.指令的地址码字段   D.程序员</strong><br>PC 存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址。</p></li><li><p><strong>【2017统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条、二地址指令 107条，每个地址字段为6位，则指令字长至少应该是( )。A.24 位   B. 26 位   C.28 位   D.32 位</strong><br>三地址指令有 29 条，所以其操作码至少为5 位。以5位进行计算，它剩余 32- 29=3种操作码给二地址。而二地址额外多了6位给操作码，因此其数量最大达 3x64 = 192。所以指令字长最少为23 位，因为计算机按字节编址，需要是8的倍数，所以指令字长至少应该是 24位。</p></li><li><p><strong>【2022 统考真题】下列选项中，属于指令集体系结构(ISA)规定的内容是()。<br>I.指令字格式和指令类型     II.CPU 的时钟周期<br>III.通用寄存器个数和位数   IV.加法器的进位方式<br>A. 仅I、II   B.仅I、III   C.仅II、IV   D.仅I、III、IV</strong><br>指令集体系结构处于软/硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由 ISA 规定。两个CPU 可以有不同的时钟周期，但指令集可以相同；加法器的进位方式涉及电路设计，这两项都属于计算机的硬件部分，不由ISA规定。</p></li><li><p><strong>指令系统中采用不同寻址方式的目的是()。<br>A.提供扩展操作码的可能并降低指令译码难度<br>B.可缩短指令字长，扩大寻址空间，提高编程的灵活性<br>C.实现程序控制<br>D.三者都正确</strong><br>采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度。程序控制是靠转移指令而非寻址方式实现的。B</p></li><li><p><strong>采用直接转移的无条件转移指令的功能是将指令中的地址码送入()。<br>A.程序计数器(PC)    B.累加器(ACC)<br>C.指令寄存器(IR)     D.地址寄存器(MAR)</strong><br>转移指令有条件/无条件、直接间接、相对/绝对三种属性。<br><strong>条件转移</strong>是指需要先判断条件是否成立，才决定是否转移<br><strong>无条件转移</strong>是指不用判断条件就可以转移，典型的是<strong>函数调用和返回</strong><br><strong>直接转移</strong>是指转移目标地址直接放在<strong>指令</strong>中，执行时直接将地址码送入<strong>PC</strong> 选A<br><strong>间接转移</strong>是指转移目标地址存放在<strong>寄存器或内存单元</strong>中<br><strong>相对转移</strong>是指转移目标地址为当前 <strong>PC值加上偏移量</strong>，偏移量一般在指令中<br><strong>绝对转移</strong>是指转移目标地址直接由<strong>指令或寄存器</strong>给出。</p></li><li><p><strong>为了缩短指令中某个地址段的位数，有效的方法是采取()。<br>A.立即寻址   B.变址寻址   C.间接寻址   D.寄存器寻址</strong><br>CPU 中寄存器的数量都不会太多，用很短的编码就可以指定寄存器，寄存器寻址需要的地址段位数为⌈log₂(通用寄存器个数)⌉，因此能有效地缩短地址段的位数。<br>立即寻址，操作数直接保存在指令中，若地址段位数太小，则操作数表示的范围会很小<br>变址寻址，EA= 变址寄存器IX的内容 + 形式地址 A，A 与主存寻址空间有关<br>间接寻址中存放的仍然是主存地址</p></li><li><p><strong>设指令中的地址码为 A，变址寄存器为 X，程序计数器为 PC，则变址间址寻址方式的操作数的有效地址 EA是( )。<br>A.((PC)+A)   B.((X)+A)   C.(X)+(A)   D.(X)+A</strong><br>变址寻址的有效地址是(X)+A，再进行间址，即把(X)+A中取出的内容作为真实地址 EA，即 EA=((X)+A)<br>寄存器中的内容和指令地址码相加得到的是操作数的地址码。</p></li><li><p><strong>某计算机的指令字长为 16 位，由低到高第 0~7位是形式地址 D，第8~9位为寻址特征位 X，第 10~15 位为操作码。<br>当X=00 时为直接寻址；当X=01 时使用 X1 进行变址寻址;；当 X=10 时使用 X2 进行变址寻址；当 X=11 时为相对寻址。<br>设(PC)= 1234H,(X1)=0005H,(X2)=1188H，则指令2222H的有效地址是()。A.1256H     B.0027H    C.2222H    D.11AAH</strong><br>将指令 2222H 展开成二进制为0010 00100010 0010B，因此寻址特征位X=10，即使用 X2进行变址寻址，其有效地址为1188H+22H=11AAH。<br>其他情况：<br>直接寻址：若指令为0022H，D=22H，有效地址为 22H<br>变址寻址：若指令为 0522H，X1=0005H，D=22H，有效地址为 0005H+22H=0027H<br>相对寻址：若指令为 1122H，(PC)=1234H，D=22H，有效地址为 1234H+22H=1256H</p></li><li><p><strong>某计算机的主存容量为 4Mx16 位，且存储字长等于指令字长，若该机能完成 97 种操作,操作码位数固定，且有直接、间接、基址、变址、相对、立即六种寻址方式，则相对寻址的偏移量范围为()。<br>A.(-32.+31)   B.(-64.+63)   C.(-128,+127)   D.(-256,+255)</strong><br>操作码位数固定，且能完成97种操作，则操作码位数是⌈log₂97⌉=7位<br>具有六种寻址方式，则寻址特征位数是⌈log₂6⌉3位:指令字长为16 位，因此地址码位数是16-3-7=6位，6 位补码的表示范围为-32~+31，即为相对寻址的偏移量范围。</p></li><li><p><strong>对按字寻址的机器，程序计数器和指令寄存器的位数各取决于()。<br>A.机器字长，存储器的字数   B.存储器的字数，指令字长<br>C.指令字长，机器字长          D.地址总线宽度，存储器的字数</strong><br>机器按字寻址，程序计数器(PC)给出下一条指令字的访存地址(指令在内存中的地址)，因此取决于存储器的字数;指令寄存器(IR)用于接收取得的指令，因此取决于指令字长。</p></li><li><p><strong>假设寄存器 R中的数值为 200，主存地址为 200和 300 的地址单元中存放的内容分别是300和400，则()方式下访问到的操作数为200。<br>A.直接寻址 200                B.寄存器间接寻址®<br>C.存储器间接寻址(200)   D.寄存器寻址 R</strong><br>直接寻址 200 访问的操作数是 300，选项A错误。<br>寄存器间接寻址®的访问结果与1一样，选项 B错误。<br>存储器间接寻址(200)表示主存地址 200 中的内容为有效地址，有效地址为 300，访问的操作数是 400，选项C错误。<br>寄存器寻址R表示寄存器R的内容为操作数，只有选项D正确。</p></li><li><p><strong>假设某条指令的第一个操作数采用寄存器间接寻址方式，指令中给出的寄存器编号为8,8 号寄存器的内容为 1200H，地址为 1200H 的单元中的内容为 12FCH，地址为 12FCH的单元中的内容为 38D8H，而地址为 38D8H 的单元中的内容为 88F9H，则该操作数的有效地址为( )。<br>A.1200H   B. 12FCH   C.38D8H   D. 88F9H</strong><br>寄存器间接寻址中操作数的有效地址 EA=®,8号寄存器内容为 1200H,因此 EA=1200H。</p></li><li><p><strong>设相对寻址的转移指令占 3B，第一字节为操作码，第二、三字节为相对位移量(补码表示)，而且数据在存储器中采用以低字节为字地址的存放方式。每当 CPU 从存储器取出一字节时，即自动完成(PC)+1→PC。<br>若 PC的当前值为 240(十进制)，要求转移到290(十进制)，则转移指令的第二、三字节的机器代码是( )<br>若 PC 的当前值为 240(十进制)，要求转移到200(十进制)，则转移指令的第二、三字节的机器代码是( )。<br>A. 2FH、FFH    B. D5H、00H    C. D5H、FFH    D.2FH、00H</strong><br>PC 的当前值为 240，该指令取出后 PC 的值为 243，要求转移到 290，即相对位移量为290-243=47，转换成补码为2FH。因为数据在存储器中采用以低字节地址为字地址的存放方式，所以该转移指令的第二字节为 2FH，而由于47 是正数，只需在高位补0，所以第三字节为 00H。<br>PC 的当前值为 240，该指令取出后 PC 的值为 243，要求转移到 200，即相对位移量为200-243=-43，转换成补码为 D5H。数据在存储器中采用以低字节地址为字地址的存放方式，因此该转移指令的第二字节为 D5H，因为-43 是负数，所以只需在高位补 1，所以第三字节为 FFH。</p></li><li><p><strong>某计算机按字节编址，采用大端方式，某指令的一个操作数的机器数为 ABCD 00FFH，该操作数采用基址寻址方式，指令中形式地址(用补码表示)为FF00H，当前基址寄存器的内容为 C000 0000H，则该操作数的LSB(即FFH)存放的地址是()。<br>A.C000 FF00H  B. C000 FF03H  C.BFFF FF00H  D. BFFF FF03H</strong><br>C000 0000H+FF00H=C000 0000H+FFFF FF00H=BFFF FF00H<br><strong>大端存储</strong>：高字节在低地址，低字节在高地址，LSB地址 = 基地址 + 数据长度【这里是4字节】 - 1。<br>按字节编址，起始地址BFFF FF00H，对应ABH（MSB），CDH则对应BFFF FF01H，所以LSB对应BFFF FF03H</p></li><li><p><strong>下列关于指令的功能及分类的叙述中，正确的是()。<br>A.算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据<br>B.移位操作指令，通常用于把指定的两个操作数左移或右移一位<br>C.转移指令、子程序调用与返回指令，用于解决数据调用次序的需求<br>D.特权指令，通常仅用于实现系统软件，这类指令一般不提供给用户</strong><br>算术与逻辑运算指令用于完成对一个(如自增、取反等)或两个数据的算术运算或逻辑运算，选项A 错误。移位操作用于把一个操作数左移或右移一位或多位，选项 B错误。转移指令、子程序调用与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求，选项C 错误。</p></li><li><p><strong>某计算机字长为 16 位，标志寄存器中存在 ZF、SF、OF 和 CF 标志位，采用双字节字长指令字。假定 bgt(大于零转移)指令的第一个字节指明操作码和寻址方式，第二个字节为立即数Imm8，用补码表示。<br>指令功能是：<br>若跳转条件成立，则PC=PC+2+Imm8×2<br>否则，PC=PC+2。<br>则下列叙述中错误的是()。<br>A.该计算机按字节编址<br>B.若 bgt 指令是无符号整数的比较，则跳转条件可以是ZF+CF=0<br>C.若 bgt 指令是有符号整数的比较，则跳转条件可以是SF⊕OF=0<br>D.转移目标地址的范围是相对于 bgt 指令的前 127 条指令到后 128 条指令之间</strong><br>PC 的增量是 2，每条指令占2字节，可知编址单位为字节。<br>若 bgt 指令是无符号整数比较大于零，结果非零（ZF=0）且无借位（CF=0），即ZF+CF=0<br>若 bgt 指令是有符号整数的比较，则跳转条件成立时，要么未发生溢出，SF=OF=0，要么发生溢出SF=OF=1，但前提是ZF 一定为0，所以正确的跳转条件是(ZF+(SF⊕OF)=0)。选C<br>Imm8是 8 位补码立即数，范围为−128∼127，转移目标地址为PC+2+Imm8×2。<code>PC + 2</code> 是因为当前指令占 2 字节，执行完后 <code>PC</code> 会先指向 <strong>下一条指令的地址</strong>（即当前指令地址 + 2），再根据 <code>Imm8</code> 进行偏移。<strong>偏移量</strong>：<code>Imm8 × 2</code>（字节），即 <code>-256 ≤ 偏移 ≤ +254.</code> <strong>指令数范围</strong>：<code>-128 ≤ 偏移指令数 ≤ +127</code>（因为每条指令占2字节）。<br>因此，实际指令数偏移范围为 <strong>-128 ≤ Imm8 ≤ +127</strong>，但相对于当前指令的可见范围是 <strong>前127条到后128条</strong>。</p></li><li><p><strong>【2011统考真题】某机器有一个标志寄存器，其中有进位/借位标志CF、零标志ZF、符号标志SF和溢出标志OF，条件转移指令bgt（无符号整数比较大于时转移）的转移条件是（ ）。<br>A. CF + OF = 1 B. $\overline{SF}$ + ZF = 1 C. $\overline{CF + ZF}$ = 1 D. $\overline{CF + SF}$ = 1</strong></p></li><li><p><strong>【2014 统考真题】某计算机有 16 个通用寄存器，采用 32 位定长指令字，操作码字段(含寻址方式位)为8位，STORE指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任意一个通用寄存器，且偏移量用补码表示，则STORE指令中偏移量的取值范围是()。<br>A.-32768-+32767   B.-32767~+32768<br>C.-65536-+65535   D.-65535-+65536</strong><br>采用 32 位定长指令字，其中操作码为8位，两个地址码共占用32-8=24位，而STORE指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址，机器中共有16 个通用寄存器，因此寻址一个寄存器需要 log16=4位，源操作数中的寄存器直接寻址用掉4 位，而目的操作数采用基址寻址也要指定一个寄存器，同样用掉4位，则留给偏移量的位数为24-4-4=16位，而偏移量用补码表示，因此 16 位补码的表示范围为-32768~+32767。</p></li><li><p><strong>【2018 统考真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器的初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器的内容自动加 1。若某次循环所取元素的地址为 2100H，则进入该次循环时变址寄存器的内容是()。<br>A.25   B. 32   C.64   D. 100</strong><br><strong>变址寻址公式</strong>：有效地址 <code>EA = 基地址 + 变址值 × sizeof(double)</code><br>每次循环：变址寄存器的值自动加1（元素索引递增）<br>某次循环的EA：2100H<br>根据变址寻址的公式 EA=(IX)+A，有(IX)=2100H-2000H=100H=256，sizeof(double)：8字节（双精度浮点数占8字节），因此数组的下标为256/8=32。</p></li><li><p><strong>【2020 统考真题】某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对4种寻址方式。在单地址指令中，直接寻址方式的可寻址范围是()<br>A.0-255   B. 0-1023   C.-128-127   D.-512-511</strong><br>48 条指令需要6位操作码字段，4种寻址方式需要2位寻址特征位，还剩16-6-2=8位作为地址码，所以直接寻址范围为0~255。注意，主存地址不能为负（内存地址是无符号数）</p></li><li><p><strong>【2023 统考真题】某运算类指令中有一个地址码为通用寄存器编号，对应通用寄存器中存放的是操作数或操作数的地址，CPU区分两者的依据是()<br>A.操作数的寻址方式   B.操作数的编码方式<br>C.通用寄存器的编号   D.通用寄存器的内容</strong><br>指令结构：操作码 + 寻址方式字段 + 地址码（通用寄存器编号）。<br>寄存器直接寻址：<br>寻址方式字段标记为“寄存器直接寻址”。<br>通用寄存器内容：直接作为操作数。<br>寄存器间接寻址：<br>寻址方式字段标记为“寄存器间接寻址”。<br>通用寄存器内容：作为操作数的内存地址。<br>CPU通过寻址方式字段（即操作数的寻址方式）确定寄存器内容是操作数还是地址。</p></li><li><p><strong>假设 R|ax]=7FE6H,R[bx]=FFE8H，执行指令“sub bx,ax”后，寄存器的内存和各标志的变化为( )。<br>A. R[ax]=8002H，OF=0，SF=1，CF=1，ZF=0<br>B. R[bx]=8002H，OF=0，SF=1，CF=0，ZF=0<br>C. R[ax]=8002H，OF=1，SF=1，CF=0，ZF=0<br>D. R[bx]=8002H，OF=1，SF=1，CF=0，ZF=0</strong><br><code>sub bx, ax</code>是<code>bx - ax</code><br>7FE6H = 0111 1111 1110 0110B（[-B]补就是[B]补连同符号位一起取反+1）<br>FFE8H = 1111 1111 1110 1000B<br>$\begin{align*} &amp;1111 1111 1110 1000\ +&amp;1000 0000 0001 1010\ \hline &amp;1000 0000 0000 0010 \end{align*}$<br>= 8002H，该结果存放在目标操作数<code>bx</code>中，所以R[bx]=8002H 。<br>溢出OF=最高位⊕次高位进位=1⊕1=0<br>进位CF=最高位进位Cout⊕Cin(减法=1，加法=0)=1⊕1=0<br>B</p></li><li><p><strong>某计算机的数据采用小端方式存储，减法指令“sub ax,imm”的功能为(ax)-imm→ax,imm 表示立即数，该指令对应的十六进机器码为 2dxxxx(从左到右以字节为单位由低地址到高地址)，其中xxxx 对应 imm 的机器码，若imm=-3,(ax)=7，则该指令对应的机器码和执行后 OF 标志位的值分别为( )。<br>A.2DFFFDH,0   B.2DFFFDH,1<br>C.2DFDFFH,0   D.2DFDFFH,1</strong><br>对于 16 位有符号数，其表示范围是<code>-32768</code>到<code>32767</code> ，计算结果 10 在这个范围内<br>-3的补码=1111 1111 1111 1101=FFFD<br>2DFDFF，C</p></li><li><p><strong>假设R[eax]=080480B4H，R[ebx]=00000011H，M[080480F8H]=000000B0H，执行指令 “<code>imul eax, [eax+ebx*4], -16</code>” 后，寄存器或存储单元的内容变为（ ）。<br>A. R[eax]=00000B00H    B. M[080480F8H]=00000B00H<br>C. R[eax]=FFFFF500H   D. M[080480F8H]=FFFFF500H</strong><br>000000B0H×(-16)，即$(2^7 + 2^5 + 2^4)\times(-2^4)= - 2^{11}-2^9 - 2^8$ 。 计算结果为负数，求其补码： 原码：1000 0000 0000 0000 1011 0000 0000，补码即1111 1111 1111  1111  1111 0101 0000 0000 = FFFF F500H，C。</p></li><li><p><strong>程序P中有两个变量i和j，被分别分配在寄存器<code>eax</code>和<code>edx</code>中，P中语句 “<code>if(i &lt; j)&#123;...&#125;</code>” 对应的指令序列如下（左边为指令地址，中间为机器代码，右边为汇编指令），其中<code>jle</code>指令的偏移量为0d：</strong><br><strong>804846a 39 c2 cmp dword ptr [edx],eax</strong><br><strong>804846c 7e 0d jle xxxxxxxx</strong><br><strong>若执行到804846aH处的<code>cmp</code>指令时，i=105，j=100，则<code>jle</code>指令执行后将转到（ ）处的指令执行。</strong><br><strong>A. 8048461H</strong>    <strong>B. 804846eH</strong>    <strong>C. 8048479H</strong>    <strong>D. 804847bH</strong><br>因为<code>jle</code>指令是 “小于或等于则跳转”，而这里i≥j不满足跳转条件，所以不会发生跳转，程序将顺序执行下一条指令。<br><code>jle</code>指令的地址是804846cH，偏移量为0dH（十六进制），顺序执行下一条指令的地址应该是<code>jle</code>指令地址加上偏移量。<br>804846cH+0dH=8048479H</p></li><li><p><strong>子程序调用指令的完整功能是（ ）。<br>A. 改变堆栈指针 SP 的值    B. 改变程序计数器 PC 的值<br>C. 改变程序计数器 PC 的值和堆栈指针 SP 的值  D. 改变地址寄存器的值</strong><br>C</p></li><li><p><strong>下列有关调用指令（转子指令）的叙述中，错误的是（ ）。<br>A. 与高级语言源程序中的过程调用相对应，一次过程调用对应一条调用指令<br>B. 指令执行时必须保留返回地址，调用指令随后一条指令的地址是返回地址<br>C. 嵌套调用时返回地址通常保存在栈中，非嵌套调用时可保存在特定寄存器中<br>D. 指令执行时将无条件转移到目标地址处，转移目标地址无须在指令中明显给出</strong><br>A 选项：在高级语言中，过程调用这一操作在机器语言层面，通常由一条调用指令来实现 ，该项叙述正确。<br>B 选项：调用指令执行时，为了能在子程序执行完后回到主程序的正确位置，需要保留返回地址，这个返回地址就是调用指令后面一条指令的地址，该项叙述正确。<br>C 选项：对于嵌套调用，由于嵌套层次不确定，使用栈这种 “先进后出” 的数据结构来保存返回地址很合适；非嵌套调用时，返回地址的保存相对简单，可放在特定寄存器中 ，该项叙述正确。<br>D 选项：调用指令执行时，虽然是转移到目标地址（子程序入口），但转移目标地址一般是在指令中明确给出的，或者通过某种寻址方式能确定目标地址，该项说无须在指令中明显给出是错误的。</p></li><li><p><strong>假设 P 为调用过程，Q 为被调用过程，程序在 32 位 x86 处理器上执行，以下是 C 语言程序中过程调用所涉及的操作：<br>① 过程 Q 保存 P 的现场，并为非静态局部变量分配空间<br>② 过程 P 将实参存放到 Q 能访问到的地方<br>③ 过程 P 将返回地址存放到特定处，并转跳到 Q 执行<br>④ 过程 Q 取出返回地址，并转跳回到过程 P 执行<br>⑤ 过程 Q 恢复 P 的现场，并释放局部变量所占空间<br>⑥ 执行过程 Q 的函数体<br>过程调用的正确执行步骤是（ ）。<br>A. ②→③→④→①→⑤→⑥<br>B. ②→③→①→④→⑥→⑤<br>C. ②→③→①→⑥→⑤→④<br>D. ②→③→①→⑤→⑥→④</strong><br>C</p></li><li><p><strong>下列关于 RISC 和 CISC 的说法中，不正确的是（ ）。<br>A. RISC 指令格式种类少，寻址方式少，指令长度固定，更容易用硬布线电路实现<br>B. CISC 指令功能强大，寻址方式多，便于汇编程序员编程<br>C. CISC 指令格式种类多，所以更有利于编译优化<br>D. RISC 多数指令能够在一个时钟周期内完成，特别适合流水线工作</strong><br>C，CISC难以编译优化</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令格式（操作码/地址码） </tag>
            
            <tag> 寻址方式（立即数/直接/间接寻址） </tag>
            
            <tag> 指令集设计（CISC/RISC） </tag>
            
            <tag> 指令执行周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 3 章 内存管理：地址映射与虚拟内存</title>
      <link href="/post/ce20e5e9.html"/>
      <url>/post/ce20e5e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理概念">内存管理概念</h2><h3 id="基本原理和要求">基本原理和要求</h3><h4 id="基本概念">基本概念</h4><ul><li><strong>内存管理</strong>：是操作系统对内存的划分和动态分配</li><li><strong>目的</strong>：<ul><li>为了更好地支持多道程序并发执行</li><li>方便用户</li><li>提高内存利用率</li></ul></li><li><strong>功能</strong>：<ul><li><strong>内存空间的分配与回收</strong>：OS 动态管理主存分配，确保进程按需获取 / 释放内存</li><li><strong>地址转换</strong>：将程序逻辑地址转换为物理地址（如通过重定位机制）</li><li><strong>内存空间的扩充</strong>：借助虚拟存储技术（如分页、分段）从<strong>逻辑</strong>上扩展可用内存</li><li><strong>共享与保护</strong>：允许多进程访问同一内存区域，同时防止越界访问或数据破坏</li></ul></li><li><strong>分配方式</strong>：<ul><li><strong>连续分配</strong>：进程占用连续内存块，包括：<ul><li>单一连续分配（单道程序）→ 固定分区分配（多道程序初期）→ 动态分区分配（适应不同程序大小）。</li></ul></li><li><strong>非连续分配</strong>：进程内存块可离散分布，包括：<ul><li>分页存储（将内存划分为固定大小页）→ 分段存储（按逻辑功能划分为段）→ 段页式存储（结合两者优势）。</li></ul></li></ul></li></ul><h4 id="程序的链接与装入">程序的链接与装入</h4><p>创建进程首先要将程序和数据装入内存，将源程序转变为可在内存中可执行程序的流程<br>源程序 → 编译.c（目标模块）→ 链接.o（可执行模块）→ 装入.exe（内存执行）<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514104221.png" alt="image.png"></p><ol><li><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块</li><li><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完整的装入地址（逻辑地址）<ul><li><strong>静态链接</strong>：程序运行前完成所有目标模块与库函数的链接，生成完整可执行文件（装入模块），装入后形成物理地址，运行时不可修改<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514104926.png" alt="image.png"></li><li><strong>装入时动态链接</strong>：将各目标模块装入内存时，边装入边链接，便于更新部分模块。<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514105049.png" alt="image.png"></li><li><strong>运行时动态链接</strong>：在程序执行中需要改目标模块时，才对它进行链接，支持模块共享与动态更新（如插件系统）。<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514105239.png" alt="image.png"></li></ul></li><li><strong>装入</strong>：由装入程序将装入模块装入内存运行，有三种方式：<ul><li><strong>绝对装入</strong>：<ul><li>编译时确定程序在内存的物理地址，逻辑地址与物理地址一致，仅适用于<strong>单道程序</strong>（编译器完成的）<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110017.png" alt="image.png"></li></ul></li><li><strong>可重定位装入</strong>【<strong>静态</strong>重定位】：<ul><li>目标模块地址从 0 开始（逻辑地址），装入时<strong>一次性</strong><u>将逻辑地址转换为物理地址</u>（重定位）</li><li>需为进程分配全部连续完整内存空间，不支持运行时地址修改。</li><li>用于早期的多道批处理操作系统<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110246.png" alt="image.png"></li></ul></li><li><strong>动态运行时装入</strong>【<strong>动态</strong>重定位】：<ul><li>编译、链接后的<strong>装入模块的地址都是从 0 开始</strong>的</li><li>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把<strong>地址转换推迟到程序真正要执行时才进行</strong></li><li>因此装入内存后所有的地址依然是<strong>逻辑地址</strong></li><li>这种方式需要一个<strong>重定位寄存器</strong>的支持</li><li>支持进程在内存中移动，是现代多道程序系统的主流方式。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110614.png" alt="image.png"><br>对比：</li></ul></li></ul></li></ol><ul><li><strong>链接方式对比</strong>：静态链接在编译阶段完成整合，动态链接则延迟至装入或运行阶段，提升灵活性。</li><li><strong>装入方式差异</strong>：绝对装入依赖固定内存地址，可重定位装入一次性转换地址，动态重定位则实时转换，适配内存动态分配场景。</li></ul><h4 id="逻辑地址与物理地址">逻辑地址与物理地址</h4><ol><li><p><strong>逻辑地址</strong>（相对地址）</p><ul><li><strong>定义</strong>：编译后目标模块从 0 开始的编址，是程序视角的 “虚拟地址”，不对应真实内存位置。</li><li><strong>空间范围</strong>：如 32 位系统中逻辑地址空间为0 \sim 2^{32}-1（4GB），64 位系统则更大。</li><li><strong>特点</strong>：不同进程可拥有相同逻辑地址（如多个进程的 main 函数均从 0 地址开始），由 OS 映射到不同物理内存。</li></ul></li><li><p><strong>物理地址</strong>（绝对地址）</p><ul><li><strong>定义</strong>：内存中实际存储单元的地址，是地址转换的最终结果，直接对应硬件存储位置。</li><li><strong>限制</strong>：受物理内存容量约束（如 8GB 内存的物理地址范围为0 \sim 8GB-1）。</li></ul></li><li><p><strong>地址重定位</strong></p><ul><li><strong>概念</strong>：装入程序将逻辑地址转换为物理地址的过程，分为静态重定位（装入时一次性转换）和动态重定位（运行时通过寄存器实时转换）。</li><li><strong>核心作用</strong>：实现程序的 “位置无关性”，允许进程在内存中动态移动（如虚拟内存换入换出）。</li></ul></li></ol><ul><li>不同进程可以有相同的逻辑地址，这些逻辑地址映射到主存的不同位置</li><li>进程运行时，看到和使用的是逻辑地址</li></ul><h4 id="内存保护">内存保护</h4><ul><li><strong>目的</strong>：确保每个进程都有一个单独的内存空间</li><li>方法：<ul><li><strong>上、下限寄存器</strong><br>CPU 中设置寄存器记录进程内存的起始（下限）和结束（上限）地址，每次访问时检查地址是否在区间内，越界则报错。</li><li><strong>基址寄存器 + 界地址寄存器</strong><br>采用<strong>重定位寄存器</strong>（也称基址寄存器）和<strong>界地址寄存器</strong>（也称限长寄存器）<ul><li>重定位寄存器：存放进程的起始物理地址</li><li>界地址寄存器：存放进程的最大逻辑地址（如进程逻辑地址范围 0~1024，则界地址为 1024）</li><li>物理地址=逻辑地址+基址寄存器值</li><li><strong>越界判断</strong>：若逻辑地址 ≥ 界地址寄存器值，则触发越界中断<img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514113902.png" alt="image.png"></li></ul></li></ul></li></ul><h4 id="内存共享">内存共享</h4><ul><li>只有<strong>只读</strong>区域的进程空间可以共享（如代码段），读写区域共享会导致数据冲突</li><li><strong>可重入代码</strong>（纯代码）：允许多进程同时访问但不允许修改的代码，如标准库函数，不属于临界资源</li><li><strong>优势</strong>：减少内存中重复代码，提升系统性能（如多个进程共用同一代码副本）</li><li>实现方式：<ul><li><strong>段共享</strong>：通过分段存储管理，多个进程映射同一代码段到各自逻辑地址空间。</li><li><strong>内存映射文件</strong>：将文件内容映射到内存，多个进程可共享文件数据（如动态链接库）。</li><li><strong>共享内存通信</strong>：进程间直接访问同一物理内存区域，是最快的 IPC 方式（需配合同步机制）。</li></ul></li></ul><h4 id="进程的内存映像">进程的内存映像</h4><ul><li>当一个进程调入内存运行时，就构成了进程的内存映像</li><li>组成要素：<ul><li><strong>代码段</strong>：程序的二进制代码【代码段是只读的，可以被多个进程共享】</li><li><strong>数据段</strong>：存储全局变量、静态变量，程序运行时可读写。</li><li><strong>进程控制块 PCB</strong>：存放在系统区，OS 通过 PCB 控制和管理进程</li><li><strong>堆</strong>：动态分配内存区域（如 malloc 申请的空间），向高地址增长。</li><li><strong>栈</strong>：存储函数调用参数、局部变量，向低地址增长<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240819144242.png" alt="image.png"><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240819144324.png" alt="image.png"></li></ul></li></ul><h3 id="内存空间的分配管理方式">内存空间的分配管理方式</h3><h4 id="连续分配方式">连续分配方式</h4><ul><li><strong>定义</strong>：为进程分配连续的内存块，进程在主存中连续存放。</li><li><strong>特点</strong>：存储密度高，但易产生碎片（外部碎片或内部碎片）</li><li><strong>外部碎片</strong>：内存中无法被利用的小空闲块（存在于分区外部）</li><li><strong>内部碎片</strong>：分配给进程的内存中未被使用的部分（存在于分区内部）</li></ul><h5 id="单一连续分配-（单道程序时代）">单一连续分配 （单道程序时代）</h5><ul><li><strong>定义</strong>：内存划分为系统区（OS 专用，低地址）+ 用户区（仅一道程序）</li><li><strong>优点</strong>：<ul><li>简单、<strong>无外部碎片</strong></li><li>不需要进行<strong>内存保护</strong></li></ul></li><li><strong>缺点</strong>：<ul><li>只能用于单用户、单任务的操作系统</li><li><strong>有内部碎片</strong></li><li>存储器的利用率极低<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514120842.png" alt="image.png"></li></ul></li></ul><h5 id="固定分区分配（多道程序初期）">固定分区分配（多道程序初期）</h5><ul><li><strong>定义</strong>：将用户内存空间大小划分若干固定大小的分区，每个分区只装入一道作业，通过分区使用表管理</li><li><strong>分区策略</strong>：<ul><li><strong>等大小</strong>分区：适合用于用一台计算机控制多个相同对象的场合</li><li><strong>不等大小</strong>分区：按常见作业大小划分，灵活性更高</li></ul></li><li>为了方便分配与回收，建立一张<strong>分区使用表</strong>，每个表项对应一个分区，包括分区大小、起始地址及状态<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514121528.png" alt="image.png"></li><li><strong>优点</strong>：实现简单，<strong>无外部碎片</strong>（分区固定）</li><li><strong>缺点</strong>：<ul><li>大程序可能无法装入（无足够大分区）；</li><li>小程序占用完整分区，内部碎片严重；</li><li>无法共享内存，利用率低。</li></ul></li></ul><h5 id="动态分区分配（按需分配）">动态分区分配（按需分配）</h5><ul><li><strong>定义</strong>：进程装入时动态分配内存，分区大小等于进程需求，无内部碎片，但产生外部碎片，可通过<strong>紧凑</strong>技术处理<br><strong>紧凑技术</strong>：通过移动已分配内存块，合并空闲分区，消除外部碎片（需重定位支持）</li><li>记录内存使用情况的数据结构<ul><li><strong>空闲分区表</strong>：<br>每个空闲分区对应一个表项<br>表项中包含分区号、分区大小、分区起始地址等信息</li><li><strong>空闲分区链</strong>：<br>每个分区的起始部分和末尾部分分别设置前向指针和后向指针<br>起始部分处还可记录分区大小等信息<br> - <strong>内存回收规则</strong><br>   回收分区时，若相邻存在空闲分区则合并，共四种情况：<br>   - 仅后邻空闲区；<br>   - 仅前邻空闲区；<br>   - 前后均邻空闲区；<br>   - 前后无空闲区。</li></ul></li><li><strong>分配算法（顺序搜索类）</strong></li></ul><table><thead><tr><th><strong>算法</strong></th><th><strong>思想</strong></th><th><strong>分区排序</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>首次适应</strong></td><td>从头查找首个足够大的分区</td><td>空闲区按地址递增排列</td><td>综合来看性能最好，开销小，回收后无需重排</td><td>可能优先使用低地址小分区，导致高地址大分区被保留</td></tr><tr><td><strong>最佳适应</strong></td><td>查找最小足够大的分区，保留大分区</td><td>空闲区按容量递增排列</td><td>保留大分区，更适合大进程</td><td>产生大量难以利用的小碎片，开销大，回收需重排</td></tr><tr><td><strong>最坏适应</strong></td><td>查找最大足够大的分区，避免小碎片</td><td>空闲区按容量递减排列</td><td>减少小碎片产生</td><td>大分区易被耗尽，不利于大进程，开销大</td></tr><tr><td><strong>邻近适应</strong></td><td>从上次查找结束处开始查找</td><td>空闲区<strong>按地址递增</strong>排列（循环链表）</td><td>避免频繁检索低地址小分区，开销小</td><td>高地址易被划分为小分区，缺乏大空闲区</td></tr></tbody></table><ul><li><strong>分配算法（索引搜索类）</strong>【大、中型系统】：</li></ul><table><thead><tr><th><strong>算法</strong></th><th><strong>核心逻辑</strong></th><th><strong>优势</strong></th><th><strong>挑战</strong></th></tr></thead><tbody><tr><td><strong>快速适应</strong></td><td>按进程大小索引最小空闲分区链表，直接分配</td><td>查找效率高，<strong>无内部碎片</strong></td><td>回收时合并分区逻辑复杂，开销大</td></tr><tr><td><strong>伙伴系统</strong></td><td>所有分区大小为 2k，分配时分裂，回收时合并（如 1024B 需求，从 2048B 分区分裂为 1024B+1024B）</td><td>分区规则统一，适合大系统</td><td>内存利用率受限于 <strong>2 的幂次</strong>，可能浪费空间</td></tr><tr><td><strong>哈希算法</strong></td><td>按分区大小建立哈希表，快速定位对应空闲链表</td><td>分配速度极快</td><td>哈希表构建与维护开销大</td></tr></tbody></table><h4 id="基本分页存储管理">基本分页存储管理</h4><h5 id="分页思想">分页思想</h5><ul><li><strong>页框（物理块/物理页面/内存块/页帧）</strong>【内存】：<strong>内存</strong>被划分为固定大小的分区（如 4KB），每个分区称为页框，编号从 0 开始（页框号、物理块号）</li><li><strong>页面（页）</strong>【进程】：<strong>进程</strong>的逻辑地址空间被划分为与页框<strong>大小相同</strong>的区域，称为页面，编号从 0 开始（页号）<br><em>页是存储器管理中的最小单位</em></li><li><strong>对应关系</strong>：<strong>进程的页面和内存的页框有一一对应关系</strong><br>进程执行时，每个页面需分配一个页框，形成逻辑页与物理块的映射<br>各个页面不必连续存放，可以放到不相邻的各个页框中</li><li><strong>特点</strong>：<ul><li><strong>优势</strong>：不产生外部碎片（内存空间被固定分割，空闲块可直接分配）。</li><li><strong>不足</strong>：产生<strong>内部碎片</strong>（页面未填满页框的部分），但碎片较小。</li><li><strong>本质</strong>：分页是面向计算机硬件的内存管理方式，简化地址转换逻辑。</li></ul></li></ul><h5 id="页表">页表</h5><ul><li><strong>定义</strong>：操作系统为每个进程维护一张页表，记录每个页面对应的<strong>物理块号</strong>。</li><li><strong>页表项</strong>：<strong>每个页面对应一个页表项</strong>，包含<strong>页号</strong>和<strong>物理块号</strong>，两者<strong>长度相同</strong></li><li><strong>存储方式</strong>：页表项<strong>连续存放</strong>，页号可<strong>隐含</strong>（通过索引计算地址），不占用存储空间，如 i 号页表项地址 = 页表始址 + i × 页表项大小。</li><li>页表的作用是实现从<strong>页号到物理块号的地址映射</strong></li><li>页表通常存放在PCB中</li><li><strong>内存块大小=页面大小</strong></li><li>内存块数量（=内存大小/内存块大小）→页表项中块号所需字节数 = ⌈ log₂(内存块数量) / 8 ⌉<br>eg. <strong>4GB 内存，4KB 页面</strong><ul><li>页面大小 = 4KB = 2¹² B</li><li>内存块数量 = 2³² / 2¹² = 2²⁰ 个</li><li>块号需位数 = 20 bit</li><li>块号需字节数 = ⌈20/8⌉ = 3 B</li></ul></li><li>页号不占存储空间，可以隐含</li><li>页表记录的只是内存块号，而不是内存块的起始地址！<br>J号内存块的起始地址 =J * 内存块大小<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514195528.png" alt="image.png"></li></ul><h5 id="地址结构">地址结构</h5><ul><li><strong>逻辑地址的组成</strong>：<strong>页号 + 页内偏移量</strong><ul><li>若<strong>偏移量</strong>占 K 位，则<strong>页面大小</strong>为 2^K 字节；</li><li>若<strong>页号</strong>占 M 位，则进程最多有 2^M 个<strong>页面</strong>。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514194129.png" alt="image.png"></li></ul></li><li>地址结构决定了虚拟内存的寻址空间有多大</li><li><strong>页号 P = 逻辑地址 / 页面长度（整数除法）</strong></li><li><strong>页内偏移量 W = 逻辑地址 % 页面长度（取余）</strong></li><li><strong>页面大小刚好是 2 的整数幂有什么好处？</strong><ul><li>逻辑地址的拆分更加迅速：若页面大小为 2^K，则逻辑地址的低 K 位为偏移量，高位为页号，无需除法运算，提升地址转换效率。</li><li>物理地址的计算更加迅速：根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可得到最终的物理地址</li></ul></li><li><strong>页面太小</strong>会使进程的页面数过多，页表过长，占用大量内存，增加硬件地址转换的开销，降低页面换入/换出的效率</li><li><strong>页面太大</strong>会使页内碎片增多，降低内存的利用率</li></ul><p>eg. <strong>在某计算机系统中，页面大小是 50B。某进程逻辑地址空间大小为 200B，则逻辑地址 110 对应的页号、页内偏移量是多少？</strong><br>P=2    W=10<br>如果每个页面大小为 2^k B，用二进制数表示逻辑地址，则末尾K位即为页内<br>偏移量，其余部分就是页号</p><h5 id="基本地址变换机构（硬件实现地址映射）">基本地址变换机构（硬件实现地址映射）</h5><ul><li><strong>任务</strong>：将逻辑地址转换为内存中的物理地址</li><li><strong>页表寄存器（PTR）</strong>：<ul><li>存储<strong>页表始址 F 和页表长度 M</strong></li><li>单 CPU 系统中只设置一个，进程调度时从 PCB 加载到 PTR<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514202615.png" alt="image.png"></li></ul></li><li>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：<ol><li>计算页号 <strong>P =⌊ A / L ⌋</strong>、页内偏移量 <strong>W = A % L</strong></li><li>判断页号是否越界：若 P &gt;= M页表长度，产生<strong>越界中断</strong>，否则，继续执行</li><li>在页表中查询页号对应的页表项，确定页面存放的物理块号【页号 P 对应的<strong>页表项地址 = F + P * 页表项长度</strong>，取出该页表项内容 b，即为物理块号 】</li><li>计算<strong>物理地址 E = b × L + W</strong>，并用物理地址访存【页面在内存中的始址 = b * L 】</li></ol></li><li>整个地址变换过程均由<strong>硬件自动完成</strong></li><li>页式管理中地址空间是<strong>一维</strong>的</li><li><strong>两次访存</strong>：<ul><li>第一次：访问页表获取物理块号</li><li>第二次：访问目标内存单元</li></ul></li></ul><h5 id="具有快表的地址变换机构">具有快表的地址变换机构</h5><ul><li><strong>快表（TLB）</strong>【<strong>相联存储器</strong>】：加速地址转换的高速缓存<ul><li>具有<strong>并行</strong>查找能力的高速缓冲存储器</li><li>用来存放当前访问的若干页表项，以加速地址变换的过程</li><li>基于<strong>局部性</strong>原理：程序倾向于频繁访问相同的页面<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514205038.png" alt="image.png"><br><strong>带快表的地址变换流程</strong></li></ul></li></ul><ol><li>计算 P 和 W，检查合法性；</li><li>先查快表<ul><li>若命中：直接用块号计算物理地址E（一次访存）；</li><li>若未命中：查主存页表，同时将页表项存入快表（两次访存）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514205530.png" alt="image.png"></li></ul></li></ol><h5 id="两级页表">两级页表</h5><p>解决<strong>大页表</strong>的内存占用问题<br>当进程页面数极多时，单级页表可能占用多个物理页，导致内存碎片化和访存效率降低</p><ul><li><strong>逻辑地址结构</strong>：一级页号（页目录号） + 二级页号 + 页内偏移量<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514210155.png" alt="image.png"><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514210216.png" alt="image.png"></li><li>在页表的每个表项中，存放的是进程的某页对应的物理块号</li><li>在外层页表（页目录）的每个表项中，存放的是每个页表分页的始址</li><li>需要增设一个<strong>外层页表寄存器</strong>【页目录基址寄存器】，用于<strong>存放页目录始址</strong></li><li>利用页目录和页表实现从逻辑地址到物理地址的转换：<ol><li>从 PCB 获取页目录始址；</li><li>查页目录表（第一次访存），获取二级页表地址；</li><li>查二级页表（第二次访存），获取物理块号；</li><li>拼接块号与偏移量，得到物理地址（第三次访存）。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514212622.png" alt="image.png"></li></ol></li><li>若没有快表机构，N 级页表访问一个逻辑地址需要 N + 1 次访存</li><li>各级页表大小不超过一个页面，避免页表本身分页导致的多级访存开销。</li></ul><p><strong>代价</strong>：若无快表，每次访存需三次内存访问（N 级页表需 N+1 次）。</p><table><thead><tr><th>机制</th><th>访存次数</th><th>适用场景</th><th>核心优化点</th></tr></thead><tbody><tr><td>基本地址变换</td><td>2 次</td><td>中小页表</td><td>硬件自动转换</td></tr><tr><td>带快表的变换</td><td>1 次（命中）</td><td>所有场景</td><td>利用局部性减少访存</td></tr><tr><td>两级页表</td><td>3 次</td><td>大页表（如 64 位系统）</td><td>减少页表内存占用</td></tr></tbody></table><h4 id="基本分段存储管理方式">基本分段存储管理方式</h4><h5 id="分段思想">分段思想</h5><ul><li>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名，<strong>每段从 0 开始编址</strong></li><li>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以互不相邻</strong>【段内要求连续，段间不要求连续】</li><li>由于是按逻辑功能模块划分，<strong>用户编程更方便，程序的可读性更高</strong></li><li><strong>特点</strong>：<ul><li>方便编程、信息保护和共享</li><li>方便动态链接、增长</li><li>会产生外部碎片</li></ul></li></ul><h5 id="段表">段表</h5><ul><li><strong>每个进程都有一张</strong>逻辑空间与内存空间映射的<strong>段表</strong></li><li>进程的每个段对应一个<strong>段表项</strong>，记录了该段在内存中的<strong>起始位置</strong>【基址】和<strong>段的长度</strong></li><li>各个段表项的<strong>长度相同</strong>，因此<strong>段号可以是隐含的，不占用存储空间</strong></li><li>段表用于实现从逻辑段到物理内存区的映射<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516141903.png" alt="image.png"></li></ul><h5 id="地址结构-2">地址结构</h5><ul><li>段号 + 段内偏移量<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516142157.png" alt="image.png"></li><li>段号的位数决定了<strong>每个进程最多可以分几个段</strong></li><li>段内偏移量的位数决定了<strong>每个段的最大长度是多少</strong></li><li>段号和段内偏移量必须由<strong>用户显示提供</strong>【在高级程序设计语言中，这个工作由编译程序完成】</li></ul><h5 id="地址变换机构">地址变换机构</h5><ul><li><strong>任务</strong>：实现进程从逻辑地址到物理地址的变换功能</li><li><strong>段表寄存器</strong>：<ul><li>存放段表始址 F 和段表长度 M</li><li>存放于进程的 PCB 中<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516142535.png" alt="image.png"></li></ul></li><li>地址变换过程：<ol><li>从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W</li><li>判断段号是否越界，若段号 S &gt;= 段表长度 M，则产生越界中断，否则继续执行</li><li>在段表中查询段号对应的段表项【段号 S 对应的段表项地址 = F + S * 段表项长度】，取出该段的段长 C，若 W &gt;= C，则产生越界中断，否则继续执行</li><li>取出段表项中该段的始址 b，计算物理地址 E = b + W，用物理地址去访存</li></ol></li><li>地址空间是<strong>二维</strong>的</li><li><strong>两次访存</strong>：<ul><li>第一次：查内存中的段表</li><li>第二次：访问目标内存单元</li></ul></li></ul><h5 id="分页和分段的对比">分页和分段的对比</h5><ul><li><strong>页是信息的物理单位</strong>，分页的主要目的是提供内存利用率，分页完全是系统行为，对用户不可见</li><li><strong>段是信息的逻辑单位</strong>，分段的主要目的是更好地满足用户需求，用户按照逻辑关系将程序划分为若干段，分段对用户是可见的</li><li><strong>页的大小固定</strong>且有系统决定</li><li><strong>段的长度不固定</strong>，具体取决于用户编写的程序</li><li><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址</li><li><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址</li><li><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong></li></ul><h5 id="段的共享与保护">段的共享与保护</h5><ul><li><strong>共享实现</strong>：<ul><li>在每个进程的段表中设置一个段表项，指向被共享的同一物理段</li><li>为了防止程序在执行时修改共享代码，在每个进程中都必须配以局部数据区，将在执行过程中可能改变的部分复制到数据区</li></ul></li><li><strong>保护实现</strong>：<ul><li>存取控制保护</li><li>地址越界保护：两次越界判断【段号、段内偏移】</li></ul></li></ul><h4 id="段页式存储管理方式">段页式存储管理方式</h4><h5 id="段页思想">段页思想</h5><ul><li>分页存储管理能有效提高内存利用率，分段存储管理能反映程序的逻辑结构并有利于段的共享和保护，于是将两种方式结合起来</li><li>进程的地址空间：<strong>首先被分成若干逻辑段</strong>，每段都有自己的段号，然后将<strong>每段分成若干大小固定的页</strong></li><li>内存空间：和分页存储管理一样，将其分成若干<strong>和页面大小相同的存储块</strong>，对内存的分配以存储块为单位<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516150206.png" alt="image.png"></li></ul><h5 id="地址结构-3">地址结构</h5><ul><li>段号 + 页号 + 页内偏移量<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516150145.png" alt="image.png"></li><li>段号的位数决定了<strong>每个进程最多可以分几个段</strong></li><li>页号位数决定了<strong>每个段最大有多少页</strong></li><li>页内偏移量决定了<strong>页面大小、内存块大小是多少</strong></li></ul><h5 id="地址变换机构-2">地址变换机构</h5><ul><li><strong>每个进程建立一张段表</strong>，每个段对应一个<strong>段表项</strong>，每个段表项至少包括段号、<strong>页表长度和页表始址</strong>【每个段表项长度相等，段号隐含】</li><li><strong>每个段有一张页表</strong>，每个页面对应一个<strong>页表项</strong>，每个页表项至少包括页号、页面存放的内存块号【每个页表项长度相等，页号隐含】</li><li>系统中有一个段表寄存器，指出进程的段表始址和段表长度【用于寻址和判断越界】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516151437.png" alt=""></li><li>地址空间是<strong>二维</strong>的</li><li><strong>三次访存</strong>：<ul><li>第一次：查段表</li><li>第二次：查页表</li><li>第三次：访问目标内存单元</li></ul></li></ul><h2 id="虚拟内存管理">虚拟内存管理</h2><h3 id="虚拟内存">虚拟内存</h3><h4 id="传统存储管理方式的特征">传统存储管理方式的特征</h4><ul><li><strong>一次性</strong>：<ul><li>作业必须一次性全部装入内存，才能开始运行</li></ul></li><li><strong>驻留性</strong>：<ul><li>作业被装入内存后，就一直驻留在内存中，直到作业结束</li><li>运行中的进程会因等待 I/O 而被阻塞，可能处于长期等待状态</li></ul></li></ul><h4 id="局部性原理">局部性原理</h4><ul><li><strong>时间局部性</strong>：<ul><li>程序中的某条指令一旦执行，不久后该指令可能再次运行</li><li>原因是程序中存在着大量的循环结构</li></ul></li><li><strong>空间局部性</strong>：<ul><li>程序在一段时间内所访问的地址，可能集中在一定的范围内</li><li>因为指令通常是顺序存放、顺序执行的</li></ul></li><li>局部性原理既适用于程序结构，又适用于数据结构</li></ul><h4 id="虚拟存储器">虚拟存储器</h4><ul><li><strong>定义</strong>：系统为用户提供的一个比实际内存容量大得多的存储器<ul><li>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行</li><li>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>【请求调页/段】，然后继续执行程序</li><li>若内存空间不够，由<strong>操作系统</strong>负责<strong>将内存中暂时用不到的信息换出到外存</strong>【页面/段置换】</li></ul></li><li><strong>特征</strong>：<ul><li><strong>多次性</strong>：只需将当前运行的那部分程序和数据装入内存即可开始运行【最重要的特征】</li><li><strong>对换性</strong>：作业无需一直常驻内存，暂不使用的从内存调至外存的对换区（换出），要用时换入</li><li><strong>虚拟性</strong>：从逻辑上扩充内存的容量【最重要的目标】</li></ul></li><li><strong>注意</strong>：<ul><li>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构（CPU 寻址范围）确定的</li><li>虚拟内存的<strong>实际容量</strong> = min（内存和外存容量之和，CPU 寻址范围）<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240516155342.png" alt="image.png"></li></ul></li></ul><h4 id="虚拟内存的实现">虚拟内存的实现</h4><ul><li><strong>方式</strong> 【离散分配】：<ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul></li><li><strong>需要的东西</strong>：<ul><li>一定的硬件支持，一定容量的内存和外存</li><li>页表/段表机制，作为主要的数据结构</li><li>中断机制，当程序要访问的部分还未调入内存时，产生中断</li><li>地址变换机构</li></ul></li></ul><h3 id="请求分页管理方式">请求分页管理方式</h3><h4 id="基本概念-2">基本概念</h4><ul><li>只要求将当前一部分页面装入内存，便可启动作业运行，不需要一次全部装入</li><li>在作业执行的过程中，当访问的页面不存在时，再通过调页功能将其调入</li><li>相比基本分页管理，增加的功能：<ul><li>请求调页功能：将要用的页面调入内存【调入】</li><li>页面置换功能：将不用的页面换出到外存【调出】</li></ul></li></ul><h4 id="页表机制">页表机制</h4><ul><li>页表的构成：页号 + 页框号 + 状态位 P + 访问字段 A + 修改位 M + 外存地址【新增后四个字段】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240517160356.png" alt="image.png"></li><li><strong>状态位/合法位 P</strong>：标记该页是否已被调入内存中供程序访问时参考，用于判断是否触发缺页异常</li><li><strong>访问字段 A</strong>：记录本页在一段时间内被访问的次数供置换算法换出页面时参考</li><li><strong>修改位 M</strong>：标识该页在调入内存后是否被修改过当页面被淘汰时，若页面数据没有修改，则不用写回外存</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号供写回外存和从外存中调入此页时参考</li></ul><h4 id="缺页中断机构">缺页中断机构</h4><ul><li><strong>缺页</strong>：<ul><li>是在 CPU 执行某条指令过程中，进行取指令或读写数据时发生的一种故障，是<strong>内中断</strong>【异常】</li><li>每当要访问的页面不在内存中时，便产生一个缺页中断，请求 OS 将所缺的页调入内存</li><li>缺页中断是访存指令引起的，说明所要访问的页面不在内存中</li><li>进行缺页中断处理并调入所要访问的页后，访存指令应该重新执行</li><li><strong>特点</strong>：<ul><li>在指令执行期间而非一条指令执行完后产生和处理中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li></ul></li></ul></li><li><strong>处理过程</strong>：<ul><li>假设此时要访问逻辑地址=（页号，页内偏移量）=（0, 102</li><li>在请求分页系统中，每当要访问的<strong>页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的缺页<strong>中断处理程序处理中断</strong></li><li>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列</li><li>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项</li><li>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>【未修改过的页面不用写回外存】</li></ul></li></ul><h4 id="地址变换机构-3">地址变换机构</h4><ul><li>相比基本分页管理，增加的步骤：<ul><li>请求调页（查到页表项时进行判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240517162050.png" alt="image.png"></li></ul></li></ul><ol><li>先检索快表，若命中，从相应表项中取出该页的物理块号，并修改页表项中的访问位，以供置换算法换出页面时参考</li><li>若快表未命中，则要到页表中查找，若找到，则从相应表项中取出物理块号，并将该页表项写入快表，若快表已满，则需采用某种算法替换</li><li>若在页表中未找到，则需要进行缺页中断处理，请求系统将该页从外存换入内存，页面被调入内存后，由 OS 负责更新页表和快表，并获得物理块号</li><li>根据形成的物理地址访存<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240517162123.png" alt=""><br><strong>注意</strong>：</li></ol><ul><li><strong>只有“写指令”才需要修改“修改位”</strong>，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表【这样可以减少访存次数】</li><li>换入/换出页面都需要启动慢速的 I/O 操作，可见，如果换入/换出太频繁，会有很大的开销</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中</li></ul><h3 id="页框分配策略">页框分配策略</h3><h4 id="驻留集">驻留集</h4><ul><li><strong>驻留集</strong>：给一个进程分配的物理页框（也叫做物理块）的集合</li><li>驻留集<strong>越小</strong>：驻留在内存的进程就越多，可以提高多道程序的并发度，但分配给每个进程的页框太少，会导致缺页率较高，CPU 需耗费大量时间处理缺页</li><li>驻留集<strong>越大</strong>：分配的页框过多时，对缺页率的改善不明显，反而是浪费内存空间，还会导致多道程序并发度下降</li></ul><h4 id="页面分配、置换策略">页面分配、置换策略</h4><ul><li>两种内存分配策略：<ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，<strong>驻留集大小不变</strong>，分配的算法有：<ul><li>平均分配算法</li><li>按比例分配算法</li><li>优先权分配算法</li></ul></li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，<strong>驻留集大小可变</strong></li></ul></li><li>两种页面置换策略：<ul><li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</li><li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240517170214.png" alt="image.png"></li></ul></li><li><strong>固定分配局部置换</strong>：<ul><li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</li><li><strong>缺点</strong>：很难在刚开始就确定应为每个进程分配多少个物理块才算合理</li></ul></li><li><strong>可变分配全局置换</strong>：<ul><li>刚开始会为每个进程分配一定数量的物理块，操作系统会保持一个空闲物理块队列</li><li>当某进程发生缺页时，从空闲物理块中取出一块分配给该进程</li><li><strong>优点</strong>：只要某进程发生缺页，都将获得新的物理块</li><li><strong>缺点</strong>：被选择调出的页可能是系统中<strong>任何一个进程中的页</strong>，因此这个<strong>被选中的进程</strong>拥有的物理块会减少，<strong>缺页率会增加</strong></li></ul></li><li><strong>可变分配局部置换</strong>：<ul><li>刚开始会为每个进程分配一定数量的物理块</li><li>当某进程发生缺页时，只允许<strong>从该进程自己的物理块</strong>中选出一个进行换出外存</li><li>根据发生<strong>缺页的频率</strong>来动态地增加或减少进程的物理块【频率高，多分配几个物理块】</li></ul></li></ul><h4 id="何时调入页面">何时调入页面</h4><ul><li><strong>预调页策略</strong>【运行前调入】：<ul><li>根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效</li><li><strong>主要用于进程的首次调入</strong>，由程序员指出应该先调入哪些部分</li></ul></li><li><strong>请求调页策略</strong>【运行时调入】：<ul><li>进程在运行期间发现缺页时才将所缺页面调入内存</li><li><strong>优点</strong>：调入的页面一定会被访问到</li><li><strong>缺点</strong>：每次只能调入一页，每次都要磁盘 I/O 操作，开销较大</li></ul></li></ul><h4 id="从何处调页">从何处调页</h4><ul><li><strong>对换区</strong>：存放对换页面，采用连续分配方式，速度更快</li><li><strong>文件区</strong>：存放文件，采用离散分配方式，速度更慢</li></ul><ol><li><strong>系统拥有足够的对换区空间</strong>：<ul><li>页面的调入、调出都是在<strong>内存与对换区之间</strong>进行，这样可以保证页面的调入、调出速度很快</li><li>在进程运行前，需将进程相关的数据从文件区复制到对换区<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518135710.png" alt="image.png"></li></ul></li><li><strong>系统缺少足够的对换区空间</strong>：<ul><li>凡是<strong>不会被修改的数据都直接从文件区调入</strong>，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可</li><li>对于可能<strong>被修改的部分</strong>，换出时需写回磁盘对换区，下次需要时再从对换区调入<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518135502.png" alt="image.png"></li></ul></li><li><strong>UNIX 方式</strong>：<ul><li><strong>运行之前</strong>进程有关的数据<strong>全部放在文件区</strong>，故未使用过的页面，都可从文件区调入</li><li>若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518135621.png" alt="image.png"></li></ul></li></ol><h4 id="如何调入页面">如何调入页面</h4><ul><li>情况 1：所访问的页面不在内存时 —&gt; 缺页中断 —&gt; 无空闲物理块 —&gt; 决定淘汰页 —&gt; 调出页面 —&gt; 调入所缺页面</li><li>情况 2：所访问的页面不在内存时 —&gt; 缺页中断 —&gt; 有空闲物理块 —&gt; 调入所缺页面</li></ul><h4 id="其他概念">其他概念</h4><h5 id="抖动-（颠簸）现象">抖动 （颠簸）现象</h5><ul><li><strong>定义</strong>：在页面置换时，出现频繁的页面调度行为</li><li><strong>产生原因</strong>：<ul><li>系统中同时运行的进程太多，分配给每个进程的物理块太少，导致进程在运行时频繁出现缺页，出现频繁的页面调度行为</li><li>主要原因是因为页面置换算法不合理</li></ul></li><li><strong>解决办法</strong>：<ul><li>撤销部分进程</li><li>增加磁盘交换区大小和提高用户进程优先级都与抖动无关</li></ul></li></ul><h5 id="工作集">工作集</h5><ul><li><strong>定义</strong>：在某段时间间隔内，进程实际访问的页面集合</li><li><strong>如何确定</strong>：基于局部性原理，用最近访问过的页面来确认</li><li><strong>作用</strong>：<ul><li>工作集反映了进程在接下来一段时间内很可能频繁访问的页面集合</li><li>为了<strong>防止抖动现象</strong>，要使分配给进程的物理块数 <strong>【驻留集大小】&gt;= 工作集大小</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518141818.png" alt="image.png"></li></ul></li></ul><h3 id="页面置换算法">页面置换算法</h3><h4 id="最佳置换算法-OPT">最佳置换算法 OPT</h4><ul><li><strong>基本思想</strong>：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率</li><li><strong>特点</strong>：<ul><li>可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面</li><li>操作系统无法提前预判页面访问序列，因此，<strong>最佳置换算法是无法实现的</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518142907.png" alt="image.png"></li></ul></li></ul><h4 id="先进先出置换算法-FIFO">先进先出置换算法 FIFO</h4><ul><li><strong>基本思想</strong>：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong></li><li><strong>实现方法</strong>：<ul><li>把调入内存的页面根据调入的先后顺序排成一个<strong>队列</strong>，需要换出页面时选择队头页面即可</li><li>队列的最大长度取决于系统为进程分配了多少个内存块</li></ul></li><li><strong>特点</strong>：<ul><li><strong>Belady 异常</strong>：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li><li><strong>只有 FIFO 算法才会出现 Belady 异常</strong></li><li>实现简单</li><li>与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问，故<strong>算法性能差</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518143420.png" alt="image.png"></li></ul></li></ul><h4 id="最近最久未使用置换算法-LRU">最近最久未使用置换算法 LRU</h4><ul><li><strong>基本思想</strong>：每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></li><li><strong>实现方法</strong>：<ul><li>赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间 t</strong></li><li>当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面</li></ul></li><li><strong>特点</strong>：<ul><li>堆栈类算法</li><li>需要寄存器和栈的硬件支持</li><li>实现困难，开销大</li><li>算法性能好<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518144133.png" alt="image.png"></li></ul></li></ul><h4 id="时钟置换算法-CLOCK">时钟置换算法 CLOCK</h4><ul><li><strong>基本思想</strong>：基于访问位和循环队列，考虑一个页面最近是否被访问过，又称为<strong>最近未用算法（NRU）</strong></li><li><strong>实现方法</strong>：<ul><li>为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接成一个循环队列</strong></li><li>当某页被访问时，其访问位置为 1</li><li>当需要淘汰一个页面时，只需检查页的访问位<ul><li>如果是 0，就选择该页换出</li><li>如果是 1，则将它置为 0，暂不换出，继续检查下一个页面</li></ul></li><li>若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描</li></ul></li><li><strong>特点</strong>：<ul><li>选择一个淘汰页面<strong>最多会经过两轮扫描</strong></li><li>性能和开销较为均衡</li><li>实现简单</li><li>未考虑页面是否被修改<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518144856.png" alt="image.png"><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518144911.png" alt="image.png"></li></ul></li></ul><h4 id="改进型的时钟置换算法">改进型的时钟置换算法</h4><ul><li><strong>基本思想</strong>：<ul><li>对于 NRU 算法，如果被淘汰的页面没有被修改过，就不需要执行 I/O 操作写回外存【<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>】</li><li>增加一个置换代价——<strong>修改位</strong></li><li>优先淘汰<strong>既未使用又未修改过的页面</strong></li></ul></li><li><strong>实现方法</strong>：<ul><li>用 <strong>（访问位，修改位）</strong> 的形式表示各页面状态【如（1，表示一个页面近期被访问过，且被修改过】</li><li>将所用可能被置换的页面排成一个循环队列</li><li>第一轮：从当前位置开始扫描到第一个 <strong>（0，0）【第一优先级】</strong> 的帧用于替换，本轮扫描不修改任何标志位</li><li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个 <strong>（0，【第二优先级】</strong> 的帧用于替换，本轮将所有扫描过的帧<strong>访问位设为 0</strong></li><li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）【原本（1，0）第三优先级】的帧用于替换，本轮扫描不修改任何标志位</li><li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，【原本（1，第四优先级】的帧用于替换</li></ul></li><li><strong>特点</strong>：<ul><li>选择一个淘汰页面最<strong>多会进行四轮扫描</strong></li><li>可减少磁盘的 I/O 操作次数</li><li>算法开销较小，相比 NRU 稍有增加</li></ul></li></ul><h3 id="其他概念-2">其他概念</h3><h4 id="内存映射文件">内存映射文件</h4><ul><li><p><strong>定义</strong>：</p><ul><li>是 OS 向应用程序提供的一个<strong>系统调用</strong></li><li>与虚拟内存有些相似，在磁盘文件与进程的虚拟地址空间之间建立映射关系</li></ul></li><li><p><strong>特性</strong>：</p><ul><li>进程可使用系统调用，请求 OS 将文件映射到进程的虚拟地址空间</li><li><strong>以访问内存的方式读文件</strong>【将一个文件当作内存中的一个大字符数组，不通过 I/O 访问，更便利】</li><li>磁盘文件的读入/写出操作由 OS 负责完成，对进程透明</li><li>当映射进程的页面时，不会实际读入文件的内容【访问时才被每次一页地读入】</li><li>当进程退出或关闭文件映射时，所用被改动的页面才被写回磁盘文件</li><li>多个进程可以映射一个文件，方便共享<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240518152815.png" alt="image.png"></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li><li>文件数据的读入/写出完全由 OS 负责，I/O 效率可以由 OS 负责优化</li></ul></li></ul><h4 id="虚拟存储器性能影响因素">虚拟存储器性能影响因素</h4><ol><li><strong>页面较大</strong> —&gt; 缺页率较低 —&gt; 可以减少页表长度，但使得页内碎片增大</li><li><strong>页面较小</strong> —&gt; 缺页率较高<ul><li>可以减少内存碎片，提高内存利用率</li><li>使得页表过长，占用大量内存</li></ul></li><li>分配给进程的<strong>物理块数越多，缺页率就越低</strong></li><li>分配给进程的物理块数超过某个值时，对缺页率的改善并不明显</li><li>好的页面置换算法可以使进程在运行过程中具有较低的缺页率</li><li>LRU，CLOCK 将未来可能要用到的进程保存在内存中，可以提高页面的访问速度</li><li>在系统建立一个已修改换出页面的链表，这些页面暂不写回磁盘，仅当换出页面数达到给定值时，才一起写回磁盘，可以显著减少磁盘的 I/O 次数</li><li>编写程序的<strong>局部化程度越高，执行时的缺页率越低</strong></li><li>存储和访问尽量<strong>使用相同的访问方式</strong>（如按行存储就进行按行访问）</li></ol><h4 id="地址翻译">地址翻译</h4><ul><li>见王道书 2025 版 p223，举例较为清晰</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分配（连续 / 非连续） </tag>
            
            <tag> 页表 / 快表（TLB） </tag>
            
            <tag> 虚拟内存 </tag>
            
            <tag> 请求分页存储 </tag>
            
            <tag> 页面置换算法（LRU/OPT/Clock） </tag>
            
            <tag> 地址转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 3 章 存储系统</title>
      <link href="/post/a81d4c7b.html"/>
      <url>/post/a81d4c7b.html</url>
      
        <content type="html"><![CDATA[<h1>1 存储系统基本概念</h1><h2 id="1-1-存储系统的层次结构">1.1 存储系统的层次结构</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409174256637.png" alt="image.png|400"></p><ul><li><strong>层次思想</strong>：上一层的存储器作为低一层存储器的高速缓存，上一层的内容是下一层的内容的一部分<br>Cache（或主存）中的内容只是主存（或辅存）中的内容的一部分</li><li>层次结构主要体现在 缓存-主存 和 主存-辅存 这两个层次上。<ul><li><strong>Cache —— 主存层</strong></li><li><font color="#ff0000">解决 CPU 和主存速度不匹配的问题</font></li><li>数据调度由<strong>硬件自动</strong>完成</li><li>对<strong>所有</strong>程序员透明</li><li><strong>主存 —— 辅存层</strong></li><li><font color="#ff0000">解决存储系统容量的问题</font></li><li>数据调度由<strong>硬件和操作系统</strong>共同完成【换入换出技术】</li><li>对<strong>应用</strong>程序员透明</li><li>逐渐发展形成虚拟存储系统</li></ul></li><li>主存与 CPU，Cache，辅存都能交换信息</li><li>Cache 和主存能与 CPU 直接交换信息</li><li>CPU &amp; 主存——字长</li><li>CPU &amp; Cache——字长</li><li>主存 &amp; Cache——块</li><li>寄存器集成在CPU内部</li><li>辅存中的数据要调入主存后，才能与 CPU 交换信息</li></ul><table><thead><tr><th><strong>组件</strong></th><th><strong>比喻</strong></th><th><strong>作用</strong></th><th><strong>速度</strong></th><th><strong>容量</strong></th></tr></thead><tbody><tr><td><strong>CPU</strong></td><td>看书的人</td><td>执行计算和处理任务</td><td>极快（纳秒）</td><td>无存储能力</td></tr><tr><td><strong>Cache</strong></td><td>桌上的书（随时拿）</td><td>临时存放 CPU 急需的数据</td><td>极快</td><td>极小（MB）</td></tr><tr><td><strong>主存</strong></td><td>书架上的书（走几步拿）</td><td>存放正在运行的程序和数据</td><td>较快</td><td>较大（GB）</td></tr><tr><td><strong>辅存</strong></td><td>仓库里的书（开车去取）</td><td>长期存储所有数据（如硬盘、SSD）</td><td>慢（毫秒）</td><td>极大（TB）</td></tr></tbody></table><ol><li><strong>CPU 需要数据时</strong>：<ul><li>先翻桌上的书（<strong>Cache</strong>）：找到直接使用（<strong>命中</strong>），速度飞快。</li><li>如果桌上没有（<strong>未命中</strong>），去书架上找（<strong>主存</strong>），找到后<strong>复制一份到桌上</strong>方便下次快速访问。</li><li>如果书架上也没有，只能去仓库（<strong>辅存</strong>）搬回来，速度最慢。</li></ul></li><li>实际例子：<br>你打开微信：<ol><li><strong>辅存</strong>（硬盘）中的微信程序被加载到 <strong>主存</strong>（内存）。</li><li>CPU 处理消息时，频繁用的聊天记录会被缓存到 <strong>Cache</strong>。</li><li>当你切换聊天窗口，CPU 优先从 Cache 读取数据，感觉流畅；若 Cache 没有，需从主存加载，可能稍卡顿。</li><li>关闭微信后，主存释放空间，但数据仍长期保存在辅存。</li></ol></li></ol><h2 id="1-2-存储器的分类">1.2 存储器的分类</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409172314148.png" alt="image.png|450"></p><h3 id="1-2-1-按在计算机中的作用分类">1.2.1 按在计算机中的作用分类</h3><ul><li><strong>主存储器</strong>【主存、内存】<ul><li>用来存放计算机<strong>运行期间</strong>所需的程序和数据</li><li>容量小，存取速度较快，每位价格较高</li><li>主存由RAM 和ROM 组成</li><li>可以直接被CPU读写</li></ul></li><li><strong>辅助存储器</strong>【辅存、外存】<ul><li>用来存放当前暂时不用的程序和数据以及一些需要永久性保存的信息</li><li>容量大，存取速度较慢，单位成本低</li><li>辅存的内容需要调入主存后才能被CPU访问</li></ul></li><li><strong>高速缓存存储器</strong>【Cache】<ul><li>位于<strong>主存和 CPU 之间</strong></li><li>用来存放当前 CPU 经常使用的指令和数据，以便 CPU 能高速地访问它们</li><li>现代计算机通常将其制作在 CPU 内</li><li>容量小，存取速度很快，价格高</li><li>可以直接被CPU读写</li></ul></li></ul><h3 id="1-2-2-按存储介质分类">1.2.2 按存储介质分类</h3><ul><li><strong>磁表面存储器</strong>：磁盘，磁带</li><li><strong>磁芯存储器</strong></li><li><strong>半导体存储器</strong>：主存、Cache、MOS 型存储器，双极型存储器</li><li><strong>光存储器</strong>：光盘</li></ul><h3 id="1-2-3-按存取方式分类">1.2.3 按存取方式分类</h3><h4 id="随机存储器【RAM】：">随机存储器【RAM】：</h4><ul><li>每个单元读写时间一样，且与各单元所在位置无关。如：内存</li><li>可读/写</li><li>RAM就是内存</li><li>存储器的任何一个存储单元都可以随机存取</li><li>每个单元存取时间一样，存取时间与存储单元的物理位置无关</li><li>主要用于做<strong>主存或高速缓冲存储器</strong></li><li>读写方便，使用灵活</li><li>RAM 分为<strong>静态 RAM</strong> 和<strong>动态 RAM</strong></li><li>RAM 主要为用户编程设置的</li><li>易失</li><li><strong>主要用于主存储器（主存）和高速缓存（Cache）</strong></li><li>分类：<ul><li><strong>静态随机存储存储器</strong>（SRAM）<ul><li>存储元，双稳态触发器（元晶体管MOS）</li><li><strong>非破坏性读出</strong>（不会影响原数据）</li><li>速度快，集成度低（同等面积存储数据较少），功耗大，造价贵</li><li>用于<mark>Cache缓存</mark>（一级L1、二级L2缓存）等高速度要求场景</li></ul></li><li><strong>动态随机存储存储器</strong>（DRAM）<ul><li>一个晶体管 + 一个电容构成的单元</li><li><strong>破坏性读出</strong>（读取时需重新写回）</li><li>速度慢，集成度高，功耗低，造价低</li><li>用于<mark>主存</mark>等大容量需求场景</li><li>刷新（以行为单位）分散刷新不存在死时间</li><li>DRAM行缓冲用SRAM实现，提高访问速度</li><li><strong>地址复用技术</strong><br><strong>将一条地址总线分成两次使用</strong>，第一次传输<strong>行地址</strong>，第二次传输<strong>列地址</strong>，这样就可以用<strong>一组引脚</strong>传递两种地址信息，从而<strong>减少芯片所需引脚数量，提高封装密度</strong>。</li><li>SDRAM（同步动态随机存取存储器）<ul><li>是 DRAM 的一种改进形式，它具有同步接口，意味着在响应控制输入之前会等待一个时钟信号，从而与计算机的系统总线同步，能够在单个时钟周期内执行多个操作 。（DRAM与CPU采用异步方式交换数据）</li><li>SDRAM也是DRAM的一种，也需要定期刷新</li><li>SDRAM的行缓冲器用来缓存指定行中整行的数据，通常用SRAM实现</li></ul></li></ul></li></ul></li></ul><h4 id="只读存储器【ROM】">只读存储器【ROM】</h4><ul><li>存储器的内容只能随机读出而不能写入</li><li>信息一旦<strong>写入就不变</strong>，断电后也不消失，可靠性高</li><li>通常用于存放固定不变的程序，常数和汉字字库</li><li>ROM 与 RAM <strong>一起统一构成主存的地址域</strong></li><li>ROM 和 RAM 的存取方式<strong>均为随机存取</strong></li><li>操作系统的内存储器既有 RAM 也有 ROM</li><li>广义上的 ROM 现在可通过电擦除进行写入，写入速度比读取速度慢</li><li>ROM 存放系统程序，标准子程序和各类常数</li><li>结构简单，所以位密度比可读写存储器的高</li><li>分类：<ul><li>不可在线该些内容的ROM</li><li>闪存（用作BIOS）</li></ul></li></ul><h4 id="串行访问存储器">串行访问存储器</h4><ul><li>可读/写</li><li>对存储单元进行读写操作时，需按其物理位置的先后顺序寻址</li><li><strong>顺序存取存储器</strong>【SAM】：<strong>磁带</strong><ul><li>存取速度慢，只能按某种顺序存取</li><li><strong>存取时间的长短与信息所在位置有关</strong></li><li>信息记录方式以记录块(或数据块)为单位，加上间隔和标志区顺序排列若干记录块组成记录文件</li></ul></li><li><strong>直接存取存储器</strong>【DAM】：<strong>磁盘、光盘</strong><ul><li>既有随机存取特性，也有顺序存取特性。先<strong>直接选取信息所在区域，然后按顺序方式存取</strong></li><li>速度介于<strong>随机存取器和顺序存取器之间</strong></li></ul></li></ul><h4 id="相联存储器【CAM】">相联存储器【CAM】</h4><ul><li>按内容访问</li><li><strong>快表</strong></li></ul><p>注：<strong>RAM与ROM</strong>是两种重要的存储设备，尽管它们都属于电脑内存的部分，但各自扮演着不同的角色。RAM主要用于临时存储数据，而ROM则负责固定数据的存储。</p><h4 id="1-2-3-1-RAM-VS-ROM">1.2.3.1 RAM VS ROM</h4><table><thead><tr><th><strong>特性</strong></th><th><strong>RAM（内存/主存）</strong></th><th><strong>ROM（只读存储器）</strong></th></tr></thead><tbody><tr><td><strong>数据易失性</strong></td><td>断电后数据丢失（易失性）</td><td>断电后数据保留（非易失性）</td></tr><tr><td><strong>读写能力</strong></td><td>可随时读写</td><td>出厂写入，部分类型可擦写（如闪存）</td></tr><tr><td><strong>典型用途</strong></td><td>运行中的程序、临时数据</td><td>BIOS固件、手机系统固件、引导程序</td></tr><tr><td><strong>速度</strong></td><td>极快</td><td>较慢（擦写需特殊操作）</td></tr><tr><td><strong>常见类型</strong></td><td>DDR4/DDR5（电脑）、LPDDR（手机）</td><td>Mask ROM、PROM、EPROM、EEPROM、闪存</td></tr><tr><td><strong>随机访问</strong></td><td>可以</td><td>可以</td></tr></tbody></table><h3 id="1-2-4-按信息的可更改性分类">1.2.4 按信息的可更改性分类</h3><ul><li><strong>读写存储器</strong><ul><li>磁盘、内存、Cache</li></ul></li><li><strong>只读存储器</strong><ul><li>实体音乐专辑采用CD-ROM，实体电影采用蓝光光碟，BIOS通常写在ROM中<br>注：CD-ROM是只读光盘存储器，不属于只读存储器ROM</li></ul></li></ul><h3 id="1-2-5-按信息的可保存性分类">1.2.5 按信息的可保存性分类</h3><ul><li><strong>易失性存储器</strong><ul><li>断电后，存储信息消失【RAM，主存，Cache】</li></ul></li><li><strong>非易失性存储器</strong><ul><li>断电后，信息仍保存【ROM，磁盘，光盘】</li></ul></li><li><strong>破坏性读出</strong><ul><li>信息读出后，原存储信息被破坏【<strong>DRAM</strong> 芯片，读出数据后要进行重写】</li></ul></li><li><strong>非破坏性读出</strong><ul><li>信息读出后，原存储信息不被破坏【SRAM 芯片，磁盘，光盘】</li></ul></li></ul><h2 id="1-3-存储器的性能指标">1.3 存储器的性能指标</h2><h3 id="1-3-1-存储容量">1.3.1 存储容量</h3><ul><li>存储容量 = 存储字数  × 字长 （1 M × 8 bit）</li><li>存储字数表示存储器的地址空间大小【MAR】</li><li>字长表示一次存取操作的数据量【MDR】</li></ul><h3 id="1-3-2-单位成本">1.3.2 单位成本</h3><ul><li>每位价格 = 总成本 / 总容量</li></ul><h3 id="1-3-3-存取速度">1.3.3 存取速度</h3><ul><li><strong>数据传输率</strong> = 数据宽度（即存储字长） / 存取周期</li><li>数据传输率中的 <strong>K, M 是 10 的次方不是 2 的次方，只有存储容量是 2的次方</strong></li><li>存取周期 = 存取时间 + 恢复时间<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409185142007.png" alt="image.png|300"><ul><li>存取时间 $T_a$ ：从启动一次存储器到完成该操作所经历的时间（从存储器读出或写入一次信息所需要的平均时间。）</li><li>存取周期 $T_m$ ：存储器进行一次完整的读写操作所需的全部时间（连续两次访问存储器之间所必需的最短时间间隔）</li><li>主存带宽 $B_m$ （数据传输率 ）：每秒从主存进出信息的最大数量 （单位：字 / 秒）</li></ul></li></ul><p>存取时间≠存取周期，通常存取周期＞存取时间。<br>这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达2倍，因为存储器中的信息读出后需要马上进行再生。</p><h1>2 主存储器</h1><h2 id="2-1-主存储器的基本组成">2.1 主存储器的基本组成</h2><ol><li><p><strong>主存中存放的信息及CPU访问时机</strong><br><strong>(1) 主存存放的信息</strong></p><ul><li>**指令：程序的可执行代码（如机器码、函数指令）。</li><li><strong>数据</strong>：程序运行时需要处理的静态数据、动态变量、堆栈数据等。</li></ul><p><strong>(2) CPU访问主存的时机</strong></p><ol><li>**取指令：<br>CPU从主存中读取下一条待执行的指令（程序计数器PC指向的地址）。</li><li><strong>取数据</strong>：<br>执行指令时，若操作数在主存中（如<code>LOAD [addr]</code>），需读取数据到寄存器。</li><li><strong>存数据</strong>：<br>执行指令时，若需将结果写回主存（如<code>STORE [addr]</code>）。</li></ol></li><li><p><strong>地址译码器的输入、输出与可寻址范围</strong><br><strong>(1) 输入与输出</strong></p><ul><li><strong>输入</strong>：<br>CPU发出的<strong>地址信号</strong>（二进制编码的地址值，如32位或64位地址）。</li><li><strong>输出</strong>：<br><strong>地址驱动信号</strong>（选通信号），每次只有一个存储单元（或存储块）被激活。<ul><li><em>例如</em>：若地址总线为 <code>n</code> 位，译码器将 <code>n</code> 位地址转换为 <code>2^n</code> 个选通信号中的唯一有效信号。</li></ul></li></ul><p><strong>(2) 可寻址范围</strong></p><ul><li><strong>计算公式</strong>：   $\text{可寻址范围} = 0 \sim 2^{\text{地址总线位数}} - 1$</li><li><strong>示例</strong>：<ul><li>若地址总线为36位（按字节编址），则：$\text{可寻址范围} = 0 \sim 2^{36} - 1 = 0 \sim 64\text{GB} - 1$</li></ul></li></ul><h4 id="3-主存地址空间与主存容量的区别"><strong>(3) 主存地址空间与主存容量的区别</strong></h4><ul><li><strong>主存地址空间</strong>：<br>CPU理论上可访问的最大地址范围（由地址总线位数决定），如36位地址总线对应64GB地址空间。</li><li><strong>主存容量</strong>：<br>实际物理安装的内存大小（如16GB），可能远小于地址空间。<ul><li>原因：部分地址空间可能保留给外设、BIOS或未安装物理内存。</li></ul></li></ul><h4 id="4-按字节编址的读写特性"><strong>(4) 按字节编址的读写特性</strong></h4><ul><li><strong>每次读写的最小单位</strong>：1字节（按字节编址）。</li><li><strong>实际读写粒度</strong>：<br>若数据总线为64位（8字节），则每次可读写8个连续字节，但需满足地址对齐（首地址为8的倍数）。<ul><li><em>示例</em>：<br>执行64位数据总线读操作时，若首地址为 <code>0x1000</code>，则读取 <code>0x1000~0x1007</code> 共8字节。</li></ul></li></ul></li><li><p><strong>地址译码器与存储单元的映射示例</strong><br>以简化模型说明（假设地址总线为3位，按字节编址）：</p><ul><li><strong>地址总线位数</strong>：3位 → 可寻址范围 <code>0x000~0x111</code>（共8字节）。</li><li><strong>地址译码器输出</strong>：8条选通线（每条对应一个存储单元）。<ul><li>输入地址 <code>101</code>（二进制） → 选中第5号存储单元（<code>0x101</code>）。</li></ul></li></ul></li></ol><h3 id="2-1-1-基本的半导体元件及原理">2.1.1 基本的半导体元件及原理</h3><p>主存储器：存储体、MAR、MDR<br>存储体用于存放实际的二进制数据<br>一个存储体由多个存储单元构成，每个存储体由多个存储元件构成<br>半导体基本元器件：</p><ul><li>MOS 管，作为通电&quot;开关&quot;，输入电压达到某个阙值时，MOS管就可以接通<ul><li>充电：写数据</li><li>放电：读数据</li></ul></li><li>电容，存储电容（即存储二进制 0/1）<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409193925450.png" alt="image.png"></li></ul><h3 id="2-1-2-存储芯片的结构">2.1.2 存储芯片的结构</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409194347024.png" alt="image.png"></p><ul><li>译码驱动电路：译码器将地址信号转化为字选通线的高低电平</li><li>存储矩阵（存储体）：由多个存储单元构成，每个存储单元又由多个存储元构成</li><li>读写电路：每次读 / 写一个存储字</li><li>读 RD / 写 WR控制线：决定芯片是进行读还是写操作（可能分开两根，也可能只有一根）</li><li>片选线 CS：确定哪个存储芯片被选中，可用于容量扩充</li><li>引脚最低数目：片选线（1）+ 控制线（2）+ 数据线 + 地址线<br>左地址右数据<br><strong>地址复用技术：</strong></li><li>由于<strong>DRAM 芯片</strong>容量大，地址位数多，为了减少地址引脚线，采用地址复用技术</li><li>DRAM 因为分两次发送，长度相同，因此地址线可以复用，线数减少了一半</li><li>引脚数 = 地址线减半 + 数据线不变 + 行通选 (1) + 列通选 (1) + 读写控制线 (2)</li><li>片选线用行通选线替代<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411200512798.png" alt="image.png|450"></li><li>总容量 = 存储单元个数 * 存储字长</li><li>常见的描述：8 K × 8 位，即 $2^{13}×8 bit$ = 8 KB<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240419133619.png" alt="image.png"><br>eg. 某一DRAM芯片，采用地址复用技术，其容量为1024×8位，除电源和接地端外，该芯片的引脚数最少是多少（读写控制线为两根）。  A. 16 B. 17 C. 19 D. 21<br>地址复用技术地址线分两次送入（行地址和列地址共用一套引脚），除电源和接地外，还要加上2根控制线（读/写）<ol><li>需要寻址 1024 个单元 → 所以 <code>2^n = 1024</code> → <code>n = 10</code></li><li>如果<strong>不使用地址复用</strong>，则需要10根地址线；但由于采用<strong>地址复用</strong>，所以这些地址是<strong>分两次输入</strong>的，分别是：5 位行地址 + 5 位列地址，<strong>共用 5 根地址引脚即可</strong></li><li>芯片需要：</li></ol><ul><li>8根数据引脚（因为每次读写是8位）</li><li>5根地址引脚（复用）</li><li>2根控制引脚（如 <code>读/写</code>）</li><li>行地址和列地址分别需要锁存引脚：RAS 和 CAS</li><li>总共17根</li></ul></li></ul><h3 id="2-1-3-寻址方式">2.1.3 寻址方式</h3><ul><li>题目上没有明确指定按字编址，那么就默认是按字节编址【一字节8位】</li><li>32位的计算机中：32位(bit) = 4字节(byte) = 1字(word)</li><li>64位的计算机中：64位(bit) = 8字节(byte) = 1字(word)</li><li>如果计算机中可编程的最小单位是字存储单元，则该计算机称为<strong>按字寻址</strong>的计算机</li><li>如果计算机中可编程的最小单位是字节，则该计算机称为<strong>按字节寻址</strong>的计算机</li><li>一个<strong>机器字可以包含数个字节</strong>，所以<strong>一个存储单元也可以包含数个能够单独编制的字节地址</strong></li><li>按位编址 ：1b</li><li>字节编址 ：1 B=8b</li><li>字编址：机器字长word=32b/64b<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409195727835.png" alt="image.png"><br><strong>题目</strong>：计算机字长（word）为32位，存储容量为16MB，按字节编址和字编制的时候，它的寻址范围分别为多少？</li></ul><ol><li><strong>按字节编址</strong>：<ul><li>已知$1Byte = 8b$，$16MB = 2^{24}B=2^{24}×8b = 2^{27}b$</li><li>寻址范围：$(2^{27}b)÷(8b)=2^{24}b = 16M$。</li></ul></li><li><strong>按字编址</strong>：<ul><li>字长为$32b$。</li><li>寻址范围：$(2^{27}b)÷(32b)=2^{22}b = 4M$。</li></ul></li></ol><h3 id="2-1-4-主存储器的组成部分">2.1.4 主存储器的组成部分</h3><ul><li>数据线的宽度 = MDR 的宽度 = 存储字长</li><li>地址线的宽度 = MAR 的宽度 = 存储字数</li><li>下图总容量 = $2^{36}×64$ 位= $2^{39} B$<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409212258542.png" alt="image.png"></li></ul><h2 id="2-2-2、DRAM-VS-SRAM">2.2 2、DRAM VS SRAM</h2><table><thead><tr><th></th><th>DRAM动态</th><th>SRAM静态</th></tr></thead><tbody><tr><td>主要用途</td><td>主机内存</td><td>高速缓存Cache</td></tr><tr><td>存储信息</td><td>栅极电容</td><td>双稳态触发器</td></tr><tr><td>破坏性读出</td><td>是，读出后应有重写操作，即再生</td><td>非，无需重写</td></tr><tr><td>运行速度</td><td>慢</td><td>快</td></tr><tr><td>集成度</td><td>高（单元面积更小）</td><td>低（单元面积大）</td></tr><tr><td>存储成本</td><td>低</td><td>高</td></tr><tr><td>发热量</td><td>小</td><td>大</td></tr><tr><td>易失/非易失</td><td>易失（断电后信息消失）</td><td>易失（断电后信息消失）</td></tr><tr><td>需要刷新</td><td>需要</td><td>不要</td></tr><tr><td>送行列地址</td><td>分两次送（地址复用技术），地址线减半，引脚数减半</td><td>同时送</td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250409212320486.png" alt="image.png"></td><td></td><td></td></tr></tbody></table><h3 id="2-2-1-DRAM-的刷新">2.2.1 DRAM 的刷新</h3><h4 id="2-2-1-1-刷新的概念">2.2.1.1 刷新的概念</h4><ul><li>DRAM电容的电荷维持时间短，即使电源不断电，信息也会自动消失</li><li>因此每隔一段时间必须刷新，保证被破坏信息恢复，一般取2ms，即<strong>刷新周期</strong>（再生周期）</li><li>DRAM的刷新是以<font color="#ff0000">行</font>为单位的</li><li><strong>刷新时间</strong>：刷新一行花费时间<br>为什么用行列地址？<br>减少选通线的数量</li><li>一次完整的刷新过程只需要<strong>占用一个存储周期（读/写周期）</strong><br>默认存储周期=刷新时间</li><li>刷新由存储器独立完成，不需要CPU控制</li><li>三种方式：<ul><li><strong>集中刷新</strong>：手机长期使用后，在一个固定时刻进行大规模充电；优点是刷新过程简单、批量操作，缺点是会导致一次性较长时间的“停机”（死区）。</li><li><strong>分散刷新</strong>：手机以固定节奏（例如工作 5 分钟充电 5 分钟）不断进行小幅充电；优点是刷新均匀、几乎不影响正常使用，但需要更频繁地暂停片刻。（没有死区）</li><li><strong>异步刷新</strong>：手机根据电量实时情况，在必要时自动充电；优点是更灵活智能，不必固定等待，但充电时点可能不规律，需要智能控制机制协调工作。（有死区）<br>刷新/行数=异步刷新时间间隔<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250410185301610.png" alt="image.png"></li></ul></li></ul><h4 id="2-2-1-2-集中刷新">2.2.1.2 集中刷新</h4><ul><li>在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻<strong>必须停止读 / 写操作</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240420140852.png" alt="image.png|400"><br><strong>刷新过程</strong></li><li>用 <strong>0.5μs ×128=64μs</strong> 的时间对 128 行进行逐行刷新</li><li>由于这 64μs 的时间不能进行读/写操作，故称为<strong>死时间或访存死区</strong></li><li>由于存取周期为 0.5μs，刷新周期为 2 ms，即 <strong>4000 个存取周期</strong><br><strong>为什么刷新与存取不能并行</strong></li><li>因为内存就一套地址译码和片选装置，刷新与存取有相似的过程</li><li>它要选中一行【这期间片选线、地址线、地址译码器全被占用着】</li><li>同理，刷新操作之间也不能并行【意味着一次只能刷一行】’</li></ul><h4 id="2-2-1-3-分散刷新">2.2.1.3 分散刷新</h4><ul><li>是指对每行存储单元的刷新分散到每个存取周期内完成</li><li>其中，把机器的存取周期tc分成两段，<strong>前半段tM</strong>用来读 / 写或维持信息，<strong>后半段tR</strong>用来刷新<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240420141316.png" alt="image.png|400"><br><strong>刷新过程</strong></li><li>在每个存取操作后绑定一个刷新操作，延长了存取周期</li><li>这样存取周期就成了 <strong>0.5μs + 0.5μs =1μs</strong></li><li>但是由于与存取操作绑定，就不需要专门给出一段时间来刷新了</li><li>这样，每有 128 个读取操作，就会把 0-127 行全部刷新一遍</li><li>故每隔 128μs 就可将存储芯片全部刷新一遍【即<strong>刷新周期是 1μs×128=128μs</strong> 远短于 2 ms】</li><li>而且<strong>不存在停止读 / 写的死时间</strong>，但是<strong>存取周期长了，整个系统速度降低了</strong></li><li>分散刷新的刷新周期 128μs ，其实不需要这么频繁，会导致浪费</li></ul><h4 id="2-2-1-4-4）异步刷新">2.2.1.4 4）异步刷新</h4><ul><li>既可以<strong>缩短“死时间”</strong>【仍然存在死时间】，又充分利用最大刷新间隔为2ms的特点<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240420141719.png" alt="image.png|400"><br><strong>刷新过程</strong></li><li>具体操作为：在 2 ms 内对 128 行各刷新一遍</li><li>即<strong>每隔 15.6μs 刷新一行 (2000μs/128≈15.6μs)</strong>，而<strong>每行刷新的时间仍为 0.5μs</strong></li><li>这样，刷新一行只能停止一个存取周期</li><li>但对每行来说，<strong>刷新间隔时间仍为 2 ms，而死时间为 0.5μs</strong></li><li>相对每一段来说，是集中式刷新，相对整体来说，是分散式刷新<br><strong>特点</strong></li><li>将 DRAM 的刷新安排在 CPU 对指令的译码阶段，这个阶段 CPU 不访问存储器</li><li>既克服了分散刷新需独占 0.5μs 用于刷新，使存取周期加长且降低系统速度的缺点</li><li>异步刷新相比于集中刷新没有降低死时间占总时间的占比，但是死时间不在聚集分布，因此死时间可以认为是0.5us，相比于集中刷新的64μs有了很大的进步。(相较于刷新次数没有降低)</li><li>又不会出现集中刷新的访存“死区”问题</li><li>从根本上提高了整机的工作效率<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250410190834713.png" alt="image.png"></li></ul><h2 id="2-3-3、只读存储器-ROM">2.3 3、只读存储器 ROM</h2><h3 id="2-3-1-ROM-的特点">2.3.1 ROM 的特点</h3><ul><li>结构简单，位密度比可读写存储器高</li><li>具有非易失性，可靠性高</li></ul><h3 id="2-3-2-ROM-的类型">2.3.2 ROM 的类型</h3><h4 id="2-3-2-1-掩模式只读存储器-MROM">2.3.2.1 掩模式只读存储器 MROM</h4><ul><li>内容由厂家在生产过程中直接写入，<font color="#ff0000">任何人不可重写</font>（只读）</li><li>可靠性高，集成度高，生产周期长，只适合批量定制，价格便宜但灵活性差</li></ul><h4 id="2-3-2-2-一次可编程只读存储器-PROM">2.3.2.2 一次可编程只读存储器 PROM</h4><ul><li>用户可用专门的PROM写入器实现一次性编程</li><li><font color="#ff0000">一次写入后不可更改</font></li></ul><h4 id="2-3-2-3-可擦除可编程只读存储器-EPROM">2.3.2.3 可擦除可编程只读存储器 EPROM</h4><ul><li>用于用户实现多次性编程</li><li>可<strong>多次重写</strong>，但次数有限，写入时间过长</li><li>分类：<ul><li>UVEPROM：用紫外线照射8~20min，擦除<font color="#ff0000">所有</font>信息</li><li>EEPROM：可用电擦除方式，擦除<font color="#ff0000">特定的字</font></li></ul></li></ul><h4 id="2-3-2-4-Flash-闪速存储器">2.3.2.4 Flash 闪速存储器</h4><ul><li>既可在<strong>不加电</strong>的情况下长期保存信息，又能在线进行快速擦除和重写，可进行<font color="#ff0000">多次快速擦除重写</font></li><li>需要先擦除后写入，<strong>写速度 &lt; 读速度</strong></li><li>每个存储元只需要单个 MOS 管，位密度比 RAM 高</li><li>U盘、SD卡就是闪存</li><li>价格便宜，集成度高，电可擦除重写且擦除重写速度快</li></ul><h4 id="2-3-2-5-固态硬盘-SSD">2.3.2.5 固态硬盘 SSD</h4><ul><li><strong>SSD 是基于闪存的硬盘</strong>，是一种非易失性存储器，采用<font color="#ff0000">随机访问</font>方式</li><li>由控制单元 + 存储单元（Flash 芯片）组成，与闪存的区别在于控制单元的不一样，但存储介质都类似</li><li>可长期保存信息，<font color="#ff0000">多次快速擦除和重写</font></li><li>相比传统硬盘也有读写速度快、低功耗的特性，但价格较高</li></ul><p>PROM和MROM只读</p><h3 id="2-3-3-重要的ROM">2.3.3 重要的ROM</h3><p>CPU：由运算器和控制器组成，其任务是到主存中取指令并执行指令。<br>主存（RAM，<font color="#ff0000">随机存取存储器</font>）：用于存储指令和数据，但断电后，RAM 内数据全部丢失。<br>辅存：操作系统安装在辅存中，常见的辅存如硬盘<br>主板上的 <strong>BIOS</strong> 芯片属于 ROM，存储了 “自举装入程序” ，负责引导装入操作系统，即计算机开机时的启动引导工作。<br>因计算机的操作系统保存于硬盘上，所以需要BIOS 的引导程序将操作系统引导到主存(RAM)中，而引导程序则固化于 ROM 中。所以内存储器应采用RAM和ROM</p><h2 id="2-4-4、多模块存储器">2.4 4、多模块存储器</h2><h3 id="2-4-1-概念">2.4.1 概念</h3><p>一种<strong>空间并行技术</strong>，利用多个结构完全相同的存储模块的并行工作来<strong>提高存储器的吞吐率</strong></p><h3 id="2-4-2-单体并行存储器">2.4.2 单体并行存储器</h3><ul><li><strong>定义</strong>：存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽也为 m 个字，地址必须顺序排列并处于同一存储单元</li><li>主要解决<strong>访存速度</strong>问题，没有解决主存容量太小问题</li><li><strong>过程</strong>：在一个存取周期（存取周期T=存取时间r+恢复时间）内，从同一地址取出 m 条指令，然后将指令逐条送至 CPU</li><li><strong>缺点</strong>：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240420144318.png" alt="image.png"></li></ul><h3 id="2-4-3-多体并行存储器">2.4.3 多体并行存储器</h3><p>由多体模块组成，每块都有相同容量和读取速度，各模块都有<strong>独立的读写控制电路</strong>、<strong>MAR 和 MDR</strong>，既能<strong>并行工作也能交叉工作</strong></p><h4 id="2-4-3-1-高位交叉编址（顺序方式）【竖】">2.4.3.1 高位交叉编址（顺序方式）【竖】</h4><ul><li><strong>特点</strong>：先在一个模块内访问，等到该模块访问完之后才转到下一个模块访问。<br>理论上多个存储体可以被并行访问，但是由于通常会连续访问【相当于扩容】</li><li><strong>编号</strong>：高位地址表示<strong>体号【模块号】</strong>，低位地址表示<strong>体内地址</strong></li><li><strong>优点</strong>：<ul><li>某个模块进行存取时，其它模块不工作</li><li>某一模块出现故障时，其它模块可以照常工作</li><li>通过增添模块来扩充存储器容量比较方便</li></ul></li><li><strong>缺点</strong>：各模块串行工作，存储器的带宽受到了限制，并<strong>不能提高吞吐量</strong><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250410194153119.png" alt="image.png|400"></li></ul><h4 id="2-4-3-2-低位交叉编址（交叉方式）【横】">2.4.3.2 低位交叉编址（交叉方式）【横】</h4><ul><li><p><strong>特点</strong>：</p><ul><li>连续地址分布在相邻的不同模块内，同一模块内的地址是<strong>不连续</strong>的</li><li>地位交叉编制是交叉存放的，满足程序的<strong>局部性原理</strong></li><li>提速，适合频繁访问连续数据</li></ul></li><li><p><strong>编号</strong>：高位地址表示<strong>体内地址</strong>，低位地址表示<strong>体号【模块号】</strong></p></li><li><p><strong>优点</strong>：对连续字的成块传送可实现多模块并行存取，<strong>提高了存储器的带宽</strong></p></li><li><p><strong>计算</strong>：每个模块按“模 m”交叉编址，<strong>模块号 = 单元地址 % m</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250410194228767.png" alt="image.png|400"></p></li><li><p><strong>启动方式</strong>：</p><ul><li><p><strong>轮流启动方式</strong>：</p><ul><li>设模块字长等于数据总线宽度，模块<font color="#ff0000">存取周期</font>为 T，<font color="#ff0000">总线周期为 r</font>  m ≥ T / r</li><li><strong>存储器交叉模块的数目最小为 m = T / r</strong>（流水线不间断）</li><li>每个存储周期内可读写地址连续的m个字</li><li>每隔 1/m 个存取周期轮流启动各模块，则每隔 1/m 个存取周期就可读出或写入一个数据，<strong>存取速度提高 m 倍</strong></li><li>当模块数目不小于 m 时，就可以保证 T 时间之后再启动该模块，上次的存取操作已经完成，流水线就不会断</li><li>**连续存取 m 个字的时间为 T + (m - 1) r</li><li><strong>判断发送访问冲突的规则</strong>：给定的访存地址在相邻的四次访问中出现在同一个存储模块中【m=4 时】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240420150628.png" alt="image.png"></li></ul></li><li><p><strong>同时启动方式</strong>：</p><ul><li>所有模块一次并行读 / 写的总位数正好等于数据总线位数</li><li>同时启动所有模块进行读 / 写</li></ul></li></ul></li><li><p><strong>计算带宽</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240420145345.png" alt="image.png"></p></li></ul><h2 id="2-5-5、主存储器与-CPU-的连接">2.5 5、主存储器与 CPU 的连接</h2><h3 id="2-5-1-连接原理">2.5.1 连接原理</h3><ul><li>主存储器通过数据总线、地址总线和控制总线与 CPU 连接</li><li>数据总线的位数与工作频率的乘积正比于数据传输速率</li><li><strong>地址总线的位数</strong>决定了可寻址的<strong>最大内存空间</strong></li><li>控制总线（读 / 写）指出总线周期的类型和本次输入 / 输出操作完成的时刻</li><li>CPU 读指令，通过地址线去访问存储器的 MAR（地址寄存器）</li><li>MAR（地址寄存器）通过选通线去访问矩阵中的数据</li><li>矩阵需要通过数据线与 MDR（数据寄存器）进行接发<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412181836220.png" alt="image.png|300"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412182238747.png" alt="image.png"></li></ul><h3 id="2-5-2-主存容量的扩展">2.5.2 主存容量的扩展</h3><h4 id="2-5-2-1-位扩展法">2.5.2.1 位扩展法</h4><ul><li>$8 K* 8 位$ 的存储器 = 8片 $8 K*1 位$ 的 RAM 组成</li><li>地址线并行，数据线一一接上<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412182724821.png" alt="image.png"></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412182755722.png" alt="image.png"></p><h4 id="2-5-2-2-字扩展法">2.5.2.2 字扩展法</h4><ol><li><p><strong>线选法</strong></p><ul><li>$16 K * 8 位$的存储器 = 2片 $8 K*8 位$的存储器</li><li>地址线是 $A_0$~$A_{12}$ 共 13 位，译码线是 $A_{13}$ 和 $A_{14}$ 共 2 位</li><li>由片选信号来区分各芯片的地址范围</li><li>当 $A_{13}$ 为 1 时，第一块工作，$A_{14}$ 的 CS 必须为 0</li><li>谁工作，数据线就接送谁的数据，即将 CS 设置为 1</li><li>2 位二进制时：只能利用 01，10。n条线对应n个片选信号</li><li>优点：不需要地址译码器，线路简单</li><li>缺点：地址空间不连续，选片的地址线必须分别为低电平（否则不能工作）不能充分利用系统的存储空间，造成地址资源的浪费<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412184217668.png" alt="image.png"></li></ul></li><li><p><strong>译码片实现</strong></p><ul><li>用除片内寻址外的高位地址线通过地址译码器产生片选信号</li><li>有 4 块芯片，不需要 4 条线而只需要两条</li><li>地址线是 $A_0$~$A_{12}$ 共 13 位，译码线是 $A_{13}$ 和 $A_{14}$ 共 2 位</li><li>2 位二进制时：可以利用 00，01，10，11</li><li>【译码器】一个二进制转十进制的物理元件，将左边三根地址线表示的二进制意义映射到右边十进制的选通线<br>1-2译码器：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412183536010.png" alt="image.png">2-4译码器：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412183855794.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412185116645.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412185440908.png" alt="image.png"></li></ul></li></ol><table><thead><tr><th></th><th>线选法</th><th>译码片选法</th></tr></thead><tbody><tr><td>选片信号数量</td><td>n条线→n个选片信号</td><td>n条线→2^n个选片信号</td></tr><tr><td>电路复杂度</td><td>电路简单</td><td>电路复杂</td></tr><tr><td>地址空间特性</td><td>地址空间<strong>不连续</strong></td><td>地址空间<strong>可连续</strong>，可以增加逻辑设计</td></tr></tbody></table><h4 id="2-5-2-3-字位同时扩展法">2.5.2.3 字位同时扩展法</h4><ul><li>一块芯片只有 4 位，因此通过 2 片叠加先实现位拓展</li><li>等价于实现了一个 8 位的存储芯片</li><li>再通过译码片选的方式实现字拓展</li><li>在不同的地址线中选择不同的芯片组合进行工作<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412184709726.png" alt="image.png"></li></ul><h1>3 外部存储器</h1><h2 id="3-1-1、磁盘存储器">3.1 1、磁盘存储器</h2><p>计算机的外存储器又称为<strong>辅助存储器</strong>，目前主要使用<strong>磁表面存储器</strong>。<br>所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。<br>如图所示，最下面的为磁带，在磁带移动的过程中，给&quot;写线圈&quot;的一端，加上两种方向的电流，能够使磁层产生两种状态，这两种状态分别为0和1。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412200829046.png" alt="image.png|300">而对于&quot;<strong>读线圈</strong>&quot;，在磁带运动的过程中，会产生两种不同的磁场，从而使&quot;读线圈&quot;一端，产生两个方向的电流，分别代表0和1。<br>所以磁带划过磁头下方时，磁头就能<strong>以1bit为单位</strong>往其中写数据，读线圈同理，以1bit为单位读数据。<br>若主机给磁盘传送了8bit数据，那么会将数据并行的传送到磁盘，由于磁盘的读/写数据以1bit为单位，所以还需将并行的数据转化为串行的数据写入。<br>同理，主机从磁盘读数据，数据是以1bit为单位读出的，若主机接收的是并行的数据，那么需要将串行数据转化为并行数据，传给主机。</p><p><strong>注：读/写两个操作是不能同时进行的</strong></p><blockquote><p>磁表面存储器的<strong>优点</strong>：<br>①存储容量大，位价格低;<br>②)记录介质可以重复使用;<br>③记录信息可以长期保存而不丢失，甚至可以脱机存档;<br><strong>④非破坏性读出，读出时不需要再生</strong>。</p><p>磁表面存储器的<strong>缺点</strong>：<br>①存取速度慢;<br>②)机械结构复杂;<br>③对工作环境要求较高。</p></blockquote><p><strong>外存储器既可以作为输入设备，也可以作为输出设备（既可以存数据，也可以读数据）</strong></p><h3 id="3-1-1-磁盘设备的组成">3.1.1 磁盘设备的组成</h3><p>驱动轴中有一个马达，会带动驱动轴旋转，进而带动盘片旋转，磁盘设备有很多盘片，每个盘片的表层会涂上磁性材质，磁性材质是一圈一圈地涂的，当需要读取某一圈的磁性材质时，就需要将磁头臂移动到这一圈上。由于盘片旋转，这一圈的磁性材质都会划过磁头下方</p><ol><li><strong>存储区域</strong>：<br>一块硬盘含有若干个<strong>记录面</strong>，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，<strong>扇区</strong>(也称块)是磁盘读写的<font color="#ff0000">最小单位</font>，也就是说磁盘按块存取。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412201450993.png" alt="image.png"></li><li><strong>磁盘存储器</strong>：<br><strong>磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。</strong></li></ol><blockquote><p><strong>磁盘驱动器</strong>：核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动头固定盘片的硬盘存储器。</p><p><strong>磁盘控制器</strong>：是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</p></blockquote><p>注：一个磁盘的正面和反面都可以涂上磁性材质， 那么其磁盘的结构如下图所示，磁头臂会有上下两个磁头：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412201807928.png" alt="image.png|250"></p><h3 id="3-1-2-磁盘的性能指标">3.1.2 磁盘的性能指标</h3><ol><li><p><strong>磁盘的容量</strong>：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有<strong>非格式化</strong>容量和<strong>格式化容量</strong>之分。</p><blockquote><p><strong>非格式化容量</strong>是指磁记录表面可以利用的磁化单元总数。磁盘物理上可以存储的2进制bit的上限。</p><p><strong>格式化容量</strong>是指按照某种特定的记录格式所能存储信息的总量。例如某些磁盘扇区会损坏，为了防止某个扇区损坏导致整个磁盘无法工作。因此需要对磁盘进行格式化，例如留下某些备用扇区作为替换，某扇区A损坏，则使用备份扇区B替换。</p><p>注：在磁盘的格式化过程中，要对磁盘划分扇区，每个扇区要写入一些控制信息，扇区尾部还要留有一定的空隙，这些均需占用一些存储空间，因此导致<strong>格式化后的实际容量 &lt; 非格式化的容量</strong></p></blockquote></li><li><p><strong>记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。</p><blockquote><p><strong>道密度</strong>是沿磁盘半径方向单位长度上的磁道数；</p><p><strong>位密度</strong>是磁道单位长度上能记录的二进制代码位数；若题目给出磁道或扇区的长度，若再知道位密度，就能知道某磁道或某扇区能够存储多少bit数据。</p></blockquote></li></ol><blockquote><p><strong>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。所以越内侧的磁道位密度越大。</strong><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412202500707.png" alt="image.png|200"><br>所以一个磁盘的存储性能很多时候会受到<strong>最内侧</strong>磁道制约，因为最内侧磁道很短，可以存储的数据一定有上限。所以<strong>最内侧磁道的位密度会影响磁盘的整体容量</strong>。</p><p><strong>面密度</strong>=位密度×道密度</p></blockquote><ol start="3"><li><strong>平均存取时间</strong>：常考<br>$\begin{aligned}平均存取时间&amp;= 寻道时间(磁头移动到目的磁道)\&amp;+ 旋转延迟时间(磁头定位到所在扇区)\&amp;+ 传输时间(传输数据所花费的时间)\end{aligned}$<blockquote><p>若要读写某一个扇区，先将磁头臂移动到扇区所在位置（<strong>寻道</strong>），继续旋转，使要读写的扇区划到磁头臂的下方（<strong>旋转</strong>），继续旋转，让整个扇区划过磁头臂（<strong>传输</strong>）</p></blockquote></li></ol><blockquote><p>若题目中未给出<strong>旋转延迟时间</strong>，那么就默认为<strong>磁盘转半圈所需时间</strong></p><p>注：有的题目会加上<strong>磁盘控制器的延迟时间</strong>，即磁盘电子部件接收主机的命令，并且对磁盘驱动器机械部分发出控制信号所需要的延迟时间<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412203045767.png" alt="image.png"></p></blockquote><ol start="4"><li><strong>数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。<blockquote><p>假设磁盘转数r(转/秒)，每条磁道容量为N个字节,则数据传输率为$D_{r}=rN$</p></blockquote></li></ol><h3 id="3-1-3-磁盘地址">3.1.3 磁盘地址</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412203530642.png" alt="image.png"><br><strong>所以磁盘扇区中不止包含数据，还包含地址，校验等信息。</strong></p><h3 id="3-1-4-硬盘的工作过程">3.1.4 硬盘的工作过程</h3><p>硬盘的主要操作是<strong>寻址</strong>、<strong>读盘</strong>、<strong>写盘</strong>，每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。<br>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p><h3 id="3-1-5-磁盘阵列">3.1.5 磁盘阵列</h3><p>RAID(Redundant Array ofInexpensive Disks，廉价冗余磁盘阵列)是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、<strong>并行访问，具有更好的存储性能、可靠性和安全性。</strong></p><blockquote><p>RAID的分级如下所示。在RAID1~RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。</p><p>RAID0:<strong>无冗余和无校验</strong>的磁盘阵列。【无容错能力】<br>RAID1:<strong>镜像</strong>磁盘阵列。                     【有容错能力，容量减少一半】<br>RAID2:采用<strong>纠错</strong>的<strong>海明码</strong>的磁盘阵列。<br>RAID3:位交叉奇偶校验的磁盘阵列。<br>RAID4:块交叉奇偶校验的磁盘阵列。<br>RAID5:无独立校验的奇偶校验磁盘阵列。</p><p><strong>从上至下，磁盘阵列的安全性和可靠性越高。</strong></p><p><strong>对于RAID0</strong>：<u>逻辑上相邻的两个扇区在物理上存到两个磁盘</u>，类比“<strong>低位交叉编址的多体存储器</strong>”。 <img src="https://i-blog.csdnimg.cn/blog_migrate/820fadde5482f905721616b288eb1545.png" alt="|150"><br>如图所示，将逻辑上相邻的数据块，物理上通过RAID0相关软件的处理，存储在不同物理盘上，这样能使整个磁盘的读写速度增快。 <img src="https://i-blog.csdnimg.cn/blog_migrate/237009d0808e1aa40db23f5bded55bef.png" alt=""><br>因为没有存储冗余的信息，所以当某个扇区损坏后，无法恢复数据，RAID0也不包含校验功能。</p><p><strong>对于RAID1</strong>：会存储两份数据。若其中一个磁盘某些扇区损坏或者整个磁盘损坏，也可以在第二个磁盘中找到相应数据，同时可以对比两个磁盘的数据是否一致，来判断是否发生数据错误。所以RAID1可以冗余存储，也有校验功能。但是可以看到两个磁盘当一个磁盘使用，存储空间利用率为50%<img src="https://i-blog.csdnimg.cn/blog_migrate/938c43ef54e0945c0925f04b6394673b.png" alt="|150"></p><p><strong>对于RAID2</strong>：逻辑上连续的几个bit物理上分散存储在各个盘中<strong>4bit信息位+3bit海明校验位</strong>—<font color="#ff0000">可纠正一位错，发现两位错</font>。<br>因为使用了海明码，若丢失了1bit数据，依然可以使用海明码恢复数据。<img src="https://i-blog.csdnimg.cn/blog_migrate/265668113386037209eff14e4a540e7c.png" alt="|250"><br><strong>越靠后，冗余的占比会越少，磁盘的利用率会越来越高，可靠性和安全性越高，成本越廉价，同时会通过数据校验的设计，提高容错率。</strong></p><p>RAID通过同时使用多个磁盘，提高了<strong>传输率</strong>；通过在多个磁盘上<strong>并行</strong>存取来大幅提高存储系统的<strong>数据吞吐量</strong>：通过<strong>镜像</strong>功能，可以提高<strong>安全可靠性</strong>；通过<strong>数据校验</strong>，可以提供<strong>容错</strong>能力。</p></blockquote><h2 id="3-2-2、固态硬盘-SSD">3.2 2、固态硬盘 SSD</h2><h3 id="3-2-1-原理">3.2.1 原理</h3><ul><li>基于<strong>闪存技术</strong> Flash Memory，属于电可擦除 ROM，即 <strong>EEPROM</strong></li></ul><h3 id="3-2-2-组成">3.2.2 组成</h3><ul><li><strong>闪存翻译层</strong>：负责翻译逻辑块号，找到对应<strong>页</strong></li><li><strong>存储介质</strong>：多个<strong>闪存芯片</strong>，每个芯片包含多个<strong>块</strong>，每个块包含多个<strong>页</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421142222.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412210311196.png" alt="image.png"></li></ul><table><thead><tr><th><strong>传统磁盘（HDD）</strong></th><th><strong>固态硬盘（SSD）</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>扇区（Sector）</strong></td><td><strong>页（Page）</strong></td><td><strong>最小读写单元</strong>：磁盘读写以扇区为单位（512B/4K），SSD读写以页为单位（4K~16K）。</td></tr><tr><td><strong>磁道（Track）</strong></td><td><strong>块（Block）</strong></td><td><strong>物理管理单元</strong>：磁道是磁盘上的环形路径，SSD块是多个页的集合（如256页），是擦除的最小单元。</td></tr><tr><td><strong>柱面（Cylinder）</strong></td><td><strong>通道（Channel）</strong></td><td><strong>并行访问单元</strong>：柱面是多个盘片的同一磁道，SSD通道是独立操作的NAND芯片组，支持并行读写。</td></tr></tbody></table><h3 id="3-2-3-读写性能特性">3.2.3 读写性能特性</h3><ul><li>以<font color="#ff0000">页</font>为单位<strong>读 / 写</strong>：相当于磁盘的“扇区”</li><li>以<font color="#ff0000">块</font>为单位“<strong>擦除</strong>”：擦干净的块，其中的每页都可以写一次，读无限次</li><li>支持<strong>随机访问</strong>：系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li><li><strong>读快，写慢</strong>：要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的块）中，再写入新的页</li></ul><h3 id="3-2-4-与机械硬盘相比的特点">3.2.4 与机械硬盘相比的特点</h3><ul><li>SSD 读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li><li>SSD 安静无噪音、耐摔抗震、能耗低、造价更贵</li><li>SSD 的一个“块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</li></ul><h3 id="3-2-5-磨损均衡技术">3.2.5 磨损均衡技术</h3><ul><li>思想：将“擦除”平均分在各个块上，以提升使用寿命</li><li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块</li><li>静态磨损均衡：SSD 检测并自动进行数据分配、迁移，让<strong>老旧的闪存块</strong>承担以<strong>读为主</strong>的存储任务，让<strong>较新的闪存块</strong>承担更多的<strong>写任务</strong></li></ul><h3 id="3-2-6-磁盘-VS-固态硬盘">3.2.6 磁盘 VS 固态硬盘</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>磁盘（HDD）</strong></th><th><strong>固态硬盘（SSD）</strong></th></tr></thead><tbody><tr><td><strong>读写单位</strong></td><td>扇区（512B/4K）</td><td>页（4K~16K）</td></tr><tr><td><strong>擦除单位</strong></td><td>无需擦除（覆盖写入）</td><td>块（多个页的集合，如256页）</td></tr><tr><td><strong>随机访问性能</strong></td><td>受磁头寻道时间限制（毫秒级）</td><td>支持，无机械延迟（微秒级）</td></tr><tr><td><strong>写入放大问题</strong></td><td>无</td><td>存在（需整块擦除后再写入新页）</td></tr><tr><td><strong>寿命管理</strong></td><td>无磨损均衡需求</td><td>依赖FTL进行磨损均衡（动态映射逻辑页到物理页）</td></tr></tbody></table><h1>4 高速缓存存储器</h1><h2 id="4-1-1、Cache-的基本原理">4.1 1、Cache 的基本原理</h2><h3 id="4-1-1-基本概念">4.1.1 基本概念</h3><ul><li>高速缓冲存储器就是存在于主存与 CPU 之间的一级存储器，有了它 CPU 可以直接对其存取数据，从而减少了时间，提高了系统的运行速度</li><li><strong>CPU 与 Cache / 主存</strong>的信息交互单位为<font color="#ff0000">字</font>，<strong>Cache 与主存</strong>的信息交互单位为<font color="#ff0000">块</font></li><li><strong>一个块通常由若干字组成</strong></li><li>Cache 利用了<strong>局部性</strong>原理：将程序中正在使用的部分存在在容量较小但速度更快的 Cache 中</li></ul><h3 id="4-1-2-局部性原理">4.1.2 局部性原理</h3><ul><li><strong>时间局部性</strong>：<ul><li>在最近的未来要用到的信息，很可能是现在正在使用的信息（指令和数据）</li><li>例如<strong>循环</strong></li></ul></li><li><strong>空间局部性</strong>：<ul><li>在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的</li><li>例如对<strong>数组</strong>的访问，如果数组按行存的，则先行再列的访问方式空间局部性更好</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumvec</span><span class="params">(<span class="type">int</span> v[N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        sum += v[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i</code>和<code>sum</code>时间局部性，<code>v[N]</code>空间局部性</p><ul><li>重复引用相同变量的程序，具有良好的时间局部性。</li><li>具有步长的程序，步长越小，空间局部性越好。</li><li>在内存中以大步长跳来跳去的程序，空间局部很差。</li><li>取指令时循环操作，具有好的时间和空间局部性循环体越小，循环迭代次数越多，其局部性越好。</li><li>良好局部性的程序比局部性差的程序，运行得更快。</li></ul><h3 id="4-1-3-读写过程">4.1.3 读写过程</h3><ol><li>CPU、Cache、和主存三者的读写关系<ul><li>Cache 会从主存中一并读取目标数据以及附近空间的数据<br>【通常以块为单元取出】【速度如图需要 1000 ns】</li><li>CPU 要取数据会优先从 Cache 中读取，因为速度快<br>【速度如图 5 ns】</li><li>CPU 计算完后，会把数据再次返回给 Cache<br>【速度也是 5 ns】<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413194435991.png" alt="image.png|300"></li></ul></li><li>整个过程全部由<strong>硬件实现</strong></li></ol><h3 id="4-1-4-性能分析">4.1.4 性能分析</h3><p>设 $t_c$ 为访问一次 Cache 所需的时0间，$t_m$ 为访问一次主存所需的时间</p><ul><li><p><strong>Cache 命中率 H</strong> =  $\frac{Cache 的总命中次数}{Cache 的总命中次数+访问主存的总次数}$</p></li><li><p><strong>缺失（未命中）率 M</strong> = 1 - H</p></li><li><p>Cache - 主存系统的<strong>平均访问时间 t</strong></p><ul><li><strong>先访问 Cache，未命中再访问主存</strong>：$t=Ht_c+(1-H)(t_c+t_m)$</li><li><strong>同时访问 Cache 和主存，若Cache命中则立即停止访问主存</strong>：$t=Ht_c+(1-H)t_m$</li></ul></li><li><p><strong>系统平均访问时间</strong> = $命中的概率<em>命中所需要花费的时间+缺失的概率</em>平均访存次数*一次总线读突发总线事务所需时间$ 【13 年统考大题】</p></li><li><p><strong>性能效率</strong> = $\frac{访问 Cache 的时间}{系统平均访问时间}$</p></li></ul><p>eg.假设 Cache 的速度是主存的 5 倍，且 Cache 的命中率为 95%，则采用 Cache 后，存储器性能提高多少（设 Cache 和主存同时被访问，若 Cache 命中则中断访问主存）</p><ol><li><strong>设周期</strong>：设 Cache 的存取周期为t，则主存的存取周期为5t。</li><li><strong>Cache 和主存同时访问情况</strong><ul><li>命中时访问时间为t，未命中时访问时间为5t。</li><li>平均访问时间为0.95×t+0.05×5t=1.2t。</li><li>性能为原来的5t/1.2t​≈4.17倍。</li></ul></li><li><strong>先访问 Cache 再访问主存情况</strong><ul><li>命中时访问时间为t，未命中时访问时间为t+5t。</li><li>平均访问时间为Ta​=0.95×t+0.05×6t=1.25t。</li><li>性能为原来的5t/1.25t​=4倍。</li></ul></li></ol><h3 id="4-1-5-要解决的关键问题">4.1.5 要解决的关键问题</h3><ul><li><strong>地址映射</strong>：主存块如何存放在 Cache 中，如何将主存地址转换为 Cache 地址</li><li><strong>替换策略</strong>：Cache 满后，使用何种策略对 Cache 块进行替换或淘汰</li><li><strong>写入 / 更新策略</strong>：CPU修改了Cache中的数据副本，如何既保证主存块和 Cache 块的数据一致性，又尽量提升效率<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413202441485.png" alt="image.png">注：</li><li>操作系统中，通常将主存中的一个”块”也称为“一个页/页面/页框”Cache中的“块”也称为“行”</li><li>每次被访问的主存块，一定会被立即调入Cache</li></ul><h2 id="4-2-2、Cache-主存映射方式">4.2 2、Cache-主存映射方式</h2><ul><li><p><strong>按字节编址</strong>：1单元 = 1字节<br>例：主存容量为512KB，块大小为64字节 → 块内地址占6位（26=6426=64）。</p></li><li><p><strong>按字编址</strong>：1单元 = 1字（字长由题目定义）<br>例：主存容量为512K×16位（每个字16位），块大小为4字 → 块内地址占2位（22=422=4）。</p></li><li><p><strong>主存与Cache的传送单位是块</strong><br>每次数据交换以块为单位（如64字节），而非单个字。</p></li><li><p><strong>块大小的选择</strong><br>块越大，局部性利用越好，但Cache行数减少，可能增加冲突概率。<br>注：主存块大小指的是块内地址2^n，占n位<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250415183423084.png" alt="image.png|300"></p></li></ul><h3 id="4-2-1-全相联映射（随便放）">4.2.1 全相联映射（随便放）</h3><ul><li>只规定了主存需要映射到 Cache 中</li><li>没有规定它映射到 Cache 中的哪一个位置</li><li>通常使用按内容访问的<strong>相联存储器</strong>进行地址映射</li><li>主存地址=标记位（整个主存块号）+块内地址</li><li>Cache总容量=行数×(Tag位+有效位+脏位（回写时需加）+数据块大小)<br>回写有脏位1，采用LRU和LFU时有替换位log2n（n为组相联中每组的块数）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413203854822.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413204112143.png" alt="image.png"><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421145924.png" alt="image.png|400"><br><strong>优点</strong></li><li>映射灵活</li><li>块冲突概率比较低</li><li>空间利用率也高<br><strong>缺点</strong></li><li>成本高</li><li>查找标记最慢，有可能需要对比所有行的标记，速度慢耗时多</li></ul><h3 id="4-2-2-直接映射（位置固定）">4.2.2 直接映射（位置固定）</h3><ul><li><p>规定好了主存中每一块都放置在 Cache 中的哪个地方</p></li><li><p>相邻块之间映射的位置也是相邻的</p></li><li><p>因为主存的容量肯定比 Cache 大得多，所以其实它相当于一轮轮映射过去</p></li><li><p><strong>主存地址位数 = 标记位位数 + Cache行号位数 + 块内地址位数</strong></p></li><li><p>Cache总容量=行数×(标签位+有效位+脏位+数据块大小)<br>eg.主存地址32位，Cache行数256（行号占8位），块大小64字节（块内地址占6位）→ 标记位占 32−8−6=18位，Cache总容量=(64×8bit+1+18)×256bit</p></li><li><p>Cache行号=主存块号%Cache总行数<br>主存块号的低c位即为对应的Cache块号<br>Cache有64行（c=6），主存块号 <code>0x1234</code> 对应的行号为 <code>0x34</code>（取低6位）。</p></li><li><p>主存块大小→块内地址位数</p></li><li><p>Cache行数（Cache块/行号）→Cache数据总大小/主存地址</p></li><li><p>Tag位=主存地址-Cahce行号-主存块大小=主存容量/Cache容量</p></li><li><p>Cache行数据大小=主存块大小×每个字多少位<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413211625320.png" alt="image.png"><br><strong>直接映射地址变换方法</strong>：</p></li><li><p><strong>主存地址结构</strong>：主存地址由m位组成，分为主存块标记（t位）、Cache 块号（c位）、块内地址（b位）。</p></li><li><p><strong>变换流程</strong></p><ul><li>CPU 送来主存地址和读 / 写命令后，只需根据中间c位字段找到 Cache 存储器字块。</li><li>然后查看其标记是否与主存地址高t位符合：<ul><li>如果符合，且有效位为 “1”，根据b位块内地址，从 Cache 中取得所需指令或数据。</li><li>如果不符合，或有效位为 “0”，从主存读入新的字块来替换旧的字块，并将 CPU 所需数据送往 CPU，同时修改 Cache 标记。假如原来有效位为 “0”，还要将有效位改置成 “1”。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413204902130.png" alt="image.png"><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421151107.png" alt="image.png|400"></li></ul></li></ul></li><li><p><strong>主存地址长度</strong>：主存中存储单元个数为 $2^{10}$， 则主存地址长度就是10</p></li><li><p><strong>Cache 地址长度</strong>：Cache 中存储单元个数为 $2^{10}$， 则 Cache 地址长度就是10</p></li><li><p><strong>Cache 行的总位数</strong>： = 标记位数t + 数据位 + 1 位有效位 + 1 位脏位 (回写策略)</p></li><li><p>t：【主存区号】【Tag 位】【主存字块标记】</p><ul><li>通过主存区的标记位数就能知道这个 Cache 是属于主存的第几区</li><li>t = 主存地址长度 - Cache 地址长度</li><li>t = 主存大小 / Cache 大小</li></ul></li><li><p>c：【Cache 块的地址位数】</p><ul><li>如有 1 k 个 Cache 行，则 Cache 块的地址位数=10</li></ul></li><li><p>m：【主存块的地址位数】</p><ul><li>如有 1 k个主存块，则主存块的地址位数=10</li></ul></li><li><p>b：【块内地址位数】</p><ul><li>如块的大小为 32 B，按字节编制，块内地址位数=5</li></ul></li><li><p><strong>标记项</strong>：</p><ul><li>包括有效位，脏位，替换算法位，标记位</li><li>每个 Cache 行对应一个标记项</li></ul></li></ul><table><thead><tr><th></th><th>容量</th><th>块容量</th><th>多少块</th><th>m是c的几倍</th></tr></thead><tbody><tr><td>Cache</td><td>$2^{c+b}$</td><td>$2^b$</td><td>$2^c$</td><td>$2^{m-c}$</td></tr><tr><td>主存</td><td>$2^n$</td><td>$2^b$</td><td>$2^m$</td><td>$2^{m-c}$</td></tr></tbody></table><ul><li>简单、成本低、易实现</li><li>由于物理位置也是相邻的所以地址变换速度最快</li><li>不需要替换算法</li><li>对于任意一个地址，只需对比一个标记<br><strong>缺点</strong></li><li>映射方式不够灵活</li><li>空间利用率最低</li><li>命中率低，块冲突概率最高</li></ul><h3 id="4-2-3-组相联映射">4.2.3 组相联映射</h3><ul><li>先按号分组【组间是直接映射】</li><li>组内再任意放【组内是全相联映射】</li><li>所属分组 = 主存块号 % 分组数</li><li>主存地址=标记位（主存块号前几位）+组号（主存块号末几位）+块内地址</li><li>组号位数=log2组数</li><li>Cache总容量=组数×(每行控制位×组内行数+替换控制位)<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413205403266.png" alt="image.png"></li></ul><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421152651.png" alt="image.png|400"></p><ul><li>Cache 的总块数：$2^c$</li><li>Cache 分组个数：$2^q$  【分块个数 / 组内块数】</li><li>组内包含的块数：$2^r$  【r=1，每组包含 2 块，即二路组相联】<br><strong>优点</strong></li><li>另外两种方式的折中，综合效果较好</li></ul><table><thead><tr><th><strong>对比维度</strong></th><th><strong>直接映射</strong></th><th><strong>全相联映射</strong></th><th><strong>N路组相联映射</strong></th></tr></thead><tbody><tr><td><strong>映射关系</strong></td><td>每个主存块只能映射到 Cache 中某一固定行。</td><td>每个主存块可映射到所有 Cache 行。</td><td>每个主存块可映射到对应组的 N 行。</td></tr><tr><td><strong>命中率</strong></td><td>最低。因主存块固定映射，冲突概率高。</td><td>最高。映射灵活，冲突概率低。</td><td>介于两者之间。冲突概率低于直接映射，高于全相联映射。</td></tr><tr><td><strong>判断开销与时间</strong></td><td>判断开销最小、所需时间最短。固定行查找，逻辑简单。</td><td>判断开销最大、所需时间最长。需遍历所有 Cache 行进行匹配。</td><td>开销与时间适中。只需在对应组的 N 行内查找。</td></tr><tr><td><strong>标记空间开销</strong></td><td>标记所占额外空间开销最少。</td><td>标记所占额外空间开销最大。</td><td></td></tr></tbody></table><h3 id="4-2-4-例题">4.2.4 例题</h3><ol><li><strong>假设主存容量为 512 KB, Cache 容量为 4 KB, 每个字块为 16 个字，每个字为 32 位</strong><ul><li><strong>Cache 地址为多少位？可容纳多少块？</strong></li><li><strong>主存地址为多少位？可容纳多少块？</strong></li><li><strong>在直接映射方式下，主存的第几块映射到 Cache 中的第五块（设起始字块号为 1）</strong></li><li><strong>画出直接映射方式下主存地址字段中各段的位数</strong><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413212316750.png" alt="image.png|500"><strong>如果按字访问</strong>，主存容量512KB，Cache容量4KB，块大小16个字，字大小32位（4字节）<ul><li>Cache地址数：4KB/4B=1024b，10位</li><li>Cache可容纳块数：每块大小16字×4字节/字=64字节，Cache块数=4KB/64B=64块</li><li>主存地址位数=512KB/4B=2^17，17位</li><li>主存可容纳块数：512KB/64B=2^13块</li><li>直接映射：答案一样</li><li>直接映射地址字段划分：7 6 4<br>若题目未明确说明，<strong>默认按字节编址</strong><br>若题目给出“xxxK×xx位”且指定按字访问，则按字编址</li></ul></li></ul></li><li><strong>假设主存容量为 $512 K<em>16$ 位，Cache 容量为 $4096</em>16$ 位，块长为 4 个 16 位的字，访存地址为字</strong><ul><li><strong>在直接映射下，设计主存的地址格式</strong></li><li><strong>在全相联映射下，设计主存的地址格式</strong></li><li><strong>在二路组相联映射方式下，设计主存的地址格式</strong></li><li><strong>若主存容量为 $512 K*32$ 位，块长不变，在四路组相联映射下，设计主存的地址格式</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413212843334.png" alt="image.png|900"></li></ul></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250413212234340.png" alt="image.png"></li><li><strong>假设某个计算机的主存地址空间大小为 256MB，按字节编址，其数据 Cache 有 8 个 Cache 行，行长为 64B。</strong><br><strong>1）若不考虑用于 Cache 的一致维护性位（脏位）和替换算法控制位，并且采用直接映射方式，则该数据 Cache 的总容量为多少？</strong><br><strong>2）若该 Cache 采用直接映射方式，则主存地址为 3200（十进制）的主存块对应的 Cache 行号是多少？采用 2 路组相联映射时又是多少？</strong><br><strong>3）以直接映射方式为例，简述访问过程（设访问的地址为 0123456H）。</strong><br>1）主存地址有 28 位，其中 6 位为块内地址，3 位为行号，剩余 28 - 6 - 3 = 19 位为标记字段。数据 Cache 的总容量为 8×(1 + 19 + 512) = 4256 位（1 位有效位，19 位标记位，512 位存储容量 64×8 = 512）。<br>2）直接映射方式：主存地址 3200 对应的字块号为 3200B/64B = 50，50 % 8 = 2，故 Cache 行号为 2。<br>2 路组相联映射：8 行分为 4 组（每组 2 行），50 % 4 = 2，对应组号为 2，Cache 行号为 4 或 5。<br>3）直接映射方式下，28 位主存地址分为 19 位标记位、3 位块号、6 位块内地址。对于 0123456H，先根据 3 位块号（001）查找对应 Cache 行的标记位。若标记位相同且有效位为 1，则命中，按块内地址（010110）读取 Cache 行单元送 CPU；若标记位不同或有效位为 0，则不命中，访问主存取数据送 CPU 和对应 Cache 块，写入主存地址高 19 位到标记位，置有效位为 1。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250418191918706.png" alt="image.png"></li><li><strong>设主存与 Cache采用主存容量1MB，Cache的容量为64KB，每个块为8KB。<br>(1)直接映射<br>Cache地址格式共[填空1]位主存地址格式总共[填空2]位Cache中保留标记位[填空3]位Cache中有效位[填空4]位<br>(2)全相联映射<br>Cache地址格式共[填空5]位主存地址格式总共[填空6]位Cache中保留标记位[填空7]位Cache中有效位[填空8]位<br>(3)组相联映射(4路组相联)Cache地址格式共[填空9]位主存地址格式总共[填空10]位Cache中保留标记位[填空11]位Cache中有效位[填空12]位</strong><br>16;20;4;1;16;20;7;1;16;20;6;1<br><strong>(1)直接映射，主存地址25301H，映射到Cache的具体位置是：Cache第[填空1]块，块内地址为[填空2]<br>(2)全相联映射，映射到Cache的具体位置是：Cache第[填空3]块，块内地址为[填空4]<br>(3)4路组相联映射，位于主存的第[填空5]组群，映射到Cache的具体位置是：Cache第[填空6] 组，第[填空7]块，块内地址为[填空8]</strong><br>010B;1001100000001B;<br>任意;1001100000001B;<br>001001B;0B;任意;1001100000001B</li><li></li></ol><h2 id="4-3-3、Cache-替换算法">4.3 3、Cache 替换算法</h2><p>直接映射不需要替换算法</p><h3 id="4-3-1-随机算法-RAND">4.3.1 随机算法 RAND</h3><ul><li>若Cache已满，则随机选择一块替换</li><li>实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定<br>![][<a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250414183956510.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250414183956510.png</a>]</li></ul><h3 id="4-3-2-先进先出-FIFO">4.3.2 先进先出 FIFO</h3><ul><li>按调入 Cache 的先后顺序来淘汰，<strong>先进的先替换</strong></li><li>需要记录进入 Cache 的先后次序</li><li>实现起来比较简单</li><li>没有考虑局部性原理</li><li>会有<strong>抖动现象</strong>：频繁的换入换出现象（刚被替换的块很快又被调入）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250414184137550.png" alt="image.png"></li></ul><h3 id="4-3-3-近期最少使用-LRU">4.3.3 近期最少使用 LRU</h3><ul><li>把<strong>最近比较少用的替换掉</strong></li><li>需要记录进入 Cache 的先后次序</li><li>需要软件<font color="#ff0000">计数器</font>来记录使用的频率<br>①命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变<br>②)未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1<br>③未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。</li><li>Cache块的总数=2^n，则计数器只需n位。且Cache装满后所有计数器的值一定不重复</li><li>实现起来较复杂且开销大</li><li>根据程序访问<font color="#ff0000">局部性原理</font>选择近期使用得最少的存储块作为替换的块</li><li>若被频繁访问的主存块数量&gt;Cache行的数量，则有可能发生“抖动”<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250414185815772.png" alt="5546e9c7cf10e95be646c8be3d0ed62.jpg|400"></li></ul><h3 id="4-3-4-最不经常使用-LFU">4.3.4 最不经常使用 LFU</h3><ul><li>只统计使用次数，<strong>用的最少的就替换掉谁</strong></li><li>需要硬件设计<font color="#ff0000">计数器</font>支持<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421154926.png" alt="image.png"><br>注：刚开始没全命中的时候也算进失效率</li></ul><h2 id="4-4-4、Cache-写策略">4.4 4、Cache 写策略</h2><p>CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性问题</p><ul><li>写命中<ul><li>全写法 —— Cache和内存都改，写缓冲SRAM，不适合频繁，适合安全性高的</li><li>回写法 —— 只改Cache，减少主存访问次数，数据可能不一致，适合密集型应用</li></ul></li><li>不命中<ul><li>写分配法 —— 主存加载到Cache，再用写回法</li><li>非写分配法 —— 只写入主存，全写法</li></ul></li></ul><h3 id="4-4-1-写命中">4.4.1 写命中</h3><h4 id="4-4-1-1-全写法——Cache和内存都改">4.4.1.1 全写法——Cache和内存都改</h4><ul><li>当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，一般使用<strong>写缓冲</strong>（<strong>SRAM实现的FIFO队列</strong>）</li><li>访存次数增加，速度变慢，但更能保证数据一致性<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421160039.png" alt="image.png"><ul><li>在写的时候 CPU 将数据通过数据总线橙色箭头方向传输</li><li>由于 CPU 写给 Cache 的速度和写入主存的速度会差很多</li><li>所以需要设计一个<strong>缓冲</strong>，先写到缓冲块中，再慢慢写入<br>使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好，若频繁，可能会因为写缓冲饱和发生阻塞</li></ul></li></ul><h4 id="4-4-1-2-回写法——只改Cache">4.4.1.2 回写法——只改Cache</h4><ul><li>当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存</li><li>减少了访存次数，但存在数据<strong>不一致</strong>的隐患<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421155443.png" alt="image.png"><ul><li>在 CPU 执行写操作时，先按橙色线写入 Cache 存储体中</li><li>此时并没有修改主存的内容，会在 Cache 中设计一个脏位</li><li>当一块中的任何一个单元被修改时，脏位 (修改位) 被置“1”</li><li>需要替换掉这一块时，如果<strong>修改位为“1”</strong>，则必须<strong>先把这一块写回到主存中，然后才能再调入新的块</strong></li><li>如果<strong>修改位为“0”</strong>，则这一块<strong>不必写回主存</strong>，只要用新调入的块覆盖这一块即可</li></ul></li></ul><h3 id="4-4-2-写不命中">4.4.2 写不命中</h3><h4 id="4-4-2-1-写分配法——主存加载到Cache，再用写回法">4.4.2.1 写分配法——主存加载到Cache，再用写回法</h4><ul><li>当 CPU 对 Cache 写不命中时，把主存中的块调入 Cache ，在 Cache 中修改</li><li>搭配<strong>回写法</strong>使用<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421160455.png" alt="image.png"></li></ul><h4 id="4-4-2-2-非写分配法——只写入主存">4.4.2.2 非写分配法——只写入主存</h4><ul><li>当 CPU 对 Cache 写不命中时只写入主存，不调入 Cache</li><li>搭配<strong>全写法</strong>使用<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421160655.png" alt="image.png"></li></ul><h3 id="4-4-3-多级-Cache">4.4.3 多级 Cache</h3><ul><li>现代计算机通常采用多级 Cache 结构</li><li>离CPU越近的速度越快，容量越小</li><li>离CPU越远的速度越慢，容量越大</li><li>各级Cache之间常采用“全写法+非写分配法&quot;</li><li>Cache-主存之间常采用“写回法+写分配法&quot;<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421161037.png" alt="image.png"><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240421161105.png" alt="image.png"></li></ul><h1>5 虚拟存储器</h1><p>主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。</p><h2 id="5-1-虚拟存储器的基本概念">5.1 虚拟存储器的基本概念</h2><ol><li><strong>逻辑地址</strong>（虚地址）：程序员视角看到的地址<br>虚地址=虚存页号+页内字地址</li><li><strong>物理地址</strong>（实地址）：实际在内存中的地址<br>实地址=主存页号+页内字地址<br>虚地址&gt;&gt;实地址</li><li>辅存地址=磁盘号+盘面号+磁道号+扇区号</li><li>CPU 使用虚地址时，先判断这个虚地址对应的内容是否已装入主存<br>若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元<br>若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU访问<br>若主存已满，则采用替换算法置换主存中的交换块(页面)</li><li><strong>虚拟存储器只能采用回写法的原因</strong>：<br>虚拟存储器也采用和 Cache 类似的技术，将辅存中经常访问的数据副本存放到主存中。但是缺页(或段)而访问辅存的代价很大，提高命中率是关键，因此虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因此，在处理一致性问题时，采用回写法。</li></ol><h2 id="5-2-页式虚拟存储器">5.2 页式虚拟存储器</h2><p>页式虚拟存储器以页为基本单位。主存空间和虚拟地址空间都被划分成相同大小的页，主存空间中的页称为物理页、实页、页框，虚拟地址空间中的页称为虚拟页、虚页。页表记录了程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。</p><h3 id="5-2-1-虚拟存储器的基本概念">5.2.1 虚拟存储器的基本概念</h3><ol><li><p><strong>定义与组成</strong></p><ul><li>由<strong>主存（<font color="#ff0000">DRAM</font>）</strong> 和<strong>辅存（硬盘/SSD）</strong> 共同构成，通过硬件（MMU）和操作系统（页表管理）协同工作。</li><li>是一个<strong>逻辑模型</strong>，而非物理实体，对应用程序员透明。</li><li><strong>作用</strong>：<ul><li>提供比物理主存更大的地址空间。</li><li>实现内存隔离与程序重定位。</li><li>通过分页/分段机制管理内存。</li></ul></li></ul></li><li><p><strong>核心特性</strong></p><ul><li><strong>透明性</strong>：应用程序员无需关心物理内存分配。</li><li><strong>逻辑地址（虚地址）</strong>：程序员视角的地址。</li><li><strong>物理地址（实地址）</strong>：实际存储在主存中的地址。</li><li><strong>速度与容量</strong>：接近主存的访问速度，但可寻址辅存的容量。</li></ul></li><li><p>地址转换与访存流程</p><ul><li><strong>虚实地址转换</strong>：每次访问需通过页表将<strong>逻辑地址</strong>转换为<strong>物理地址</strong>。</li><li><strong>访问顺序</strong>（含TLB和Cache）：</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU请求 → 查TLB（快表）→ 若未命中 → 查页表/慢表（主存内）→ 查Cache → 若未命中 → 访主存 → 若缺页 → 调入辅存数据。</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250416203531931.png" alt="image.png"></p><pre><code class="highlight mermaid">graph TD;    A[访问：某逻辑地址（页号，页内地址）] --&gt; B[根据页号查TLB（速度很快）];    B --&gt; C&#123;TLB命中？&#125;;    C --&gt;|是| D[根据TLB页表项得到主存块号];    C --&gt;|否| E[查慢表（访存）];    E --&gt; F[根据慢表页表项得到主存块号。并将页表项复制到TLB];    D --&gt; G[得到物理地址（主存块号+页内地址）];    F --&gt; G;    G --&gt; H[在Cache中找主存块副本];    H --&gt; I&#123;Cache命中？&#125;;    I --&gt;|是| J[从Cache中访问目标数据（速度很快）];    I --&gt;|否| K[从主存中访问目标数据（访存）。并将主存块调入Cache];    J --&gt; L[结束];    K --&gt; L;</code></pre><h4 id="2-分页机制"><strong>2. 分页机制</strong></h4><ul><li><strong>页与块</strong>：<ul><li><strong>页（Page）</strong>：虚拟地址空间的最小单位（通常4KB~2MB）。</li><li><strong>块（Frame）</strong>：主存中与页大小相同的物理存储单元。</li></ul></li><li><strong>页表（Page Table）</strong>：<ul><li>存储在主存（DRAM）中，记录逻辑页号到物理块号的映射。</li><li><strong>有效位</strong>也称装入位，用来表示<strong>对应页面是否在主存</strong><br>若为1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号；<br>若为0，则表示没有调入主存此时页表项可以存放该页的磁盘地址。</li><li><strong>脏位</strong>也称修改位，用来表示<strong>页面是否被修改过</strong>，虚存机制中采用<strong>回写</strong>法，利用脏位可判断替换时是否需要写回磁盘。</li><li><strong>引用位</strong>也称使用位，用来配合<strong>页面置换算法</strong>进行设置，例如统计这个页面被访问过多少次，是否实现最先调入(FIFO 位)或最近最少用(LRU位)策略等。</li><li><strong>物理位</strong>：即<strong>主存块号</strong></li><li><strong>磁盘地址</strong>：即这个<strong>页面的数据再磁盘中的存放位置</strong></li><li>结构：逻辑页号 → 物理块号 + 状态位（有效位、修改位等）。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250416211056926.png" alt="image.png"></li></ul></li><li><strong>快表（TLB）</strong>：<ul><li>页表的高速缓存（<font color="#ff0000">SRAM实现</font>），按内容寻址（<font color="#ff0000">相联存储器</font>）。</li><li>作用：加速<strong>地址转换</strong>，减少访存次数。</li><li>TLB未命中时需访问主存中的页表。</li></ul></li><li>快表 VS Cache<ul><li>快表是在<strong>地址变换</strong>过程中起加速作用</li><li>Cache是在访问最终的得到的地址的时候起加速作用</li><li>快表中存储的是<strong>页表项</strong>的副本</li><li>Cachè中存储的是<strong>主存块</strong>的副本</li></ul></li></ul><h4 id="3-页面大小的影响"><strong>3. 页面大小的影响</strong></h4><table><thead><tr><th><strong>页面过小</strong></th><th><strong>页面过大</strong></th></tr></thead><tbody><tr><td>页表体积大，占用主存空间多</td><td>页面换入/换出时间长（I/O开销大）</td></tr><tr><td>局部性利用率低</td><td>内存碎片增加</td></tr><tr><td>TLB命中率低</td><td>主存中驻留页面数少</td></tr></tbody></table><h3 id="5-2-2-虚拟存储器-VS-Cache的对比">5.2.2 虚拟存储器 VS Cache的对比</h3><h4 id="1-相同点"><strong>1. 相同点</strong></h4><ul><li><strong>局部性原理</strong>：均利用时间局部性和空间局部性缓存热点数据。</li><li><strong>透明性</strong>：数据换入换出对用户透明（由硬件或OS管理）。</li><li><strong>层级结构</strong>：通过高速缓存（Cache/TLB）提升性能。</li></ul><h4 id="2-不同点"><strong>2. 不同点</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>Cache</strong></th><th><strong>虚拟存储器</strong></th></tr></thead><tbody><tr><td><strong>物理/逻辑</strong></td><td>物理存储器（SRAM）</td><td>逻辑存储器（主存-辅存结构）</td></tr><tr><td><strong>管理方式</strong></td><td>完全由硬件管理</td><td>由OS和硬件协同管理</td></tr><tr><td><strong>透明性</strong></td><td>对系统程序员和应用均透明</td><td>对系统程序员不透明，对应用透明</td></tr><tr><td><strong>不命中代价</strong></td><td>低（访问主存，延迟约10倍）</td><td>高（访问硬盘，延迟约100倍）</td></tr><tr><td><strong>数据交换单位</strong></td><td>块（Block，通常64B）</td><td>页（Page，通常4KB~2MB）</td></tr><tr><td><strong>直接访问通路</strong></td><td>CPU ↔ Cache ↔ 主存</td><td>CPU ↔ 主存 ↔ 辅存（无直接通路）</td></tr></tbody></table><h3 id="5-2-3-段式虚拟存储器">5.2.3 段式虚拟存储器</h3><p>按功能模块拆分，每个段长并不一样<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250416211356460.png" alt="image.png"></p><h3 id="5-2-4-段页式虚拟存储器">5.2.4 段页式虚拟存储器</h3><p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位。每个程序对应一个段表，每段对应一个页表。<br>虚拟地址：段号+段内页号+页内地址</p><h3 id="5-2-5-关键问题与设计权衡">5.2.5 关键问题与设计权衡</h3><ol><li><p><strong>缺页处理</strong></p><ul><li>触发条件：访问的页面不在主存中。</li><li>处理流程：<ol><li>中断CPU，由OS从辅存调入缺失页。</li><li>更新页表，若主存已满则按算法（如LRU）替换旧页。</li></ol></li></ul></li><li><p><strong>TLB与Cache协作</strong></p><ul><li><strong>TLB命中</strong>：直接获取物理地址，后续访问Cache。</li><li><strong>TLB未命中</strong>：需访问主存中的页表，增加额外延迟。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li><strong>增大TLB容量</strong>：提高快表命中率。</li><li><strong>预取策略</strong>：根据局部性预加载可能访问的页。</li><li><strong>页面替换算法</strong>：如LRU、FIFO、Clock算法等。</li></ul></li></ol><table><thead><tr><th><strong>管理方式</strong></th><th><strong>交换单位</strong></th><th><strong>地址空间划分</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>页式</strong></td><td>页（固定）</td><td>固定大小的页</td><td>无外部碎片，管理简单</td><td>逻辑结构不直观</td></tr><tr><td><strong>段式</strong></td><td>段（可变）</td><td>可变长度的逻辑段</td><td>支持模块化，易于共享保护</td><td>外部碎片多，管理复杂</td></tr><tr><td><strong>段页式</strong></td><td>页（固定）</td><td>段内分页，逻辑+物理</td><td>兼具灵活性与效率</td><td>地址转换复杂，性能开销大</td></tr></tbody></table><ul><li><strong>页式</strong>和<strong>段页式</strong>的交换单位均为页，但段页式需通过段表+页表两级映射。</li><li><strong>段式</strong>的交换单位为段，适合需要强隔离性和模块化的场景（如嵌入式系统）。</li></ul><h1>6 错题</h1><ol><li><p><strong>设机器字长为 64 位，存储容量为 128MB，若按字编址，它可寻址的单元个数是( )。A. 16MB   B.16M   C.32M   D.32MB</strong><br>128MB/8B=16M</p></li><li><p><strong>80386DX是32位系统，以4B为编址单位，当在该系统中用8KB(8Kx8位)的存储32k芯片构造32KB的存储体时，应完成存储器的()设计。<br>A.位扩展   B.字扩展   C.字位扩展   D.字位均不扩展</strong><br>要构造的存储体是 32 位的，因为系统是 32 位系统，数据总线是 32 位，需要一次能读出或写入 32 位数据。所以需要将 4 个 8 位的存储芯片进行位扩展，才能组成一个 32 位的存储体，这样就可以满足系统一次处理 32 位数据的要求。位扩展后，存储体的字数不变，还是 8K，只是每个字的位数从 8 位变成了 32 位，即 8K×32 位，其存储容量为 8K×32 位 ÷8 = 32KB，正好满足题目要求的 32KB 存储体。A</p></li><li><p><strong>在 Cache 和主存构成的两级存储体系中，主存与Cache 同时访问，Cache 的存取时间是100ns，主存的存取时间是 1000ns，设 Cache 和主存同时访问，若希望有效(平均)存取时间不超过 Cache 存取时间的 115%，则 Cache 的命中率至少应为( )。</strong><br>同时访问 Cache 和主存：$t=Ht_c+(1-H)t_m$，得出98.33%，至少99%</p></li><li><p><strong>下列关于存储器的说法中，不正确的是()</strong><br><strong>A.随机存储器和只读存储器不可以统一编址</strong><br><strong>B.在访问随机存储器时，访问时间与存储单元的物理位置无关</strong><br><strong>C.随机存储器 RAM 芯片可随机存取信息，掉电后信息会丢失</strong><br><strong>D.只读存储器 ROM 芯片可随机存取信息，掉电后信息不会丢失</strong><br>主存由 RAM 和 ROM 构成，两者统一编址，A错误。B正确。RAM 芯片具有随机访问特性和易失性，选项C正确。ROM芯片具有随机访问特性和非易失性，选项 D 正确。</p></li><li><p><strong>某一DRAM 芯片，采用地址复用技术，容量为1024x8位，该芯片的地址引脚和数据引脚总数至少是( )。</strong><br>1采用地址复用技术，分两次传送行、列地址，地址引脚减半为5根，数据引脚仍为8根，因此地址引脚和数据引脚总数至少为13 根。注意 SRAM 和 DRAM 的区别，DRAM 采用地址复用技术，而 SRAM 不采用。</p></li><li><p><strong>下列( )是动态半导体存储器的特点</strong><br><strong>I.在工作中存储器内容会产生变化</strong><br><strong>II.每隔一定时间，需要根据原存内容重新写入一遍</strong><br><strong>III.一次完整的刷新过程需要占用两个存取周期</strong><br><strong>IV.一次完整的刷新过程只需要占用一个存取周期</strong><br><strong>A. I、III   B. II、III   C.II、IV   D. 只有III</strong><br>动态半导体存储器（DRAM）的特点，DRAM 的内容不会自发变化，只是电荷会泄漏，需要通过刷新维持数据。通常刷新占用 <strong>1 个周期</strong>（读取后回写）。选c</p></li><li><p><strong>采用 64Kx1 位的 DRAM 芯片构成 128Kx8 位的存储器，若采用异步刷新方式，每单元刷新间隔不超过 2ms，则生成的刷新信号的间隔时间是( )；若采用集中刷新方式，则存储器刷新一遍最少用( )个读1写周期。</strong><br><strong>A. 7.8us，256   B. 1.9us，256   C. 7.8us，128   D. 1.9us，128</strong><br>芯片： 64Kx1位（即 64K 个存储单元，每个单元大小是 1 位），16位地址，采用地址复用技术，行地址8位，列地址8位，即256行×256列<br>存储器容量：128K×8 位（需要 16 片 64K×1 位芯片，位扩展 + 字扩展）<br>异步刷新：DRAM 的刷新要求：每 <strong>2ms</strong> 内必须刷新所有行。刷新间隔=总刷新时间/行数=2ms/256≈7.8us，即每 7.8μs 刷新一行。<br>集中刷新：最少刷新周期数。集中刷新需要在短时间内刷新所有行，每行刷新占用 <strong>1 个存取周期</strong>。行数 = 256 行 → 最少需要 <strong>256 个读/写周期</strong>。<br>此外，需要字位扩展2×8，需要一个片选线，属于地址线，所以一共需要9条地址线，8条数据线</p></li><li><p><strong>每推出新一代 DRAM 芯片，地址线至少增1根，则容量至少提高到原来的()倍   A. 2   B. 4   C.8   D. 16</strong><br>DRAM 芯片采用地址线复用技术，行地址和列地址分时复用，每增加1根地址线，则行地址和列地址各增加1位，所以行数和列数各增加1倍，因此容量至少提高到原来的4倍。</p></li><li><p><strong>已知单个存储体的存取周期为 110ns，总线传输周期为 10ns，采用低位交叉编址的多模块存储器时，存储体数应()。</strong><br><strong>A. 小于 11   B. 等于 11   C.大于 11   D.大于或等于 11</strong><br>低位交叉编址多模块存储器，采用轮流启动的方式时，类似于流水线的工作方式，为保证某个模块再次启动时，其上次的存取操作已完成(流水线不间断)，要求两次启动间隔的时间必须大于或等于一个存取周期，即“模块数x总线周期≥存取周期”m ≥ T / r，得出存储体数应大于或等于 11。</p></li><li><p><strong>一个四体并行低位交叉存储器，每个模块的容量是 64Kx32 位，存取周期为 200ns，总线周期为 50ns，在下述说法中，()是正确的。<br>A.在 200ns 内，存储器能向CPU 提供256 位二进制信息<br>B.在 200ns 内，存储器能向 CPU 提供 128 位二进制信息<br>C.在 50ns 内，每个模块能向 CPU 提供 32 位二进制信息<br>D.以上都不对</strong><br>采用低位交叉存储（如果没有说明，默认低位），T=200ns，r=50ns，m≥4，四体，m=4，可在一个存储周期内连续访问4个模块，32位×4=128位。如果题目给出总线宽度是128位，则是同时启动，没给，默认是轮流启动，B。如果是同时启动，B、C也是对的<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411193435312.png" alt="image.png"></p></li><li><p><strong>某机器采用四体低位交叉存储器，现分别执行下述操作:①读取6个连续地址单元中存放的存储字，重复 80次;②读取8个连续地址单元中存放的存储字，重复 60 次。则①、②所花费的时间之比为<br>A. 1:1   B.2:1   C.4:3   D. 3:4</strong><br>操作1：6 个地址的分布：M1→M2→M3→M4→M1→M2，第 5、6 个地址回到 M1 和 M2，而非继续 M5、M6（因为只有 4 个存储体）<br>操作2：8 个地址的分布：M1→M2→M3→M4→M1→M2→M3→M4<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411200248618.png" alt="image.png"></p></li><li><p><strong>假定用若干 16Kx8 位的存储芯片组成一个 64Kx8 位的存储器，芯片各单元采用交叉编址方式，则地址 BFFFH 所在的芯片的最小地址为()。A.0000H   B. 0001H   C.0002H   D. 0003H</strong><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411201717234.png" alt="image.png"></p></li><li><p><strong>某存储器总线的宽度是 64 位，若用8个 16Mx8 位的 DRAM 芯片扩展构成 16Mx64 位的内存条，按字节编址，支持突发传送方式，某double 型的变量x的主存地址为 20260000H，某 int型的变量y的主存地址为 2026 1006H，则下列叙述中错误的是()。<br>A.该内存条可不采用多模块交叉编址<br>B.DRAM 芯片的行缓冲采用的是 SRAM<br>C.读取变量x只需要一个存取周期<br>D.读取变量y需要两个存取周期</strong><br>存储器总线宽度是 <strong>64位</strong>，即一次传输 <strong>8字节（8B）</strong>，使用了 <strong>8个 16M×8 位</strong> 的 DRAM 芯片，每个 DRAM 芯片提供 1B的数据，若未采用交叉编址，连续 8 字节可能位于同一芯片，无法并行读取，因此一定采用多模块交叉编址，否则无法一次读取 8 字节（64位），违反总线宽度设计，选项A 错误。DRAM 读取某一行时，整行数据会被缓存到 <strong>SRAM 行缓冲</strong> 中，利用 SRAM 的高速特性提升访问效率。在此内存条中，同时读出的 64 位只可能是第 0~7单元、第 8~15 单元……第8k-8k+7单元。突发传送（一次启动后，连续快速地传送多个数据）。<code>double x</code> 占 8 字节，地址末3位为 <code>000</code>，属于 <strong>首个 8 字节块</strong>（地址范围 <code>20260000H~20260007H</code>）。所以 x 正好完整落在一个 8 字节块中，一个周期可以读完。<code>int y</code> 占 4 字节，地址是 <code>20261006H</code>，地址末3位为 <code>110</code>，说明起始地址是一个 8 字节块的 <strong>第7个字节</strong>（因为8字节为单位分块）。所以 y 的4字节跨了两个块：一部分在 <code>20261000H~20261007H</code>，另一部分在 <code>20261008H~2026100FH</code>。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411205210456.png" alt="image.png"></p></li><li><p>【<strong>2015 统考真题】某计算机使用四体交叉编址存储器，假定在存储器总线上出现的主存地址(十进制)序列为8005,8006,8007,8008,8001,8002,8003,8004,8000，则可能发生访存冲突的地址对是()。</strong><br>A.8004和8008   B.8002和8007<br>C.8001和8008   D.8000和8004<br>模块序号=访存地址%存储器交叉模块数。分别对4取余，只有D模块号都是0，即表明这两次访问出现在同一模块内且在相邻的访问请求中，满足发生冲突的条件</p></li><li><p><strong>【2017 统考真题】某计算机主存按字节编址，由4个64Mx8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读1写 32 位数据。若double 型变量x的主存地址为 804 001AH，则读取x需要的存取周期数是()。1/2/3/4</strong><br>按字节8位编制，一次可读32位，本题中所有存储模块一次并行写的总位数正好等于系统总线中的数据线数，所以是<strong>同时启动</strong>（总线宽度=存储字长：轮流启动；总线宽度=体数×存储字长）。交叉编制是低位，顺序编制是高位，由于选用4个DRAM芯片交叉编址，看低2位10，四个分别是00，01，10，11，在第三个芯片，x是double型，占8位，需要3次<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411211316183.png" alt="image.png|300"></p></li><li><p><strong>【2018 统考真题】假定 DRAM 芯片中存储阵列的行数为r、列数为 c，对于一个 2Kx1位的 DRAM 芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则r、c的取值分别是( )。</strong><br><strong>A. 2048，1   B. 64，32   C.32，64   D. 1，2048</strong><br>尽量减少刷新开销：由于刷新以行为单位，使行尽量少，并且行列数尽量相同。c</p></li><li><p><strong>【2022 统考真题】某内存条包含8个 8192x8192x8 位的 DRAM 芯片，按字节编址，支持突发(burst)传送方式，对应存储器总线宽度为 64 位，每个 DRAM 芯片内有一个行缓冲区(row bufer)。下列关于该内存条的叙述中，不正确的是( )。</strong><br><strong>A.内存条的容量为 512 MB   B.采用多模块交叉编址方式</strong><br><strong>C.芯片的地址引脚为 26 位   D.芯片内行缓冲有8192x8位</strong><br>64位=8个×8位，所以同时启动，看14题。A，B对；本来是26根地址线，由于复用，所以13，C错；<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250411212849898.png" alt="image.png|300"></p></li><li><p><strong>80386DX是 32 位系统，以4B为编址单位，当在该系统中用8KB(8Kx8位)的存储芯片构造 32KB的存储体时，应完成存储器的()设计。A.位扩展   B.字扩展   C.字位扩展   D.字位均不扩展</strong><br>1B→4B，位扩展，即8K×4B=32KB，a</p></li><li><p><strong>某计算机字长为 16 位，存储器容量为 256KB，CPU 按字寻址，其寻址范围是()。</strong><br><strong>A.0~2^19-1   B.0~2^20-1   C.0~2^18-1   D.0~2^17-1</strong><br>256KB/2B=2^17，d</p></li><li><p><strong>地址总线 A0(高位)~A15(低位)，用4Kx4位的存储芯片组成16KB存储器，则产生片选信号的译码器的输入地址线应该是( )。</strong><br><strong>A. A2A3   B.A0A1   C.A12A13   D.A14A15</strong><br>A15是低位，反着来，a</p></li><li><p><strong>若内存地址区间为 4000H~43FFH，每个存储单元可存储 16 位二进制数，该内存区域用4片存储器芯片构成，构成该内存所用的存储器芯片的容量是()。</strong><br><strong>A. 512x16bit   B.256x8bit   C.256x16bit   D.1024x8bit</strong><br>43FF-4000+1=400H=1K，总容量是1K×16位，每片芯片容量= 1K×16bit/4 = 256x16bit</p></li><li><p><strong>若片选地址为 111 时，选定某一32Kx16 位的存储芯片工作，则该芯片在存储器中的首地址和末地址分别为()。<br>A.00000H,01000H   B.3800H,3FFFH<br>C.38000H,3FFFFHB   D.0000H,0100H</strong><br>32Kx16的存储芯片有地址线 15 根(片内地址)，片选地址为3位，因此地址总位数为 18 位，现高 3 位为 111，则首地址为 111000000000000000= 38000H，末地址为 111111111111111111 =3FFFFH</p></li><li><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250412193331334.png" alt="image.png">A17和A18是或信号，整体还要经过一个&amp;，再非取反。每个选项写出A12~A19，剔除掉A14,A16，只有D译码输出是1，无效</p></li><li><p><strong>【2010 统考真题】假定用若干 2Kx4 位的芯片组成一个 8Kx8 位的存储器，则地址 0BIFH所在芯片的最小地址是( )。</strong><br><strong>A.0000H   B. 0600H   C.0700H   D.0800H</strong><br>总共需要4组，每组2片芯片。<br>第一组(两个芯片并联):0000H~07FFH<br>第二组(两个芯片并联):0800H~0FFFH<br>第三组(两个芯片并联):1000H~17FFH<br>第四组(两个芯片并联):1800H~1FFFH<br>地址 0B1FH 所在的芯片属于第二组，所以其所在芯片的最小地址为0800H。</p></li><li><p><strong>【2011 统考真题】某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4M×8位的 RAM 芯片组成 32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是( )。<br>A.22 位   B.23 位   C.25 位   D.26 位</strong><br>MAR位数看主存地址空间最大有多大，所以是64MB/1B=2^26，D</p></li><li><p><strong>下列关于磁盘的说法中，错误的是()。</strong><br><strong>A.本质上，U盘(闪存)是一种只读存储器</strong><br><strong>B.RAID 技术可以提高磁盘的磁记录密度和磁盘利用率</strong><br><strong>C.未格式化的硬盘容量要大于格式化后的实际容量</strong><br><strong>D.计算磁盘的存取时间时，“寻道时间”和“旋转等待时间”常取其平均值</strong><br>RAID是通过组合多个磁盘实现数据冗余和性能提升，但是不会对单个磁盘进行任何修改。RAID可以提高<strong>磁盘利用率</strong>（如RAID 0通过条带化提高性能，RAID 5通过分布式校验提高利用率）。RAID<strong>不能提高磁记录密度</strong>：磁记录密度是单个磁盘的物理特性，取决于磁盘的制造技术（如PMR、SMR等），RAID是逻辑层面的组合，不改变物理密度。</p></li><li><p><strong>下列关于磁盘驱动器的叙述中，错误的是()。<br>A.送到磁盘驱动器的地址由磁头号、盘面号和扇区号组成<br>B.能控制磁头移动到指定磁道，并发回“寻道结束”信号<br>C.能控制磁盘片转过指定的扇区，并发回“扇区符合”信号<br>D.能控制对指定盘面的指定扇区进行数据的读或写操作</strong><br>因为每个盘面对应一个磁头，所以盘面号和磁头号是同一个概念，显然A的说法是错误的，磁盘地址应该由磁道号(柱面号)、磁头号(盘面号)和扇区号组成。</p></li><li><p><strong>若磁盘的转速提高一倍，则()。<br>A.平均寻道时间减少一半<br>B.存取速度也提高一倍<br>C.平均旋转延迟时间减少一半<br>D.不影响磁盘传输速率</strong><br>磁盘存取的步骤为：启动磁头、寻找磁道(寻道时间)、查找扇区(旋转延迟时间)、传输数转速提高对寻道时间无影响；存取速度取决于所有步骤的时间，虽然会提高，但不会提高一倍；平均旋转延迟时间为旋转半圈的时间，因此会减少一半；转速提高则传输速率也提高。</p></li><li><p><strong>一个磁盘的转速为 7200转/分，每个磁道有160个扇区，每个扇区有512字节，则在理想情况下，磁盘每秒传输的数据量是</strong><br><strong>A.7200x160KB/S   B.7200KB/s   C.9600KB/s   D.19200KB/s</strong><br>7200转/分=120转/秒，磁盘每秒传输的数据量=120×160×512B=C</p></li><li><p><strong>某磁盘盘面共有 200个磁道，盘面总存储容量为60MB，磁盘旋转一周的时间为 25ms,每个磁道有8个扇区，各扇区之间有一间隙，磁头通过每个间隙需 1.25ms。则磁盘接口所需的最大传输速率是()<br>A.10MB/S   B.60MB/S   C.83.3MB/S   D.20MB/S</strong><br>每个磁道的容量=60MB/200=0.3MB，读一个道数据的时间等于磁盘旋转一周的时间减去通过扇区间隙的总时间(每个磁道有8个间隙)，即 25ms-1.25msx8=15ms，数据传输速率=0.3MB/15ms=20MB/S。</p></li><li><p><strong>【2013 统考真题】某磁盘的转速为 10000转/分，平均寻道时间是 6ms，磁盘传输速率是20MB/s，磁盘控制器延迟为0.2ms，读取一个4KB的扇区所需的平均时间约为()<br>A.9ms   B. 9.4ms   C.12ms   D. 12.4ms</strong><br>平均时间=寻道（6ms）+旋转延迟（60s/10000r/min=6ms）+磁盘控制器延迟（0.2ms）+传输时间（4KB/20MB/s=0.0002048s=0.2048ms）=D<br>注意：速率单位，是10^n次方，此处20MB=20×10^6B，4KB=2^12B。选择题可以直接全算2^n，大题要写对应的2/10</p></li><li><p><strong>【2013 统考真题】下列选项中，用于提高RAID 可靠性的措施有 I.磁盘镜像 II.条带化 III.奇偶校验 IV.增加 Cache 机制<br>A.仅I、II   B.仅I、I   C、仅I、I和IV   D.仅I、I和IV</strong><br>RAID0 方案是无冗余和无校验的磁盘阵列技术，而 RAID1~RAID5 方案均是加入了冗余(镜像)或校验的磁盘阵列技术。因此，提高 RAID 可靠性的措施主要是对磁盘进行镜像和奇偶校验，其余选项不符合条件。条带化是一种将数据分片，分别存储至不同的磁盘，提高读/写速度的技术。条带化的优点是读/写速度快，缺点是没有冗余，若其中一块盘损坏，则数据就会丢失。因此，条带化通常和其他技术如磁盘镜像或奇偶校验结合使用，形成不同的RAID级别。</p></li><li><p><strong>【2015 统考真题】若磁盘转速为 7200 转/分，平均寻道时间为 8ms，每个磁道包含 1000个扇区，则访问一个扇区的平均存取时间大约是()。<br>A. 8.1ms   B. 12.2ms   C. 16.3ms   D.20.5ms</strong><br>若题目中未给出<strong>旋转延迟时间</strong>，那么就默认为<strong>磁盘转半圈所需时间</strong><br>平均时间=寻道（8ms）+平均旋转延迟（旋转延迟=60s/7200r/min=8.3ms，8.3/2=4.15ms）+传输时间（8.3ms/1000=0.0083）=B</p></li><li><p><strong>假定用作 Cache 的 SRAM 的存取时间为 2ns，用作主存的 SDRAM 的存取时间为 40ns。为使存储系统的平均存取时间达到3ns，则Cache命中率应达到()左右<br>A.92.5%   B.85%   C.97.5%   D.99.9%</strong><br>Cache 命中时的存取时间为 2ns；Cache 不命中时先访问 Cache，再访问主存，总存取时间为42ns。设 Cache 命中率为x，则平均存取时间为2×x+42x(1-x)=3，解得x= 97.5%。</p></li><li><p><strong>下列关于高速缓存 Cache 的描述中，正确的是()<br>A.Cache 的功能全部由硬件实现<br>B.Cache 替换时的单位为字|<br>C.Cache 与主存统一编址，即主存地址空间的某一部分属于Cache<br>D.无论何时，Cache 中的信息一定与主存中的信息一致</strong><br>Cache 的功能完全由硬件实现，A 正确。Cache 替换时的单位是块，而不是字或字节，因为Cache 和主存是以块为单位进行数据交换的。Cache 地址空间和主存地址空间相互独立，通过地址映射把主存地址空间映射到 Cache 地址空间。Cache 中的信息不一定与主存中的信息一致，因为 Cache 可能采用回写策略，只有当被修改的块被换出时才写回主存。</p></li><li><p><strong>下列关于 Cache 的描述中，比较合理的是()。<br>I.指令 Cache 通常比数据 Cache 具有更好的空间局部性<br>II.由于空间局部性，适当增加 Cache 块大小通常会提高命中率<br>III.回写法的写主存操作次数少于直写法<br>A.III   B.I和II   C.Ⅱ和III   D.I和II和III</strong><br>指令 Cache 通常比数据 Cache 具有更好的空间局部性，这是因为指令流通常是顺序执行的，而数据流跳转或随机访问的概率较高,I正确。因为空间局部性，同一主存块中的数据的访问概率较高，所以增加 Cache块大小会提高命中率，Ⅱ正确。写回法只有在被修改的块被换出时才写回主存，而直写法每次写操作都会同时写回主存，正确。</p></li><li><p><strong>某个具有两级 Cache 的存储系统中，访存时依次通过两级 Cache，某程序在执行过程中访存 1000 次，其中访问第一级 Cache 时有 40 次不命中，接着访问第二级 Cache，仍有10次不命中，则总命中率是()<br>A.99%   B.96%   C.95%   D.97%</strong><br>二级Cache看的是第二次命中率，（1000-10）/1000=A</p></li><li><p><strong>某存储系统中，主存容量是 Cache 容量的 4096 倍，Cache 被分为 64个块，当主存地址和 Cache 地址采用直接映像方式时，地址映射表的大小应为( )。(假设不考虑一致维护和替换算法位。)<br>A.6x4097bit   B.64x12bit   6x4096bit   D.64x13bit</strong><br>地址映射表仅计算地址映射表（Tag Store）的容量，不包含数据存储区，一致维护对应脏位，替换算法只有LRU需要考虑。主存容量是Cache容量的2^n倍，就是标记位位数12，Cache总容量=64×(标签位12+有效位1)=D</p></li><li><p><strong>有效容量为128KB的Cache，每块16B，采用8路组相联。字节地址为1234567H的单元调入该 Cache，则其Tag应为()<br>A. 1234H   B.2468H   C.048DH   D. 12345H</strong><br>一块16B，按字节编址，16B/1B=16，一块有16个存储单元，即组内地址占4位。8路组相联即一个组有8块，128KB/(8×16B)=2^10，组号占10位。字节地址7×4=24位，标记位有28-4-10=14位，即0001 0010 0011 01，从后往前数0000 0100 1000 1101=C</p></li><li><p><strong>有一主存-Cache 层次的存储器，其主存容量为1MB，Cache 容量为16KB，每块有8个字，每字32位，采用直接地址映像方式，Cache起始字块为第0块，若主存地址为 35301H，且CPU访问Cache命中，则在Cache的第（）(十进制表示)字块中<br>A. 152   B. 153   C. 154   D.151</strong><br>主存：6-9-5，A</p></li><li><p><strong>设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中，则按字节编址逻辑地址的有效位是()，物理地址至少是()位。<br>A. 10，12   B. 10，15   C. 13，15   D. 13，12</strong><br>对于逻辑地址，看逻辑页面有多大，8×1024=2^13B，因此逻辑地址共 13 位。物理地址看物理容量，32个块，每个块有1024B，所以15</p></li><li><p><strong>对于n路组相联映射 Cache，在保持n及主存和 Cache 总容量不变的前提下，将主存块大小和 Cache 块大小都增加一倍，则下列描述中正确的是()。<br>A.字块内地址的位数增加1位，主存tag 字段的位数增加1位<br>B.字块内地址的位数增加1位，主存tag 字段的位数不变<br>C.字块内地址的位数减少1位，主存tag字段的位数增加1位<br>D.字块内地址的位数增加1倍，主存tag字段的位数减少一半</strong><br>tag位数=log2(主存容量/Cache容量)<br><strong>字块内地址</strong></p><ul><li>原块大小为 B ，块内地址占 $\log_2 B$ 位。</li><li>新块大小为 2B ，块内地址占 $\log_2 (2B) = \log_2 B + 1$ 位。</li><li><strong>结论</strong>：块内地址位数<strong>增加1位</strong>。<br><strong>组索引</strong></li><li>原组数 $S = \frac{\text{Cache总块数}}{n}$ ，组索引占 $\log_2 S$ 位。</li><li>新块大小翻倍后，Cache总块数减半，组数变为 $S’ = \frac{S}{2}$ ，组索引占 $\log_2 S’ = \log_2 S - 1$ 位。</li><li><strong>结论</strong>：组索引位数<strong>减少1位</strong>。<br><strong>主存Tag字段</strong></li><li>主存地址总位数固定（因总容量不变）。</li><li>原Tag位数： $\text{主存地址位数} - (\text{组索引位数} + \text{块内地址位数})$ 。</li><li>新Tag位数： $\text{主存地址位数} - [(\text{组索引位数} - 1) + (\text{块内地址位数} + 1)] = \text{原Tag位数}$</li><li><strong>结论</strong>：主存Tag位数<strong>不变</strong>。B</li></ul></li><li><p><strong>某计算机的 Cache 有 16 行，块大小为 16B，其映射方式可配置为直接映射或 2 路组相联映射，主存按字节编址，主存单元从0开始编号。若依次访问下列主存单元，则不论采取上述哪种映射方式都可能引起 Cache 冲突的是()。<br>A.52 号和 102 号单元   B. 48 号和 308 号单元<br>C.60 号和 160 号单元   D.46 号和 236 号单元</strong><br>组相联：因为从0开始编址，实际单元号=单元号+1，例如48号对应的是第49个，一共16行/2=8组，49/16=3.0625，也就是第4个主存块，由于主存块是从0开始编址的，所以主存块号为3，3%8=3；308也相应计算得到主存块号为19%8=3，冲突<br>直接映射：主存块号%行，48号对应第的主存块号是3，%16=3，308是19%16=3，也冲突</p></li><li><p><strong>假设主存地址位数为 32 位，按字节编址，主存和Cache 之间采用全相联映射方式，主存块大小为1个字，每字32位，采用回写(write back)方式和随机替换策略，则能存放 32K字数据的 Cache 的总容量至少应有( )位。<br>A. 1536K   B.1568K   C.2016K   D.2048K</strong><br>Cache总容量=行数{32K字/1个字}×(Tag位30+有效位1+脏位1+数据块大小32)=D</p></li><li><p><strong>【2015 统考真题】假定主存地址为 32位，按字节编址，主存和Cache 之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写方式，则能存放4K字数据的Cache的总容量的位数至少是()<br>A. 146K   B. 147K   C.148K   D.158K</strong><br>主存块4×32位/8位=2^4，块内地址大小4bit<br>4K字数据，一个块4字，共1K=2^10行，行号10bit<br>Tag=32-4-10=18bit<br>Cache总容量=行数×(Tag位+有效位+脏位（回写时需加）+数据块大小)，每行数据块大小是4×32位，Cache总容量=(4×32+18+1+1)×1K=C</p></li><li><p><strong>假设主存按字节编址，Cache 共有64行，采用4路组相联映射方式，主存块大小为 32字节，所有编号都从0开始。则第2593号存储单元所在主存块的Cache组号是()。1/15/14/4</strong><br>64/4=2^4，4组，4bit；主存地址=2^5，5bit；2593=101 0001 00001，组号1</p></li><li><p><strong>假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需1个时钟周期，存储器准备一个数据需8个时钟周期，总线上每传送1个数据需1个时钟周期。若主存和Cachc之间交换的主存块大小为64B，存取宽度和总线宽度都为8B，则Cache 的一次缺失损失至少为( )个时钟周期。64/72/80/160</strong><br>Cache缺失损失：CPU在Cache未命中时，从主存读取整个主存块到Cache的时间。<br>一次缺失损失需要从主存读出一个主存块(64B)，每个总线事务读取 8B，因此需要8个总线事务。<br>CPU通过存储器总线读取数据的过程：</p><ol><li>发送地址和读命令需1个时钟周期。</li><li>存储器准备一个数据需8个时钟周期。</li><li>总线上每传送1个数据需1个时钟周期。<br>单次总时间：10个时钟周期，共需要80个时钟周期。<br>本题无突发传送 ，每次传输需独立完成地址发送、数据准备和传输。<br>顺序执行，无并行优化。</li></ol></li><li><p><strong>假定8个存储器模块采用交叉方式组织，存储器芯片和总线支持突发传送，CPU通过存储器总线读取数据的过程为：发送首地址和读命令需1个时钟周期，存储器准备第一个数据需8个时钟周期，随后每个时钟周期总线上传送1个数据，可连续传送8个数据（突发长度为 8）。若主存和 Cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 Cache 的一次缺失损失至少为()个时钟周期 17/20/33/80</strong><br>本题有突发传送+交叉存储</p><ol><li><strong>突发传送</strong>：一次总线事务可连续传输多个数据（本题中为8个）。</li><li><strong>交叉存储</strong>：多个存储器模块并行工作，通过流水线减少延迟。</li><li><strong>突发长度8</strong>：一次传输64B（8B×8），覆盖整个主存块。<br><strong>单次总线事务的步骤</strong>：</li></ol><ul><li><p>发送首地址和读命令：1周期。</p></li><li><p>准备第一个数据：8周期（后续数据通过流水线准备）。</p></li><li><p>连续传输8个数据：8周期（每周期传1个数据）。</p></li><li><p><strong>总时间</strong>：1+8+8=171+8+8=17 周期。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250415194239621.png" alt="image.png|300"></p></li></ul></li><li><p><strong>若计算机按字编址，Cache 数据区容量为 8K 字，主存块大小为 512 字，主存地址空间为 1M 字，采用2路组相联映射方式。每次根据主存地址访问Cache 时，需要同时进行()次tag位的比较，每次需要比较的位数是()。<br>A. 2.8   B. 2.16   C. 4.8   D. 4.16</strong><br>主存地址20位，主存块内地址9位，Cache总行数8K/512=16行，组数16/2=8组，索引位3位，Tag位数20-3-9=8位。<br>比较过程：<br>每次访问时，根据索引位定位到1组，每组有2行，需同时比较2行的Tag位。<br>每次比较的Tag位数为8位。</p></li><li><p><strong>【2016 统考真题】有如下C语言程序段：<br>for(k=0;k&lt;1000;k++)<br>a[k]= a[k]+ 32;<br>若数组a和变量k均为 int型，int型数据占 4B，数据 Cache  采用直接映射方式，数据区大小为 1KB、块大小为 16B，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组a的 Cache 缺失率约为()。<br>A.1.25%   B.2.5%   C.12.5%   D.25%</strong><br>Cache总块数=1K/16B=64块<br><code>a[k]= a[k]+ 32;</code>要先读<code>a[k]</code>，再写入<code>a[k]</code>，每个元素被 <strong>读和写各一次</strong>，需要读写2次。循环访问 <code>a[0]</code> 到 <code>a[999]</code>（共2000次访问）。<br>每4个连续元素属于同一主存块（如 <code>a[0]~a[3]</code> 属于块0，<code>a[4]~a[7]</code> 属于块1，依此类推）。<br>块大小16B，int型占4B，所以一个块可以放4个数组元素，访问8次</p><ul><li><strong>首次访问块内元素</strong>（如 <code>a[0]</code>）时，触发Cache缺失，加载整个块（包含4个元素）。</li><li><strong>后续访问同一块的其他元素</strong>（如 <code>a[1]</code>、<code>a[2]</code>、<code>a[3]</code>）均命中。</li><li><strong>每个块共8次访问</strong>（4元素×读+写），其中 <strong>仅第一次读操作缺失</strong>，其余7次命中。<br><strong>缺失率计算</strong>：</li><li><strong>总缺失次数</strong>：1000元素 / 4元素/块 = 250块 → 250次缺失（每块首次读缺失）。</li><li><strong>总访问次数</strong>：1000元素 × 2次（读+写） = 2000次。</li><li><strong>缺失率</strong>：250 / 2000 = <strong>12.5%</strong>。</li></ul></li><li><p><strong>【2022 统考真题】若计算机主存地址为 32 位，按字节编址，某 Cache 的数据区容量为32KB，主存块大小为 64B，采用8路组相联映射方式，该 Cachc 中比较器的个数和位数分别为( )<br>A. 8,20   B. 8,23   C.64,20   D. 64,23</strong><br>比较器的作用：检查主存地址的Tag是否与Cache行的Tag匹配<br><strong>不同映射方式的比较器数量</strong>：</p><ul><li><strong>直接映射</strong>：1个（每个主存块唯一映射到Cache的某一行）。</li><li><strong>全相联映射</strong>：等于Cache总行数（所有行同时比较）。</li><li><strong>组相联映射</strong>：等于每组的路数（如本题中的8路）。<br>块内地址6，组索引6，Tag20，组相联映射每组8行，比较器个数为8，每个比较器需要比较Tag位20</li></ul></li><li><p><strong>虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是<br>A.在程序的执行过程中，程序对主存的访问是不均匀的<br>B.空间局部性<br>C.时间局部性<br>D.代码的顺序执行</strong><br>在虚拟存储管理系统中，程序只能访问主存获得指令和数据，A 正确。选项 B、C、D 均是局部性原理的一个方而而己。</p></li><li><p><strong>虚拟存储器的常用管理方式有段式、页式、段页式，对于它们在与主存交换信息时的单位，以下表述正确的是()。<br>A.段式采用“页”                   B.页式采用“块”<br>C.段页式采用“段”和“页&quot;      D.页式和段页式均仅采用“页&quot;</strong><br>页式虚拟存储方式对程序分页，采用页进行交互<br>段页式则先按照逻分段，然后分页，以页为单位和主存交互，D正确。</p></li><li><p><strong>下列关于 Cache 与虛拟存储器的说法中，错误的有()。<br>I.一次访存时，页表不命中，则Cache 一定也不命中<br>II.Cache 不命中的损失要大于页表不命中的损失<br>III.Cache 和 TLB 缺失后的处理都由硬件完成<br>IV.虚拟存储器的实际容量可以大于主存和辅存的容量之和<br>A.I和II   B.II和III   C.I和III和IV   D.I和III和IV</strong><br>页表不命中，表示该页面没有调入主存，而 Cache 是页面的副本，因此 Cache 一定也不命中I正确。<br>Cache 不命中时只需从主存读取数据，页表不命中时需要从辅存读取数据，而辅存的速度比主存慢很多，II错误。<br>Cache 缺失处理由硬件完成，TLB 缺失处理既可以由硬件完成，又可以由软件完成，Ⅲ错误。<br>虚拟存储器的实际容量小于或等于主存和辅存的容量之和，IV错误。D</p></li><li><p><strong>下列有关页式存储管理的叙述中，错误的是()。<br>A.进程地址空间被划分成等长的页，内存被划分成同样大小的页框<br>B.采用全相联映射，每页可以映射到任何一个空闲的页框中<br>C.当从磁盘装入的信息不足一页时会产生页内碎片<br>D.相对于段式存储管理，分页式更利于存储保护</strong></p><ol><li><p><strong>选项 A</strong><br><strong>正确</strong>。页式存储管理的核心特征是将进程的地址空间划分为<strong>固定大小的页</strong>，物理内存划分为相同大小的<strong>页框（Frame）</strong>。这种设计消除了外部碎片，简化了内存分配逻辑。</p></li><li><p><strong>选项 B</strong><br><strong>正确</strong>。页式存储管理采用<strong>全相联映射</strong>，即任意逻辑页可以映射到任意物理页框，只要目标页框空闲。这种灵活性通过页表实现，每个页表项独立记录页框映射关系。</p></li><li><p><strong>选项 C</strong><br><strong>正确</strong>。<strong>页内碎片</strong>是页式管理的固有缺陷。当进程所需内存不足一页时，仍需分配完整的一页，导致页内部分空间未被利用。例如，若页大小为 4KB，进程仅需 3KB，则剩余 1KB 成为页内碎片。</p></li><li><p><strong>选项 D</strong><br><strong>错误</strong>。段式存储管理更利于<strong>存储保护</strong>，原因如下：</p></li></ol><ul><li><strong>段式管理</strong>基于逻辑段（如代码段、数据段），每段可独立设置访问权限（读/写/执行），天然支持模块化保护。</li><li><strong>页式管理</strong>的存储保护依赖页表项中的权限位（如 <code>R/W/X</code>），但页是物理划分单位，无法直接关联程序逻辑结构，保护粒度较粗。</li></ul><p>P155略</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储层次结构（Cache/主存/辅存） </tag>
            
            <tag> 主存储器组成（MAR/MDR） </tag>
            
            <tag> Cache工作原理（映射/替换策略） </tag>
            
            <tag> 存储器性能指标（带宽/延迟） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 2 章 数据的表示与计算</title>
      <link href="/post/e72f3b9c.html"/>
      <url>/post/e72f3b9c.html</url>
      
        <content type="html"><![CDATA[<h1>1 计算机内部的数据表示</h1><h2 id="1-1-数值转换与编码">1.1 数值转换与编码</h2><p>基数r：进位计数制中，每个数位所用到的不同数码个数<br>真值（前面带+/-）：现实中用于计算的数据，在计算机中不存在；<br>正数或负数的真值为其绝对值对应的二进制数前面加上正号或负号。<br>例如+1 表示为 +00000001，-1 表示为 -00000001；<br>移码大真值就大<br>补码若符号位相同，数值位越大（即二进制中1的位数越多），码值越大。若 <code>1</code> 的个数相同，<strong>最高位的 <code>1</code> 位置越靠左（权重越大），码值越大</strong>。</p><table><thead><tr><th><strong>进制名称</strong></th><th><strong>基数</strong></th><th><strong>数码范围</strong></th><th><strong>进位规则</strong></th><th><strong>权值</strong></th><th><strong>示例</strong></th><th><strong>二进制转换规则</strong></th><th><strong>表示方法（后缀/前缀）</strong></th><th><strong>C语言表示</strong></th></tr></thead><tbody><tr><td><strong>二进制</strong></td><td>2</td><td>0, 1</td><td>逢二进一</td><td>2^i</td><td>101011<sub>2</sub></td><td>3位二进制 → 1位八进制</td><td>后缀<code>B</code>（如<code>101011B</code>）</td><td><code>0b101011</code></td></tr><tr><td><strong>八进制</strong></td><td>8</td><td>0, 1, 2, 3, 4, 5, 6, 7</td><td>逢八进一</td><td>8^i</td><td>101011<sub>8</sub></td><td>1位八进制 → 3位二进制</td><td>后缀<code>O</code>（如<code>101011O</code>）</td><td><code>0101011</code>（前导0）</td></tr><tr><td><strong>十进制</strong></td><td>10</td><td>0, 1, 2, …, 9</td><td>逢十进一</td><td>10^i</td><td>101011<sub>10</sub></td><td>无直接转换</td><td>无后缀（如<code>101011</code>）</td><td><code>101011</code></td></tr><tr><td><strong>十六进制</strong></td><td>16</td><td>0-9, A-F（10-15）</td><td>逢十六进一</td><td>16^i</td><td>101011<sub>16</sub></td><td>4位二进制 → 1位十六进制</td><td>后缀<code>H</code>（如<code>101011H</code>）</td><td><code>0x101011</code></td></tr><tr><td>2^-1=0.5，2^-2=0.25，2^-3=0.125</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><p><strong>二进制↔八进制数</strong><br>二进制→八进制：从小数点向左右划分，每三个一组，不够的补零<br>八进制→二进制：每个八进制数转换为三位二进制数，前后去0</p></li><li><p><strong>二进制↔十六进制数</strong><br>二进制→十六进制：从小数点向左右划分，每四个一组，不够的补零<br>十六进制→二进制：每个十六进制数转换为四位二进制数，前后去0</p></li><li><p><strong>八进制→十六进制</strong><br>先转二进制，在转十六进制</p></li><li><p><strong>十进制小数→任意进制（除基取余，乘基取整）</strong><br>除基取余针对整数部分，乘基取整针对小数部分<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328084356810.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328084506522.png" alt="image.png"></p><ul><li><strong>注</strong>：<br>若转换后无限循环（精度缺失），需根据精度要求截断。<br>十进制小数转八进制和十六进制小数也可能出现精度缺失</li></ul></li><li><p><strong>BCD码（Binary-Co ded Decimal）</strong></p><ul><li><strong>压缩BCD码</strong>：用<font color="#ff0000">4位</font>二进制表示1位十进制数（如 <code>9 → 1001</code>）。</li><li><strong>非压缩BCD码</strong>：用<font color="#ff0000">8位</font>二进制表示1位十进制数（如 <code>9 → 00001001</code>）。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328090505451.png" alt="image.png"></li><li><strong>常见编码类型</strong>：<ul><li><strong>8421码（自然BCD码）</strong>：<ul><li>加法后若结果超过9（如 <code>1001 + 1001 = 1 0010</code>），需加 <code>0110</code>（6）校正。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328090725385.png" alt="image.png"></li></ul></li><li><strong>余3码</strong>：无权码，每个数比原值大3（如 <code>0 → 0011</code>）。</li><li><strong>2421码</strong>：有权码，5~9的最高位为1（如 <code>5 → 1011</code>）。</li></ul></li></ul></li><li><p><strong>ASCII码</strong></p><ul><li><strong>范围</strong>：<ul><li><code>0-9</code>：<code>30H-39H</code>（48-57）。</li><li><code>A-Z</code>：<code>41H-5AH</code>（65-90）。</li><li><code>a-z</code>：<code>61H-7AH</code>（97-122）。</li></ul></li></ul></li></ol><h2 id="1-2-定点数的编码">1.2 定点数的编码</h2><h3 id="1-2-1-定点数">1.2.1 定点数</h3><ul><li><strong>定义</strong>：小数点位置固定，分为<strong>定点整数</strong>和<strong>定点小数</strong>。</li><li><strong>表示范围</strong>：</li></ul><table><thead><tr><th>类型</th><th>范围（n位）</th><th>8位二进制范围</th></tr></thead><tbody><tr><td><strong>定点整数</strong></td><td>$-2^{n-1} \leq x \leq 2^{n-1} - 1$</td><td>-128~127</td></tr><tr><td><strong>定点小数</strong></td><td>$-1 \leq x \leq 1 - 2^{-(n-1)}$</td><td>-1~0.992</td></tr></tbody></table><ul><li><p>数据范围影响因素</p><ul><li>机器字长：越长，越大</li><li>所采用的机器码：补码和移码所能表示的数据范围，比原码和反码所能表示的数据范围要多一个最小负数。</li></ul></li><li><p><strong>定点整数</strong>：</p><ul><li>小数点固定在数值位最右侧。<br>一般用<mark>补码</mark>表示<br>总位数为 n+1 位，给定真值  x ，其补码 [x]补 定义为：$[x]_{\text{补}} = \begin{cases} x &amp; \text{若 } 0 \leq x &lt; 2^{n}, \2^{n+1} + x &amp; \text{若 } -2^{n} \leq x &lt; 0 \ (\text{mod } 2^{n+1}).\end{cases}$<ul><li><strong>模数</strong>： $2^{n+1}$ ，即补码表示的数值范围在模  $2^{n+1}$  下。<br>以  n = 3 （总位数  n+1 = 4 ）为例：</li><li>x = -5 ：补码为  $2^{4} + (-5) = 16 - 5 = 11$ ，即 <code>1011</code>。</li></ul></li></ul></li><li><p><strong>定点小数</strong>：</p><ul><li>小数点固定在符号位右侧。</li><li><strong>示例</strong>：<code>1.011</code>表示<code>-0.625</code>（补码）。</li></ul></li></ul><p>注：拓展位不一样<br>定点小数：<br>[x]原=1.110<br>[x]原= 1.1100000<br>定点整数：<br>[x]原=1,110<br>[x]原= 1,0000110</p><h3 id="1-2-2-原码">1.2.2 原码</h3><ol><li><p><strong>定义</strong>：</p><ul><li>原码是最基础的二进制表示方法，<strong>符号位 + 数值位</strong>。</li><li><strong>符号位</strong>：最高位，<code>0</code>表示正数，<code>1</code>表示负数。</li><li><strong>数值位</strong>：绝对值的二进制形式。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><code>+5</code>（4位）：<code>0 101</code></li><li><code>-5</code>（4位）：<code>1 101</code></li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>优点</strong><ul><li>与真值的对应关系简单、直观，与真值的转换简单</li><li>用原码实现乘除运算比较简便。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>符号位不能直接参与运算</strong>，用原码实现加减运算比较复杂</li><li><strong>0的表示不唯一，有±0两个编码</strong>：<code>+0</code>（<code>0 000</code>）和 <code>-0</code>（<code>1 000</code>）。</li></ul></li></ul></li></ol><p>原码在计算机中仅用于表示浮点数的尾码<br>计算：<br>加法:正+正或负+负 结果可能溢出<br>减法：负数取反</p><h3 id="1-2-3-反码">1.2.3 反码</h3><ol><li><p><strong>定义</strong>：</p><ul><li><strong>正数</strong>：与原码相同。</li><li><strong>负数</strong>：符号位不变，数值位按位取反。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><code>+5</code>（4位）：<code>0 101</code></li><li><code>-5</code>（4位）：<code>1 010</code></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>符号位可以参与运算</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>最高位(符号位)产生的进位要加到运算结果的低位(循环进位)</li><li>真值0在反码中有两种不同的表示</li></ul></li></ol><h3 id="1-2-4-补码">1.2.4 补码</h3><ol><li><p><strong>定义</strong>：</p><ul><li><strong>正数</strong>：与原码相同。</li><li><strong>负数</strong>：反码加1（符号位不变）。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><code>+5</code>（4位）：<code>0 101</code></li><li><code>-5</code>（4位）：<code>1 011</code>（反码<code>1 010</code> + 1）</li></ul></li><li><p><strong>优点</strong>：</p><ul><li><strong>统一加减法</strong>：减法可转换为加法（<code>A - B = A + (-B)</code>）。</li><li><strong>唯一0表示</strong>：<code>0 000</code>，无<code>-0</code>。使得补码比原码多表示一个最小负数</li><li><strong>硬件友好</strong>：无需额外处理符号位，简化电路设计。</li></ul></li><li><p><strong>缺点</strong>：<br>补码的表示相对原码更加复杂。<br>原码的数值位与真值的绝对值相同。因此，通过原码可以很容易地得出真值。但是，补码就没有这么简单了。</p></li><li><p><strong>补码快速转换</strong>：</p><ul><li>从右往左找到第一个<code>1</code>，该位左侧数值位取反。</li><li><strong>示例</strong>：<code>-5</code>（原码<code>1 101</code> → 补码<code>1 011</code>）。</li></ul></li></ol><p>补码1111 1111是-1<br>补码1000 0000是-128<br>8位补码所表示的真值x的范围：-128 ≤ x ≤ 127<br>16位补码所表示的真值x的范围：-32768 ≤ x ≤ 32767<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328123122040.png" alt="image.png"><br>3. <strong>补码运算示例</strong>：<br>$[A + B]<em>{\text{补}} = [A]</em>{\text{补}} + [B]<em>{\text{补}}, \quad [A - B]</em>{\text{补}} = [A]<em>{\text{补}} + [-B]</em>{\text{补}}$<br>可以验证结果$[A + B]<em>{\text{补}} = [A+B]</em>{\text{补}}$<br>$(-5) + 3 = 11111011_2 + 00000011_2 = 11111110_2 = -2_{10}$<br>[-0.0101]原=[1.1011]补<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328123942413.png" alt="image.png|350">补码的补码是原码<br>[x]补=1,011 0100 [x]原=1,100 1100<br>4. 补码的真值计算公式为：<br>$真值=−符号位×2^{n−1}+剩余位的无符号值$<br>对于 <code>11100000</code>：$真值=−1×2^7+1100000_2=−128+96=−32$<br>技巧：对于n位补码，其真值为最高位的-2^(n-1)加上其余各位的正权重之和。<br>eg.<code>1 1011</code>=-2^4+8+2+1=-5<br>5. $[-x]<em>{\text{补}} = \text{全部位取反}([x]</em>{\text{补}}) + 1$<br><mark>对-40求补运算，就是求40的补码。就是求相反数的补码</mark><br>1. <strong>正数转负数</strong>：<br>- 设[x]补 = <code>00000101</code>（+5）<br>- <strong>取反</strong>：<code>11111010</code><br>- <strong>加1</strong>：<code>11111010 + 1 = 11111011</code><br>- <strong>结果</strong>：[-x]补 = <code>11111011</code>（-5）</p><pre><code>2. **负数转正数**：   - 设\[x\]补 = `11111011`（-5）     - **取反**：`00000100`     - **加1**：`00000100 + 1 = 00000101`     - **结果**：\[-x\]补 = `00000101`（+5）</code></pre><ol start="6"><li>定点小数的补码<br>正数补码和原码相同，负数补码定义为$[X]<em>{\text{补}} = 2 + X$（模2）。<br>负数的补码是其绝对值的“模2补数”。<br>eg.X = -0.101，则：$[X]</em>{\text{补}} = 2 + (-0.101) = 10.000 + 1.011 = 11.011(\text{舍去超过整数位的最高位}) = 1.011 \quad (\text{二进制})$<br>对于整数部分占1位、小数部分占n位的数，补码的一般形式为：$[X]<em>{\text{补}} = 2^{n+1} + X \quad (\text{模 } 2)$<br>eg.n=3，X = -0.101$[X]</em>{\text{补}} = 2^{4} + (-0.101) = 16 - 0.625 = 15.375 \mod 16 = 1.011 \quad (\text{二进制})$  对应补码 <code>1.011</code>（十进制 -0.101）。</li><li>补码加减法的硬件实现<br>补码加减法可通过<strong>同一个加法器</strong>实现，核心设计如下：<ul><li><strong>控制信号 <code>Sub</code></strong>：决定执行加法或减法。</li><li><strong><code>Sub = 0</code></strong>：加法运算，输入为 <code>X</code> 和 <code>Y</code>。</li><li><strong><code>Sub = 1</code></strong>：减法运算，输入为 <code>X</code> 和 <code>Y</code> 的反码，并<strong>末位加1</strong>（通过低位进位实现）。</li><li><strong>电路设计</strong>：</li><li><strong>多路选择器（MUX）</strong>：选择 <code>Y</code> 或 <code>~Y</code>（取反）。</li><li><strong>加法器</strong>：接收 <code>X</code> 和 MUX 输出，同时将 <code>Sub</code> 作为初始<strong>低位进位输入</strong>（减法时 <code>C_in = 1</code>）。<br><strong>示例</strong>：</li><li>减法运算：<code>X - Y</code> 转换为 <code>X + (~Y) + 1</code>，即 <code>[X]补 + [-Y]补</code>。</li><li>电路公式：<code>Result = X + (Y ^ &#123;n&#123;Sub&#125;&#125;) + Sub</code>（异或门实现按位取反）。</li></ul></li></ol><h3 id="1-2-5-移码">1.2.5 移码</h3><ol><li>移码就是在真值上加一个常数 2^n（补码最前一位取反）</li><li>在数轴上，移码所表示的范围对应于真值在数轴上的范围向轴的正方向移动2^n个单元</li><li>移码只用于<strong>定点整数</strong>的表示。</li><li>优点：<ul><li>真值0在移码中只有一种表示。</li><li>移码保持了真值原有的大小顺序，可以<strong>直接比较大小</strong>。最小真值的移码为全0，最大真值的移码为全1，符合人们的习惯</li><li>当浮点数的阶码用移码来表示时，就能很方便地比较阶码的大小。</li></ul></li></ol><p>注：<br><strong>1. 移码与补码的转换适用场景</strong></p><ul><li><strong>移码</strong> 主要用于 <strong>浮点数的阶码（指数部分）</strong>，目的是将指数值转换为无符号整数，便于直接比较大小。</li><li><strong>补码</strong> 用于 <strong>普通有符号整数</strong>，简化加减法运算。</li><li><strong>关键区别</strong>：<ul><li>移码的真值计算依赖 <strong>偏置值</strong>，公式为：$\text{真值} = \text{移码值} - \text{偏置值}$</li><li>补码的真值计算依赖 <strong>符号位和数值位</strong>，无需偏置值。</li><li><font color="#ff0000">移码和补码的转换 仅在浮点数阶码处理时结合使用，普通整数无需混合操作。</font></li></ul></li></ul><p>在IEEE 754中，移码用于表示浮点数的指数（阶码），其核心公式为：</p><ul><li><strong>偏置值</strong>：对于8位阶码，IEEE 754单精度浮点数使用 <strong>Bias = 127</strong>。其他情况是128</li><li><strong>真值范围</strong>：移码值是无符号整数，8位范围为 $0 \leq \text{移码值} \leq 255$，对应真值范围为 $-127 \leq \text{真值} \leq 128$。<br>eg.<strong>真值</strong>：-128  $\text{移码值} = -128 + 127 = -1$<ul><li>由于移码值需为无符号数，负数结果需进行模运算：<br>$-1 \mod 256 = 255 \quad \Rightarrow \quad 255_{(10)} = 11111111_{(2)}$<br>eg.- <strong>真值</strong>：-127  $\text{移码值} = -127 + 127 = 0$</li><li>直接转换为无符号数：$0_{(10)} = 00000000_{(2)}$</li></ul></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328131557327.png" alt="image.png|450"><br>n位能表示$2^{n-1}$个原码，$2^n$个补/移码</p><table><thead><tr><th><strong>编码类型</strong></th><th><strong>合法表示范围</strong></th><th><strong>最大的数（二进制）假设8位</strong></th><th><strong>最小的数（二进制）</strong></th><th><strong>真值0的表示</strong></th></tr></thead><tbody><tr><td><strong>原码（n+1位）</strong></td><td>$-(2^n - 1) \leq x \leq 2^n - 1$<br>[-127,127] 255个<br>最小正数1<br>最大负数-1</td><td><code>0,1111111</code>$2^n - 1$</td><td><code>1,1111111</code>$-(2^n - 1)$</td><td><code>0,0000000</code>（+0）<br><code>1,0000000</code>（-0）</td></tr><tr><td><strong>反码（n+1位）</strong></td><td>$-(2^n - 1) \leq x \leq 2^n - 1$<br>[-127,127] 255个<br>最小正数1<br>最大负数-1</td><td><code>0,1111111</code>$2^n - 1$</td><td><code>1,0000000</code>$-(2^n - 1)$</td><td><code>0,0000000</code>（+0）<br><code>1,1111111</code>（-0）</td></tr><tr><td><strong>补码（n+1位）</strong></td><td>$-2^n \leq x \leq 2^n - 1$<br>[-128,127] 256个<br>最小正数1<br>最大负数-1</td><td><code>0,1111111</code>$2^n - 1$</td><td><code>1,0000000</code>$-2^n$</td><td><code>0,0000000</code>（唯一表示）</td></tr><tr><td><strong>移码（8位，偏移量128）</strong></td><td>$-2^n \leq x \leq 2^n - 1$<br>[-128,127] 256个<br>最小正数1<br>最大负数-1</td><td><code>11111111</code>$2^n - 1$</td><td><code>00000000</code>$-2^n$</td><td><code>10000000</code>（偏移后0）</td></tr><tr><td><strong>无符号整数（n+1位）</strong></td><td>$0 \leq x \leq 2^{n+1} - 1$<br>[0,255] 256个</td><td><code>1111111</code>$2^{n+1} - 1$</td><td><code>00000000</code>（0）</td><td><code>00000000</code></td></tr><tr><td><strong>定点小数：原码</strong></td><td>$−(1−2^{−n})≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$</td><td><code>01111111</code>$1-2^{-n}$</td><td><code>1111111</code>$-(1-2^{-n})$</td><td><code>0,0000000</code>（+0）<br><code>1,0000000</code>（-0）</td></tr><tr><td><strong>定点小数：反码</strong></td><td>$−(1−2^{−n})≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$</td><td><code>01111111</code>$1-2^{-n}$</td><td><code>10000000</code>$-(1-2^{-n})$</td><td><code>0,0000000</code>（+0）<br><code>1,1111111</code>（-0）</td></tr><tr><td><strong>定点小数：补码</strong></td><td>$-1≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$</td><td><code>01111111</code>$1-2^{-n}$</td><td><code>10000000</code>（-1）</td><td><code>0,0000000</code>（唯一表示）</td></tr></tbody></table><h3 id="1-2-6-负数大小判断">1.2.6 负数大小判断</h3><p>原码：数值位越大，值越小<br>补码和反码：数值位越小，值越小<br>原码很容易判断大小，而负数的补码、反码很难直接判断大小</p><h3 id="1-2-7-定点数的位数扩展">1.2.7 定点数的位数扩展</h3><h4 id="1-2-7-1-定点整数与定点小数的扩展规则">1.2.7.1 定点整数与定点小数的扩展规则</h4><table><thead><tr><th><strong>类型</strong></th><th><strong>扩展方向</strong></th><th><strong>规则</strong></th></tr></thead><tbody><tr><td><strong>定点整数</strong></td><td>高位扩展</td><td>根据编码方式（原码、补码、反码）决定填充 <code>0</code> 或 <code>1</code>（见下文）。</td></tr><tr><td><strong>定点小数</strong></td><td>低位扩展</td><td>小数部分低位补 <code>0</code>（保持精度），高位扩展规则与编码方式一致。</td></tr></tbody></table><h4 id="1-2-7-2-原码、补码、反码的扩展规则">1.2.7.2 原码、补码、反码的扩展规则</h4><table><thead><tr><th><strong>编码类型</strong></th><th><strong>正数扩展规则</strong></th><th><strong>负数扩展规则</strong></th><th><strong>示例（8位 → 16位）</strong></th></tr></thead><tbody><tr><td><strong>原码</strong></td><td>符号位 <code>0</code>，数值位高位补 <code>0</code></td><td>符号位 <code>1</code>，数值位高位补 <code>0</code></td><td><code>+5</code>（原码 <code>00000101</code> → <code>00000000 00000101</code>）<br><code>-5</code>（原码 <code>10000101</code> → <code>10000000 00000101</code>）</td></tr><tr><td><strong>补码</strong></td><td>符号位 <code>0</code>，数值位高位补 <code>0</code></td><td>符号位 <code>1</code>，数值位高位补 <code>1</code>（符号扩展）</td><td><code>+5</code>（补码 <code>00000101</code> → <code>00000000 00000101</code>）<br><code>-5</code>（补码 <code>11111011</code> → <code>11111111 11111011</code>）</td></tr><tr><td><strong>反码</strong></td><td>符号位 <code>0</code>，数值位高位补 <code>0</code></td><td>符号位 <code>1</code>，数值位高位补 <code>1</code></td><td><code>+5</code>（反码 <code>00000101</code> → <code>00000000 00000101</code>）<br><code>-5</code>（反码 <code>11111010</code> → <code>11111111 11111010</code>）</td></tr></tbody></table><h2 id="1-3-整数表示与运算">1.3 整数表示与运算</h2><ol><li><strong>无符号整数（unsigned）</strong> 没有符号位<ul><li><strong>范围</strong>：$0 \sim 2^{n-1}$<code>（n为机器字长）。 8位2进制范围：</code>[0,255]`</li><li><strong>硬件实现</strong>：直接存储二进制原码，无符号位。<br>无符号数用来存地址</li><li>无符号整数溢出时，结果自动对 $2^n$ 取模（n 为位数）。<ul><li><strong>示例</strong>：<ul><li>8位无符号数：256 \mod 256 = 0，-1 \mod 256 = 255。</li><li>移码计算中，负数真值转换为无符号移码值：$\text{移码值} = (\text{真值} + \text{Bias}) \mod 2^n$<br>如8位移码（Bias=127）：$-128 + 127 = -1 \quad \Rightarrow \quad -1 \mod 256 = 255 = 11111111_{(2)}$</li></ul></li></ul></li></ul></li><li><strong>有符号整数（补码表示）</strong><ul><li><strong>范围</strong>：$- 2^{n-1} \sim 2^{n-1} - 1$。<br>8位2进制范围：<code>[-128,128]</code><br>−128<sub>10</sub>​=1000 0000<sub>2</sub> 补码仍为1000 0000<sub>2</sub></li><li><strong>补码转换规则</strong>：<ul><li><strong>正数</strong>：原码、反码、补码相同。</li><li><strong>负数</strong>：原码符号位不变，数值位取反加1。</li></ul></li></ul></li><li><strong>溢出判断</strong><ul><li><p>加减法溢出判断</p><ul><li><mark>**有符号</mark>数溢出（OF）**：只有符号位相同才有可能溢出<ul><li>看符号位与次高位进位是否异或$OF = C_{符号位} \oplus C_{次高位}$       $0111_2 (+7) + 0001_2 (+1) = 1000_2 (-8) \quad (\text{OF}=1)$</li><li>最高数值的进位C<sub>n-1</sub>与符号位C<sub>n</sub>的进位是否一致$OF = C_{n-1} \oplus C_{n}$<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330101044131.png" alt="image.png"></li><li>变形补码（模4补码）01正溢出，10负溢出<br>模4 补码具有模2补码的全部优点且更易检查加减运算中的溢出问题<br>存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的<br>只在把两个模 4 补码的数送往 ALU 完成加减运算时，才把个数的符号位的值同时送到ALU的双符号位中，即只在 ALU 中采用双符号位<br>采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出。<ul><li><strong>正溢出</strong>：两个正数（符号位为 <code>0</code>）相加，结果符号位为 <code>1</code>（负数）。</li><li><strong>负溢出</strong>：两个负数（符号位为 <code>1</code>）相加，结果符号位为 <code>0</code>（正数）。</li></ul></li></ul></li><li><mark>**无符号</mark>数进位（CF）**：最高位进位（加法）或借位（减法）。</li></ul></li><li><p>2个n位无符号与有符号乘法的溢出条件</p></li><li><p>无符号乘法溢出条件：高n位 ≠0<br>两个n位无符号数的乘积最多需要 <strong>2n位</strong> 表示，范围是 $0 \leq \text{乘积} \leq (2^n - 1)^2$。</p><ul><li>若乘积的 <strong>高n位全为0</strong>，说明结果可用n位无符号数表示（范围 $0 \leq \text{结果} \leq 2^n - 1$），<strong>不溢出</strong>。</li><li>若高n位不全为0，说明结果超出n位范围（&gt; $2^n - 1$），<strong>溢出</strong>。</li></ul></li><li><p>有符号乘法溢出条件：高n+1位≠全0或全1<br>两个n位补码数的乘积最多需要 <strong>2n位</strong> 表示，范围是 $-2^{2n-2} \leq \text{乘积} \leq (2^{n-1}-1)^2$。</p><ul><li>若乘积的 <strong>高n+1位全为0或全为1</strong>，说明结果可用n位补码表示（符号位扩展一致），<strong>不溢出</strong>。</li><li>若高n+1位不全为0或不全为1，说明结果超出n位补码范围，<strong>溢出</strong>。<ul><li>补码乘法需要符号位扩展。若乘积的高n+1位全为0，表示正数且数值在n位范围内。</li><li>若高n+1位全为1，表示负数且数值在n位范围内。</li><li>若高n+1位不一致（如部分0和部分1），说明结果无法正确用n位补码表示。</li></ul></li></ul></li></ul></li></ol><table><thead><tr><th><strong>类型</strong></th><th><strong>溢出条件</strong></th><th><strong>示例（n=4）</strong></th></tr></thead><tbody><tr><td><strong>无符号乘法</strong></td><td>乘积高n位不全为0 → 溢出</td><td>$15 \times 15 = 225$（溢出）</td></tr><tr><td><strong>有符号乘法</strong></td><td>乘积高n+1位不全为0或不全为1 → 溢出</td><td>$-8 \times -8 = 64$（溢出）</td></tr></tbody></table><ul><li>零标志ZF=1 结果为零【都】</li><li>符号标志SF=1 结果为负【有符号数】</li><li><strong>运算器不区分数据类型</strong>：同一电路处理两种数（有符号、无符号），但需通过<strong>标志位</strong>解释结果。</li></ul><table><thead><tr><th><strong>标志位</strong></th><th><strong>名称</strong></th><th><strong>作用</strong></th><th><strong>逻辑表达式</strong></th></tr></thead><tbody><tr><td><strong>ZF</strong></td><td>零标志</td><td>结果为0时置1，否则置0。对所有运算有效。</td><td><code>ZF = 1</code> ⇨ <code>Result == 0</code></td></tr><tr><td><strong>OF</strong></td><td>溢出标志</td><td><strong>仅对有符号数有效</strong>，表示结果超出范围。</td><td><code>OF = C_n ⊕ C_&#123;n-1&#125;</code></td></tr><tr><td><strong>SF</strong></td><td>符号标志</td><td><strong>仅对有符号数有效</strong>，表示结果的符号（最高位）。</td><td><code>SF = Result[n-1]</code></td></tr><tr><td><strong>CF</strong></td><td>进位/借位标志</td><td><strong>仅对无符号数有效</strong>，加法表示进位，减法表示借位。</td><td><code>CF = Sub ⊕ C_out</code></td></tr></tbody></table><ol start="4"><li>数值比较的逻辑<br><strong>(1) 无符号数比较（执行 <code>A - B</code>）</strong></li></ol><table><thead><tr><th><strong>条件</strong></th><th><strong>标志位状态</strong></th><th><strong>结论</strong></th></tr></thead><tbody><tr><td><code>A = B</code></td><td><code>ZF = 1</code></td><td>相等</td></tr><tr><td><code>A &gt; B</code></td><td><code>ZF = 0, CF = 0</code></td><td>A大于B</td></tr><tr><td><code>A &lt; B</code></td><td><code>ZF = 0, CF = 1</code></td><td>A小于B</td></tr><tr><td><strong>(2) 有符号数比较（执行 <code>A - B</code>）</strong></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>条件</strong></th><th><strong>标志位状态</strong></th><th><strong>结论</strong></th></tr></thead><tbody><tr><td><code>A = B</code></td><td><code>ZF = 1</code></td><td>相等</td></tr><tr><td><code>A &gt; B</code></td><td><code>ZF = 0, OF = SF</code></td><td>A大于B</td></tr><tr><td><code>A &lt; B</code></td><td><code>ZF = 0, OF ≠ SF</code></td><td>A小于B</td></tr></tbody></table><ul><li><strong>未溢出（<code>OF = 0</code>）</strong>：直接根据 <code>SF</code> 判断（<code>SF=0</code> 结果非负，<code>SF=1</code> 结果为负）。</li><li><strong>溢出（<code>OF = 1</code>）</strong>：符号位 <code>SF</code> 与实际大小相反，需结合 <code>OF</code> 修正判断。</li></ul><ol start="5"><li>示例分析<br><strong>(1) 无符号数比较</strong></li></ol><ul><li><strong><code>A = 0000 0011 (3), B = 0000 0010 (2)</code></strong>：<ul><li><code>A - B = 0000 0001</code> → <code>ZF = 0, CF = 0</code> → <code>A &gt; B</code>。</li></ul></li><li><strong><code>A = 0000 0000 (0), B = 0000 0001 (1)</code></strong>：<ul><li><code>A - B = 1111 1111</code> → <code>ZF = 0, CF = 1</code> → <code>A &lt; B</code>。</li></ul></li></ul><p><strong>(2) 有符号数比较</strong></p><ul><li><strong><code>A = 0111 (7), B = 1011 (-5)</code></strong>（补码）：<ul><li><code>A - B = 0111 + 0101 = 1100</code> → <code>SF = 1, OF = 1 → </code>A &gt; B`</li></ul></li></ul><table><thead><tr><th><strong>位</strong></th><th>操作</th><th>进位</th></tr></thead><tbody><tr><td>第1位</td><td>1 + 1 = 0，进位1</td><td>C0=1</td></tr><tr><td>第2位</td><td>1 + 0 + 1 = 0，进位1</td><td>C1=1</td></tr><tr><td>第3位</td><td>1 + 1 + 1 = 1，进位1</td><td>C2=1</td></tr><tr><td>第4位</td><td>0 + 0 + 1 = 1，进位0</td><td>C3=0</td></tr></tbody></table><pre><code>OF=C3⊕C2=0⊕1=1（溢出发生）</code></pre><h2 id="1-4-定点数运算">1.4 定点数运算</h2><h3 id="1-4-1-移位运算">1.4.1 移位运算</h3><ul><li><strong>算术移位（有符号数）</strong>：<ul><li><strong>原码</strong>：符号位不变，数值位补0（左移）或舍弃（右移）。</li><li><strong>补码</strong>：正数同原码；负数左移补0，右移补1。</li><li><strong>反码</strong>：负数空位补1</li></ul></li><li><strong>逻辑移位（无符号数）</strong>：统一补0。<br>应用：RGB</li><li><strong>循环移位</strong>：带进位时用于数据高低位交换（如大端转小端）。<br>适合将数据的第字节数据和高字节数据呼唤</li></ul><h4 id="1-4-1-1-逻辑移位（无符号数）">1.4.1.1 逻辑移位（无符号数）</h4><h5 id="1-4-1-1-1-按位或（-）：将某位置1">1.4.1.1.1 按位或（<code>|</code>）：将某位置1</h5><p><strong>用途</strong>：将特定位设为1，其他位保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT3_MASK (1U &lt;&lt; 3)  <span class="comment">// 掩码: 0x00000008</span></span></span><br><span class="line">regData |= BIT3_MASK;         <span class="comment">// 第3位置1</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000000</code> → 结果 <code>0x00000008</code>。</li><li>若 <code>regData = 0x00000004</code> → 结果 <code>0x0000000C</code>（第2位和第3位均为1）。</li></ul><h5 id="1-4-1-1-2-按位与（-）：将某位清0">1.4.1.1.2 按位与（<code>&amp;</code>）：将某位清0</h5><p><strong>用途</strong>：将特定位设为0，其他位保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT5_MASK ~(1U &lt;&lt; 5)  <span class="comment">// 掩码: 0xFFFFFFDF</span></span></span><br><span class="line">regData &amp;= BIT5_MASK;          <span class="comment">// 第5位清0</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000020</code> → 结果 <code>0x00000000</code>。</li><li>若 <code>regData = 0xFFFFFFFF</code> → 结果 <code>0xFFFFFFDF</code>（仅第5位为0）。</li></ul><h5 id="1-4-1-1-3-按位异或（-）：切换某位状态">1.4.1.1.3 按位异或（<code>^</code>）：切换某位状态</h5><p><strong>用途</strong>：若目标位为1则置0，若为0则置1（翻转位状态）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2_MASK (1U &lt;&lt; 2)  <span class="comment">// 掩码: 0x00000004</span></span></span><br><span class="line">regData ^= BIT2_MASK;         <span class="comment">// 切换第2位状态</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000000</code> → 结果 <code>0x00000004</code>（第2位置1）。</li><li>若 <code>regData = 0x00000004</code> → 结果 <code>0x00000000</code>（第2位清0）。</li></ul><h5 id="1-4-1-1-4-按位非（-）：取反所有位">1.4.1.1.4 按位非（<code>~</code>）：取反所有位</h5><p><strong>用途</strong>：将所有位取反（1变0，0变1）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regData = ~regData;  <span class="comment">// 所有位翻转</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x0000000F</code> → 结果 <code>0xFFFFFFF0</code>。</li><li>若 <code>regData = 0x12345678</code> → 结果 <code>0xEDCBA987</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置第1位和第4位，同时清除第3位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_MASK   ((1U &lt;&lt; 1) | (1U &lt;&lt; 4))  <span class="comment">// 0x00000012</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLEAR_MASK ~((1U &lt;&lt; 3))             <span class="comment">// 0xFFFFFFF7</span></span></span><br><span class="line"></span><br><span class="line">regData |= SET_MASK;    <span class="comment">// 第1、4位置1</span></span><br><span class="line">regData &amp;= CLEAR_MASK;  <span class="comment">// 第3位清0</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000000</code> → 结果 <code>0x00000012</code>。</li><li>若 <code>regData = 0x00000008</code> → 结果 <code>0x00000010</code>（第3位清0，第4位置1）。</li></ul><table><thead><tr><th><strong>操作符</strong></th><th><strong>作用</strong></th><th><strong>示例代码</strong></th></tr></thead><tbody><tr><td>|</td><td>置1特定位</td><td>regData |= (1U &lt;&lt; n)</td></tr><tr><td>&amp;</td><td>清0特定位</td><td>regData &amp;= ~(1U &lt;&lt; n)</td></tr><tr><td>^</td><td>翻转特定位</td><td>regData ^= (1U &lt;&lt; n)</td></tr><tr><td>~</td><td>取反所有位</td><td>regData = ~regData</td></tr></tbody></table><p>eg1.<br>要将变量 <code>regData</code> 中的第6位（从0开始计数）置1而不影响其他位，假设寄存器的内容保存在变量regData中，可以使用以下C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> b6_mask (1 &lt;&lt; 6)  <span class="comment">// 定义掩码，确保无符号移位</span></span></span><br><span class="line">regData |= b6_mask;        <span class="comment">// 按位或操作置位</span></span><br></pre></td></tr></table></figure><ol><li><strong>掩码定义</strong>：<br><code>#define b6_mask (1 &lt;&lt; 6)</code><br>无符号整型常量1，左移6位后得到二进制掩码 <code>01000000</code>（即十六进制 <code>0x40</code>）。</li><li><strong>置位操作</strong>：<br><code>regData |= b6_mask;</code><ul><li>按位或操作 (<code>|=</code>) 将 <code>regData</code> 的第6位设置为1，其他位保持不变。</li></ul></li></ol><p><strong>假设 <code>regData</code> 初始值为 <code>0x28</code>（二进制 <code>00101000</code>）：</strong><br><code>regData |= b6_mask;  // regData = 0x68 (二进制 01101000)</code><br>eg2.<br>要将变量 <code>regData</code> 中的第6位（从0开始计数）清0而不影响其他位，假设寄存器的内容保存在变量regData中，可以使用以下C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> b6_mask ~(1 &lt;&lt; 6)</span></span><br><span class="line">regData &amp;= b6_mask</span><br></pre></td></tr></table></figure><p>eg3.<br>要将某个8位寄存器的b0和b5的内容清0、b2和b3的内容置1，并且不影响寄该寄存器中的其他各位，请使用C语言编程实现(假设该寄存器的内容保存在变量regData中)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLEAR_MASK ((1U &lt;&lt; 0) | (1U &lt;&lt; 5))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_MASK   ((1U &lt;&lt; 2) | (1U &lt;&lt; 3))</span></span><br><span class="line">regData &amp;= ~CLEAR_MASK;  <span class="comment">// 清0 b0和b5</span></span><br><span class="line">regData |= SET_MASK;     <span class="comment">// 置1 b2和b3</span></span><br></pre></td></tr></table></figure><h4 id="1-4-1-2-算数移位（有符号数）">1.4.1.2 算数移位（有符号数）</h4><p>针对定点数（定点整数、顶点小数）<br>不论正数还是负数，符号位保持不变，仅对数值位进行移位<br>左移×2^n 【&lt;&lt; 对应逻辑左移（高位移除，低位补0）】<br>右移÷2^n 【&gt;&gt; 无符号对应逻辑右移（低位移除，高位补0），有符号对应算术右移（低位移除，低位补符号位）】<br>注意：补码的算数移位：</p><ul><li><strong>右移</strong>：符号位保留（填充符号位）。</li><li><strong>左移</strong>：<ul><li>若左移未溢出，符号位保留。</li><li>若左移导致符号位改变（如正数变负数或负数变正数），则符号位不保留，<strong>溢出发生</strong>。</li></ul></li><li>补码 <code>00001101</code>（+13）左移1位 → <code>00011010</code>（+26），符号位保留。</li><li>补码 <code>11110011</code>（-13）左移2位 → <code>11001100</code>（-52），符号位保留。</li><li>补码 <code>01111111</code>（+127）左移1位 → <code>11111110</code>（-2），符号位改变，<strong>溢出</strong>。</li></ul><table><thead><tr><th><strong>真值</strong></th><th><strong>机器码</strong></th><th><strong>空位添补</strong></th><th><strong>丢位情况</strong></th></tr></thead><tbody><tr><td><strong>正数</strong>（符号位不保留）</td><td>原码=补码=反码</td><td>补0</td><td>- <strong>最高位丢1</strong>：结果溢出（出错）  <br>- <strong>最低位丢1</strong>：精度缺失（值变小）</td></tr><tr><td><strong>负数</strong>（符号位保留1）</td><td><strong>原码</strong></td><td>补0</td><td>- <strong>最高位丢0</strong>：结果溢出（出错）  <br>- <strong>最低位丢0</strong>：精度缺失（绝对值变大）</td></tr><tr><td></td><td><strong>反码</strong></td><td>补1</td><td>- <strong>最高位丢0</strong>：结果溢出（出错）  <br>- <strong>最低位丢1</strong>：精度缺失（绝对值变大）</td></tr><tr><td></td><td><strong>补码</strong></td><td>左移补0右移补1</td><td>- <strong>最高位丢0</strong>：结果溢出（出错）  <br>- <strong>最低位丢1</strong>：精度缺失（值变小）</td></tr><tr><td><strong>有符号定点数</strong>的<strong>补码</strong>的另一种算术移位方法，即“符号位也参与移位”，具体规则如下</td><td></td><td></td><td></td></tr><tr><td>左移：高位移除，低位添补0；移动前后若符号位发生变化，则发生<strong>溢出</strong>。</td><td></td><td></td><td></td></tr><tr><td>右移：低位移除，高位添补符号。</td><td></td><td></td><td></td></tr><tr><td>注：题目中有机器数、寄存器等用机器移动，左移符号位和数值位一起移。算数右移保留符号位</td><td></td><td></td><td></td></tr><tr><td>补码算术左移时，高位移出，低位补0，若左移前后的符号位不同，则发生溢出</td><td></td><td></td><td></td></tr><tr><td>无符号数逻辑左移时，若最高位移出的是1，则发生溢出</td><td></td><td></td><td></td></tr><tr><td>逻辑左移和补码算术左移的结果都一样，都是移出最高位，并在低位补0</td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-4-1-3-循环移位（无符号数）">1.4.1.3 循环移位（无符号数）</h4><p>将无符号数二进制形式中的各个位向左或向右移动，被移出的位会重新出现在另一端，形成循环。<br>在很多处理器架构中，循环移位指令会影响状态寄存器中的<strong>进位标志CF(CarnyFlag)位</strong>，CF标志位用于标识在执行算术或逻辑操作时是否发生了<strong>进位</strong>。<br>根据CF标志位是否加入循环移位过程，循环移位可分为以下四种:<br>小循环：CF不参与循环，但是保留当前循环的移位<br>不带CF标志位的循环右移<br>不带CF标志位的循环左移<br>大循环：CF参与循环<br>带CF标志位的循环右移<br>带CF标志位的循环左移<br>循环移位的应用主要有：<strong>加密算法、哈希函数、优化算法</strong><br>加密算法：通过循环移位可以实现数据的混淆和置换，增强加密算法的安全性。<br>哈希函数：通过循环移位可以用来改变输入数据的排列顺序，以产生不同的哈希值，有利于增强哈希函数的混淆性和扩散性。<br>优化算法:<br>在某些算法中，循环移位可以用于优化性能和节省资源。例如，在图形处理和数字信号处理中，循环移位可以用于加速算法的执行。</p><p>可以使用移位运算操作符(左移“&lt;&lt;”或右移“&gt;&gt;”)和位运算操作符(例如:或运算)来实现。</p><table><thead><tr><th><strong>移位类型</strong></th><th><strong>数值类型</strong></th><th><strong>溢出判断条件</strong></th><th><strong>示例（4位）</strong></th></tr></thead><tbody><tr><td><strong>逻辑左移</strong></td><td>无符号数</td><td>移出有效位（<code>CF = 1</code>）</td><td><code>1100 &lt;&lt; 1 → 1000</code>（未溢出）</td></tr><tr><td><strong>算术左移</strong></td><td>有符号数</td><td>符号位改变（<code>OF = 1</code>）</td><td><code>0100 &lt;&lt; 1 → 1000</code>（溢出）</td></tr><tr><td><strong>逻辑右移</strong></td><td>无符号数</td><td>不会溢出</td><td><code>1100 &gt;&gt; 1 → 0110</code>（无溢出）</td></tr><tr><td><strong>算术右移</strong></td><td>有符号数</td><td>不会溢出</td><td><code>1100 &gt;&gt; 1 → 1110</code>（无溢出）</td></tr></tbody></table><h2 id="1-5-逻辑门">1.5 逻辑门</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330110026671.png" alt="image.png"></p><h3 id="1-5-1-半加器">1.5.1 半加器</h3><p>和数S，进位数C<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330122433587.png" alt="image.png|300"></p><h3 id="1-5-2-一位全加器FA">1.5.2 一位全加器FA</h3><p>一位全加器 = 两个半加器<br>FA是最基本的加法单元</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330121705189.png" alt="image.png"></p><h3 id="1-5-3-串行进位加法器">1.5.3 串行进位加法器</h3><p>将n个全加器相连可得到n位加法器，称为串行进位加法器，如图2.4所示。串行进位也称行波进位，每级进位直接依赖于前一级的进位，即进位信号是<strong>逐级</strong>形成的。<br>在串行进位加法器中，低位运算产生进位所需的时间将影响高位运算的时间。因此，串行进位加法器的最长运算时间主要是由进位信号的<strong>传递时间</strong>决定的，位数越多，延迟时间就越长，所以加快进位产生和提高传递的速度是关键。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330121720156.png" alt="image.png"><br>在n位串行进位加法器中，每个高位的一位全加器FA的运算依赖于相邻低位的一位FA的进位Ci+1因此所有一位FA不能并行运行，其时间关键延迟为(2n+4)T，与串行进位加法器的位数n呈线性关系，<strong>当n较大时性能较差</strong>。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330124049316.png" alt="image.png|400"></p><h3 id="1-5-4-先行进位加法器">1.5.4 先行进位加法器</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330130038330.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330130239644.png" alt="image.png"><br>针对C4，S4：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330125514620.png" alt="image.png|400"></p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330120614661.png" alt="image.png"><br>带符号整数和无符号整数的加减法<strong>可以共用同一加法器</strong>，因为：</p><ol><li>补码设计使得加减法操作与无符号数一致。<strong>硬件无需区分有符号和无符号数</strong>，加法器直接执行二进制位相加。</li><li>减法统一转换为加法，仅需额外取反加1逻辑。</li><li>溢出判断通过独立电路（CF和OF）区分处理，不依赖加法器本身。<ul><li><strong>无符号数溢出</strong>：<br>通过<strong>最高位进位</strong>判断。例如，8位无符号数相加结果超过255时，最高位产生进位（Carry Flag, CF=1）。</li><li><strong>有符号数溢出</strong>：<br>通过<strong>符号位变化</strong>判断。若两个正数相加结果为负，或两个负数相加结果为正，则溢出（Overflow Flag, OF=1）。</li><li><strong>共用加法器，独立标志位</strong>：</li><li>加法器生成结果后，<strong>CF</strong> 和 <strong>OF</strong> 由不同电路独立计算。</li><li>例如，8位运算中：<ul><li><code>CF = 第8位进位</code>。</li><li><code>OF = 第7位进位异或第8位进位</code>。</li></ul></li></ul></li></ol><h2 id="1-6-乘法与除法">1.6 乘法与除法</h2><h3 id="1-6-1-无符号数乘法的硬件逻辑">1.6.1 无符号数乘法的硬件逻辑</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401183330629.png" alt="image.png|400"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330132332682.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330133038038.png" alt="image.png"></p><h3 id="1-6-2-定点数的乘法运算">1.6.2 定点数的乘法运算</h3><ul><li><strong>原码乘法</strong>：符号位异或，数值位累加并右移。</li><li><strong>补码乘法（Booth算法）</strong>：根据乘数位决定加减被乘数，算数右移。</li><li><strong>原码除法（加减交替法）</strong>：通过余数符号调整商和下一步操作。</li></ul><h4 id="1-6-2-1-原码乘法运算的硬件逻辑实现">1.6.2.1 原码乘法运算的硬件逻辑实现</h4><p>对于定点整数原码乘法，其过程与定点小数原码乘法完全相同，仅将符号位与数值位之间的小数点改为逗号即可。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401185018200.png" alt="image.png"><br>先加法再移位，重复n次<br>符号位不参与运算，符号位单独处理：符号位=x⊕y<br>取绝对值进行乘法计算<br>当前位=1，ACC加上被乘数。=0，不加<br>补位是逻辑右移<br>进行n轮加法、移位<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401200316949.png" alt="image.png|350"></p><h4 id="1-6-2-2-补码乘法运算的硬件逻辑实现">1.6.2.2 补码乘法运算的硬件逻辑实现</h4><p>补码一位乘法运算（Booth算法）：<br>是一种加速乘法计算的方法（比如计算 <code>5 × 3</code>），特别适合用硬件电路实现，比传统的乘法更高效。<br><strong>核心思想：用“加减”代替“乘”</strong><br>硬件不喜欢直接做乘法（电路复杂），但擅长加减和移位。Booth算法把乘法拆解成：</p><ol><li><strong>观察乘数的相邻两位</strong>（比如当前位是<code>1</code>，前一位是<code>0</code>，就表示“需要加被乘数”）。</li><li><strong>被乘数左移</strong>（相当于十进制乘法中的“后面补零”）。</li><li><strong>重复步骤1和2，最后把所有结果加起来</strong>。</li></ol><p><strong>硬件</strong>：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402181608205.png" alt="image.png"></p><ol><li><p><strong>控制逻辑</strong>：</p><ul><li><strong>核心大脑</strong>，协调所有操作：根据乘数位（MQ的当前位和附加位）判断加减、移位操作，控制循环次数（计数器），确保算法按步骤执行。</li></ul></li><li><p><strong>时钟</strong>：</p><ul><li><strong>同步时序</strong>，确保每一步操作（如加减、移位）在固定时钟周期内完成，保持硬件同步。</li></ul></li><li><p><strong>计数器（Cn）</strong>：</p><ul><li><strong>记录迭代次数</strong>，例如n位乘法需计数n次，控制循环终止。</li></ul></li><li><p><strong>ACC（累加器）</strong>：</p><ul><li><strong>存储部分积</strong>，保存当前累加结果，每次操作后与ALU结果同步，参与算术右移。</li></ul></li><li><p><strong>MQ（乘商寄存器）</strong>：</p><ul><li><strong>存储乘数及附加位</strong>，初始存放乘数Y，末尾附加一位Y₋₁（初始为0）；每次右移时，ACC和MQ联合移位。</li></ul></li><li><p><strong>ALU（算术逻辑单元）</strong>：</p><ul><li><strong>执行加减操作</strong>，根据控制信号对ACC和[X]补（或被乘数补码）进行加减，结果写回ACC。</li></ul></li><li><p><strong>选择器（多路复用器）</strong>：</p><ul><li><strong>选择操作数</strong>，例如选择被乘数[X]补或其补码（−[X]补）输入ALU，实现加减操作切换。</li></ul></li><li><p><strong>译码器</strong>：</p><ul><li><strong>解析操作码</strong>，将MQ的当前位（Y₀）和附加位（Y₋₁）转换为控制信号（如“加”“减”或“不移位”）。</li></ul></li><li><p><strong>反相器</strong>：</p><ul><li><strong>生成补码</strong>，将被乘数取反后加1，用于实现减法操作（−[X]补）。</li></ul></li></ol><p>辅助位-MQ中最低位=1，ACC+[x]补<br>=0，不加<br>=-1，ACC+[-x]补（会有辅助电路实现[-x]的转换）<br>补位是算数右移<br>进行n轮加法、移位，最后再多来一次加法<br>被乘数A，B采用双符号位补码，符号位参与运算；乘数C采用单符号位补码，符号参与移位，且在尾部增加一位附加位0<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401200540813.png" alt="image.png|400"><br>补码一位乘法中，最多需要 n 次移位，n+1次加法运算，共2n+1位。<br>原码乘法移位和加法运算最多均为n次。<br>凡是原码运算，不论加减乘除，符号位都单独处理，其中乘除运算的结果符号由参加运算的两个操作数符号相“异或”得到。</p><p>【2020年 题43】有实现x×y的两个C语言函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">umul</span> <span class="params">(<span class="type">unsigned</span> x, <span class="type">unsigned</span> y)</span> &#123; <span class="keyword">return</span> x*y; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">imul</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br></pre></td></tr></table></figure><p>假定某计算机M中ALU只能进行加减运算和逻辑运算。请回答下列问题。<br>(1) 若M的指令系统中<strong>没有</strong>乘法指令，但有加法、减法和移位等指令，则在M上也能实现上述两个函数中的乘法运算，为什么？<br>(2) 若M的指令系统中有乘法指令，则基于ALU、移位器、寄存器以及相应控制逻辑实现乘法指令时，<strong>控制逻辑</strong>的作用是什么？<br>(3) 针对以下三种情况：①<strong>没有乘法指令</strong>；②有使用<strong>ALU</strong>和<strong>移位器</strong>实现的乘法指令；③有使用<strong>阵列乘法器</strong>实现的乘法指令，函数umul()在哪种情况下<strong>执行时间</strong>最长？哪种情况下执行的时间最短？说明理由。<br>(4) n位整数乘法指令可保存2n位乘积，当仅取低n位作为乘积时，其结果可能会发生溢出。当n=32、x= 231−1 、y=2时，带符号整数乘法指令和无符号整数乘法指令得到的x×y的2n位乘积分别是什么（用十六进制表示）？此时函数umul()和imul()的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低位作为乘法结果时，如何用2n位乘积进行溢出判断？<br>解答：<br>(1) 乘法本质上是<strong>重复累加</strong>和<strong>位移操作</strong>的组合。以二进制乘法为例，假设计算 <code>x * y</code>，可以将 <code>y</code> 的每一位分解为权重（如第 <code>i</code> 位对应 <code>2^i</code>），通过将 <code>x</code> 左移 <code>i</code> 位后累加到结果中。例如：  <code>5 * 3 = 5 * (0011B) = (5 &lt;&lt; 1) + (5 &lt;&lt; 0) = 10 + 5 = 15</code>。</p><ul><li><strong>软件实现流程</strong>：<ol><li>初始化结果为0。</li><li>逐位检查乘数 <code>y</code> 的每一位：<ul><li>若当前位为1，将 <code>x</code> 左移对应位数后加到结果中。</li><li>若当前位为0，跳过加法。</li></ul></li><li>重复上述步骤直到处理完所有位。</li></ol></li><li><strong>符号处理</strong>（针对有符号乘法 <code>imul</code>）：<ul><li>取 <code>x</code> 和 <code>y</code> 的绝对值进行无符号乘法。</li><li>根据符号位异或（<code>x ^ y</code>）确定结果的符号，最终修正结果。</li></ul></li></ul><p>(2) 控制逻辑的作用是<strong>控制循环次数，控制加法和移位操作</strong>。</p><ol><li><p><strong>操作选择</strong>：</p><ul><li>根据乘数的当前位（或附加位）决定加减操作。</li><li>例如，在 Booth 算法中，通过检查 <code>CnCn-1</code>（当前位和前一位）的组合选择：<ul><li><code>01</code>：加被乘数</li><li><code>10</code>：减被乘数</li><li><code>00/11</code>：不操作</li></ul></li></ul></li><li><p><strong>移位控制</strong>：</p><ul><li>管理算术右移（补码运算）或逻辑右移（无符号运算）的时机和位数。</li><li>例如，每次加减操作后执行右移，保持符号位不变。</li></ul></li><li><p><strong>迭代计数</strong>：</p><ul><li>控制乘法步骤的循环次数。对于 <code>n</code> 位数，通常需要 <code>n</code> 次迭代。</li><li>在 Booth 算法中，需额外处理附加位，总次数为 <code>n+1</code> 次加减和 <code>n</code> 次移位。</li></ul></li><li><p><strong>符号处理</strong>（针对补码乘法）：</p><ul><li>自动扩展符号位，确保运算过程中符号正确参与。</li></ul></li></ol><p><strong>(3) 三种情况下的执行时间对比</strong></p><table><thead><tr><th><strong>情况</strong></th><th><strong>执行时间</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td>① 无乘法指令（软件实现）</td><td><strong>最长</strong></td><td>需要循环逐位处理，每次循环包含条件判断、加法和移位操作，时间复杂度为 <code>O(n)</code>。</td></tr><tr><td>② ALU+移位器(通用硬件实现)</td><td><strong>中等</strong></td><td>硬件加速，但仍需多周期完成（如 <code>n</code> 次迭代），时间复杂度为 <code>O(n)</code>。</td></tr><tr><td>③ 阵列乘法器(专用硬件实现)</td><td><strong>最短</strong></td><td>全并行电路，通过门电路直接计算每一位乘积，单周期完成，时间复杂度为 <code>O(1)</code>。</td></tr><tr><td>①的执行时间最长，③的执行时间最短。</td><td></td><td></td></tr><tr><td>对于①，需要使用其他指令和算法来模拟乘法操作。常见的方法是通过编写（软件）程序使用加法、位移和逻辑操作来实现乘法功能，需要反复执行很多条指令，而对于每条指令，都需要经历“取指、译码、取数、执行、保存结果”这一过程，②和③都是硬件乘法指令，所以①的执行时间最长。</td><td></td><td></td></tr><tr><td>对于②和③，都只需用一条乘法指令实现乘法操作。</td><td></td><td></td></tr><tr><td>对于③，阵列乘法器是专门用于执行乘法操作的硬件电路，可以在一个时钟周期内完成乘法运算。由于其硬件实现的特性，阵列乘法器通常是执行乘法操作最高效的方式。所以③的执行时间最短。</td><td></td><td></td></tr><tr><td>对于②，ALU和位移器实现的乘法指令通常需要多个时钟周期来完成乘法运算。它通过将乘法操作划分为一系列的加法、位移和逻辑操作来实现。尽管比情况①中的方法更高效，但仍然需要多个时钟周期来执行，因此相对于情况③中的阵列乘法器，执行时间较长。</td><td></td><td></td></tr></tbody></table><ul><li><strong>阵列乘法器</strong>：<br>通过门电路并行生成所有部分积，并一次性相加，无需循环。例如，32位乘法器包含32×32个与门和加法器，直接输出64位结果。</li><li><strong>ALU+移位器实现</strong>：<br>需要逐位迭代（如Booth算法），每个周期完成一次加减和移位，共需 <code>n</code> 个周期。</li></ul><p><strong>(4) 32位乘法的溢出分析与乘积表示</strong><br><strong>给定条件</strong>：</p><ul><li><code>n = 32</code></li><li><code>x = 2^31 - 1 = 0x7FFFFFFF</code>（32位补码最大正数）</li><li><code>y = 2</code></li></ul><p><strong>64位乘积计算</strong>：</p><ul><li><strong>无符号乘法</strong>（<code>umul</code>）：<ul><li><code>x = 0x7FFFFFFF</code>（无符号值为 <code>2^31 - 1</code>）</li><li><code>x * y = (2^31 - 1) * 2 = 2^32 - 2 = 0xFFFFFFFE</code><br>32位无符号整数的表示范围是$[0,2^{32}-1]$</li><li><strong>64位乘积</strong>：<code>0x00000000FFFFFFFE</code>（高32位全0，无溢出）。</li></ul></li><li><strong>有符号乘法</strong>（<code>imul</code>）：<ul><li><code>x = 0x7FFFFFFF</code>（补码最大正数 <code>+2^31 - 1</code>）</li><li><code>x * y = (2^31 - 1) * 2 = 2^32 - 2</code>，但32位补码范围为 32位无符号整数的表示范围是$[-2^{31},2^{31}-1]$，结果 <code>2^32 - 2</code> 超出范围。</li><li><strong>64位乘积</strong>：<code>0xFFFFFFFE</code>（低32位） + 高32位符号扩展为 <code>0xFFFFFFFF</code> → 完整乘积为 <code>0xFFFFFFFFFFFFFFFE</code>（即 <code>-2</code> 的补码）。</li></ul></li></ul><p>对于无符号整数乘法运算，当仅取乘积的低 n 位作为结果时，<strong>若 2n  位乘积的高 n 位不全为0，则说明结果发生了溢出</strong>。以下是详细的解释：</p><ul><li><strong>输入范围</strong>：两个 n 位无符号整数的取值范围为 $0 \leq x, y \leq 2^n - 1$</li><li><strong>乘积范围</strong>：它们的乘积最大为 $(2^n - 1) \times (2^n - 1) = 2^{2n} - 2^{n+1} + 1$，需要 2n  位才能完整表示。</li><li><strong>截断后的结果</strong>：若仅取乘积的低 n 位（即忽略高 n 位），则低 n 位的表示范围为 $0 \leq \text{结果} \leq 2^n - 1$。</li><li><strong>溢出条件</strong>：当实际乘积 $x \times y &gt; 2^n - 1$  时，低 n 位无法正确表示真实值，此时发生溢出。</li></ul><p>高n位的意义：</p><ul><li><strong>二进制表示</strong>：乘积的 2n  位可拆分为高 n 位和低 n 位，即：$x \times y = (\text{高 } n \text{ 位}) \times 2^n + (\text{低 } n \text{ 位})$</li><li><strong>高 n 位的作用</strong>：<ul><li>若高 n 位全为0，说明乘积 $x \times y \leq 2^n - 1$ ，未溢出。</li><li>若高 n 位不全为0，说明乘积 $x \times y \geq 2^n$ ，低 n 位无法容纳真实值，发生溢出。</li></ul></li></ul><p><strong>例1：未溢出（高 n 位全0）</strong></p><ul><li>设 n = 4 ，x = 15(1111_2) ，y = 1(0001_2) 。</li><li>乘积：$15 \times 1 = 15(0000\ 1111_2)$ 。</li><li>高4位为 <code>0000</code>，低4位为 <code>1111</code>，结果未溢出。</li></ul><p><strong>例2：溢出（高 n 位不全0）</strong></p><ul><li>设 n = 4 ，x = 15(1111_2) ，y = 15(1111_2) 。</li><li>乘积：$15 \times 15 = 225(1110\ 0001_2)$ 。</li><li>高4位为 <code>1110</code>，低4位为 <code>0001</code>，实际值远超 2^4 - 1 = 15 ，溢出发生。</li></ul><p><strong>溢出判断</strong>：</p><ul><li><p><strong>无符号乘法</strong>（<code>umul</code>）：</p><ul><li><strong>判断方法</strong>：检查高32位是否全为0。</li><li><strong>结果</strong>：高32位为 <code>0x00000000</code>，未溢出，返回 <code>0xFFFFFFFE</code>。</li></ul></li><li><p><strong>有符号乘法</strong>（<code>imul</code>）：</p><ul><li><strong>判断方法</strong>：结果是否超出 <code>[-2^31, 2^31 - 1]</code>。</li><li><strong>结果</strong>：<code>0xFFFFFFFE</code> 对应 <code>-2</code>，但实际数学结果为 <code>+2^32 - 2</code>，溢出发生，返回值为截断后的错误结果。</li></ul></li></ul><h4 id="1-6-2-3-无符号阵列乘法器">1.6.2.3 无符号阵列乘法器</h4><p>原码、补码一位乘法的硬件逻辑实现，需要在时钟节拍下、通过控制逻辑的控制，执行相应轮次的“加法、右移”操作来实现，速度较慢。<br>为了提高运算速度，可以仅采用<strong>组合逻辑电路</strong>以<strong>专用硬件</strong>方式构建阵列乘法器<br><strong>硬件结构</strong><br>阵列乘法器的核心由<strong>与门阵列</strong>和<strong>加法器阵列</strong>组成，典型结构如下：</p><ul><li><strong>输入</strong>： n 位无符号被乘数  $X = x_{n-1}x_{n-2}…x_0$ ， n 位无符号乘数  $Y = y_{n-1}y_{n-2}…y_0$ 。</li><li><strong>输出</strong>： 2n 位无符号乘积  $P = p_{2n-1}p_{2n-2}…p_0$ 。</li></ul><p>由  n × n  个与门 和 n × ( n - 1 )个全加器构成</p><table><thead><tr><th><strong>特性</strong></th><th><strong>阵列乘法器</strong></th><th><strong>串行乘法器（原码/补码一位乘法）</strong></th></tr></thead><tbody><tr><td><strong>硬件复杂度</strong></td><td>高（需要  O(n^2)  门电路）</td><td>低（仅需加法器、移位器和控制逻辑）</td></tr><tr><td><strong>运算速度</strong></td><td>快（组合逻辑延迟）</td><td>慢（需  n  个时钟周期）</td></tr><tr><td><strong>适用场景</strong></td><td>高性能计算、专用硬件</td><td>通用处理器、资源受限场景</td></tr><tr><td><strong>控制逻辑</strong></td><td>无（纯组合逻辑）</td><td>需状态机控制加减和移位操作</td></tr><tr><td>![image.png</td><td>200](<a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402194158184.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402194158184.png</a>)</td><td></td></tr></tbody></table><h4 id="1-6-2-4-补码阵列乘法器">1.6.2.4 补码阵列乘法器</h4><ul><li><strong>核心思想</strong>：将补码乘法转换为无符号乘法，并通过符号修正处理负数。</li></ul><h3 id="1-6-3-定点数的除法运算">1.6.3 定点数的除法运算</h3><h4 id="1-6-3-1-原码除法">1.6.3.1 原码除法</h4><p>恢复余数法，不恢复余数法（加减交替法）<br>前提条件：<br>除数≠0<br>定点小数：|被除数| ＜ |除数|<br>定点整数：|被除数| ≥ |除数|</p><ul><li><strong>恢复余数法</strong><ul><li><code>|x|补+[-|Y|]补</code><ul><li>结果为正，商1，左 移+<code>[-|Y|]补</code> 【正1左负】</li><li>结果为负，商0，+<code>[|Y|]补</code>（恢复）【负0恢左负】<ul><li>恢复后左移+<code>[-|Y|]补</code><ul><li>结果为正/负，重复上述步骤，直到商位为n<br>商位的符号位是异或的结果</li></ul></li></ul></li></ul></li></ul></li><li><strong>不恢复余数法</strong><ul><li><code>|x|补+[-|Y|]补</code><ul><li>结果为正，商1，左移+<code>[-|Y|]补</code> 【正1左负】</li><li>结果为负，商0，左移+<code>|Y|补</code>【负0左正】<br>商位的符号位是异或的结果</li></ul></li></ul></li></ul><h4 id="1-6-3-2-补码除法">1.6.3.2 补码除法</h4><p>加减交替法<br>符号位参与运算<br>被除数/余数，除数采用<mark>双符号位</mark></p><ul><li><code>[X]补</code>+<code>[Y]补</code><ul><li>和除数<code>[Y]补</code> 同号，商1，左移+<code>[-Y]补</code> 【同1左负】</li><li>和除数<code>[Y]补</code> 异号，商0，左移+<code>[Y]补</code> 【异0左正】</li></ul></li><li>左移n次，余数×2^-n</li><li>商位满足后，将<strong>商位的最后一位改成1</strong>（精度差≤2^n）</li></ul><p>商位的符号位是异或的结果<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402210721111.png" alt="520578617831cd6b53059193def8c15.jpg|400"></p><table><thead><tr><th><strong>特性</strong></th><th><strong>原码一位乘法</strong></th><th><strong>补码一位乘法（Booth算法）</strong></th></tr></thead><tbody><tr><td><strong>符号处理</strong></td><td>符号位单独处理：<code>符号 = x⊕y</code></td><td>符号位参与运算，无需单独处理</td></tr><tr><td><strong>操作数形式</strong></td><td>取绝对值进行乘法计算</td><td>直接使用补码参与运算</td></tr><tr><td><strong>核心步骤</strong></td><td>1. 加法后移位<br>2. 重复<code>n</code>次</td><td>1. 根据乘数末位和附加位判断加减<br>2. 算术右移<br>3. 重复<code>n</code>次</td></tr><tr><td><strong>加减条件</strong></td><td>当前位为<code>1</code>：ACC加被乘数<br>当前位为<code>0</code>：不操作</td><td>根据<code>CnCn-1</code>组合：<br><code>01</code>加被乘数，<code>10</code>减被乘数，<code>00/11</code>不操作</td></tr><tr><td><strong>移位方式</strong></td><td><strong>逻辑右移</strong>（高位补<code>0</code>）</td><td><strong>算术右移</strong>（符号位保持不变）</td></tr><tr><td><strong>加法次数</strong></td><td>最多<code>n</code>次</td><td>最多<code>n+1</code>次（可能多一次修正）</td></tr><tr><td><strong>移位次数</strong></td><td><code>n</code>次</td><td><code>n</code>次</td></tr><tr><td><strong>结果形式</strong></td><td>符号位与数值位分离</td><td>直接得到补码结果</td></tr></tbody></table><table><thead><tr><th><strong>特性</strong></th><th><strong>原码不恢复余数法（加减交替法）</strong></th><th><strong>补码不恢复余数法</strong></th></tr></thead><tbody><tr><td><strong>符号处理</strong></td><td>符号位单独处理：<code>符号 = x⊕y</code></td><td>符号位参与运算</td></tr><tr><td><strong>余数调整</strong></td><td>最终余数为负时需恢复余数</td><td>余数无需恢复，直接修正商</td></tr><tr><td><strong>商的确定</strong></td><td>根据余数符号：<br>余数正商<code>1</code>，余数负商<code>0</code></td><td>异号相除时：<br>余数与除数同号商<code>1</code>，否则商<code>0</code></td></tr><tr><td><strong>核心操作</strong></td><td>1. 余数正：减除数<br>2. 余数负：加除数<br>3. 重复<code>n</code>次</td><td>1. 余数与除数同号：减除数<br>2. 余数与除数异号：加除数<br>3. 重复<code>n</code>次</td></tr><tr><td><strong>移位方向</strong></td><td>左移</td><td>左移</td></tr><tr><td><strong>余数修正</strong></td><td>若最终余数为负，需加除数恢复</td><td>无需恢复余数</td></tr></tbody></table><ul><li>原码除法（加减交替法）仅在最终余数为负时恢复余数。</li><li>补码除法通过余数与除数的符号关系直接确定商。</li></ul><p><strong>操作次数</strong>：</p><ul><li>原码乘法：<code>n</code>次加法 + <code>n</code>次移位。</li><li>补码乘法：最多<code>n+1</code>次加法 + <code>n</code>次移位。</li><li>除法：均需<code>n</code>次迭代。</li></ul><p><strong>区别总结</strong></p><ol><li><p><strong>移位方式</strong>：</p><ul><li>原码乘法：逻辑右移（高位补<code>0</code>）。</li><li>补码乘法：算术右移（符号位不变）。</li></ul></li><li><p><strong>修正操作</strong>：</p><ul><li>原码除法需要恢复余数，补码除法直接修正商。</li></ul></li><li><p><strong>符号参与</strong>：</p><ul><li>原码运算符号独立，补码运算符号融入数值。</li></ul></li></ol><h2 id="1-7-浮点数表示与运算">1.7 浮点数表示与运算</h2><h3 id="1-7-1-浮点运算步骤">1.7.1 <strong>浮点运算步骤</strong></h3><ul><li><strong>对阶</strong>：小阶向大阶对齐，尾数右移两个阶的绝对插值（精度损失）。</li><li><strong>尾数运算</strong>：加减后规格化，处理溢出。</li><li><strong>舍入</strong>：就近舍入、向零舍入等。</li></ul><h3 id="1-7-2-浮点数的溢出">1.7.2 <strong>浮点数的溢出</strong></h3><ul><li>上溢：阶码超过最大允许值（OF=1）<br>单精度浮点数阶码最大为 127，若计算结果阶码超过 127，则上溢</li><li>下溢：运算结果的绝对值小于机器所能表示的最小绝对值<br>运算结果在0至规格化最小正数之间时称为正下溢，运算结果在0至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。<br>单精度浮点数阶码最小为 -126，若计算结果阶码低于 -126，则下溢</li></ul><h3 id="1-7-3-浮点数表示范围">1.7.3 <strong>浮点数表示范围</strong></h3><p>阶码和尾数都是<strong>原码</strong>表示时：</p><ul><li><strong>阶码 E</strong>（假设 k+1 位，1 位阶符 + k 位数值）：<ul><li><strong>最大值</strong>：$E_{\text{max}} = +(2^k - 1)$</li><li><strong>最小值</strong>：$E_{\text{min}} = -(2^k - 1)$</li></ul></li><li><strong>尾数 M</strong>（假设 n+1 位，1 位数符 + n 位数值）：<ul><li><strong>正数范围</strong>：$+2^{-n} \leq M \leq (1 - 2^{-n})$</li><li><strong>负数范围</strong>：$-(1 - 2^{-n}) \leq M \leq -2^{-n}$<br>如果都用<strong>补码</strong>表示：</li></ul></li><li><strong>阶码 E（k+1 位补码）</strong>：<ul><li><strong>最大值</strong>：$E_{\text{max}} = 2^{k} - 1$</li><li><strong>最小值</strong>：$E_{\text{min}} = -2^{k}$</li></ul></li><li><strong>尾数 M（n+1 位补码，定点小数）</strong>：<ul><li><strong>正数范围</strong>：$2^{-n} \leq M \leq 1 - 2^{-n}$</li><li><strong>负数范围</strong>：$-1 \leq M \leq -2^{-n}$</li></ul></li></ul><table><thead><tr><th><strong>类型</strong>（基数=2）</th><th><strong>公式</strong></th><th><strong>说明</strong></th><th></th></tr></thead><tbody><tr><td><strong>正数最大值</strong></td><td>$2^{E_{\text{max}}} \times M_{\text{max}}$</td><td>阶码最大，尾数最大正数。</td><td></td></tr><tr><td><strong>正数最小值</strong></td><td>$2^{E_{\text{min}}} \times M_{\text{min}}$</td><td>阶码最小，尾数最小正数（即精度）。</td><td></td></tr><tr><td><strong>负数最小值</strong></td><td>$2^{E_{\text{max}}} \times M_{\text{min}}$</td><td>阶码最大，尾数最小负数。</td><td></td></tr><tr><td><strong>负数最大值</strong></td><td>$2^{E_{\text{min}}} \times M_{\text{max}}$</td><td>阶码最小，尾数最大负数。</td><td></td></tr><tr><td>3位阶码 + 3位尾数，原码表示：</td><td></td><td></td><td></td></tr></tbody></table><ol><li><p><strong>阶码</strong>（1位阶符 + 2位数值）：</p><ul><li>最大值：$E_{\text{max}} = +3$（二进制 <code>0,11</code>）</li><li>最小值：$E_{\text{min}} = -3$（二进制 <code>1,11</code>）</li></ul></li><li><p><strong>尾数</strong>（1位数符 + 2位数值）：</p><ul><li>正数范围：<ul><li>最大值：$M_{\text{max}} = +0.75$（二进制 <code>0.11</code>）</li><li>最小值：$M_{\text{min}} = +0.25$（二进制 <code>0.01</code>）</li></ul></li><li>负数范围：<ul><li>最小值：$M_{\text{min}} = -0.75$（二进制 <code>1.11</code>）</li><li>最大值：$M_{\text{max}} = -0.25$（二进制 <code>1.01</code>）</li></ul></li></ul></li><li><p><strong>浮点数范围</strong>：</p><ul><li><strong>正数最大值</strong>：$2^{+3} \times 0.75 = 8 \times 0.75 = 6$</li><li><strong>正数最小值</strong>：$2^{-3} \times 0.25 = 0.125 \times 0.25 = 0.03125$</li><li><strong>负数最小值</strong>：$2^{+3} \times (-0.75) = 8 \times (-0.75) = -6$</li><li><strong>负数最大值</strong>：$2^{-3} \times (-0.25) = 0.125 \times (-0.25) = -0.03125$</li></ul></li></ol><p>eg.<br>(1) 设浮点数字长为8位，其中阶码3位（含1位阶符），尾数5位（含1位数符），阶码和尾数均以原码表示，基数r为8，则浮点数的最大最小值分别是多少？<br>(2) 设定点数原码为8位，则定点数的最大最小值分别是多少？<br>(3) 比较 (1) 和 (2) 能得出什么结论？</p><ul><li>浮点数最大值：$8^{+3}×(+0.9375)= +480$</li><li>浮点数最小值：$8^{+3}×(-0.9375)= -480$</li><li>定点数最大值：$+(2^{7}-1)= +127$</li><li>定点数最小值：$-(2^{7}-1)= -127$</li><li>结论：浮点数有效扩大了数据表示范围</li></ul><h3 id="1-7-4-浮点数的规格化">1.7.4 <strong>浮点数的规格化</strong></h3><p>规格化是调整浮点数的尾数和阶码，使得尾数的有效数字集中在高位，以最大化精度。不同基数（ r ）的浮点数规格化条件不同<br>浮点数规格化的好处是：增加数据的表示精度（精度最高）；使浮点数的表示形式唯一<br>当尾数为<mark>补码</mark>表示，且为 1.0xxxx形式时为规格化数。<strong>符号位与小数点后第一位相反</strong><br><mark>原码</mark>表示时，正数的规格化形式为0.1x···，负数的规格化形式为 1.1x···。<strong>尾数第一位固定为 1</strong><br>2^110ⅹ0.0111规格化右移1位，110B=6，6-1=5=101B。∴2^101ⅹ0.1110</p><table><thead><tr><th>**基数  r **</th><th><strong>规格化条件</strong></th><th><strong>左规操作</strong></th><th><strong>右规操作</strong></th></tr></thead><tbody><tr><td><strong>2</strong></td><td>尾数数值部分最高位为1</td><td>尾数左移1位，阶码减1</td><td>尾数右移1位，阶码加1</td></tr><tr><td><strong>4</strong></td><td>尾数数值部分最高2位不全为0</td><td>尾数左移2位，阶码减1</td><td>尾数右移2位，阶码加1</td></tr><tr><td><strong>8</strong></td><td>尾数数值部分最高3位不全为0</td><td>尾数左移3位，阶码减1</td><td>尾数右移3位，阶码加1</td></tr><tr><td><strong>16</strong></td><td>尾数数值部分最高4位不全为0</td><td>尾数左移4位，阶码减1</td><td>尾数右移4位，阶码加1</td></tr></tbody></table><ol><li><p><strong>规格化条件</strong>：</p><ul><li>基数  r = 2^k  时，尾数数值部分的 <strong>最高  k  位不全为0</strong>。</li><li>例如：<ul><li>r = 4 = 2^2  → 最高2位不全为0。</li><li>r = 8 = 2^3  → 最高3位不全为0。</li></ul></li></ul></li><li><p><strong>左规与右规操作</strong>：</p><ul><li><strong>左规</strong>：尾数左移  k  位，阶码减1（确保有效数字前移）。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329122019961.png" alt="image.png|400"></li><li><strong>右规</strong>：尾数右移  k  位，阶码加1（防止溢出或调整精度）。 <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329122140256.png" alt="image.png|400"></li></ul></li></ol><p>eg.<br>r=4，二进制浮点数 110.0101</p><ul><li>非规格化表示<ul><li>$4^{11}\times0.0001100101$，操作：$4^{11}$ 减1， 0.0001100101 左移2位</li><li>$4^{100}\times0.000001100101$ ，操作：$4^{100}$ 减2， 0.000001100101 左移4位</li></ul></li><li>规格化表示<ul><li>$4^{10}\times0.0110010100$</li><li>$4^{10}\times0.01100101000$</li></ul></li></ul><p>浮点数规格化后的表示范围：<br>阶码和尾数都是<strong>原码</strong>表示时：</p><ul><li><strong>阶码 E</strong>（假设 k+1 位，1 位阶符 + k 位数值）：<ul><li><strong>最大值</strong>：$E_{\text{max}} = +(2^k - 1)$</li><li><strong>最小值</strong>：$E_{\text{min}} = -(2^k - 1)$</li></ul></li><li><strong>尾数 M</strong>（假设 n+1 位，1 位数符 + n 位数值）：<ul><li><strong>正数范围</strong>：$+2^{-1} \leq M \leq (1 - 2^{-n})$</li><li><strong>负数范围</strong>：$-(1 - 2^{-n}) \leq M \leq -2^{-1}$<br>只有尾数的最小正数和最大负数从$2^{-n}$变成$2^{-1}$</li></ul></li></ul><p>阶码和尾数都是<strong>补码</strong>表示时：</p><ul><li><strong>阶码 E（k+1 位补码）</strong>：<ul><li><strong>最大值</strong>：$E_{\text{max}} = 2^{k} - 1$</li><li><strong>最小值</strong>：$E_{\text{min}} = -2^{k}$</li></ul></li><li><strong>尾数 M（n+1 位补码，定点小数）</strong>：<ul><li><strong>正数范围</strong>：$2^{-1} \leq M \leq 1 - 2^{-n}$</li><li><strong>负数范围</strong>：$-1 \leq M \leq -(2^{-1}+2^{-n})$</li></ul></li></ul><p>eg1.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)，将十进制数-56写成二进制定点数和浮点数(要求规格化表示)，并分别写出它们各自的机器数(原码、反码、补码)形式。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329115350757.png" alt="image.png">eg2.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)将十进制数 +13/128 写成二进制定点数和浮点数(要求规格化表示)，并写出它们各自的机器数(原码、反码、补码)形式。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329115731894.png" alt="image.png">注：$2^{-11}$是$2^{-3}$<br>eg3.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)，写出十进制数- 53/512对应的浮点规格化数的原码、反码和补码以及阶码用移码、尾数用补码的形式。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329120730451.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329121728139.png" alt="image.png"></p><h3 id="1-7-5-浮点数的加减法">1.7.5 <strong>浮点数的加减法</strong></h3><p><strong>1. 对阶（对齐阶码）</strong></p><ul><li><strong>原则</strong>：小阶向大阶对齐，尾数右移（差值为阶码差的绝对值）。</li><li><strong>操作</strong>：<ul><li>较小阶码的尾数<strong>算术右移</strong>（补符号位），右移位数 = 阶码差值。</li><li>阶码更新为较大的阶码。</li></ul></li><li><strong>关键</strong>：右移可能导致尾数低位丢失（需隐藏保留，后续舍入处理）。<br><strong>2. 尾数求和/差</strong></li><li><strong>操作</strong>：对阶后的尾数按<strong>补码规则直接加减</strong>。</li><li><strong>溢出判断</strong>：<ul><li>双符号位为 <code>01</code> 或 <code>10</code>：尾数溢出，需右归（见步骤3）。</li><li>双符号位一致（<code>00</code> 或 <code>11</code>）：直接进入规格化。</li></ul></li></ul><p><strong>3. 规格化</strong></p><ul><li><strong>目标</strong>：使尾数最高有效位与符号位不同（即形如 <code>0.1xxx</code> 或 <code>1.0xxx</code>）。<br>左-右+</li></ul><table><thead><tr><th><strong>情况</strong></th><th><strong>操作</strong></th><th><strong>调整阶码</strong></th></tr></thead><tbody><tr><td><strong>左归</strong>（<code>00.0xxx</code> 或 <code>11.1xxx</code>）</td><td>尾数左移，直到最高有效位为1</td><td>阶码减少左移次数</td></tr><tr><td><strong>右归</strong>（<code>01.xxx</code> 或 <code>10.xxx</code>）</td><td>尾数右移1位</td><td>阶码加1</td></tr><tr><td><strong>溢出处理</strong></td><td>上溢（<code>01.xxx</code>）：触发异常</td><td>下溢（<code>10.xxx</code>）：置为机器零（阶码全0）</td></tr><tr><td><strong>4. 舍入与最终结果</strong></td><td></td><td></td></tr></tbody></table><ul><li><strong>舍入</strong>：规格化后对尾数低位进行截断或舍入<ul><li>截断法：直接丢弃超出机器字长的尾数低位（导致误差积累）</li><li>末位恒置1法：将机器字长内的尾数的最低位恒置为1（损失1位精度，但误差积累较小）</li><li>0舍1入法：当需要丢弃的尾数低位中的最高位为1时，将机器字长内的尾数的最低位加1</li></ul></li><li><strong>阶码检查</strong>：若阶码超出范围（上溢/下溢），按溢出规则处理。<br>注：如果是转补码，按隐藏符号位的最后一个1算。eg.<code>[x]补=11,10100(1)，[-x]补=00,01011(1)</code><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7e8a9d22d02d94cba50966f9772de0f.jpg" alt="7e8a9d22d02d94cba50966f9772de0f.jpg"></li></ul><h3 id="1-7-6-IEEE-754-浮点数运算">1.7.6 <strong>IEEE 754 浮点数运算</strong></h3><p>任何一个二进制数N可表示：N=r<sup>E</sup>×M</p><ol><li>对阶 → 2. 尾数加减 → 3. 规格化 → 4. 舍入 → 5. 溢出判断 → 输出结果。<br><strong>1. 对阶（对齐阶码）</strong></li></ol><ul><li><strong>阶码表示</strong>：采用移码（偏置码），单精度偏置值为 <code>127</code>，双精度为 <code>1023</code>。</li><li><strong>对齐规则</strong>：<ul><li>小阶向大阶对齐，尾数<strong>算术右移</strong>（移位数 = 阶差绝对值），右移时隐藏位（最高位）需显式参与。</li><li><strong>移码加减规则</strong>：阶码相加减时，需按移码运算公式处理（实际运算需转换为真值后再调整偏置值）。<br><strong>2. 尾数运算（原码运算）</strong></li></ul></li><li><strong>隐藏位处理</strong>：<ul><li>运算前需恢复隐藏的 <code>1.</code>（规格化数的隐含前导1）。</li><li>运算后需重新隐藏（规格化后保留前导1）。</li></ul></li><li><strong>运算规则</strong>：<ul><li><strong>加法</strong>：两尾数直接相加（原码加减需处理符号位，实际硬件中可能转换为补码运算）。</li><li><strong>减法</strong>：转换为加法（减数符号取反）。<br><strong>3. 规格化</strong></li></ul></li><li><strong>规格化条件</strong>：尾数必须满足 <code>1.xxxxx...</code>（原码形式）。</li><li><strong>规格化操作</strong>：</li></ul><table><thead><tr><th><strong>情况</strong></th><th><strong>操作</strong></th><th><strong>阶码调整</strong></th></tr></thead><tbody><tr><td><strong>左规</strong>（尾数形式为 <code>0.xxxx</code>）</td><td>尾数左移1位，阶码减1</td><td>阶码减1</td></tr><tr><td><strong>右规</strong>（尾数形式为 <code>1b.xxxx</code>）</td><td>尾数右移1位，阶码加1</td><td>阶码加1</td></tr><tr><td><strong>4. 舍入处理</strong></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>模式</strong></th><th><strong>规则</strong></th></tr></thead><tbody><tr><td><strong>就近舍入（默认）</strong></td><td>舍入到最近的数，中间值向偶数（末位为0）舍入。</td></tr><tr><td><strong>朝正∞舍入</strong></td><td>结果向正无穷方向舍入（取右侧更大的可表示数）。</td></tr><tr><td><strong>朝负∞舍入</strong></td><td>结果向负无穷方向舍入（取左侧更小的可表示数）。</td></tr><tr><td><strong>截断（朝0舍入）</strong></td><td>直接丢弃多余位，结果向0方向舍入。</td></tr><tr><td><strong>5. 溢出判断</strong></td><td></td></tr></tbody></table><ul><li><strong>上溢</strong>：<ul><li>阶码超过最大可表示值（单精度阶码全1，即 <code>11111111</code>，对应真值 <code>+127</code>）。</li><li>结果视为 <code>±∞</code>（根据符号位）。</li></ul></li><li><strong>下溢</strong>：<ul><li>阶码低于最小可表示值（单精度阶码全0，即 <code>00000000</code>，对应真值 <code>-126</code>）。</li><li>结果视为<strong>非规格化数</strong>或<strong>机器零</strong>（尾数全0）。</li></ul></li></ul><p><strong>与补码浮点运算的差异</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>IEEE 754</strong></th><th><strong>补码浮点运算</strong></th></tr></thead><tbody><tr><td><strong>阶码表示</strong></td><td>移码（偏置码）</td><td>补码</td></tr><tr><td><strong>尾数表示</strong></td><td>原码（隐含前导1，需显式参与运算）</td><td>补码（显式符号位）</td></tr><tr><td><strong>规格化规则</strong></td><td>尾数必须为 <code>1.xxxx</code></td><td>补码尾数最高位与符号位不同（如 <code>0.1xxx</code> 或 <code>1.0xxx</code>）</td></tr><tr><td><strong>舍入模式</strong></td><td>支持多种舍入方式（如就近舍入、向偶数舍入）</td><td>通常仅截断或简单舍入</td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329091853718.png" alt="image.png"></td><td></td><td></td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329092307636.png" alt="image.png">浮点数相加：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250405194750013.png" alt="image.png"></td><td></td><td></td></tr><tr><td>浮点数相乘：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406064555148.png" alt="image.png"></td><td></td><td></td></tr><tr><td>浮点数相除：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406064740616.png" alt="image.png"></td><td></td><td></td></tr></tbody></table><h3 id="1-7-7-浮点数结构">1.7.7 <strong>浮点数结构</strong></h3><p>用<strong>阶码（指数）</strong> 和<strong>尾数</strong>表示数值，适合大范围和高精度需求。 <strong>IEEE 754标准</strong></p><ul><li><strong>单精度（32位）</strong>：1位符号 + 8位阶码（偏置值127） + 23位尾数。$([2^{-126},(2 - 2^{-23})\times2^{127}])$<br>$(2 - 2^{-23})\times2^{127}$即$2^{128}-2^{104}$</li><li><strong>双精度（64位）</strong>：1位符号 + 11位阶码（偏置值1023） + 52位尾数。$([2^{-1022},(2 - 2^{-52})\times2^{1023}])$</li><li><strong>阶码范围</strong>：单精度 <code>-126 ~ +127</code>，双精度 <code>-1022 ~ +1023</code>。</li><li><strong>偏移常数</strong>：偏移常数（Bias）用于浮点数的阶码（指数）编码，将实际指数转换为无符号整数存储。对于 n 位阶码，偏移常数为：$2^{n-1}-1$<br>单精度浮点数（32位）偏移常数127<br><strong>作用</strong>：将实际指数范围对称分布在正负区间，避免存储负指数时使用符号位<br>为什么不采用标准的128，而采用127?<ul><li><p>若偏移值为128，<strong>最小规格化数的实际指数为-127</strong>（对应二进制阶码<code>00000001</code>），其倒数为2^127。</p></li><li><p>但单精度浮点数的最大可表示值约为2^127（指数上限为+127）。此时倒数与最大值相等，<strong>可能引发溢出</strong>（因符号位或特殊值冲突）。</p></li><li><p>若偏移值为127，<strong>最小规格化数的实际指数为-126</strong>（对应阶码<code>00000001</code>），其倒数为2^126，而单精度的指数上限仍为+127。此时倒数2^126<strong>完全在可表示范围内</strong>，不会溢出。</p></li></ul></li><li>IEEE 754标准中，<strong>规格化数</strong>的尾数有一个隐含的<strong>最高位1</strong><br>1. <strong>节省存储空间</strong>：<br>实际存储的尾数部分不包含这个1（例如单精度浮点数的23位尾数），但在计算时会自动补上。这相当于“白嫖”一个额外比特，<strong>提高精度</strong>。<br>2. <strong>扩展动态范围</strong>：<br>隐含的1使规格化数的实际值为 1.尾数×2^指数，而非 0.尾数×2^指数，从而能表示更大的数值范围。</li></ul><h3 id="1-7-8-特殊值">1.7.8 <strong>特殊值</strong></h3><p>IEEE 754定义了多种特殊值，用于处理边界情况和异常运算：</p><table><thead><tr><th><strong>数值分类</strong></th><th><strong>符号S</strong></th><th><strong>阶码E</strong></th><th><strong>尾数M</strong></th><th><strong>真值公式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>正零（+0）</strong></td><td>0</td><td>全0（0）</td><td>0</td><td>+0</td><td>符号为0，表示正零。</td></tr><tr><td><strong>负零（-0）</strong></td><td>1</td><td>全0（0）</td><td>0</td><td>-0</td><td>符号为1，表示负零。实际使用中与+0等效，但符号位不同。</td></tr><tr><td><strong>非规格化正数</strong></td><td>0</td><td>全0（0）</td><td>M \neq 0</td><td>(-1)^0 \times 2^{-126} \times 0.M</td><td>用于表示接近零的极小正数，无隐藏位1，指数固定为-126。</td></tr><tr><td><strong>非规格化负数</strong></td><td>1</td><td>全0（0）</td><td>M \neq 0</td><td>(-1)^1 \times 2^{-126} \times 0.M</td><td>类似非规格化正数，但符号为负。</td></tr><tr><td><strong>正无穷大（+∞）</strong></td><td>0</td><td>全1（255）</td><td>0</td><td>+∞</td><td>表示数值溢出（如非零数除以0），符号为0。</td></tr><tr><td><strong>负无穷大（-∞）</strong></td><td>1</td><td>全1（255）</td><td>0</td><td>-∞</td><td>类似正无穷大，但符号为负。</td></tr><tr><td><strong>NaN（非数）</strong></td><td>0或1</td><td>全1（255）</td><td>M \neq 0</td><td>\text{NaN}</td><td>表示无效运算结果（如0/0、负数平方根），尾数非0。</td></tr><tr><td><strong>规格化正数</strong></td><td>0</td><td>1 \leq E \leq 254</td><td>任意M</td><td>(-1)^0 \times 2^{E-127} \times 1.M</td><td>常规正数，隐藏位1自动补到尾数前，指数范围为-126到+127。</td></tr><tr><td><strong>规格化负数</strong></td><td>1</td><td>1 \leq E \leq 254</td><td>任意M</td><td>(-1)^1 \times 2^{E-127} \times 1.M</td><td>常规负数，隐藏位1自动补到尾数前，指数范围同上。</td></tr></tbody></table><ol><li><p><strong>正零与负零</strong>：</p><ul><li>实际运算中两者等效（如  +0 = -0 ），但符号位不同，某些场景（如函数极限）可能区分两者。</li></ul></li><li><p><strong>非规格化数</strong>：</p><ul><li><strong>作用</strong>：<ul><li>解决“<strong>阶码下溢</strong>”问题。当数值小于最小规格化数（ $2^{-126}$ ）时，用非规格化数平缓过渡到零。</li><li>避免计算结果突然归零（例如  $1.0 \times 2^{-127}$  无法用规格化数表示，但可用非规格化数  $0.5 \times 2^{-126}$ 表示）。</li></ul></li></ul></li><li><p><strong>无穷大（±∞）</strong>：</p><ul><li><strong>作用</strong>：<ul><li>标记数值溢出（如  1.0 / 0.0 ）或不可达值。</li><li>使程序在溢出时继续运行，而非直接崩溃（例如浮点数除0返回无穷大，整数除0则报错）。</li></ul></li></ul></li><li><p><strong>NaN（非数）</strong>：</p><ul><li><strong>作用</strong>：<ul><li>表示无效运算（如  0/0 、 ∞/∞ 、负数平方根）。</li><li>程序可通过检测NaN跳过错误，避免中断（例如返回NaN后继续执行后续逻辑）。</li></ul></li></ul></li><li><p><strong>规格化数</strong>：</p><ul><li><strong>隐藏位1</strong>：尾数前隐含的1无需存储，节省1位空间，提升精度（例如23位尾数实际表示24位数值）。</li><li><strong>指数范围</strong>：阶码E偏移127，实际指数范围为  $-126 \leq E \leq +127$</li></ul></li></ol><ul><li><p><strong>非规格化数应用</strong>：<br>计算  $1.0 \times 2^{-128}$ （远小于最小规格化数  $2^{-126}$ ），可用非规格化数表示为  $0.25 \times 2^{-126}$ 。</p></li><li><p><strong>无穷大应用</strong>：<br>当计算  1.0 / 0.0  时，结果为  +∞ ，程序可继续执行后续操作（如判断结果是否为无穷大）。</p></li><li><p><strong>NaN应用</strong>：<br>计算  $\sqrt{-1}$ 时返回NaN，程序员可捕获此结果并处理异常。</p></li></ul><p>总结：</p><ul><li>非规格化数：缓冲极小值，避免数值突变。</li><li>无穷大：标记溢出，防止程序崩溃。</li><li>NaN：兜底无效运算，增强容错能力。</li></ul><p>注：</p><ul><li><p>浮点数加减法第一步是<strong>对阶</strong><br>对阶的规则是：小阶向大阶看齐。即阶码小的数的尾数<mark>算术右移</mark>，每右移一位，阶码加 1直到两数的阶码相等为止。<br>因此不存在阶码减小、尾数左移。<mark>只有阶码增大，尾数右移</mark>。<br>对阶不会引起阶码<strong>上溢或下溢</strong><br><strong>右规、尾数舍入</strong>时可能引起阶码<strong>上溢</strong><br><strong>左规</strong>时可能引起阶码<strong>下溢</strong></p></li><li><p>在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有<strong>规格化后阶码</strong>超出所能表示的范围时，才发生溢出。<br>判断浮点数运算是否溢出，取决于阶码是否上溢。阶码下溢可以通过非规格化数来表示。尾数上溢或下溢，可以通过左移或右移进行调整。</p></li><li><p>与非规格化浮点数相比，采用规格化浮点数的目的主要是为了增加数据的表示精度</p></li><li><p>运算结果在0至规格化最小正数之间时称为正下溢，运算结果在0至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。</p></li><li><p><strong>舍入</strong>是浮点数的概念，定点数没有舍入的概念。</p></li><li><p>浮点数舍入的情况有两种：对阶、右规格化。</p></li><li><p>舍入不一定产生误差，如向下舍入11.00 到11.0时是没有误差的</p></li><li><p>浮点数表示中基数的值是约定好的，因此将其隐含。</p></li><li><p>阶移尾原</p></li><li><p>偏置值=2^(n-1)-1</p></li><li><p>阶码决定范围，尾数决定精度。在浮点数总位数不变的情况下。<strong>阶码</strong>位数越多，<strong>尾数</strong>位数越少。即<strong>范围越大，精度越低</strong></p></li><li><p><strong>阶码</strong>的值决定了<strong>小数点的位置</strong></p></li><li><p><strong>基数</strong>越大，在运算中尾数<strong>右移</strong>的可能性越小，运算的<strong>精度损失越小</strong>。</p></li><li><p>由于<strong>基数</strong>大时发生因对阶或尾数溢出需右移及规格化需左移的次数显著减少，因此运算<strong>速度</strong>可以提高。</p></li><li><p><strong>基数</strong>越大，可表示的数的<strong>范围</strong>越大，所表示的数的个数越多，精度降低。</p></li><li><p>IEEE 754浮点数格式位数有限(单精度32位、双精度64位)，无法精确表示无限循环小数。</p></li></ul><h2 id="1-8-C语言中的数据类型及转换">1.8 C语言中的数据类型及转换</h2><p>无论是无符号数还是有符号数，C语言程序并不检测数据在加、减、乘等运算中产生的<strong>溢出</strong>现象。<br>程序员应尽量避免出现这种情况，所编制的应用程序应具有对溢出进行判断的功能。<br>char 8<br>short 16<br>int 32<br>long 64<br>float 32<br>double 64<br>65535=1111 1111 1111 1111<br><mark>都是按照补码形式存储的</mark><br><font color="#f79646">定义的变量值是真值，存储的是补码，输出的值是真值，要把补码转成有符号位的原码</font><br>eg.<br>unsigned short x = unsigned short = 65535;<br>short y = (short)x;<br>y存储的值是1111 1111 1111 1111，补码全为1对应的十进制真值是-1</p><h2 id="1-9-有符号数与无符号数的转换">1.9 有符号数与无符号数的转换</h2><ol><li><strong>转换规则</strong><ul><li>当位数相同的<strong>有符号数</strong>与<strong>无符号数</strong>相互转换时，<strong>二进制位保持不变</strong>，仅改变解释方式。<br>注：如果是<strong>负数</strong>，要转换成<strong>补码</strong>形式。同样，如果无符号转有符号，第一位是1，是负数，也要转成补码</li><li><strong>有符号数 → 无符号数</strong>：符号位被当作数值的一部分。<br>①若从小字长转换到大字长，则要先对原数字的高位部分进行扩展，若原数字是无符号整数，则进行零扩展；若原数字是有符号整数，则进行符号扩展。<br>②若从大字长转换到小字长，则直接截取低位部分。也就是说，先进行字长的转换，再进行符号的转换。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> x = <span class="number">-4321</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y = (<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="comment">// x的二进制补码：11101111 11101111</span></span><br><span class="line"><span class="comment">// y被解释为无符号数：61215</span></span><br></pre></td></tr></table></figure></li><li><strong>无符号数 → 有符号数</strong>：最高位被当作符号位。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> x = <span class="number">65535</span>;  <span class="comment">// 二进制全1</span></span><br><span class="line"><span class="type">short</span> y = (<span class="type">short</span>)x;</span><br><span class="line"><span class="comment">// y的二进制补码10000000 00000001解释为有符号数：-1</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-10-不同字长整数之间的转换">1.10 不同字长整数之间的转换</h2><ol><li><strong>大字长 → 小字长（截断高位）</strong><ul><li><strong>规则</strong>：直接截断高位部分，保留低位部分。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">165537</span>;      <span class="comment">// 0010 1000 0110 1010 0001</span></span><br><span class="line"><span class="type">short</span> y = (<span class="type">short</span>)x;  <span class="comment">// 保留低16位，1000 0110 1010 0001 当前是补码，负数，转真值1,111 1001 0101 1111 → 十进制-31071</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> u = <span class="number">-34991</span>;      <span class="comment">// 存储为补码，-34491全部取反+1 0,111 1111 1111 1111 0111 0111 0101 0001</span></span><br><span class="line"><span class="type">short</span> v = (<span class="type">short</span>)u;  <span class="comment">// 保留低16位0111 0111 0101 0001 → 十进制30545</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>小字长 → 大字长（符号扩展或零扩展）</strong><ul><li><strong>规则</strong>：<ul><li><strong>有符号数</strong>：进行<strong>符号扩展</strong>（高位填充原符号位）。</li><li><strong>无符号数</strong>：进行<strong>零扩展</strong>（高位填充0）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> x = <span class="number">-4321</span>;      <span class="comment">// 二进制补码：11101111 11101111（符号位1）</span></span><br><span class="line"><span class="type">int</span> y = x;            <span class="comment">// 符号扩展为11111111 11111111 11101111 11101111 → 十进制-4321</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> u = <span class="number">61215</span>;  <span class="comment">// 二进制：11101111 11101111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v = u;        <span class="comment">// 零扩展为00000000 00000000 11101111 11101111 → 十进制61215</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>注：</p><ol><li><p><strong>混合运算的隐式转换</strong></p><ul><li>若表达式中混合有符号和无符号数，<strong>有符号数会被隐式转换为无符号数</strong>，可能导致逻辑错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="comment">// 条件为假，因为-1被转换为无符号数（即4294967295）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据溢出与截断</strong></p><ul><li>大字长转小字长可能导致<strong>数据丢失</strong>（如<code>int</code>→<code>short</code>）。</li><li>小字长转大字长时，需明确扩展方式以避免数值错误。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329144222273.png" alt="image.png"></li></ul></li><li><p><strong>字符型转换的特殊性</strong></p><ul><li><code>char</code>类型(8位)默认按无符号整数处理，转换为<code>int</code>时进行<strong>零扩展</strong>。</li></ul></li></ol><h2 id="1-11-浮点数之间的转换">1.11 浮点数之间的转换</h2><table><thead><tr><th>转换方向</th><th>情况描述</th></tr></thead><tbody><tr><td><code>float</code> → <code>double</code></td><td>值相同</td></tr><tr><td><code>double</code> → <code>float</code></td><td>大数可能溢出，高精度发生舍入</td></tr><tr><td><code>float/double</code> → <code>int</code></td><td>小数部分向 0 截断，大数可能溢出</td></tr><tr><td><code>int</code> → <code>float</code></td><td>比较大的数无法精确表示</td></tr><tr><td><code>int</code> → <code>double</code></td><td>值相同</td></tr><tr><td>假设变量 <code>i</code>、<code>f</code>、<code>d</code> 的类型分别是 <code>int</code>、<code>float</code> 和 <code>double</code>，判断下列 C 语言关系表达式是否恒为真。</td><td></td></tr></tbody></table><ol><li><code>i == (int)(float) i;</code><ul><li>结果：不恒为真</li><li>原因：<code>i</code> 转换为 <code>float</code> 型时就可能出现精度缺失，可不考虑再转回 <code>int</code> 型。</li></ul></li><li><code>f == (float)(int) f;</code><ul><li>结果：不恒为真</li><li>原因：<code>f</code> 转换为 <code>int</code> 型时就可能出现小数部分向 0 截断 ，可不考虑再转回 <code>float</code> 型。</li></ul></li><li><code>i == (int)(double) i;</code><ul><li>结果：恒为真</li><li>原因：<code>i</code> 转换为 <code>double</code> 型后数值不变，因此再转回 <code>int</code> 型后数值不变。</li></ul></li><li><code>f == (float)(double) f;</code><ul><li>结果：恒为真</li><li>原因：<code>f</code> 转换为 <code>double</code> 型后数值不变，因此再转回 <code>float</code> 型后数值不变。</li></ul></li><li><code>d == (float) d;</code><ul><li>结果：不恒为真</li><li>原因：<code>d</code> 转换为 <code>float</code> 型时可能出现大数溢出和高精度舍入。</li></ul></li><li><code>f == -(- f);</code><ul><li>结果：恒为真</li><li>原因：浮点数取负仅将其数符（最高位）取反即可。</li></ul></li></ol><h2 id="1-12-数据存储和边界对齐">1.12 数据存储和边界对齐</h2><ol><li>大小端存储<ul><li><strong>小端</strong>：低对低，高对高（如 <code>0x1234</code> 存储为 <code>34 12</code>）。</li><li><strong>大端</strong>：低对高，高对低（如 <code>0x1234</code> 存储为 <code>12 34</code>）。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406115230806.png" alt="image.png|200">指令的二进制编码按 <strong>操作码 → 操作数 → 立即数</strong> 的顺序排列。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406115722956.png" alt="image.png|400"><br>在指令编码中，操作码（Opcode）和寄存器编号按顺序连续存放。操作码 MOV 为 40H，存放在地址 1000H；寄存器 EAX 的编号为 12H，存放在地址 1001H。<strong>立即数</strong>按大小端规则存放在后续地址<br>在阅读以小端方式存储的机器代码时，要注意字节是按相反顺序显示的。</li></ul></li><li>数据边界对齐存储<br><strong>边界对齐（Alignment）</strong> 是计算机内存管理的重要机制，要求数据在内存中的 <strong>起始地址</strong> 必须是其 <strong>自身大小的整数倍</strong>。现代计算机（尤其是 RISC 架构）普遍采用边界对齐存储，以优化访存效率。</li></ol><table><thead><tr><th><strong>数据类型</strong></th><th><strong>对齐要求（地址必须是…的倍数）</strong></th><th><strong>32位系统示例</strong></th></tr></thead><tbody><tr><td>字节（char）</td><td>1</td><td>地址任意（如 <code>0x0000</code>, <code>0x0001</code>）</td></tr><tr><td>半字（short）</td><td>2</td><td>地址为偶数（如 <code>0x0002</code>, <code>0x0004</code>）</td></tr><tr><td>字（int）</td><td>4</td><td>地址为4的倍数（如 <code>0x0004</code>, <code>0x0008</code>）</td></tr><tr><td>在 C 语言中，结构体（<code>struct</code>）的对齐需满足以下条件：</td><td></td><td></td></tr></tbody></table><ol><li><strong>成员对齐</strong>：每个成员的起始地址必须满足 <code>地址 % 对齐值 = 0</code>。</li><li><strong>结构体对齐</strong>：结构体总长度必须是 <strong>最大成员对齐值</strong> 的整数倍（不足则填充）。</li></ol><p>eg.<br><strong>1. 结构体 A：<code>struct A &#123; int a; char b; short c; &#125;</code></strong></p><ul><li><strong>成员对齐</strong>：</li></ul><table><thead><tr><th><strong>地址范围</strong></th><th><strong>内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>0x0000-0x0003</code></td><td><code>int a</code>（4字节）</td><td>对齐到 4 的倍数（0x0000）</td></tr><tr><td><code>0x0004</code></td><td><code>char b</code>（1字节）</td><td>对齐到 1 的倍数（0x0004）</td></tr><tr><td><code>0x0005</code></td><td><strong>填充 1 字节</strong></td><td>确保 <code>short c</code> 对齐到 2 的倍数</td></tr><tr><td><code>0x0006-0x0007</code></td><td><code>short c</code>（2字节）</td><td>对齐到 2 的倍数（0x0006）</td></tr></tbody></table><ul><li><strong>总大小</strong>：<ul><li>实际占用：<code>4 + 1 + 1（填充） + 2 = 8字节</code></li><li>结构体对齐：最大对齐值为4，8是4的倍数，无需额外填充。</li></ul></li></ul><p><strong>2. 结构体 B：<code>struct B &#123; char b; int a; short c; &#125;</code></strong></p><ul><li><strong>成员对齐</strong>：</li></ul><table><thead><tr><th><strong>地址范围</strong></th><th><strong>内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>0x0000</code></td><td><code>char b</code>（1字节）</td><td>对齐到 1 的倍数（0x0000）</td></tr><tr><td><code>0x0001-0x0003</code></td><td><strong>填充 3 字节</strong></td><td>确保 <code>int a</code> 对齐到 4 的倍数</td></tr><tr><td><code>0x0004-0x0007</code></td><td><code>int a</code>（4字节）</td><td>对齐到 4 的倍数（0x0004）</td></tr><tr><td><code>0x0008-0x0009</code></td><td><code>short c</code>（2字节）</td><td>对齐到 2 的倍数（0x0008）</td></tr><tr><td><code>0x000A-0x000B</code></td><td><strong>填充 2 字节</strong></td><td>确保结构体总大小为 4 的倍数</td></tr></tbody></table><ul><li><strong>总大小</strong>：<ul><li>实际占用：<code>1 + 3（填充） + 4 + 2 = 10字节</code></li><li>结构体对齐：最大对齐值为4，10不是4的倍数，需填充2字节至12字节。</li></ul></li></ul><p><strong>边界对齐 vs 边界不对齐</strong></p><ol><li>对齐存储</li></ol><ul><li><strong>特点</strong>：<ul><li>数据按对齐要求紧密排列，填充字节插入以对齐地址。</li><li><strong>优点</strong>：单次访存读取完整数据，效率高。</li><li><strong>缺点</strong>：可能浪费少量空间。</li></ul></li></ul><ol start="2"><li>不对齐存储</li></ol><ul><li><strong>特点</strong>：<ul><li>数据连续存放，无填充字节。</li><li><strong>缺点</strong>：跨存储字的数据需多次访存并拼接，效率低。</li></ul></li></ul><p><strong>应用场景</strong></p><ul><li><p><strong>RISC架构</strong>：强制边界对齐，确保指令流水线高效运行。</p></li><li><p><strong>嵌入式系统</strong>：权衡空间与效率，通常选择对齐存储。</p></li><li><p><strong>网络协议</strong>：数据包按对齐格式传输，避免接收端处理复杂度。</p></li><li><p><strong>结构体设计建议</strong>：</p><ul><li>按成员对齐值降序排列（如 <code>int → short → char</code>），减少填充字节。</li></ul></li></ul><h2 id="1-13-第二章错题">1.13 第二章错题</h2><ol><li>已知 [x]补 =1,0000000，则[-x]补 是(D)<br>A.0,1111111   B.0,0000001   C.1.0000000   D.无法表示<br><code>1,0000000</code>表示真值-128（最小负数）。  计算[-x]补 )，即求+128的补码。然而，8位补码的最大正数为+127，+128超出表示范围，<strong>无法表示</strong>。</li><li>设x为真值，x* 为其绝对值，满足 [-x*]补=[-x]补 当且仅当<br>A. x任意   B.x为正数   c.x为负数   D.以上都不对<br>当x为正数时，x* = x，等式成立<br>当x为0时，等式成立<br>当x为负数时，x* = -x， [x]补≠[-x]补，等式不成立<br>b是充分条件，选d</li><li>由3个“1”和5个“0”组成的8位二进制补码，能表示的最小整数是()。<br>A.-126   B.-125   C.-32   D.-3<br>补码若符号位相同，数值位越大（即二进制中1的位数越多），码值越大。此处1位数一样，<strong>最高位的 <code>1</code> 位置越靠左（权重越大），对应的绝对值越小，码值越大</strong>。故补码为1000 0011，真值为-125<br>刚开始想的补码1110 0000，是一个无效补码，因为补码的最小负数是<code>10000000</code>（-128），而<code>11100000</code>不是合法的补码表示。</li><li>若某浮点数为$2^{11}×1.1011$，其中阶码为原码表示，尾数为补码表示，则该浮点数()<br>A.需要将尾数数值部分右移1位规格化<br>B.需要将尾数数值部分右移2位规格化<br>C.需要将尾数数值部分左移1位规格化<br>D.已经规格化<br>补码负数规格化，符号位为1，则尾数最高位应为0，将尾数数值部分左移1位规格化，即为$2^{10}×1.0110$</li><li>-0.4375的IEEE754单精度浮点数表示为()<br>A.BEE0 0000H   B.BF60 0000H    C.BF70 0000H   D.C0E0 0000H<br>-0.4375=-0.0111，应该转化为$2^{-2}×(-1.11)$，S=1，E=125=01111101，M=11，选A</li><li>有如下C语言程序段：short si=-32767;unsigned short usi = si;执行上述两条语句后，usi的值为()。<br>A.-32767   B.32767   C.32768   D.32769<br>因为si是负数，先转换成补码形式1000 0000 0000 0001，转换成无符号数后为32769</li><li>unsigned short usi=65535:short si = usi;执行上述程序段后，si的值为()。<br>A.-1   B.-32767   C.-32768   D.-65535<br>1111 1111 1111 1111，第一个1看作符号位，负数，转补码，即1000 0000 0000 0001，-1</li><li>一个C语言程序在一台32位机器上运行。程序中定义了三个变量x，y和z，x和z为int型，y为short型当x=127，y=-9时，执行赋值语句z=x+y后，x，y和z的值分别是()。<br>A.x=0000007FH，y=FFF9H，2=00000076H<br>B.x=0000007FH，y=FFF9H，Z=FFFF0076H<br>C.x=0000007FH，y=FFF7H，Z=FFFF0076H<br>D.X=0000007FH，y=FFF7H，2=00000076H<br><code>x</code> 为 <code>int</code> 型（32位），赋值为 <code>127</code>，其补码为0x0000007\text{F}<br><code>y</code> 为 <code>short</code> 型（16位），赋值为 <code>-9</code>，其补码为0xFFF7<br><code>y</code> 从 <code>short</code> 提升为 <code>int</code> 时，进行符号扩展0xFFFFFFF7<br>执行 <code>z = x + y</code>：  $\begin{align*}0x0000007\text{F} &amp; \quad (\text{十进制 } 127) \+,0xFFFFFFF7 &amp; \quad (\text{十进制 } -9) \\hline0x00000076 &amp; \quad (\text{十进制 } 118)\end{align*}$ d</li><li>对于相同位数(设为N位，不考虑符号位)的二进制补码小数和十进制小数，二进制小数能表示的数的个数/十进制小数所能表示数的个数为()。<br>A.$(0.2)^N$   B.$(0.2)^{N-1}$  C.$(0.02)^N$   D.$0.02^{N-1}$<br>N位二进制小数共有2^N种状态，每种状态都能表示一个不同的小数，而十进制小数能表示的数的个数为 10^N，二者的商为(0.2)^N</li><li>下列关于补码和移码关系的叙述中，()是不正确的。<br>A.相同位数的补码和移码表示具有相同的数据表示范围<br>B.0的补码和移码表示相同<br>C.同一个数的补码和移码表示，其数值部分相同，而符号相反<br>D.一般用移码表示浮点数的阶码，而补码表示定点整数<br>0的补码是0000 0000，0的移码是1000 0000，选b</li><li>一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则下列说法中正确的是()。<br>A.若采用移码表示，偏置值为127，则此整数最小为-64<br>B若采用移码表示，偏置值为128，则此整数最大为123<br>C.若采用补码表示，则此整数最小为-96<br>D.若采用补码表示，则此整数最大为 252<br>当采用补码表示时，要使得数值最大，就要让符号位为0，且把“1”放在高位，得到的补码为01111110B=126<br>要使得数值最小，就要让符号位为1，且把“1”放在低位，得到的补码为 10011111B=-97。<br>当采用移码表示时，设偏置值为128，要使数值最大，就要把“1”放在高位，得到的移码为11111100B，转补码是0111 1100=124<br>设偏置值为127，要使得数值最小，则应把“1”放在低位，得到的移码为 0,011 1111B，【错误：转补码是1,011 1111B，转原码是1,100 0001B=-65。移码和补码的转换仅适用于特定场景】，真值=移码值−偏置值=63−127=−64，A 正确。</li><li>在计算机中，通常用来表示主存地址的是()<br>A.移码   B.补码   C.原码   D.无符号数<br>主存地址都是正数，因此不需要符号位，因此直接采用无符号数表示。</li><li>ALU作为运算器的核心部件，其属于()<br>A.时序逻辑电路 B.组合逻辑电路 C.控制器 D.寄存器<br>ALU 是由组合逻辑电路构成的，最基本的部件是并行加法器。单纯的ALU 不能够存储运算结果和中间变量，因此往往将 ALU 和寄存器或暂存器相连。</li><li>下列四个补码整数存放于8位寄存器中，算术左移不会发生溢出的是()。A. 80H  B. 90H  C.B0H  D.C0H<br>80H=(1000 0000)&lt;&lt;1=00000000，左移前的符号位为1，左移后的符号位为0，溢出；90H=(10010000)&lt;&lt;1=0010 0000，左移前的符号位为1，左移后的符号位为0，溢出；B0H=(1011 0000)&lt;&lt;1=01100000，左移前的符号位为1，左移后的符号位为0，溢出。C0H=(11000000)&lt;&lt;1=10000000，左移前的符号位为1，左移后的符号位为1，未溢出，选项D正确。</li><li>设机器数字长8位(含1位符号位)，若机器数BAH为补码，算术左移1位和算术右移1位分别得()。<br>A. F4H,EDH  B. B4H,6DH  C.74H,DDH  D. BSH,EDH<br>题目中有机器数、寄存器等用机器移动，符号位和数值位一起移。BAH=(10111010)，算术左移1位得(01110100)= 74H，左移前后的符号位不同，溢出；算术右移1位得(1101 1101)= DDH。</li><li>在定点运算器中，无论是采用双符号位还是采用单符号位，必须有()。<br>A.译码电路，它一般用“与非”门来实现<br>B.编码电路，它一般用“或非”门来实现<br>C.溢出判断电路，它一般用“异或”门来实现<br>D.移位电路，它一般用“与或非”门来实现<br>无论采用单符号位还是双符号位，运算器必须包含<strong>溢出判断电路OF=Cn​⊕Cn−1​</strong><ul><li><strong>译码电路（A）</strong>：用于指令译码，属于控制单元功能，非运算器必需。</li><li><strong>编码电路（B）</strong>：用于信号编码，非运算核心部件。</li><li><strong>移位电路（D）</strong>：乘除运算需要移位，但纯加减运算无需移位，非必需。</li></ul></li><li>机器运算发生溢出的根本原因是()<br>A.寄存器的位数有限                 B.运算中将符号位的进位丢弃<br>C.运算中将符号位的借位丢弃  D.数据运算中发生错误<br>a</li><li>关于模4补码，下列说法正确的是()。<br>A.模4补码和模2补码不同，它不容易检查乘除运算中的溢出问题B.每个模4补码存储时只需一个符号位<br>C.存储每个模4 补码需要两个符号位<br>D.模4补码，在算术与逻辑单元中为一个符号位<br>模4补码（即双符号位补码）是一种用于检测运算溢出的编码方式。c</li><li>某计算机字长为8位，CPU中有一个8位加法器。已知无符号数x=69，y=38，若在该加法器中计算x-y，则加法器的两个输入端信息和输入的低位进位信息分别为()。<br>A.01000101、00100110、0<br>B.01000101、11011001、1<br>C.01000101、11011010、0<br>D.01000101、11011010、1<br>x=01000101，y=00100110，-y的补码=11011010，低位进位Sub为1，d</li><li>某8位计算机中，x和y是两个有符号整数，用补码表示，[x]补=44H，[y]补=DCH，则x-2y的机器数及相应的溢出标志OF分别是()。<br>[x]补=44H = 01000100，[y]补=DCH = 11011100。执行 x - 2y 时，先将 y 算术左移一位，得到 10111000，未溢出，然后各位取反，再与 x 相加，做减法时 sub = 1，即 01000100+01000111 + 1=10001100(8CH)，两个加数的符号都为 0，而结果的符号为 1，因此发生了溢出，即 OF = 1。</li><li>某C语言代码段如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> si=<span class="number">65536</span>;</span><br><span class="line"><span class="type">short</span> i=si;</span><br><span class="line"><span class="type">unsigned</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=j<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;王道&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;计算机教育&quot;</span>);</span><br></pre></td></tr></table></figure>当上述代码段执行到i分支条件的判断时，会根据标志寄存器中的()决定执行顺序最终的输出结果是()。<br><a href="http://A.CF">A.CF</a>、王道   B.CF.计算机教育   C.OF,王道   D.OF，计算机教育<br><strong><code>int si = 65536</code></strong>：00000000 00000001 00000000 00000000<br><strong><code>short i = si</code></strong>：截取低16位 <code>0x0000</code>，转换为有符号 <code>short</code>，值为 <strong>0</strong>。<br><strong><code>unsigned j = 0</code></strong>：<code>j-1</code> 为 <code>0-1</code>，无符号运算结果为 <code>UINT_MAX</code>（如32位为 <code>4294967295</code>）。<br><strong>比较 <code>i &lt;= j-1</code></strong>：<ul><li><p>有符号 <code>i</code>（0）转换为无符号 <code>0</code>，与无符号 <code>j-1</code>（<code>UINT_MAX</code>）比较。</p></li><li><p><strong>无符号比较规则</strong>：通过进位标志 <code>CF</code> 判断。若 <code>a &lt;= b</code>，则 <code>CF=1</code>（借位）或 <code>ZF=1</code>（相等）。</p></li><li><p>此处 <code>0 &lt;= UINT_MAX</code> 为真，触发 <code>CF=1</code>，条件成立。</p><ul><li><strong>CF（进位标志）</strong>：无符号比较时，<code>CF=1</code> 表示被减数小于减数。</li><li><strong>OF（溢出标志）</strong>：有符号运算溢出时触发，此处不适用。<br><strong>A. CF、王道</strong>。</li></ul></li></ul></li><li>【2024 统考真题】C语言代码段如下，执行该代码段后，j的值是()。int i=32777;short si=i;int j=si;<br>A.-32777   B.-32759   C.32759   D.32777<br>2^15=32768，i=000…0 1000000000001001，将32 位有符号数i强制转换为 16 位有符号数si机器数为1000000000001001，补码1,111111111110111，si=-32759。</li><li>设机器数字长8位(含1位符号位)，若机器数BAH为原码，算术左移1位和算术右移1位分别得()。<br>A. F4H,EDH   B. B4H,6DH   C.F4H,9DH   D.BSH,EDH<br>若机器数 BAH为补码，其余条件同上题，则有<br>A.F4H, DDH   B.B4H,6DH   C.F4H,9DH   D. BSH,EDH<br>BA=1,0111010<br>原码时：算数左移1,1110100 FAH；算数右移1,0011101 9DH<br>补码时：算术左移1,1110100 FAH；算数右移1,1011101 DDH</li><li>在规格化浮点运算中，若某浮点数为2^5x1.10101，其中尾数为补码表示，则该数()。<br>A.不需规格化                          B.需右移规格化<br>C.需将尾数左移一位规格化   D.需将尾数左移两位规格化<br>补码浮点数规格化应该形如 1.0xxx，尾数左移1位，变为 1.01010，2^4×1.01010。c</li><li>下列关于对阶操作说法正确的是()<br>A.在浮点加减运算的对阶操作中，若阶码减小，则尾数左移<br>B.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移；若阶码减小，则尾数左移<br>C.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移<br>D.以上都不对<br>对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况，因此选项 A、B 错误。选c</li><li>若某单精度浮点数、某原码、某补码、某移码的 32 位机器数均为 0xF0000000，则这些数从大到小的顺序是()<br>A.浮原补移   B.浮移补原   C.移原补浮   D.移补原浮<br>x=1111 000…0，浮点数=-2^113；原码=-111 000…0=-1879048192；补码=-0001 000…0=-268435456；移码=x-128=1,879,048,192<br>选d</li><li>已知 foat 型采用 IEEE 754单精度浮点格式,若x、y为foat型变量,且x=-126,y= 15.75,则执行语句 z=x+y时，在浮点运算单元中进行对阶操作后的结果是()<br>A.x不变，y为010000101,0.001111110…0<br>B.x不变，y为010000110,0.001111110…0<br>C.y不变，x为 110000101,0.001111110…0<br>D.y不变，x为 110000110,0.001111110…0<br>-126 = -1.11111 × 2^6，阶码：<code>6 + 127 = 133 → 10000101</code><br>15.75 = 1.11111 × 2^3，阶码：<code>3 + 127 = 130 → 10000010</code><br>y是小阶，要向大阶6对齐，y的尾数相应右移3位，变为0.00111111B<br>a</li><li>在 IEEE 754 标准浮点格式中，非规格化浮点数表示为<br>A.阶码为 0，尾数为任意非0的二进制数<br>B.阶码为 255，尾数全为 0<br>C.阶码为 255，尾数为任意非0的二进制数<br>D.阶码为 0，尾数全为 0<br>在 IEEE 754 标准格式中，阶码全为0，尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行下去。</li><li>假设已定义三个 int 型变量 x、y和 z，sizeof(int)=4，double 型采用 IEEE 754 双精度浮点数格式，变量 dx、dy 和 dz 的声明和初始化如下：double dx=(double)x;double dy=(double)y;double dz=(double)z;则下列关系表达式中永远为真的是()。<br>I. dx+ dy == (double)(x+y)<br>Il. dx × dx &gt;= 0<br>III. dx/dx == dy/dy<br>IV.(dx + dy)+ dz== dx + (dy + dz)<br>A. I和 II   B.II和III   C.III和IV   D.II和IV<br>选项I非永真，因为x+y可能溢出，而 dx+dy 不会溢出。如果是dx+ dy == (double)x+(double)y正确；选项Ⅱ永真，符号和数值部分分开计算，不管结果是否溢出，都不会影响乘积的符号；选项III非永真，dx 和 dy 中只要有一个为 0、另一个不为0 就不相等；选项 IV 永真，因为dx、dy 和 dz 是由 32 位 int 型转换得到的，double 型可以精确地表示 int 型，且对阶时尾数移动位数不会超过 52 位，因此尾数不会舍入，于是不会发生大数吃小数的情况。</li><li>在按字节编址的计算机中，采用小端方式存储数据，某静态二维数组b的声明如下：<code>static short b[2][4]=&#123;&#123;2,9,-1,5&#125;,&#123;3,1,-6,2&#125;&#125;;</code>若b的首地址为 0x8049820，采用按行优先存储，地址0x804982c中的内容是()<br>A. FAH   B. FFH   C.00H   D.05H<br>short型占2字节，采用按行优先存储，<code>b[0][0]</code>的地址为 0x8049820，<code>b[0][1]</code>的地址为 0x8049822，以此类推，<code>b[1][2]</code>的地址为 0x804982c。d对应值为-6，补码表示为 1111 1111 1111 1010，FFFAH，采用小端方式存储，因此地址 0x804982c存放的是低位字节 FAH。</li><li>在按字节编址的 32 位计算机中，按边界对齐方式为以下结构型变量x分配存储空间：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   struct cont info&#123;</span><br><span class="line">    char id;</span><br><span class="line">    unsigned post;</span><br><span class="line">    char phone;</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure>若x的首地址为 0x8049820，则成员变量phone的起始地址为()<br>A.0x8049828   B.0x8049826   C.0x8049825   D.0x8049822<br>char放到0x8049820，unsigned默认是unsigned int，起始地址应该是4的整数倍，0x8049821不可以，往后直到0x8049824可以，占四个字节，char是0x8049828</li><li>【2009 统考真题】浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7(均含2位符号位)。若有两个数X=2^7×29/32和Y=2^5×5/8，则用浮点加法计算X+Y的最终结果是( )。<br>A.001111100010   B.001110100010<br>C.010000010001   D.发生溢出<br>29的二进制是11101，尾数共7位，写成0011101，除32，即2^5，定点整数的小数点在最后，即0011101.，向左移动五位，00,11101，X=00,111;00,11101<br>5的二进制是101，扩展位数0000101，向左3位，即0000,101，前面多的0省略并补充位数，即00,10100，Y=00.101;00,10100<br>对阶：Y=00,111;00,00101<br>尾数相加：01,00010<br>规格化：右规，即01,000;00,10001(0)，阶码01，溢出，d</li><li>【2014 统考真题】float 型数据常用 IEEE 754 单精度浮点格式表示。假设两个 foat 型变量x和y分别存放在 32位寄存器和12中,若(fl)=CC90 0000H,(f2)=B0C0 0000H,则x和y之间的关系为()<br>A.x&lt;y且符号相同      B. x&lt;y 且符号不同<br>C.x&gt;y且符号相同      D.x&gt;y且符号不同<br>x，y都是负数，(f1)和(12)对应的二进制分别是(110011001001.),和(101100001100…)，(f1)的绝对值为 1.001×2^26，(f2)的绝对值为 1.1×2^-30，(1)的绝对值比(12)的绝对值大，而符号为负，真值大小相反，即(f1)的真值比(f2)的真值小，即 x&lt;y。a</li><li>【2018 统考真题】某 32 位计算机按字节编址，采用小端方式。若语句“inti=0:”对应指令的机器代码为“C7 45 FC 00 00 00 00”，则语句“inti=-64:”对应指令的机器代码是()。<br>A. C7 45 FC CO FF FF FF   B. C 45 FC OC FF FF FF<br>C. C7 45 FC FF FF FF CO   D. C7 45 FC FF FF FF OC</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数制转换（二/十/十六进制） </tag>
            
            <tag> 定点数与浮点数 </tag>
            
            <tag> 原码/反码/补码运算 </tag>
            
            <tag> 算术逻辑单元（ALU） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 2 章 进程与线程：并发管理核心</title>
      <link href="/post/833e46bb.html"/>
      <url>/post/833e46bb.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程">进程与线程</h2><h3 id="进程的概念与特征">进程的概念与特征</h3><h4 id="进程的定义">进程的定义</h4><ul><li>进程是程序的一次执行过程</li><li>一个程序可能对应多个进程</li><li>程序不运行，就没有进程<br>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。<br>进程：是动态的，是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程</li><li>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个<strong>独立单位</strong><br>一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行</li><li><strong>为什么引入进程</strong>：<ul><li>为了使多道程序并发执行，提高资源利用率和系统吞吐量</li><li>为了可以对并发执行的程序加以描述和控制，实现操作系统的并发性和共享性</li></ul></li></ul><p>进程目的：描述程序动态执行过程的性质</p><h4 id="进程的特征">进程的特征</h4><ul><li><strong>动态性</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的【<strong>最基本的特征</strong>】</li><li><strong>并发性</strong>：内存中有多个进程实体，各进程可并发执行</li><li><strong>独立性</strong>：进程是能独立运行、<strong>独立获得资源、独立接受调度的基本单位</strong></li><li><strong>异步性</strong>：各进程按各自独立的、不可预知的速度向前推进【操作系统要提供“进程同步机制”来解决异步问题】</li><li><strong>结构性</strong>：每个进程都会配置一个PCB，从结构上看，进程由程序段、数据段、PCB组成</li></ul><p>由于并发进程之间的<mark>执行相对速度</mark>不能有进程本身控制，当他们在共享某些资源的时候可能会产生与<mark>时间</mark>有关的错误</p><h4 id="进程-VS-程序-VS-作业">进程 VS 程序 VS 作业</h4><ul><li>作业：用户提交给系统的一个计算任务<ul><li>批作业 = 程序 + 数据 + 作业控制说明书<br>从后备状态【外存：作业输入井】，通过作业调度，到驻留【宏观上运行，内存】，再完成【磁盘】</li><li>交互作业 = 程序 + 数据 + 交互命令<br>是用于人机之间交互的一个概念<br>直接进入驻留状态</li></ul></li><li>进程：是<strong>动态的</strong>，是程序的一次执行过程【如：可同时启动多次 QQ】</li><li>程序：是<strong>静态的</strong>，是作业的组成部分，就是存放在磁盘里的可执行文件【如：QQ.exe】</li><li>同一个程序多次执行会对应多个进程</li></ul><p>注：一个作业可以包含多个程序和数据集，但<strong>至少包含一个程序</strong></p><h4 id="进程的组成">进程的组成</h4><ul><li><p>一个<strong>进程实体</strong>（进程映像）由 <strong>PCB、程序段、数据段</strong>组成<br>进程实体 管理控制每一个程序的每一次执行过程<br>进程实体反映了进程在某一时刻的状态</p></li><li><p>PCB是给os用的，程序段【程序的代码（指令序列）】、数据段【运行中产生的各种数据】是给进程自己用的，与进程自身的运行逻辑有关</p></li><li><p>进程是动态的，进程实体（进程映像）是<strong>静态的</strong></p></li><li><p>进程包含：代码、数据、CPU寄存器的值、堆、栈、进程所占用的系统资源（如打开的文件）</p></li></ul><h5 id="进程控制块（PCB）">进程控制块（PCB）</h5><ul><li><strong>定义</strong>：<ul><li>PCB 是进程实体的一部分，<strong>是进程存在的唯一标志</strong></li><li>进程创建时，操作系统为它新建一个 PCB，该结构常驻内存</li><li>当进程结束时，会回收其PCB</li><li><strong>操作系统对进程进行管理工作所需的信息都存在PCB中</strong></li></ul></li><li><strong>包含</strong>：<ol><li><strong>进程描述信息</strong>：<ul><li>进程标识符 PID：标识各个进程，每个进程都有一个并且唯一的标识号</li><li>用户标识符 UID：进程归属的用户，用户标识符主要为共享和保护服务，每个用户都有一个唯一的</li></ul></li><li><strong>进程控制和管理信息</strong>：<ul><li>进程当前状态【就绪态、阻塞态、运行态】：描述进程状态信息，作为 CPU 调度的依据</li><li>进程优先级：描述进程抢占 CPU 的优先级</li><li>代码运行入口地址</li><li>程序的外存地址</li><li>进入内存时间</li><li>CPU 占用时间</li><li>信号量使用</li></ul></li><li><strong>资源分配清单</strong>：<ul><li>有关内存地址空间和虚拟地址空间的状况</li><li>所打开文件的列表和所使用的输入/输出设备信息</li><li>正在使用哪些文件</li><li>正在使用哪些内存区域</li><li>正在使用哪些I/O设备</li></ul></li><li><strong>处理机相关信息</strong>【CPU 的上下文】：<ul><li>CPU 中各寄存器的值，用于实现进程切换（如PSW、PC的值）</li><li>当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中以便进程重新执行时，能从断点处继续执行</li></ul></li></ol></li><li><strong>组织方式</strong>：<ul><li>链接方式：<ul><li>把同一状态的 PCB 链成一个队列，不同状态对应不同的队列</li><li>也可把处于阻塞态的进程的 PCB，根据阻塞原因，排成多个阻塞队列</li></ul></li><li>索引方式：<ul><li>将同一状态的进程组织在一个索引表中，索引表的表项指向相应的 PCB</li><li>如就绪索引表，阻塞索引表</li></ul></li></ul></li></ul><h5 id="程序段">程序段</h5><ul><li>能被进程调度程序调度到 CPU 执行的程序代码段</li><li>程序可以被多个进程共享，即多个进程可以运行同一个程序</li></ul><h5 id="数据段">数据段</h5><ul><li>可以是进程对应的程序加工处理的原始数据</li><li>可以是程序执行时产生的中间或最终结果</li><li>同一个应用程序之间是共享多个进程的，只是数据段不相同<br>eg.同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的(都是运行着相同的QQ程序)</li></ul><h3 id="进程的状态与转换">进程的状态与转换</h3><h4 id="五种状态">五种状态</h4><ul><li><strong>运行态</strong> Running：该时刻进程占用 CPU</li><li><strong>就绪态</strong> Ready：进程获得了<strong>除处理机外的一切所需资源</strong>，但由于没有空闲CPU，就暂时不能运行</li><li><strong>阻塞态</strong> Blocked：该进程正在等待某一事件发生而暂停运行，如等待某个资源可用（不包括 CPU）或等待 I/O 完成</li><li><strong>创建态</strong> New：进程正在被创建时的状态</li><li><strong>结束态</strong> Exit：进程正在从系统中消失时的状态</li></ul><h4 id="状态转换">状态转换</h4><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240509150939.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250507162024425.png" alt="image.png"></p><ul><li><strong>就绪态 —&gt; 运行态</strong>：<ul><li>进程被调度，获得处理机资源（分派处理机时间片）</li></ul></li><li><strong>运行态 —&gt; 就绪态</strong>：<ul><li><strong>时间片用完</strong>后，不得不让出处理机</li><li>可剥夺的 OS 中，当有<strong>更高优先级的进程就绪</strong>时，调度程序将正在执行的进程转换为就绪态</li></ul></li><li><strong>运行态 —&gt; 阻塞态</strong>：【<strong>主动</strong>】<ul><li>进程请求某一资源（如外设） 的使用和分配时</li><li>等待某一事件的发送时（如 I/O 操作的完成）</li><li>进程以<strong>系统调用</strong>的方式请求 OS 提供服务，这个过程系统从用户态转换为核心态</li></ul></li><li><strong>阻塞态 —&gt; 就绪态</strong>：【<strong>被动</strong>】<ul><li>该过程是<strong>被动行为</strong>，需要其他相关进程的协助</li><li><strong>I/O</strong>操作结束或<strong>中断结束</strong>时</li><li>发送了阻塞队列等待的事件，如发送了 V 操作，信号量+1，然后阻塞队列被唤醒到就绪队列中</li></ul></li></ul><p>注：</p><ol><li><p>不能：<strong>阻塞态→运行态</strong>，<strong>就绪态→阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在<strong>运行</strong>时才能发出这种请求）</p></li><li><p>有可能出现所有进程都在等待I/O完成的情况，故可都处于<mark>阻塞</mark>态。<br>不可能都处于<mark>就绪</mark>态，可以一个运行，其他都就绪</p></li><li><p>进程PCB中，会有一个变量 state 来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态…</p></li><li><p>为了对同一个状态下的各个进程进行<strong>统一的管理</strong>，操作系统会将各个进程的PCB组织起来。</p><ul><li>进程的组织：<ul><li>链式方式【大部分】<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250507163529557.png" alt="image.png"><ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ul></li><li>索引方式<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250507163559878.png" alt="image.png|400"><ul><li>根据进程状态的不同，建立几张索引表</li><li>操作系统持有指向各个索引表的指针</li></ul></li></ul></li></ul></li></ol><h4 id="七状态模型">七状态模型</h4><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250509205128323.png" alt="image.png"></p><p>进程管理模块是操作系统最重要的组成部分，功能分为进程控制、进程调度</p><h3 id="进程控制">进程控制</h3><p>进程控制：需要一气呵成<br>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</p><ul><li><strong>进程控制</strong>：主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能【<strong>通过原语实现进程状态转换</strong>】</li><li><strong>原语</strong>：进程控制用的程序段【执行期间不允许中断，是一个不可分割的基本单位】<ul><li>可以用 “<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这两个<strong>特权</strong>指令实现原子性<br>关中断是指禁止系统接收和处理中断请求</li></ul></li></ul><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240509155911.png" alt="image.png"></p><h4 id="进程的创建">进程的创建</h4><ul><li>允许一个进程创建另一个进程</li><li>允许子进程继承父进程所拥有的资源</li></ul><p><strong>进程的创建过程</strong>：</p><ul><li><p><strong>创建原语</strong>：</p><ul><li>为新进程分配一个进程标识号，申请一个空白的 PCB【PCB 是有限的】</li><li>为该进程分配运行时所必需的资源，如内存、文件、I/O 和 CPU 时间等</li><li>初始化 PCB，如标志、状态、控制、优先级信息</li><li>将 PCB 插入<strong>就绪</strong>队列【创建态→就绪态】</li></ul></li><li><p><strong>引起进程创建的对应事件</strong></p><ul><li><strong>用户登录</strong>：分时系统中，用户登录成功，系统会为其建立一个新的进程</li><li><strong>作业调度</strong>：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li><strong>系统提供服务</strong>：用户向操作系统提出某些请求时，会建立一个进程处理该请求</li><li><strong>用户程序的应用</strong>：由用户进程主动请求创建一个子进程<br><strong>注意</strong>：<strong>设备分配</strong>不需要创建进程</li></ul></li></ul><h4 id="进程的终止">进程的终止</h4><ul><li>当子进程被终止时，其在父进程处继承的资源应当还给父进程</li><li>当父进程被终止时，该父进程的子进程就变为孤儿进程</li></ul><p><strong>进程的终止过程</strong>：</p><ul><li><strong>终止（撤销）原语</strong>：就绪态/阻塞态/运行态→终止态→删除消失<ul><li>从PCB集合中查找需要终止的进程的 PCB</li><li>如果处于<strong>执行</strong>状态，则立即<strong>终止</strong>该进程的执行，然后将 CPU 资源分配给其他进程</li><li>如果其还有<strong>子进程</strong>，全部终止</li><li>将该进程所拥有的全部资源都<strong>归还</strong>给操作系统</li><li>将其从 PCB 所在队列中<strong>删除</strong></li></ul></li><li><strong>引起进程终止的事件</strong>：<ul><li><strong>正常结束</strong>：进程任务完成并自己准备退出运行</li><li><strong>异常结束</strong>：进程运行时发生了异常事件</li><li><strong>外界干预</strong>：如操作系统干预、父进程请求或父进程终止</li></ul></li></ul><h4 id="进程的阻塞">进程的阻塞</h4><ul><li><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待</p></li><li><p>一旦被阻塞等待，只能由另一个进程唤醒</p></li><li><p><strong>阻塞原语</strong>：<strong>运行态→阻塞态</strong></p><ul><li>找到将要被阻塞进程标识号对应的 PCB</li><li>如果该进程为运行状态，则<strong>保护其现场</strong>，将其状态转为阻塞状态，停止运行</li><li>将该 PCB 插入到阻塞队列中去</li></ul></li><li><p><strong>引起进程阻塞的事件</strong>：</p><ul><li>需要等待系统系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul><h4 id="进程的唤醒">进程的唤醒</h4><ul><li>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成</li><li>处于阻塞状态的进程是绝对不可能叫醒自己</li><li>如果某进程正在等待 I/O 事件，需由别的进程发消息给它</li><li>只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它</li><li><strong>唤醒原语</strong>：<strong>阻塞态→就绪态</strong><ul><li>在该事件的阻塞队列中找到相应进程的 PCB</li><li>将其从阻塞队列中移出，并置其状态为就绪状态</li><li>把该 PCB 插入到就绪队列中，等待调度程序调度</li></ul></li><li><strong>注意</strong>：阻塞原语和唤醒原语必须成对使用</li><li><strong>引起进程唤醒的事件</strong>：<ul><li>等待的事件发生</li></ul></li></ul><h4 id="进程的切换">进程的切换</h4><ul><li><strong>切换原语</strong>：<strong>运行态→就绪态</strong>，<strong>就绪态→运行态</strong><ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，并更新其PCB</li><li>根据PCB恢复新进程所需的运行环境（进程上下文）</li></ul></li><li><strong>引起进程切换的事件</strong>：<ul><li>当前进程<strong>时间片到</strong></li><li>有<strong>更高优先级</strong>的进程到达</li><li>当前进程<strong>主动阻塞</strong></li><li>当前进程<strong>终止</strong></li></ul></li></ul><p>无论哪个进程控制原语，要做的无非三类事情：</p><ol><li>更新PCB中的信息<br>(1) 修改进程状态<br>(2) 保存/恢复运行环境</li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h3 id="进程通信-IPC">进程通信 IPC</h3><ul><li><strong>进程通信</strong>：指进程之间的信息交换</li><li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<strong>内存地址空间相互独立</strong></li><li>为了保证安全，一个进程不能直接访问另一个进程的地址空间</li></ul><h4 id="低级通信方式">低级通信方式</h4><ul><li>PV 操作</li></ul><h4 id="高级通信方式">高级通信方式</h4><h5 id="共享存储">共享存储</h5><ul><li>设置一个共享内存区域，并映射到进程的虚拟地址空间</li><li>要<strong>互斥地访问</strong>共享空间【<font color="#ff0000">通信进程自己负责实现</font>】</li><li><strong>基于数据结构的共享</strong>：<ul><li>比如共享空间里只能放一个长度为 10 的数组</li><li>速度慢、限制多</li><li>是一种<strong>低级</strong>通信方式</li></ul></li><li><strong>基于存储区的共享</strong>：<ul><li>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由<strong>通信进程控制</strong>，而<strong>不是操作系统</strong></li><li><strong>灵活性高、速度快</strong></li><li>是一种<strong>高级</strong>通信方式</li></ul></li></ul><h5 id="信息传递">信息传递</h5><ul><li>进程间的数据交换以<strong>格式化的消息</strong>为单位</li><li>进程通过操作系统提供的“<font color="#ff0000">发送</font>原语/<font color="#ff0000">接收</font>原语”两个原语进行数据交换</li><li>隐藏了通信实现细节，对<strong>用户透明</strong>，简化了通信程序的设计</li><li>应用最广泛</li><li><strong>直接通信方式</strong>：发送进程直接将消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从队列取得消息</li><li><strong>间接通信方式</strong>：发送进程将消息发送给某个中间实体【信箱】</li></ul><h5 id="管道通信">管道通信</h5><ul><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现<strong>单向</strong>的传输【如果要实现<strong>双向同时通信</strong>，则需要设置<strong>两个管道</strong>】</li><li>各进程要<strong>互斥</strong>地访问管道【<font color="#ff0000">由操作系统实现</font>】</li><li>当<strong>管道写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程</li><li>当<strong>管道读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程</li><li>管道中的数据一旦被读出，就<strong>彻底消失</strong>。因此，当多个进程读同一个管道时，可能会错乱，解决方案：<ol><li>一个管道允许<strong>多个写进程，一个读进程</strong>【考试】</li><li>允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程<strong>轮流</strong>从管道中<strong>读数据</strong>（Linux 的方案）</li></ol></li><li>管道是一种<strong>特殊文件</strong>，可以克服使用文件通信的两个问题：<ol><li>限制管道的大小：管道文件是一个固定文件大小的缓冲区</li><li>读进程也可能工作得比写进程快</li></ol></li><li>管道只能由<strong>创建进程</strong>访问【子进程可继承父进程的管道，并可用它来与父进程通信】</li><li>从管道读数据是<strong>一次性操作</strong>，数据一旦被读取，就释放空间以便写更多数据【相当于循环队列】</li></ul><table><thead><tr><th>通信方式</th><th>关键要点</th><th>互斥实现方</th><th>通信特性</th><th>灵活性</th><th>适用场景</th></tr></thead><tbody><tr><td>共享存储</td><td>设共享内存区并映射到虚拟地址空间  <br>分基于数据结构和存储区的共享</td><td><strong>通信进程</strong>自己负责</td><td>/</td><td>基于<strong>数据结构</strong>共享速度慢、限制多；<br>基于<strong>存储区</strong>共享灵活性高、速度快</td><td>适用于对通信速度和灵活性有较高要求，且能自行处理互斥问题的场景</td></tr><tr><td>信息传递</td><td>以<strong>格式化消息</strong>为单位  <br>用<strong>发送 / 接收原语</strong>交换数据  <br>分<strong>直接和间接</strong>通信方式</td><td>/</td><td>对<strong>用户透明</strong>，应用广泛</td><td>较高</td><td>广泛应用于各类进程间通信场景</td></tr><tr><td>管道通信</td><td><strong>半双工</strong>，需<strong>互斥</strong>访问  <br>写满读空进程会阻塞  <br>数据读出即消失  <br>特殊文件</td><td><strong>操作系统</strong>实现</td><td>半双工，有<strong>读写阻塞</strong>机制</td><td>相对受限</td><td>适用于简单的单向或双向（双管道）数据传输场景，如<strong>父子进程通信</strong></td></tr></tbody></table><h3 id="信号">信号</h3><p>信号量——实现进程间的同步、互斥<br>信号——实现进程间通信（IPC）<br>信号的作用：<font color="#ff0000">用于通知某个特定事件已经发生</font>（实现简单的进程间通信）。进程收到一个信号后，对该信号进行处理<br><strong>信号的发送与保存</strong>：</p><ol><li><strong>进程信号的发送</strong><br>用于<strong>发送</strong>信号的函数：int kill(pid_t pid,int sig);pit_t：发个谁，sig：发什么信号<br>用户进程之间可以发送信号【进程之间允许发送的信号类型是有限制的】<br>操作系统的内核进程也可以给用户进程发送信号<br>一个进程也可以给自己发送信号</li><li><strong>进程信号保存</strong><br>进程控制块（PCB）中，进程 P₁ 有不少于 N bit 位向量对应 N 种信号。<ul><li><strong>待处理信号（pending）</strong>：用位向量表示，如进程 P₁ 的<code>pending</code>中信号类型 1 和 8 对应位为 1，代表收到这两种信号待处理。</li><li><strong>被阻塞信号（blocked ，也称信号掩码 signal mask）</strong>：进程 P₁ 通过系统调用设置阻塞（屏蔽）7、8 两种信号，其<code>blocked</code>位向量中对应位为 1。</li></ul></li></ol><p><strong>什么时候处理信号</strong>：<br>当进程从<font color="#ff0000">内核态→用户态</font>时（如：系统调用返回、或中断处理返回时），例行检查是否有<strong>待处理信号</strong>，如果有，就处理信号。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250508162533079.png" alt="image.png"><br><strong>怎么处理信号</strong>：</p><ol><li><strong>信号处理方式</strong><ul><li><strong>默认处理</strong>：操作系统内核对每一种信号都有默认处理程序；部分信号默认忽略，不进行处理（如Linux的SIGWINCH信号）。如<code>sig1_default()</code>是信号 1 的默认处理程序，<code>sig8_default()</code>是信号 8 的默认处理程序。</li><li><strong>自定义处理</strong>：进程可为此类信号设置用户自定义信号处理程序，会覆盖默认处理程序。例如进程 P₁ 自定义的信号 2 处理程序<code>sig2_P₁handler()</code></li></ul></li><li><strong>信号处理规则</strong><ul><li>信号处理程序运行结束后，一般返回进程下一条指令继续执行，除非处理程序将进程阻塞或终止。</li><li>处理完某个信号，<code>pending</code>位重置为 0 。</li><li>重复收到同类信号会被丢弃，因只用 1bit 记录一类待处理信号。</li><li>同时收到多个不同类信号，通常先处理序号更小的信号。</li></ul></li><li><strong>以进程 P₁ 为例</strong><ul><li>进程 P₁ 的 PCB 中，<code>pending</code>记录待处理信号（信号 1 和 8 待处理 ），<code>blocked</code>记录被阻塞信号（信号 7 和 8 被阻塞 ）。</li><li>通过<code>pending &amp; ~blocked</code>（<code>pending</code>按位与<code>blocked</code>按位取反 ）操作，仅处理信号 1，不处理信号 8。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250508163058042.png" alt="image.png"></li></ul></li></ol><p><strong>信号特点</strong>：</p><ol><li>不同的操作系统，对信号类型的定义各不相同</li><li>重复收到的同类信号，将被简单地丢弃（因为仅用1bit记录一类待处理信号）</li><li><strong>有些信号既不能被用户自定义处理函数，也不能被阻塞</strong>（如Linux的SIGKILL，SIGSTOP信号）</li></ol><p><strong>信号与异常的关系</strong>：</p><ul><li><strong>信号作为异常配套机制</strong>：信号可<strong>补充</strong>操作系统的异常处理。进程运行中特殊事件引发异常，内核负责捕获处理。</li><li><strong>处理分工</strong><ul><li>部分异常<strong>内核可全部处理</strong>，如<strong>缺页异常</strong>，无需信号机制介入。</li><li>部分异常内核无法完全处理，需<strong>用户进程配合</strong>，如 Linux 中除以 0 异常，内核向用户进程发 SIGFPE 信号。默认处理程序会终止进程并转储内存，但进程可自定义 SIGFPE 信号处理程序。例如开发计算器应用，自定义 SIGFPE 处理程序可避免除以 0 时应用闪退崩溃。</li></ul></li></ul><h3 id="线程和多线程模型">线程和多线程模型</h3><h4 id="线程的基本概念">线程的基本概念</h4><ul><li>线程可理解为轻量级进程</li><li>线程是一个<strong>基本的 CPU 执行单元</strong>，也是<strong>程序执行流的最小单位</strong></li><li>引入线程后的变化：<ul><li><strong>并发性</strong>：进程内的各线程之间也可以并发，从而进一步提升了系统的并发度</li><li><strong>资源分配、调度</strong>：<strong>进程</strong>是<font color="#ff0000">资源分配</font>的基本单位，<strong>线程</strong>是<font color="#ff0000">处理机调度</font>的基本单位</li><li><strong>系统开销</strong>：传统的进程间并发，需要切换进程的运行环境，系统开销很大。线程间并发，如果是同一进程内的切换，则不需要切换进程环境，系统开销小</li></ul></li><li>多 CPU 计算机中，各个线程可占用不同的 CPU</li><li>每个线程都有一个<strong>唯一的标识符和一个线程控制块（TCB）</strong>【记录线程执行的寄存器和栈等现场状态】</li><li>不同的线程可以执行相同的程序</li><li>线程也有<strong>就绪、阻塞、运行</strong>三种基本状态，和进程之间的转换是一样的</li><li>线程几乎不拥有系统资源，【线程<strong>共享进程地址空间和资源</strong>，线程自己<strong>没有独立的地址空间</strong></li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h4 id="线程的组成和控制">线程的组成和控制</h4><h5 id="线程控制块-TCB">线程控制块 TCB</h5><ul><li><strong>功能</strong>：每个线程配置一个 TCB，用于记录控制和管理线程的信息</li><li><strong>组成</strong>：<ul><li>线程标识符</li><li>一组寄存器，包括程序计数器、状态寄存器和通用寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区，线程切换时用于保存现场</li><li>堆栈指针，用于过程调用时保存局部变量及返回地址</li></ul></li></ul><h5 id="线程的控制">线程的控制</h5><ul><li>创建线程：<ul><li>用户程序启动时，通常仅有一个称为<strong>初始化线程</strong>的线程正在执行，其主要功能是用于创建新线程</li></ul></li><li>终止线程：<ul><li>通常，线程被终止后并<strong>不立即释放</strong>它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用</li><li>被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行</li></ul></li></ul><h4 id="线程的实现方式">线程的实现方式</h4><h5 id="用户级线程（ULT）">用户级线程（ULT）</h5><ul><li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作都由应用程序负责</strong>（包括线程切换）</li><li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在【“用户级线程”就是“<strong>从用户视角看能看到的线程</strong>”】</li><li><strong>优点</strong>：<ul><li>线程切换不需要转到内核空间，节省了模式切换的开销</li><li>调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法</li><li>与操作系统平台无关，对线程管理的代码是属于用户程序的一部分</li></ul></li><li><strong>缺点</strong>：<ul><li>当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong></li><li>此时进程才是CPU的的基本单位，不能发挥多 CPU 的优势，内核每次分配给一个进程的仅有一个 CPU，因此<strong>进程中仅有一个线程执行</strong></li></ul></li><li>形成<strong>多对一模型</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511144229.png" alt="image.png"></li></ul><h5 id="内核级线程（KLT）">内核级线程（KLT）</h5><ul><li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成</li><li>内核级线程的切换必然需要在<strong>核心态</strong>下才能完成</li><li>操作系统会为每个内核级线程建立相应的TCB，通过 TCB 对线程进行管理【“内核级线程”就是“<strong>从操作系统内核视角看能看到的线程</strong>”】</li><li><strong>优点</strong>：<ul><li>能发挥多 CPU 的优势，内核能同时调度同一进程的多个线程并行执行</li><li>如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用 CPU，也可以运行其他进程中的线程</li><li>内核支持线程具有很小的数据结构和栈，线程切换快、开销小</li><li>内核本身也可采用多线程技术，可以提高系统的执行速度和效率</li></ul></li><li><strong>缺点</strong>：<ul><li>同一进程中的线程切换，需要从<font color="#ff0000">用户态→核心态</font>进行，系统开销较大【<font color="#ff0000">用户进程的线程在用户态执行，而线程调度和管理是在内核实现</font>】</li></ul></li><li>形成<strong>一对一模型</strong>：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511145234.png" alt="image.png"></li></ul><h5 id="组合方式">组合方式</h5><ul><li>内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程</li><li>用户级线程通过<strong>时分多路复用内核线程</strong>实现</li><li>结合 KLT 和 ULT 的优点，又克服各自的不足</li><li><strong>线程库</strong>：为程序员提供创建和管理线程的 API，实现方法：<ul><li>在<strong>用户空间</strong>中提供一个<strong>没有内核支持的库</strong>【调用库内的一个函数只导致用户空间中的一个本地函数的调用】</li><li>实现由操作系统直接支持的<strong>内核级的一个库</strong>【调用库中的一个 API 函数通常会导致对内核的系统调用】</li></ul></li><li>形成<strong>多对多模型</strong></li></ul><h4 id="多线程模型">多线程模型</h4><ul><li>由于用户级线程和内核级线程的连接方式不同，从而形成了三种不同的多线程模型</li><li>操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511145328.png" alt="image.png"></li></ul><h5 id="多对一模型【用户级】">多对一模型【用户级】</h5><ul><li><strong>定义</strong>：多个用户级线程映射到一个内核级线程，且<strong>一个进程只被分配一个内核级线程</strong></li><li><strong>优点</strong>：<ul><li>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li></ul></li><li><strong>缺点</strong>：<ul><li>当<font color="#ff0000">一个用户级线程被阻塞后，整个进程都会被阻塞</font>，并发度不高</li><li>任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个CPU 上运行</li></ul></li></ul><h5 id="一对一模型【内核级】">一对一模型【内核级】</h5><ul><li><strong>定义</strong>：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程</li><li><strong>优点</strong>：<ul><li>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强</li><li>多线程可在多核处理机上并行执行</li></ul></li><li><strong>缺点</strong>：<ul><li>每创建一个用户线程，就要创建一个对应的内核线程，开销大</li><li>线程切换由操作系统内核完成，需要切换到核心态，线程管理的成本高，开销大</li></ul></li></ul><h5 id="多对多模型">多对多模型</h5><ul><li><strong>定义</strong>：n 用户及线程映射到 m 个内核级线程（<strong>n &gt;= m</strong>），每个用户进程对应 m 个内核级线程。</li><li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中<strong>一个用户进程占用太多内核级线程</strong>，开销太大的缺点</li><li>用户级线程是“代码逻辑”的载体</li><li>内核级线程是“运行机会”的载体</li><li>一段“代码逻辑”只有获得了“运行机会”才能被CPU 执行</li><li>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有所有内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</li></ul><p>一对一和多对多模型并发性较好</p><h4 id="线程的组织与控制">线程的组织与控制</h4><ol><li><strong>线程控制块（TCB）</strong><ul><li><strong>线程标识符（TID）</strong>：类似进程标识符（PID），用于标识线程。</li><li><strong>程序计数器（PC）</strong>：记录线程当前执行位置，指示线程接下来要执行的指令。</li><li><strong>其他寄存器</strong>：保存线程运行过程中的中间结果，线程切换时需妥善保存与恢复，确保再次执行时能正确继续。</li><li><strong>堆栈指针</strong>：指向堆栈，堆栈存储函数调用信息、局部变量等，对线程执行函数调用等操作至关重要。</li><li><strong>线程运行状态</strong>：如运行、就绪、阻塞，反映线程当前所处状态，供操作系统调度管理。</li><li><strong>优先级</strong>：作为线程调度和资源分配的参考依据，高优先级线程可能优先获得 CPU 等资源。</li><li>在线程切换时，上述涉及程序执行状态和运行信息的部分（程序计数器、其他寄存器、堆栈指针等 ）需要保存和恢复，以保证线程下次执行能无缝衔接。</li></ul></li><li><strong>线程表</strong>：可将多个线程控制块（TCB）组织成线程表，便于操作系统对众多线程进行统一管理和调度 。</li></ol><h2 id="CPU-调度">CPU 调度</h2><h3 id="调度的概念">调度的概念</h3><ul><li>调度是对处理机进行分配，即从<strong>就绪队列</strong>中按照一定的算法（公平、高效的原则）<strong>选择一个进程并将 CPU 分配给它运行</strong>，以实现进程并发地执行</li><li><strong>CPU 调度是多道程序操作系统的基础</strong>，是 OS 设计的核心问题</li><li>作业：一个具体的任务</li><li>用户向系统提交一个作业=用于让操作系统启动一个程序来处理一个具体任务</li></ul><h4 id="调度的层次">调度的层次</h4><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511155616.png" alt="image.png"></p><h5 id="高级调度（作业调度）【后备-谁先提交到外存，谁先进内存】">高级调度（作业调度）【后备 谁先提交到外存，谁先进内存】</h5><ul><li>按一定的原则从外存的作业<font color="#ff0000">后备队列</font>中挑选一个作业调入内存，并创建进程。<br>简化理解：好几个程序需要启动，到底先启动哪个</li><li>是<font color="#ff0000">内存与辅存</font>的调度，从<strong>外存上处于后备队列的作业</strong>中调度</li><li><strong>每个作业只调入调出一次</strong></li><li>作业调入时会建立PCB，调出时才撤销PCB</li><li>通常存在于<strong>多道批处理系统</strong>中</li><li>内存与磁盘之间交换数据的转态转换：<strong>就绪态→挂起态</strong></li></ul><h5 id="中级调度（内存调度）">中级调度（内存调度）</h5><ul><li><strong>目的</strong>：提高<strong>内存利用率和系统吞吐量</strong><ul><li>当<strong>内存资源紧张</strong>时，可以使用内存调度将那些暂时不能运行的进程调至外存等待，此时进程的状态称为<strong>挂起态</strong></li><li>一般情况下，进程控制块PCB常住内存，换出换进的是进程的程序段和数据段。</li></ul></li><li>按照某种策略决定将哪个处于挂起状态的进程重新调入内存</li><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li><li>将暂时不能运行的进程调到外存等待，设为<strong>挂起态</strong></li><li>当具备运行条件且内存稍有空闲时，重新调入内存，修改状态为<strong>就绪态</strong>，挂在就绪队列上</li><li>是存储器管理中的对换功能</li></ul><h5 id="低级调度（进程调度-处理机调度）【就绪-谁先准备好用CPU，谁先执行】">低级调度（进程调度/处理机调度）【就绪 谁先准备好用CPU，谁先执行】</h5><ul><li>从<font color="#ff0000">就绪队列</font>中选取一个进程，将处理及分配给它，<strong>调用频率很高</strong></li><li>是操作系统中<font color="#ff0000">最基本的一种调度</font>，各种 OS 都必须配置这种调度</li><li>进程调度在以下情况发生：<ul><li>当前进程<strong>主动放弃</strong>CPU：进程<strong>主动请求阻塞</strong>（如等待I/O）、运行<strong>正常终止</strong>、运行过程中发生<strong>异常</strong>而终止<br>有的操作系统中，只允许进程主动放弃处理机</li><li>当前进程<strong>被动放弃</strong>CPU：如分配给进程的<strong>时间片用完</strong>、有<strong>更紧急</strong>的事需要处理（如I/O中断）、有<strong>更高优先级</strong>的进程进入就绪队列<br>有的操作系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</li></ul></li><li><strong>不能进行进程调度与切换的情况</strong><ol><li>在<strong>处理中断的过程中</strong>【中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换】</li><li>进程在<strong>操作系统内核程序临界区</strong>中【内核程序临界区一般是用来访问某种内核数据结构的，若不尽快释放访问的临界资源，可能会影响到 OS 内核的其他管理工作】<br><strong>普通的临界区可以</strong></li><li>在<strong>原子操作</strong>过程中(原语)。原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）</li></ol></li></ul><h5 id="三种调度的联系">三种调度的联系</h5><table><thead><tr><th><strong>调度类型</strong></th><th><strong>主要功能</strong></th><th><strong>调度发生场景</strong></th><th><strong>发生频率</strong></th><th><strong>对进程状态的影响</strong></th></tr></thead><tbody><tr><td><strong>高级调度（作业调度）</strong></td><td>从<strong>后备队列</strong>中选择合适的作业调入内存，并为其<strong>创建进程</strong>。<br>适合<strong>批处理</strong>系统</td><td>外存 → 内存（面向作业）</td><td>最低</td><td>无 → 创建态 → 就绪态</td></tr><tr><td><strong>中级调度（内存调度）</strong></td><td>从<strong>挂起队列</strong>中选择合适的进程，将其数据调回内存。</td><td>外存 → 内存（面向进程）</td><td>中等</td><td>挂起态 → 就绪态  <br>（或阻塞挂起 → 阻塞态）</td></tr><tr><td><strong>低级调度（进程调度）</strong></td><td>从<strong>就绪队列</strong>中选择一个进程，为其分配 CPU 资源。</td><td>内存 → CPU</td><td>最高</td><td>就绪态 → 运行态</td></tr></tbody></table><ul><li>作业调度为进程活动做准备，进程调度使进程正常活动</li><li>中级调度将暂时不能运行的进程挂起，中级调度处于另外两个调度之间</li><li>调用频率：作业调度 &lt; 内存调度 &lt; 进程调度</li><li>进程调度是最基本的，不可或缺</li></ul><h3 id="调度的实现">调度的实现</h3><h4 id="调度程序（调度器）">调度程序（调度器）</h4><ul><li><strong>调度程序</strong>：用于调度和分配 CPU 的组件<br>调度程序决定：<ul><li>让谁运行：调度算法</li><li>运行多长时间：时间片大小</li></ul></li><li>调度时机：什么事件会<strong>触发</strong>调度程序<ul><li><strong>创建新进程</strong></li><li><strong>进程退出</strong></li><li>运行<strong>进程阻塞</strong></li><li>I/<strong>O中断</strong>发生（可能唤醒某些阻塞进程）</li></ul></li><li>不支持内核级线程的os，调度程序的处理对象是<strong>进程</strong></li><li>支持内核级线程的os，调度程序的处理对象是<strong>内核线程</strong></li><li></li></ul><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511160742.png" alt="image.png"></p><ul><li><strong>组成</strong>：<ul><li><strong>排队器</strong>：按策略将就绪进程排成一个或多个队列</li><li><strong>分派器</strong>：从<strong>就绪队列</strong>中取出进程，并分配 CPU</li><li><strong>上下文切换器</strong>：在对处理机进行切换时，会发生两对上下文的切换：<ul><li>第一对：将当前进程的上下文保存到 PCB 中，再装入分派程序的上下文，以便分派程序运行</li><li>第二对：移出分派程序的上下文，将选新进程的 CPU 现场信息装入 CPU 的各个相应寄存器</li></ul></li></ul></li></ul><h4 id="进程调度的方式">进程调度的方式</h4><ol><li><strong>非抢占调度方式</strong>【非剥夺方式】：只允许进程主动放弃处理机<ul><li>优点：实现简单，系统开销小，适用于<strong>早期的批处理系统</strong></li><li>缺点：不适合<strong>分时</strong>和大多数的<strong>实时</strong>系统</li><li>只有运行进程<strong>阻塞</strong>或<strong>退出</strong>才出发调度程序工作</li></ul></li><li><strong>抢占调度方式</strong>【剥夺方式】：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程<ul><li>优点：<strong>提高系统吞吐率和响应率</strong>，适合<strong>分时、实时os</strong></li><li>缺点：必须遵循一定的原则（优先权、短进程优先、时间片原则等）</li><li>每个<font color="#ff0000">时钟中断</font>或k个时钟中断会触发调度程序工作</li></ul></li></ol><h4 id="进程的切换与过程">进程的切换与过程</h4><ul><li><strong>狭义的进程调度</strong>：从就绪队列中<strong>选中一个要运行的进程</strong>【这个进程可以是刚刚被暂停执行的进程，也可能是<strong>另一个进程</strong>，后一种情况就需要<strong>进程切换</strong>】</li><li><strong>进程切换</strong>：指一个进程让出处理机，由另一个进程占用处理机的过程</li><li><strong>广义的进程调度</strong>：包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤<br><strong>进程切换</strong>的过程主要完成了：<ol><li>对原来运行进程各种数据的<strong>保存</strong>（保存到PCB中）</li><li>对新的进程各种数据的<strong>恢复</strong>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）<br>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</li></ol></li><li><strong>闲逛进程</strong>：<ul><li>在进程切换时，如果系统中没有就绪进程，就会调用闲逛进程一直运行【<strong>PID 为 0</strong>】，并在指令周期后测试中断</li><li>特性<ul><li>优先级最低，只要有进程就绪，就会立即让出 CPU</li><li>可以是0地址指令，占一个<strong>完整的指令周期</strong>（指令周期末尾例行检查<strong>中断</strong>）</li><li>不需要 CPU 之外的资源，不会被阻塞</li><li>能耗低</li></ul></li></ul></li></ul><h4 id="两种线程的调度">两种线程的调度</h4><ul><li><strong>用户级线程调度</strong>：<ul><li>内核不知道线程的存在，选择一个进程，并给予时间控制</li><li>由进程中的调度程序决定哪个线程运行</li><li>线程切换在同一进程中进行，仅需少量的机器指令</li></ul></li><li><strong>内核级线程调度</strong>：<ul><li>内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程</li><li>超过时间片，强制挂起该线程</li><li>需要完整的上下文切换、修改内存映像、使高速缓存失效，导致若干数量级的延迟</li></ul></li></ul><h3 id="进程的上下文切换">进程的上下文切换</h3><ul><li><strong>进程上下文切换</strong>：保存旧任务，加载新任务。上下文=进程的现场快照（寄存器值、内存状态等）<ul><li>完成 CPU 切换到另一个进程时，保存当前进程状态并恢复另一个进程的状态的任务</li><li>采用进程 PCB 表示，包括寄存器的值、进程状态和内存管理信息等</li><li>内核将旧进程状态保存在其 PCB 中，然后加载经调度而要执行的新进程的上下文</li><li>进程的运行环境发生实质性变化</li></ul></li><li>上下文切换通常是计算密集型的，需要<strong>消耗大量的 CPU 时间</strong></li><li>有些处理器提供多个寄存器组，上下文切换<strong>只需要简单改变当前寄存器组的指针，不需要用到磁盘和主存</strong></li></ul><h4 id="上下文切换的场景">上下文切换的场景</h4><ul><li>某个进程<strong>时间片耗尽</strong>时</li><li>进程在<strong>系统资源不足</strong>时，要等到资源满足后才可以运行</li><li>进程通过 sleep 将自己<strong>主动挂起</strong>（如定时任务）</li><li>有<strong>优先级更高</strong>的基础运行时</li><li>发送<strong>硬件中断</strong>时</li></ul><h4 id="上下文切换的流程">上下文切换的流程</h4><ol><li>挂起一个进程，保存 CPU 上下文，包括 PC 和其他寄存器</li><li>更新 PCB 信息</li><li>把进程的 PCB 移到相应的队列（如就绪队列，阻塞队列）</li><li>加载另一个进程执行，更新其 PCB</li><li>跳转到新进程 PCB 中的 PC 所指向的位置执行</li><li>恢复处理机上下文<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240510140821.png" alt="image.png"></li></ol><h4 id="上下文切换和模式切换">上下文切换和模式切换</h4><ul><li>模式切换时，CPU 逻辑上可能还在执行同一进程</li><li><strong>上下文切换</strong>只能发生在<font color="#ff0000">内核态</font>【多任务 OS 的一个必需特性（换了一个全新的任务）】</li><li><strong>用户态与内核态</strong>之间的切换为<strong>模式切换</strong>【没有改变当前的进程（同一个任务，切换权限）】</li></ul><h4 id="调度和切换的区别">调度和切换的区别</h4><ul><li><strong>先有资源的调度，才有进程的切换</strong>【先调度再切换】</li><li>调度：决定资源分配给哪个进程的行为；是一种<strong>决策</strong>行为</li><li>切换：实际分配的行为；是一种<strong>执行</strong>行为</li></ul><h3 id="调度的目标">调度的目标</h3><h4 id="CPU-利用率">CPU 利用率</h4><ul><li>$CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$</li><li>$利用率=\frac{忙碌的时间}{总时间}$</li></ul><p>eg.某计算机只支持单道程序，某个作业刚开始需要在 CPU 上运行 5 秒，再用打印机打印输出 5 秒，之后再执行 5 秒，才能结束。在此过程中，CPU 利用率、打印机利用率分别是多少？<br>CPU 利用率 = $\frac{5 + 5}{5 + 5 + 5}$ = 66.66%<br>打印机利用率 = $\frac{5}{15}$ = 33.33%<br>通常会考察多道程序并发执行的情况，可以用 “甘特图” 来辅助计算<br><strong>注意</strong>：计算作业完成时间时，要注意 CPU 与设备、设备与设备之间时可以并行的</p><h4 id="系统吞吐量">系统吞吐量</h4><ul><li>表示单位时间内 CPU 完成作业的数量</li><li>$系统吞吐量=\frac{总共完成了多少作业}{总共花了多少时间}$</li></ul><p>eg.某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为10/100=0.1道/秒<br>调度算法越好，单位时间完成的作业越多</p><ul><li><font color="#ff0000">短作业优先（SJF）</font> 通常能提高吞吐量（因为短任务完成得快）。</li></ul><h4 id="周转时间">周转时间</h4><p><strong>从提交到完成要等多久</strong></p><ul><li>周转时间包括四个部分：<ul><li>作业在外存后备队列上<strong>等待作业调度</strong>（高级调度）的时间</li><li>进程在就绪队列上<strong>等待进程调度</strong>（低级调度）的时间</li><li>进程在 CPU 上<strong>执行的时间</strong></li><li>进程<strong>等待 I/O 操作</strong>完成的时间</li></ul></li><li>后三项在一个作业的整个处理过程中，可能发生多次</li><li>$周转时间=作业完成时间-作业提交时间$</li><li>$平均周转时间=\frac{作业1的周转时间+…+作业n的周转时间}{n}$</li><li>$带权周转时间=\frac{作业周转时间}{作业实际运行时间}$</li><li>$平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}$</li></ul><p>带权周转时间≥1<br>带权周转时间和周转时间都是越小越好<br>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。<br>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。<br><font color="#ff0000">短作业优先</font>调度算法会使 平均周转时间最短</p><h4 id="等待时间">等待时间</h4><ul><li>指进程/作业<strong>处于等待处理机状态时间之和</strong></li><li><strong>等待时间 = 周转时间 - 运行时间</strong></li><li>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待 I/O 完成的期间其实进程也是在被服务的，所以不计入等待时间【只算等 CPU 的时间（不算 I/O 等待）】</li><li>对于<strong>作业</strong>来说，等于建立进程后的等待时间 + 作业在<strong>外存后备队列中等待</strong>的时间【还要加上在<strong>外存后备队列</strong>的等待时间（比如挂号前的排队）】</li><li><font color="#ff0000">轮转调度（RR）</font> 可以减少等待时间（大家轮流用 CPU，不会饿死）。</li><li>排队<strong>等待时间最长</strong>的作业被<strong>优先调度</strong>这种算法是<font color="#ff0000">先来先服务</font></li><li>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响<strong>作业/进程的等待时间</strong>。与前面指标类似，也有“平均等待时间”来评价整体性能。</li></ul><h4 id="响应时间">响应时间</h4><ul><li>指从用户<strong>提交请求到首次产生响应</strong>所用的时间【第一次反馈有多快】</li><li>在交互式系统中，一般采用响应时间作为衡量调度算法的准则之一</li><li><strong>时间片轮转（RR）</strong> 和 <strong>多级反馈队列（MLFQ）</strong> 能优化响应时间。</li></ul><h3 id="调度算法">调度算法</h3><h4 id="先来先服务-FCFS">先来先服务 FCFS</h4><p><strong>算法思想</strong></p><ul><li>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li></ul><p><strong>算法规则</strong></p><ul><li>按照作业/进程到达的先后顺序进行服务</li></ul><p>eg.各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P₁</td><td>0</td><td>7</td></tr><tr><td>P₂</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr><tr><td>x1. <strong>确定调度顺序</strong>：先来先服务调度算法按照到达的先后顺序调度，调度顺序为：P₁ → P₂ → P3 → P4。</td><td></td><td></td></tr></tbody></table><ol><li><strong>计算周转时间</strong>：周转时间 = 完成时间 - 到达时间<ul><li>P₁：完成时间为 7，到达时间为 0，周转时间 = 7 - 0 = 7</li><li>P₂：完成时间为 11，到达时间为 2，周转时间 = 11 - 2 = 9</li><li>P3：完成时间为 12，到达时间为 4，周转时间 = 12 - 4 = 8</li><li>P4：完成时间为 16，到达时间为 5，周转时间 = 16 - 5 = 11</li></ul></li><li><strong>计算带权周转时间</strong>：带权周转时间 = 周转时间 / 运行时间<ul><li>P₁：带权周转时间 = 7 / 7 = 1</li><li>P₂：带权周转时间 = 9 / 4 = 2.25</li><li>P3：带权周转时间 = 8 / 1 = 8</li><li>P4：带权周转时间 = 11 / 4 = 2.75</li></ul></li><li><strong>计算等待时间</strong>：等待时间 = 周转时间 - 运行时间<ul><li>P₁：等待时间 = 7 - 7 = 0</li><li>P₂：等待时间 = 9 - 4 = 5</li><li>P3：等待时间 = 8 - 1 = 7</li><li>P4：等待时间 = 11 - 4 = 7</li></ul></li><li><strong>计算平均周转时间</strong>：平均周转时间 = (7 + 9 + 8 + 11) / 4 = 8.75</li><li><strong>计算平均带权周转时间</strong>：平均带权周转时间 = (1 + 2.25 + 8 + 2.75) / 4 = 3.5</li><li><strong>计算平均等待时间</strong>：平均等待时间 = (0 + 5 + 7 + 7) / 4 = 4.75</li></ol><p>注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有I/O操作的进程，其 <strong>等待时间=周转时间 - 运行时间 - I/O操作的时间</strong></p><p><strong>用于作业/进程调度</strong></p><ul><li>用于<strong>作业</strong>调度时，考虑的是哪个作业先到达<strong>后备</strong>队列</li><li>用于<strong>进程</strong>调度时，考虑的是哪个进程先到达<strong>就绪</strong>队列</li></ul><p>是否可抢占</p><ul><li>非抢占式</li></ul><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：<ul><li>公平、算法实现简单</li><li>有利于 CPU 繁忙型作业</li><li>一般适用于早期批处理系统</li></ul></li><li><strong>缺点</strong>：<ul><li>对<font color="#ff0000">长作业有利，对短作业不利</font>【排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好】</li><li><strong>不利于 I/O 繁忙型作业</strong></li></ul></li></ul><p>是否会导致饥饿</p><ul><li>不会</li><li><strong>饥饿</strong>：某进程/作业长期得不到服务</li></ul><h4 id="短作业优先-SJF">短作业优先 SJF</h4><p><strong>算法思想</strong></p><ul><li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li></ul><p><strong>算法规则</strong></p><ul><li>最短的作业/进程优先得到服务【<strong>要求服务时间最短</strong>】</li></ul><p>非抢占式：【若题目未说明，默认非抢占】</p><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P₁</td><td>0</td><td>7</td></tr><tr><td>P₂</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table><ol><li><strong>调度顺序</strong>：P₁ → P3 → P₂ → P4</li><li><strong>周转时间</strong><ul><li>P₁：7 - 0 = 7</li><li>P3：8 - 4 = 4</li><li>P₂：12 - 2 = 10</li><li>P4：16 - 5 = 11</li></ul></li><li><strong>带权周转时间</strong><ul><li>P₁：7 / 7 = 1</li><li>P3：4 / 1 = 4</li><li>P₂：10 / 4 = 2.5</li><li>P4：11 / 4 = 2.75</li></ul></li><li><strong>等待时间</strong><ul><li>P₁：7 - 7 = 0</li><li>P3：4 - 1 = 3</li><li>P₂：10 - 4 = 6</li><li>P4：11 - 4 = 7</li></ul></li><li><strong>平均周转时间</strong>：(7 + 4 + 10 + 11) / 4 = 8</li><li><strong>平均带权周转时间</strong>：(1 + 4 + 2.5 + 2.75) / 4 = 2.56</li><li><strong>平均等待时间</strong>：(0 + 3 + 6 + 7) / 4 = 4</li></ol><p><strong>用于作业/进程调度</strong></p><ul><li>即可用于作业调度，也可用于进程调度</li><li>用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法</li></ul><p>是否可抢占</p><ul><li>SJF 和 SPF 是<strong>非抢占式算法</strong></li><li><font color="#ff0000">短剩余时间优先算法（SRTN）是抢占式的</font></li></ul><p>抢占式：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P₁</td><td>0</td><td>7</td></tr><tr><td>P₂</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table><ol><li><strong>调度规则</strong>：最短剩余时间优先算法，当有进程加入就绪队列改变时，若新到达进程剩余时间比当前运行进程剩余时间短，则新进程抢占处理机，当前运行进程重回就绪队列；进程完成时也需调度。</li><li><strong>周转时间计算</strong><ul><li>P₁：完成时间为 16，到达时间为 0，周转时间 = 16 - 0 = 16</li><li>P₂：完成时间为 7，到达时间为 2，周转时间 = 7 - 2 = 5</li><li>P3：完成时间为 5，到达时间为 4，周转时间 = 5 - 4 = 1</li><li>P4：完成时间为 11，到达时间为 5，周转时间 = 11 - 5 = 6</li></ul></li><li><strong>带权周转时间计算</strong><ul><li>P₁：带权周转时间 = 16÷7 ≈ 2.28</li><li>P₂：带权周转时间 = 5÷4 = 1.25</li><li>P3：带权周转时间 = 1÷1 = 1</li><li>P4：带权周转时间 = 6÷4 = 1.5</li></ul></li><li><strong>等待时间计算</strong><ul><li>P₁：等待时间 = 16 - 7 = 9</li><li>P₂：等待时间 = 5 - 4 = 1</li><li>P3：等待时间 = 1 - 1 = 0</li><li>P4：等待时间 = 6 - 4 = 2</li></ul></li></ol><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：<ul><li>在<strong>所有进程都几乎同时到达</strong>时，采用 SIF/SPF 调度算法的<strong>平均等待时间、平均周转时间最少</strong></li><li><strong>抢占式</strong>的 SJF/SPF 调度算法【最短剩余时间优先算法】的<strong>平均等待时间、平均周转时间最少</strong></li><li>虽然严格来说，SIF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法(如FCFS)SIF依然可以获得较少的平均等待时间、平均周转时间</li><li>如果选择题中遇到“SIF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li><li>一般适用于早期批处理系统</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>对短作业有利，对长作业不利</strong></li><li>可能产生饥饿现象</li><li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li></ul><p><strong>是否会导致饥饿</strong></p><ul><li>会</li><li>如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象</li><li>如果一直得不到服务，则称为“饿死”</li></ul><h4 id="高响应比优先">高响应比优先</h4><p><strong>算法思想</strong></p><ul><li>综合考虑作业/进程的等待时间和要求服务的时间</li></ul><p><strong>算法规则</strong></p><ul><li>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业/进程为其服务</li><li>$R_p=\frac{作业等待时间 + 作业处理时间}{作业处理时间}= 1 + \frac{等待时间}{处理时间}$</li><li>响应比≥1</li></ul><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P₁</td><td>0</td><td>7</td></tr><tr><td>P₂</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table><ol><li><strong>0 时刻</strong>：只有 P₁ 到达就绪队列，P₁ 上处理机。</li><li><strong>7 时刻（P₁ 主动放弃 CPU）</strong>：<br>就绪队列中有 P₂、P3、P4 。<br>计算响应比：<ul><li>P₂ 响应比 = (5 + 4)÷4 = 2.25</li><li>P3 响应比 = (3 + 1)÷1 = 4</li><li>P4 响应比 = (2 + 4)÷4 = 1.5<br>此时 P3 响应比最高，P3 上处理机。</li></ul></li><li><strong>8 时刻（P3 完成）</strong>：<br>就绪队列中有 P₂、P4 。<br>P₂ 响应比 = 2.25 ，P4 响应比 = (2 + 4)÷4 = 1.5（经过 1 个时间单位等待，等待时间变为 3 ，新响应比为 (3 + 4)÷4 = 1.75 ）<br>P₂ 响应比更高，P₂ 上处理机。</li><li><strong>12 时刻（P₂ 完成）</strong>：就绪队列中只剩下 P4 。</li></ol><p>计算</p><ol><li><strong>周转时间</strong><ul><li>P₁：完成时间为 7，到达时间为 0，周转时间 = 7 - 0 = 7</li><li>P₂：完成时间为 12，到达时间为 2，周转时间 = 12 - 2 = 10</li><li>P3：完成时间为 8，到达时间为 4，周转时间 = 8 - 4 = 4</li><li>P4：完成时间为 16，到达时间为 5，周转时间 = 16 - 5 = 11</li></ul></li><li><strong>带权周转时间</strong><ul><li>P₁：7÷7 = 1</li><li>P₂：10÷4 = 2.5</li><li>P3：4÷1 = 4</li><li>P4：11÷4 = 2.75</li></ul></li><li><strong>等待时间</strong><ul><li>P₁：7 - 7 = 0</li><li>P₂：10 - 4 = 6</li><li>P3：4 - 1 = 3</li><li>P4：11 - 4 = 7</li></ul></li><li><strong>平均周转时间</strong>：(7 + 10 + 4 + 11)÷4 = 8</li><li><strong>平均带权周转时间</strong>：(1 + 2.5 + 4 + 2.75)÷4 = 2.56</li><li><strong>平均等待时间</strong>：(0 + 6 + 3 + 7)÷4 = 4</li></ol><p><strong>用于作业/进程调度</strong></p><ul><li>即可用于作业调度，也可用于进程调度</li></ul><p><strong>是否可抢占</strong></p><ul><li>非抢占式的算法</li><li>因此只有当前运行的作业/进程<strong>主动放弃处理机</strong>时，才需要调度，才需要计算响应比</li></ul><p><strong>优缺点</strong></p><ul><li><strong>等待时间相同</strong>时，要求服务时间越短，响应比越高，有利于短作业，类似于 <strong>SJF</strong></li><li><strong>要求服务时间</strong>相同时，等待时间越长，响应比越高，类似于 <strong>FCFS</strong></li><li>响应比可以随等待时间的增加而提高，<strong>克服了饥饿现象</strong></li><li>适用于<font color="#ff0000">分时</font>操作系统</li></ul><p><strong>是否会导致饥饿</strong></p><ul><li>不会</li></ul><h4 id="优先级">优先级</h4><p><strong>算法思想</strong></p><ul><li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li></ul><p><strong>算法规则</strong></p><ul><li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li></ul><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th><th>优先数</th></tr></thead><tbody><tr><td>P₁</td><td>0</td><td>7</td><td>1</td></tr><tr><td>P₂</td><td>2</td><td>4</td><td>2</td></tr><tr><td>P3</td><td>4</td><td>1</td><td>3</td></tr><tr><td>P4</td><td>5</td><td>4</td><td>2</td></tr><tr><td>非抢占式：</td><td></td><td></td><td></td></tr></tbody></table><ul><li><strong>调度规则</strong>：每次调度时选择当前已到达且优先级最高的进程，当前进程主动放弃处理机时发生调度。</li></ul><p>抢占式：</p><ul><li><strong>调度规则</strong>：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度，另外，当就绪队列发生改变时也需要检查是否会发生抢占。</li></ul><table><thead><tr><th>调度算法</th><th>进程</th><th>到达时刻</th><th>开始运行时刻</th><th>完成时刻</th><th>周转时间</th></tr></thead><tbody><tr><td>非抢占</td><td>P₁</td><td>0</td><td>0</td><td>7</td><td>7</td></tr><tr><td></td><td>P₂</td><td>2</td><td>8</td><td>12</td><td>10</td></tr><tr><td></td><td>P3</td><td>4</td><td>7</td><td>8</td><td>4</td></tr><tr><td></td><td>P4</td><td>5</td><td>12</td><td>16</td><td>11</td></tr><tr><td>抢占式</td><td>P₁</td><td>0</td><td>0</td><td>16</td><td>16</td></tr><tr><td></td><td>P₂</td><td>2</td><td>2</td><td>7</td><td>5</td></tr><tr><td></td><td>P3</td><td>4</td><td>4</td><td>5</td><td>1</td></tr><tr><td></td><td>P4</td><td>5</td><td>7</td><td>11</td><td>6</td></tr></tbody></table><p><strong>用于作业/进程调度</strong></p><ul><li>既可用于作业调度，也可用于进程调度</li></ul><p><strong>是否可抢占</strong></p><ul><li><strong>非抢占式</strong>：直到由于自身原因而让出 CPU 时，更高优先级的进程才可运行【只需在进程主动放弃处理机时进行调度即可】</li><li><strong>抢占式</strong>：有更高优先级的进程进入就绪队列时，立即停止正在运行的进程【在就绪队列变化时，检查是否发生抢占】<ul><li><strong>静态优先级</strong>：<ul><li>优先级是在创建时确立的</li><li>优点：简单易行，系统开销小</li><li>缺点：不够精确，可能出现优先级低的进程长时间得不到调用</li></ul></li><li><strong>动态优先级</strong>：<ul><li>优先级随进程的推进或等待时间的增加而改变，以获得更好的性能</li><li>设置优先级原则<ul><li><strong>系统</strong>进程 &gt; <strong>用户</strong>进程</li><li><strong>前台</strong>进程 大于 <strong>后台</strong>进程</li><li><strong>交互</strong>型进程 &gt; <strong>非交互</strong>型进程</li><li><strong>I/O 型</strong>进程（I/O繁忙型进程，看作短作业） &gt; <strong>计算型</strong>进程（CPU繁忙型进程，看作长作业）<br>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备恩早地投入工作，则资源利用率、系统吞吐量都会得到提升</li></ul></li><li>什么时候调整优先级（公平、提升资源利用率等角度考虑）<ul><li>如果某进程在<strong>就绪队列中等待</strong>了很长时间，则可以适当提升其优先级</li><li>如果某进程<strong>占用处理机运行</strong>了很长时间，则可适当降低其优先级</li><li>如果发现一个进程<strong>频繁地进行I/O操作</strong>，则可适当提升其优先级</li></ul></li></ul></li></ul></li></ul><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：<ul><li>用优先级区分紧急程度、重要程度，适用于<strong>实时</strong>操作系统</li><li>可灵活地调整对各种作业/进程的偏好程度</li></ul></li><li><strong>缺点</strong>：<ul><li>若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li></ul><p><strong>是否会导致饥饿</strong></p><ul><li>会</li></ul><h4 id="时间片轮转-RR">时间片轮转 RR</h4><p><strong>算法思想</strong></p><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定<strong>时间间隔</strong>内都可以得到响应</li><li>伴随着分时操作系统的诞生而诞生的</li></ul><p><strong>算法规则</strong></p><ul><li>按照各进程<strong>到达就绪队列的顺序</strong>，轮流让各个进程执行一个<strong>时间片</strong>（如 100 ms）</li><li>若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列<strong>队尾重新排队</strong></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250511182020669.png" alt="821aeafd83dbcfc13aa1a0f648c9a67.jpg|400"></p><p><strong>用于作业/进程调度</strong></p><ul><li>用于<font color="#ff0000">进程调度</font></li><li>只有作业放入内存建立了相应的进程后，才能被分配处理机时间片</li></ul><p><strong>是否可抢占</strong></p><ul><li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<font color="#ff0000">抢占式</font>的算法</li><li>由时钟装置发出<font color="#ff0000">时钟中断</font>来通知 CPU 时间片已到</li></ul><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：<ul><li>公平，响应快</li><li>适用于<strong>分时</strong>操作系统</li><li>可以让<strong>用户及时干预系统</strong></li></ul></li><li><strong>缺点</strong>：<ul><li>由于高频率的进程切换，因此有一定开销</li><li>不区分任务的紧急程度</li></ul></li><li><strong>若时间片足够大</strong>：所有进程都能在一个时间片内执行完毕，退化为 <strong>FCFS</strong></li><li><strong>若时间片足够小</strong>：CPU 将在进程间过于频繁的切换，使 CPU 的开销增大</li></ul><p><strong>是否会导致饥饿</strong></p><ul><li>不会</li></ul><h4 id="多级反馈队列">多级反馈队列</h4><p><strong>算法思想</strong></p><ul><li>对其他调度算法的折中权衡</li></ul><p><strong>算法规则</strong></p><ol><li>设置多级就绪队列，赋予每个队列不同的优先级【第 1 级队列最高，依次降低】</li><li>赋予各个队列的进程运行时间片的大小各不相同【优先级越高的队列，每个进程的时间片越小】</li><li>每个队列采用 FCFS 算法：<ul><li>新进程进入内存后，首先放入第 1 级队列的队尾，等待调度</li><li>在第一个时间片结束时尚未完成，将其转入第 2 级队列的末尾，依次类推</li><li>当进程被降到第 n 级队列后，采用时间片轮转方式运行</li></ul></li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li></ol><p><strong>用于作业/进程调度</strong></p><ul><li>即可用于作业调度，也可用于进程调度</li></ul><p><strong>是否可抢占</strong></p><ul><li><font color="#ff0000">抢占式</font>的算法</li><li>在 k 级队列的进程运行过程中，若更上级的队列（1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾</li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250511192004018.png" alt="image.png|500"><br>有三个反馈队列，队列的时间片分别为1，2，4</p><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P₁</td><td>0</td><td>8</td></tr><tr><td>P₂</td><td>1</td><td>4</td></tr><tr><td>P3</td><td>5</td><td>1</td></tr></tbody></table><table><thead><tr><th>时刻</th><th>运行进程</th><th>所在队列</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>P₁</td><td>第 1 级队列</td><td>P₁ 到达，进入第 1 级队列并开始运行1个时间片，P₁ 时间片用完进入第 2 级队列队尾（P₁<sub>7</sub>）【2：1】</td></tr><tr><td>1</td><td>P₂</td><td>第 1 级队列</td><td>P₂ 到达，P₂ 在第 1 级队列开始运行1个时间片，然后放到第2级队列（P₂<sub>3</sub>）【2：2→1】</td></tr><tr><td>2-3</td><td>P₁</td><td>第 2 级队列</td><td>第 1 级队列空（k级队列为空，才为k+1级队头的分配时间片），P₁ 在第 2 级队列开始运行2个时间片（P₁<sub>5</sub>），用完进入第 3 级队列【2：2，3：1】</td></tr><tr><td>4</td><td>P₂</td><td>第 2 级队列</td><td>P₂ 在第 2 级队列开始运行1个时间片后，P3 到达第1级队列【1：3】，优先级高抢占处理机，P₂回到第2级队列队尾【2：2】</td></tr><tr><td>5</td><td>P3</td><td>第 1 级队列</td><td>P3执行1个时间片（P3<sub>0</sub>），P3用完调出内存</td></tr><tr><td>6-7</td><td>P₂</td><td>第 3 级队列</td><td>第1级队列为空，P₂重新回处理机运行2个时间片（P₂<sub>0</sub>），P₂用完调出内存</td></tr><tr><td>8-12</td><td>P₁</td><td>第 3 级队列</td><td>第 1，2 级队列空，P₁在第3级队列运行4个时间片（P₁<sub>1</sub>），由于没有下一级队列，重新放回第3级队列队尾【3：1】</td></tr><tr><td>13</td><td>P₁</td><td>第 3 级队列</td><td>P₁ 运行至结束（P₁<sub>0</sub>），调出内存</td></tr><tr><td><strong>优缺点</strong></td><td></td><td></td><td></td></tr></tbody></table><ul><li>对各类型进程相对<strong>公平</strong>（<strong>FCFS</strong> 的优点）</li><li>每个<strong>新到达</strong>的进程都可以很快就得到<strong>响应</strong>（<strong>RR</strong> 的优点）</li><li><strong>短进程</strong>只用较少的时间就可完成（<strong>SPF</strong> 的优点）</li><li>不必实现估计进程的运行时间（避免用户作假）</li><li>可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程</li><li>拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样I/O 型进程就可以保持较高优先级</li></ul><p><strong>是否会导致饥饿</strong></p><ul><li>会</li></ul><h4 id="多级队列">多级队列</h4><p><strong>算法思想</strong></p><ul><li>在系统中设置<strong>多个就绪队列</strong></li><li>按不同类型或性质的进程固定分配到不同的就绪队列</li><li>每个队列可实施不同的调度算法<ul><li><strong>系统</strong>队列 ：<strong>优先级调度</strong></li><li><strong>交互</strong>式队列：<strong>RR</strong></li><li><strong>批处理</strong>队列：<strong>FCFS</strong></li></ul></li><li>在多 CPU 系统中，可以很方便为每个 CPU 设置一个单独的就绪队列</li></ul><h4 id="常见算法的对比"><strong>常见算法的对比</strong></h4><table><thead><tr><th>调度算法</th><th>先来先服务 FCFS</th><th>短作业优先 SJF/SPF</th><th><strong>优先级调度</strong></th><th>高响应比优先 HRRN</th><th>时间片轮转 RR</th><th>多级反馈队列 MFQ</th></tr></thead><tbody><tr><td><strong>是否可抢占</strong></td><td>×</td><td>均可（SJF 非抢占，SJRF 抢占）</td><td>均可</td><td>均可</td><td>√</td><td>队列内算法不一定</td></tr><tr><td><strong>优点</strong></td><td><strong>公平</strong>，实现简单</td><td><strong>最优的平均等待时间和平均周转时间</strong></td><td><strong>灵活</strong>，可定制优先级</td><td><strong>兼顾长短作业</strong>，无饥饿</td><td><strong>公平</strong>性好，<strong>响应时间</strong>稳定</td><td>综合性能优秀，兼顾长短作业和响应时间</td></tr><tr><td><strong>缺点</strong></td><td>完全不考虑进程的特点</td><td>长作业饥饿，进程预计运行时间难以计算</td><td>低优先级任务可能饥饿</td><td>计算响应比有额外开销</td><td>上下文切换频繁，<strong>开销</strong>大</td><td>实现复杂，参数配置敏感</td></tr><tr><td><strong>利于</strong></td><td>长进程、<strong>处理器密集型进程</strong></td><td>短进程</td><td>高优先级进程</td><td>短进程</td><td>公平</td><td>-</td></tr><tr><td><strong>不利于</strong></td><td>短进程、<strong>I/O密集型进程</strong></td><td>长进程</td><td>低优先级进程</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>适用场景</strong></td><td>无特殊要求的简单场景【非交互】</td><td><strong>批处理</strong>系统（已知作业长度）【非交互】</td><td><strong>实时</strong>系统、任务分级场景【交互】</td><td><strong>分时</strong>系统【非交互】</td><td><strong>分时</strong>系统、交互式系统【交互】</td><td>通用型系统（如现代操作系统）【交互】</td></tr><tr><td><strong>默认决策模式</strong></td><td>非抢占</td><td>非抢占（SJF）</td><td>抢占/非抢占均可</td><td>非抢占</td><td>抢占</td><td>抢占（队列间）</td></tr><tr><td><strong>是否导致饥饿</strong></td><td>×（无）</td><td>√（长作业饥饿）</td><td>√（低优先级可能饥饿）</td><td>×（无）</td><td>×（无）</td><td>×</td></tr><tr><td><strong>考虑因素</strong></td><td>到达时间</td><td>运行时间</td><td>优先级（静态/动态）</td><td>等待时间+运行时间</td><td>所有进程公平分时使用处理器</td><td>运行历史、优先级、时间片</td></tr><tr><td><strong>用于作业/进程</strong></td><td>均可</td><td>作业调度（批处理）</td><td>进程调度</td><td>均可</td><td>进程调度</td><td>均可</td></tr><tr><td>有点（短）：饥饿</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>小（响）高：短</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>事（时）多：抢占</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>短：作业</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>室（时）友（优）：进程</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>优“势（实时）”，十（时）“分（分时）”响</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="多处理机调度">多处理机调度</h3><h4 id="单处理机调度-VS-多处理机调度">单处理机调度 VS 多处理机调度</h4><p>单处理机调度：只需决定让哪个就绪进程优先上处理机<br>多处理机调度：还需决定被调度的进程到底上哪个处理机</p><p><strong>追求目标</strong>：</p><ol><li><strong>负载均衡</strong>：尽可能让每个CPU都同等忙碌</li><li><strong>处理机亲和性</strong>：尽量让一个进程调度到同一个CPU上运行，以发挥CPU中缓存的作用(Cache)</li></ol><p>解决方案：</p><h4 id="公共就绪队列">公共就绪队列</h4><ul><li>所有 CPU 共享同一个位于内核区的就绪进程队列。</li><li>每个 CPU 运行调度程序，从公共就绪队列中挑选一个进程运行。</li><li>每个 CPU 访问公共就绪队列时需上锁，以确保互斥。</li></ul><p><strong>优点</strong><br>天然地实现<strong>负载均衡</strong>，即各个 CPU 的工作负荷能较为均匀地分配，避免出现部分 CPU 过度繁忙，而部分 CPU 闲置的情况 。<br><strong>缺点</strong><br>进程频繁地换 CPU 运行，导致 “<strong>亲和性</strong>” 不好【进程倾向于在同一个 CPU 上运行，频繁更换 CPU 运行会使进程在新 CPU 上重新建立缓存等资源，影响运行效率 】</p><p><strong>提升处理机亲和性的方法</strong></p><ul><li><strong>软亲和</strong>：通过进程调度程序来尽量保证亲和性，调度程序在选择进程时，优先考虑之前在本 CPU 上运行过的进程，减少进程在不同 CPU 间的迁移 。</li><li><strong>硬亲和</strong>：由<strong>用户进程通过系统调用</strong>，主动向操作系统请求分配固定的 CPU，从而确保亲和性，用户进程明确指定希望在哪个或哪些 CPU 上运行 。</li></ul><h4 id="私有就绪队列">私有就绪队列</h4><ul><li><strong>队列设置</strong>：每个 CPU 都拥有一个专属的<strong>私有就绪队列</strong>。</li><li><strong>调度运行</strong>：当 CPU 处于空闲状态时，会启动调度程序，从其对应的私有就绪队列里挑选一个进程来运行。</li></ul><p><strong>目标及实现方式</strong>：</p><ul><li>目标一：实现<strong>负载均衡</strong><ul><li><strong>推迁移（push）策略</strong>：一个特定的系统程序周期性检查每个处理器的负载，如果负载不平衡，就从忙碌CPU的就绪队列中“推”一些就绪进程到空闲CPU的就绪队列【有一个包工头专门负责派活】</li><li><strong>拉迁移（pull）策略</strong>：各个 CPU 运行调度程序期间，会<strong>周期性</strong>地对自身负载情况以及其他 CPU 的负载情况进行检查。要是某个 CPU 负载较低，便会从其他高负载 CPU 的就绪队列中 “拉取” 一些就绪进程到自己的就绪队列里，以此平衡各 CPU 的工作负荷【同事间互相帮忙分担任务】</li></ul></li><li>目标二：实现<strong>处理机亲和性</strong><ul><li>私有就绪队列机制本身就自然地达成了 “处理机亲和性”。这意味着进程倾向于在同一个 CPU 上运行，减少了在不同 CPU 间频繁切换带来的资源重建开销，提升了运行效率 。同时，还可通过系统调用实现 “硬亲和”，进一步保障进程与特定 CPU 的绑定关系 。</li></ul></li></ul><p><strong>优点</strong><br>天然地实现<strong>处理及亲和性</strong></p><h2 id="同步与互斥">同步与互斥</h2><ul><li>因为并发进程是异步的，为了协调进程之间的相互制约关系，所以引入同步互斥</li><li><strong>同步</strong>【直接制约关系】：<ul><li>进程同步是指在多个进程之间协调和控制其执行<mark>顺序</mark>，以避免竞争条件和数据不一致的情况，体现<mark>协作</mark>关系，解决进程<mark>异步</mark>的<mark>不可预知</mark>性。【并发带来异步性】</li></ul></li><li><strong>互斥</strong>【间接制约关系】：<ul><li>当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许访问临界资源【对顺序没有约束、竞争关系】</li></ul></li><li><strong>临界资源</strong>：<strong>一次仅允许一个进程使用的资源</strong>，eg.打印机、磁带机、进程共享的数据或变量<br>对其访问过程分为：<ul><li><strong>进入区</strong>：负责实现互斥，设置标志<br>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其他进程同时进入临界区</li><li><strong>临界区</strong>：进程中访问<strong>临界资源</strong>的那段代码</li><li><strong>退出区</strong>：负责实现互斥，清除标志<br>负责解除正在访问临界资源的标志(可理解为“解锁”)</li><li><strong>剩余区</strong>：代码中的其余部分</li><li>注意：<ul><li>临界区是访问临界资源的代码段</li><li>进入区和退出区是负责实现互斥的代码段</li><li>临界区也称为临界段</li><li>当一个进程已经在临界区中运行时，即已经使用临界资源时，其他进程不能进入相关临界区</li><li></li></ul></li></ul></li><li><strong>同步机制应遵循的准则</strong>：<ul><li><strong>空闲让进</strong>：临界区空闲，允许一个进程进入【运行进程访问空闲的临界资源】</li><li><strong>忙则等待</strong>：有进程进入临界区时，其他进程需等待【两个进程不能同时进入临界资源】</li><li><strong>有限等待</strong>：请求访问的进程应保证在有限时间内进入临界区，防止无限等待（保证不会饥饿）【进程等待进入临界区的时间是有限的】</li><li><strong>让权等待</strong>【原则上遵循，非必须】：进程不能进入临界区时，应该立即释放处理器，防止进程忙等待【不能进入临界区的执行态进程立即放弃 CPU】</li></ul></li></ul><h3 id="实现临界区互斥的方法">实现临界区互斥的方法</h3><p>软件方法、硬件方法、信号量机制、管程机制</p><ul><li>软件：用编程解决，但常常忙等待<br>实现进程互斥的软件方法有四种：单标志法，双标志先检查，双标志后检查，Peterson算法。<br>不遵循：弹孔，先忙，后有空，p让</li><li>硬件：当一个进程进入临界区，就屏蔽所有中断，但成本高<br>进程互斥的硬件实现方法有三种：中断屏蔽方法，TestAndSet(TS指令/TSL指令)，Swap指令(XCHG指令)。<br>不遵循：TS让，</li></ul><h4 id="软件实现方法">软件实现方法</h4><h5 id="单标志法">单标志法</h5><ul><li>两个进程在<mark>访问完临界区后</mark>会把使用临界区的权限转交给另一个进程。也就是说<mark>每个进程进入临界区的权限只能被另一个进程赋予</mark>。</li><li>主要问题是：违背“<font color="#ff0000">空闲让进</font>”原则；控制方式超出了互斥的要求</li><li>设置一个公用整型变量 turn，指示<strong>允许进入临界区的进程编号</strong></li><li>每次只允许一个进程进入临界区</li></ul><p>变量定义：</p><ul><li><code>int turn = 0;</code> ，<code>turn</code> 表示当前允许进入临界区的进程号，背后逻辑为 “谦让” 。</li></ul><p>进程代码：</p><ul><li><strong>P0 进程</strong>：<ol><li><code>while (turn != 0);</code> （等待进入临界区条件）</li><li><code>critical section;</code> （临界区）</li><li><code>turn = 1;</code> （在退出区修改 <code>turn</code> ，允许 P₁ 进入）</li><li><code>remainder section;</code> （剩余区）</li></ol></li><li><strong>P₁ 进程</strong>：<br>5. <code>while (turn != 1);</code> （等待进入临界区条件）<br>6. <code>critical section;</code> （临界区）<br>7. <code>turn = 0;</code> （在退出区修改 <code>turn</code> ，允许 P0 进入）<br>8. <code>remainder section;</code> （剩余区）</li></ul><p>运行逻辑：在进入区只“检查”，不&quot;上锁&quot;，退出区把临界区使用权转交给另一个进程（相当于在退出区给另一进程“解锁”，又给自己“上锁”）</p><ul><li><code>turn</code> 初值为 0，初始允许 0 号进程（P0）进入临界区。</li><li>若 P₁ 先运行，会卡在⑤处。P₁ 时间片用完调度 P0 运行，P0 可正常进入临界区，期间切换回 P₁，P₁ 仍卡在⑤ 。只有 P0 在退出区将 <code>turn</code> 改为 1 后，P₁ 才能进入临界区。</li><li>违背&quot;空闲让进&quot;的体现：<br>只能按 P0→P₁→P0→P₁→…这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P₁访问。</li></ul><h5 id="双标志先检查法">双标志先检查法</h5><ul><li>设置一个<mark>布尔</mark>型数组<code>flag[]</code>，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong><br>比如<code>flag[0]=ture</code>意味着0号进程P0现在想要进入临界区<br>每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为true，之后开始访问临界区。</li><li>主要问题：违反“<font color="#ff0000">忙则等待</font>”原则【进入区“检查”后，“上锁”前可能发生进程切换】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512154236.png" alt="image.png"></li></ul><p>变量定义：</p><ul><li><code>bool flag[2];</code> ：用于表示两个进程进入临界区意愿的数组（讨好型人格）</li><li>初始化：<code>flag[0] = false;</code> ，<code>flag[1] = false;</code> ，即初始时两个进程都不想进入临界区。</li></ul><p>进程代码：</p><ul><li><strong>P0 进程</strong>：<ol><li><code>while (flag[1]);</code> ：若 P₁ 有进入临界区意愿，P0 在此循环等待。</li><li><code>flag[0] = true;</code> ：标记 P0 想要进入临界区。</li><li><code>critical section;</code> ：访问临界区。</li><li><code>flag[0] = false;</code> ：访问完临界区，标记 P0 不想使用临界区。</li><li><code>remainder section;</code> ：剩余区操作。</li></ol></li><li><strong>P₁ 进程</strong>：<br>6. <code>while (flag[0]);</code> ：若 P0 有进入临界区意愿，P₁ 在此循环等待。<br>7. <code>flag[1] = true;</code> ：标记 P₁ 想要进入临界区。<br>8. <code>critical section;</code> ：访问临界区。<br>9. <code>flag[1] = false;</code> ：访问完临界区，标记 P₁ 不想使用临界区。<br>10. <code>remainder section;</code> ：剩余区操作。</li></ul><p>运行逻辑：进入区先“检查”后“加锁”，退出区解锁</p><ul><li>两个进程通过 <code>flag</code> 数组表达进入临界区的意愿。若一个进程想进入临界区，需先检查另一个进程的意愿，若对方也想进入，自己则循环等待，直到对方访问完临界区并修改标志位 。</li><li>忙则等待的体现：<br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。<strong>“检查”后，“上锁”前</strong>可能发生进程切换。</li></ul><h5 id="双标志后检查法">双标志后检查法</h5><ul><li>双标志先检查法的改版</li><li>前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到<strong>先“上锁”后“检查”</strong> 的方法，来避免上述问题。</li><li>双标志后检查法虽然解决了“<font color="#ff0000">忙则等待</font>”的问题，但是又违背了“<font color="#ff0000">空闲让进</font>”和“<font color="#ff0000">有限等待</font>”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。可能<mark>活锁</mark><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512154546.png" alt="image.png"><br>变量定义：</li><li><code>bool flag[2];</code> ：表示进程进入临界区意愿的数组。</li><li>初始化：<code>flag[0] = false;</code> ，<code>flag[1] = false;</code> ，即初始时两个进程均无进入临界区意愿。</li></ul><p>进程代码：</p><ul><li><strong>P0 进程</strong>：<ul><li>① <code>flag[0] = true;</code> ：标记 P0 进程想要进入临界区。</li><li>② <code>while (flag[1]);</code> ：若 P₁ 进程也想进入临界区，P0 在此循环等待。</li><li>③ <code>critical section;</code> ：访问临界区。</li><li>④ <code>flag[0] = false;</code> ：访问完临界区，标记 P0 不想使用临界区。</li><li><code>remainder section;</code> ：剩余区操作。</li></ul></li><li><strong>P₁ 进程</strong>：<ul><li>⑤ <code>flag[1] = true;</code> ：标记 P₁ 进程想要进入临界区。</li><li>⑥ <code>while (flag[0]);</code> ：若 P0 进程也想进入临界区，P₁ 在此循环等待。</li><li>⑦ <code>critical section;</code> ：访问临界区。</li><li>⑧ <code>flag[1] = false;</code> ：访问完临界区，标记 P₁ 不想使用临界区。</li><li><code>remainder section;</code> ：剩余区操作。</li></ul></li></ul><p>运行逻辑：进入区先“加锁”后“检查”，退出区解锁</p><ul><li>进程通过修改 <code>flag</code> 数组元素值表达进入临界区意愿。若两个进程同时想进入临界区，后执行标记操作的进程会在对应的 <code>while</code> 循环处等待，直到另一进程访问完临界区并修改标志位。</li></ul><h5 id="Peterson-算法">Peterson 算法</h5><ul><li>结合<strong>双标志法、单标志法</strong>的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循<font color="#ff0000">让权等待</font>的原则。</li><li>利用 flag 解决互斥访问问题，利用 turn 解决饥饿问题<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512154830.png" alt="image.png"><br>变量定义：</li><li><code>bool flag[2];</code> ：表示进入临界区意愿的数组，初始值均为 <code>false</code> ，用于 “表达意愿”。</li><li><code>int turn = 0;</code> ：表示优先让哪个进程进入临界区，体现 “谦让” 。</li></ul><p>进程代码：</p><ul><li><strong>P0 进程</strong>：<ol><li><code>flag[0] = true;</code> ：P0 表达进入临界区意愿。</li><li><code>turn = 1;</code> ：P0 表示愿意优先让 P₁ 使用临界区。</li><li><code>while (flag[1] &amp;&amp; turn == 1);</code> ：若 P₁ 有进入意愿且自己表示谦让，P0 等待。</li><li><code>critical section;</code> ：访问临界区。</li><li><code>flag[0] = false;</code> ：P0 访问完临界区，不再有进入意愿。</li><li><code>remainder section;</code> ：剩余区操作。</li></ol></li><li><strong>P₁ 进程</strong>：<br>7. <code>flag[1] = true;</code> ：P₁ 表达进入临界区意愿。<br>8. <code>turn = 0;</code> ：P₁ 表示愿意优先让 P0 使用临界区。<br>9. <code>while (flag[0] &amp;&amp; turn == 0);</code> ：若 P0 有进入意愿且自己表示谦让，P₁ 等待。<br>10. <code>critical section;</code> ：访问临界区。<br>11. <code>flag[1] = false;</code> ：P₁ 访问完临界区，不再有进入意愿。<br>12. <code>remainder section;</code> ：剩余区操作。</li></ul><p>运行逻辑推导：主动争取——主动谦让——检查对方是否想进，己方是否谦让</p><ul><li>以不同执行顺序穿插执行展示：如①②⑥⑦⑧… 、①⑥②③… 等情况，进程先表达进入临界区意愿，再表示谦让，然后检查对方意愿和谦让情况，若满足等待条件则等待，否则进入临界区，访问完后取消进入意愿 。</li></ul><p><strong>软件方法解决互斥问题失败原因</strong>：</p><ol><li><strong>执行易打断</strong>：临界区前后所加的代码越多，执行过程随时被打断的情况越多</li><li><strong>临界资源竞争</strong>：代码中<code>turn,flag[]</code>本身也是临界资源，若多个进程同时对他们进行读写操作，就会引发竞争问题</li><li><strong>未考虑让权等待</strong>：软件方法通常采用循环检测标志位的方法等待进入临界区，在等待过程中一直占用CPU资源，不释放处理机，容易造成其他进程“饥饿”</li><li><strong>未实现阻塞机制</strong>：软件方法一般没有像硬件或高级同步机制那样的阻塞功能。当进程无法进入临界区时，不能将自身置于阻塞状态并让操作系统在合适时机唤醒。只能不断循环检查条件，无法主动放弃 CPU 进入睡眠等待，无法有效利用系统资源，也不利于进程间的高效协作与调度</li></ol><h4 id="硬件实现方法">硬件实现方法</h4><h5 id="中断屏蔽法">中断屏蔽法</h5><ul><li>利用“开/关中断指令”实现<br>与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况</li><li>关中断：防止其他进程进入临界区</li><li>开中断：直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</li><li><strong>优点</strong>：简单、高效</li><li><strong>缺点</strong>：<ul><li>限制了 CPU 交替执行程序的能力，因此系统效率会明显降低</li><li><strong>不适用于多处理机</strong></li><li>只适用于操作系统<strong>内核进程</strong>，<strong>不适用于用户进程</strong>【因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险】</li></ul></li></ul><h5 id="硬件指令——TestAndSet-指令（TS或TSL-指令）">硬件指令——TestAndSet 指令（TS或TSL 指令）</h5><ul><li>为每个临界资源设置一个共享<strong>布尔变量 lock</strong>，表示该资源的两种状态【true 表示被占用】</li><li>TSL指令是用<strong>硬件</strong>实现的，执行的过程<strong>不允许被中断</strong>，只能一气呵成<br><strong>检查锁状态</strong>和<strong>设置锁状态</strong>这两个操作被合并为一个不可分割的步骤<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512160354.png" alt="image.png"><br>变量定义：</li><li><code>bool lock;</code> ：布尔型共享变量，用于表示当前临界区是否被加锁 。<code>true</code> 表示已加锁，<code>false</code> 表示未加锁。</li></ul><p>函数定义：</p><ul><li><code>bool TestAndSet (bool *lock)</code> ：<ul><li>功能：实现对<code>lock</code>变量的操作并返回其原来的值。</li><li>操作过程：<ul><li>定义<code>bool old</code>变量存放<code>lock</code>原来的值，即<code>old = *lock</code> 。</li><li>将<code>lock</code>设为<code>true</code>，即<code>*lock = true</code> 。</li><li>返回<code>lock</code>原来的值，即<code>return old</code> 。</li></ul></li></ul></li></ul><p>算法逻辑：</p><ul><li><p>使用<code>TestAndSet</code>指令实现互斥：</p><ul><li><code>while (TestAndSet (&amp;lock));</code> ：通过不断调用<code>TestAndSet</code>函数对<code>lock</code>进行 “上锁” 并检查操作，当返回值为<code>false</code>（即之前未加锁）时，跳出循环进入临界区。</li><li>临界区代码段执行临界区相关操作。</li><li><code>lock = false;</code> ：执行完临界区代码后，将<code>lock</code>设为<code>false</code>，即 “解锁”</li><li>剩余区代码段执行剩余操作。</li></ul></li><li><p><code>lock</code> 变量本身成为唯一的临界资源，而原子操作确保对它的访问是互斥的。无论多少进程同时调用 <code>TestAndSet</code>，只有一个进程能成功获取锁（即第一个遇到 <code>old == false</code> 的进程）</p></li><li><p>若刚开始 lock 是 false，则 TS 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区</p></li><li><p>若刚开始 lock 是 true，则执行 TS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”</p></li><li><p><strong>优点</strong>：</p><ul><li>实现<strong>简单</strong>，TS 指令将“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</li><li><strong>适用于多处理系统</strong></li></ul></li><li><p><strong>缺点</strong>：不满足“<font color="#ff0000">让权等待</font>”原则</p></li></ul><h5 id="硬件指令——Swap-指令（XCHG-指令）">硬件指令——Swap 指令（XCHG 指令）</h5><ul><li>为每个临界资源设置一个共享布尔变量 lock，初值 false</li><li>在每个进程中设置一个局部变量 key，初值 true，用于与 lock 交换信息</li><li>Swap指令是用<strong>硬件</strong>实现的，执行的过程不允许被中断，只能一气呵成<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512160840.png" alt="image.png"></li><li><strong><code>Swap</code>函数</strong><ul><li><strong>功能</strong>：将锁变量和临时变量的值进行交换</li><li>若交换前锁变量为<code>false</code> ，交换后锁变量变为<code>true</code>，表示当前进程获得锁可进入临界区；若交换前锁变量为<code>true</code>，交换后临时变量为<code>true</code>，当前进程需等待，直到锁变量被其他进程设为<code>false</code> 。</li></ul></li></ul><p>算法逻辑：</p><ul><li><p><strong>变量定义</strong>：</p><ul><li><code>bool lock;</code> ：表示当前临界区是否被加锁，<code>true</code> 表示已加锁，<code>false</code> 表示未加锁。</li><li><code>bool old = true;</code> ：用于辅助判断是否能进入临界区。</li></ul></li><li><p><strong>获取锁逻辑</strong>：</p><ul><li><code>while (old == true)</code> ：只要<code>old</code>为<code>true</code>，就持续循环尝试获取锁。</li><li><code>Swap (&amp;lock, &amp;old);</code> ：每次循环都调用<code>Swap</code>函数交换<code>lock</code>和<code>old</code>的值。初始时<code>old</code>为<code>true</code>，若<code>lock</code>为<code>false</code>（临界区未加锁），交换后<code>old</code>变为<code>false</code>，循环结束，进程可进入临界区；若<code>lock</code>为<code>true</code>（临界区已加锁），交换后<code>old</code>仍为<code>true</code>，继续循环等待。</li></ul></li><li><p><strong>临界区操作</strong>：进入临界区后，执行临界区代码段相关操作。</p></li><li><p><strong>释放锁逻辑</strong>：执行完临界区操作后，<code>lock = false;</code> ，将临界区状态设为未加锁，以便其他进程能获取锁进入临界区，然后执行<strong>剩余区代码段</strong> 。</p></li><li><p><strong>优点</strong>：</p><ul><li>简单，容易验证其正确性</li><li>适用于<strong>多处理机系统</strong></li><li>支持系统中有多个临界区，只需为每个临界区设立一个布尔变量</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>不满足“<font color="#ff0000">让权等待</font>”原则</li><li>从等待进程中随机选择一个进程进入临界区，有的进程可能一直选不上，导致饥饿</li></ul></li></ul><p>TSL VS Swap：</p><ul><li><strong>TSL 指令</strong>：操作对象为<strong>单个内存位置</strong>，即<strong>锁变量</strong>。通过读取并设置该锁变量的值来判断和获取临界区访问权 。比如检查锁变量<code>lock</code>的值，若为<code>false</code>（未加锁），则将其设为<code>true</code>（加锁）并获取锁进入临界区。</li><li><strong>Swap 指令</strong>：操作<strong>两个内存位置</strong>，通常是<strong>锁变量</strong>和<strong>一个临时变量</strong>。通过交换这两个变量的值，来判断和设置锁的状态，进而确定能否进入临界区 。</li></ul><h3 id="互斥锁">互斥锁</h3><ul><li><p>是解决临界区<strong>最简单</strong>的工具</p></li><li><p>用于实现进程互斥的工具，当进程使用资源前先给该资源上锁，用完后在解锁</p></li><li><p>通常采用<strong>硬件机制</strong>实现</p></li><li><p>获得锁：acquire，释放锁：release，都是原子操作</p></li><li><p>使用互斥锁解决经典同步问题<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512161756.png" alt="image.png"></p></li><li><p><strong><code>acquire()</code>函数</strong></p><ul><li><strong>功能</strong>：用于获取锁，实现对临界区的访问控制。</li><li><strong>代码逻辑</strong>：<ul><li><code>while(!available)</code> ：通过一个循环持续检查<code>available</code>变量的值，当<code>available</code>为<code>false</code>时，进程会一直处于循环等待状态，即 “忙等待”，这期间会持续占用 CPU 资源。</li><li><code>available = false;</code> ：当<code>available</code>变为<code>true</code> ，循环结束，当前进程将<code>available</code>设为<code>false</code> ，表示已获得锁，可进入临界区进行操作。</li></ul></li></ul></li><li><p><strong><code>release()</code>函数</strong></p><ul><li><strong>功能</strong>：用于释放锁，允许其他进程获取锁进入临界区。</li><li><strong>代码逻辑</strong>：<code>available = true;</code> ，将<code>available</code>变量设为<code>true</code> ，表示释放锁，此时等待获取锁的进程可以通过<code>acquire()</code>函数中的循环检查，尝试获取锁。</li></ul></li><li><p>利用<code>available</code>这个共享变量作为锁的标识，<code>true</code>代表锁处于可用状态，<code>false</code>代表锁已被占用。<code>acquire()</code>函数负责获取锁，在锁不可用时忙等待，直到锁可用并获取；<code>release()</code>函数负责在临界区操作完成后，将锁释放，使其他进程有机会获取锁 。</p></li><li><p><strong>优点</strong>：</p><ul><li>进程在等待锁期间，<strong>没有上下文切换</strong>，若上锁的时间较短，则<strong>等待代价不高</strong></li><li>适用于<strong>多处理系统</strong></li></ul></li><li><p><strong>缺点</strong>：<font color="#ff0000">忙等待</font>，违反&quot;<font color="#ff0000">让权等待</font>&quot;</p></li><li><p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁</strong>：如<strong>TSL指令、swap指令、单标志法</strong>。都有&quot;忙等待&quot;问题<br>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区<br><strong>不适合单处理机系统</strong></p></li></ul><h3 id="信号量">信号量</h3><h4 id="PV-操作定义">PV 操作定义</h4><ul><li><strong>信号量</strong>：表示系统中某种资源的数量<ul><li>信号量其实就是一个变量（<mark>可以是一个整型，也可以是更复杂的记录型变量</mark>），可以用一个信号量来<mark>表示系统中某种资源的数量</mark><br>比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</li><li>信号量是一种特殊的数据结构。用来<strong>表示资源的实体</strong></li><li>特殊之处：每个信号量与一个队列（<strong>阻塞队列</strong>）关联</li><li>信号量的分类<ul><li>公用信号量：用于进程间的<mark>互斥</mark>，初值通常为<mark>1</mark></li><li>私有信号量：用于进程间的<mark>同步</mark>，初值通常为<mark>0/n</mark></li></ul></li></ul></li><li>信号量的值可以用操作系统提供的<mark>两个原语</mark>来修改，==wait(s)<mark>原语和</mark>signal(s)<mark>原语这两个原语通常简称为</mark>P(s)<mark>操作和</mark>V(s)==操作</li><li><strong>P 操作</strong>【wait() 原语】：将信号量值 <strong>S 减 1</strong>，表示<strong>申请占用一个资源</strong></li><li><strong>V 操作</strong>【signal() 原语】：将信号量值 <strong>S 加 1</strong>，表示<strong>释放一个资源</strong>，即使用完资源后归还资源</li><li>互斥1，同步用户自定义</li></ul><h4 id="信号量分类">信号量分类</h4><h5 id="整型信号量">整型信号量</h5><ul><li>用一个整数型的变量作为信号量，用来<strong>表示系统中某种资源的数量</strong><ul><li>对信号量的操作只有三种信号量的 <mark>初始化，P操作、V操作【P、V是原子操作】</mark></li></ul></li><li>该信号量被定义为一个用于表示资源数目的整型量 S</li><li>该机制不遵循“<font color="#ff0000">让权等待</font>” 的准则，会发生<mark>忙等</mark>【只要 s≤0，就会不断循环测试】<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512164712.png" alt="image.png"></li><li><code>int S = 1;</code> ：定义整型信号量<code>S</code> ，初始值为 1，表示系统中可用的打印机资源数为 1 。</li></ul><p>操作函数：</p><ul><li><strong><code>wait</code>函数</strong><ul><li><strong>功能</strong>：相当于 “进入区” 操作，用于申请资源。</li><li><strong>代码逻辑</strong>：<ul><li><code>while (S &lt;= 0);</code> ：当可用资源数小于等于 0 时，进程会一直循环等待，即处于忙等状态，直到有资源被释放。</li><li><code>S = S - 1;</code> ：当可用资源数大于 0 时，占用一个资源，使可用资源数减 1 。</li></ul></li></ul></li><li><strong><code>signal</code>函数</strong><ul><li><strong>功能</strong>：相当于 “退出区” 操作，用于释放资源。</li><li><strong>代码逻辑</strong>：<code>S = S + 1;</code> ，使用完资源后，将可用资源数加 1 。</li></ul></li></ul><h5 id="记录型信号量">记录型信号量</h5><ul><li>用记录型<mark>数据结构</mark>表示的信号量（实现进程同步和进程互斥都是使用该信号量）</li><li>需要一个用于代表资源数目的变量 value</li><li>需要一个<strong>进程链表 L</strong>，用于链接所有<strong>等待该资源的进程</strong></li><li>S.value 的初值表示系统中某种资源的<strong>数目</strong></li></ul><p><strong>信号量定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><p>当信号量的值为 2 时，表示有 2 个资源可以使用；当信号量的值为-2 的时候，表示有两个进程正在等待使用这个资源<br><strong>申请资源P操作（wait 原语）</strong>：</p><ul><li><strong>操作逻辑</strong>：将信号量 <code>S</code> 的剩余资源数 <code>value</code> 减 1 。若减 1 后 <code>S.value &lt; 0</code> ，说明<strong>剩余资源数不够使用</strong>，使用 <code>block</code> 原语使进程从<strong>运行态→阻塞态</strong>，主动放弃处理机，并把进程挂到信号量 <code>S</code> 的等待队列S.L（即阻塞队列）中。<ul><li>遵循“<font color="#ff0000">让权等待</font>”</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        block (S,L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>释放资源V操作（signal 原语）</strong>：</p><ul><li><strong>操作逻辑</strong>：将信号量 <code>S</code> 的剩余资源数 <code>value</code> 加 1 。若加 1 后 <code>S.value &lt;= 0</code> ，说明<strong>释放资源后还有别的进程在等待这种资源</strong>，使用 <code>wakeup</code> 原语唤醒等待队列中的一个进程（S.L 中的第一个进程），该进程从<strong>阻塞态→就绪态</strong> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<br>PV操作是一种低级的进程通信原语，不是系统调用<br>P操作和V操作都属于原子操作，所以 PV操作由两个不可被中断的过程组成</p><p><strong>阻塞之后，再执行，会从原来阻塞的地方开始，而不是再次执行wait函数</strong></p><p>一个记录型信号量包含两个分量：信号量的值、信号量的等待队列指针<br>S.L 因临界区不能进入而阻塞的进程组成的阻塞队列【等待队列】<br>CR：一个信号量被用来表示临界资源的可用量<br>S.value 不同取值表示临界资源的使用情况【<strong>剩余资源数</strong>】<br>S.value的<mark>绝对值</mark>表示<strong>正在等待资源的进程数量</strong></p><ul><li><strong>S.value &lt; 0</strong>：表示有|S.value|个进程因等待该CR而阻塞</li><li><strong>S.value ≥ 1</strong>：表示当前可用资源的数量</li><li><strong>S.value = 0</strong>：表示当前没有可用的资源</li></ul><h4 id="信号量的应用">信号量的应用</h4><h5 id="利用信号量实现互斥">利用信号量实现互斥</h5><ul><li><strong>互斥信号量 S 初始值=1，即</strong><code>semaphore mutex = 1</code>【semaphore相当于上面的typedef结构体；mutex表示各进程互斥进入临界区，保证任何时候只有一个进程使用缓冲区】，表示临界区只允许一个进程进入，从而实现互斥<br>只要用<strong>semaphore</strong>这个关键字来开头的话，就意味着这个信号量并不是整型信号量，而是一个<strong>记录型的信号量</strong>，也就是说这个信号量是带有<strong>排队阻塞</strong>的功能的，并<strong>不会忙等</strong></li><li>把对临界资源的访问操作置于 P (S) 和 V（S）之间</li><li>P 操作和 V 操作<strong>必须成对出现</strong></li><li>缺少 P 操作：不能保证对临界资源的<strong>互斥</strong>访问</li><li>缺少 V 操作：导致临界资源永远得不到<strong>释放</strong>，使因等待该资源而阻塞的进程永远得不到<strong>唤醒</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化互斥信号量，初始化为 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 P₁</span></span><br><span class="line">P₁() &#123;</span><br><span class="line">    P(mutex); <span class="comment">// 申请占用资源</span></span><br><span class="line">    临界区</span><br><span class="line">    V(mutex); <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 P₂</span></span><br><span class="line">P₂() &#123;</span><br><span class="line">    P(mutex); <span class="comment">// 申请占用资源</span></span><br><span class="line">    临界区</span><br><span class="line">    V(mutex); <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="利用信号量实现同步">利用信号量实现同步</h5><ul><li>分析什么地方需要实现“同步关系”，即必须保证“<strong>一前一后</strong>”执行的两个操作（或两句代码）</li><li>设置<strong>同步信号量 S 的初始值 = 0</strong></li><li><strong>在“前操作”之后执行 V (S)</strong>【释放资源，唤醒等待进程】</li><li><strong>在“后操作”之前执行 P (S)</strong>【申请资源，若无资源则阻塞】</li></ul><p><font color="#ff0000">前V后P</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化同步信号量，表示当前可用资源为 0</span></span><br><span class="line"></span><br><span class="line">P₁() &#123;</span><br><span class="line">    代码 <span class="number">1</span>;</span><br><span class="line">    代码 <span class="number">2</span>;</span><br><span class="line">    V(S); <span class="comment">// 代码 2 运行完后，释放资源</span></span><br><span class="line">    代码 <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P₂() &#123;</span><br><span class="line">    P(S); <span class="comment">// 代码 4 运行前先申请占用资源，保证代码 4 一定是在代码 2 之后执行</span></span><br><span class="line">    代码 <span class="number">4</span>;</span><br><span class="line">    代码 <span class="number">5</span>;</span><br><span class="line">    代码 <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512182149.png" alt="image.png|300"></p><h5 id="利用信号量实现前驱关系">利用信号量实现前驱关系</h5><ul><li>信号量用来描述程序或语句之间的前驱关系</li><li>要为<strong>每一对前驱关系各设置一个同步信号量</strong></li><li>在“前操作”之后对相应的同步信号量执行 V 操作</li><li>在“后操作”之前对相应的同步信号量执行 P 操作</li><li>前驱问题的实质就是 <mark>多级同步问题</mark><br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512182327.png" alt="image.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">semaphore a,b,c,d,e,f,g = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">begin</span><br><span class="line">    parbegin;</span><br><span class="line">        begin</span><br><span class="line">            S1;</span><br><span class="line">            signal(a);</span><br><span class="line">            signal(b);</span><br><span class="line">        end;</span><br><span class="line">        begin</span><br><span class="line">            <span class="title function_">wait</span><span class="params">(a)</span>;</span><br><span class="line">            S2;</span><br><span class="line">            signal(c);</span><br><span class="line">            signal(d);</span><br><span class="line">        end;</span><br><span class="line">        begin</span><br><span class="line">            <span class="title function_">wait</span><span class="params">(b)</span>;</span><br><span class="line">            S3;</span><br><span class="line">            signal(g);</span><br><span class="line">        end;</span><br><span class="line">        begin</span><br><span class="line">            <span class="title function_">wait</span><span class="params">(c)</span>;</span><br><span class="line">            S4;</span><br><span class="line">            signal(e);</span><br><span class="line">        end;</span><br><span class="line">        begin</span><br><span class="line">            <span class="title function_">wait</span><span class="params">(d)</span>;</span><br><span class="line">            S5;</span><br><span class="line">            signal(f);</span><br><span class="line">        end;</span><br><span class="line">        begin</span><br><span class="line">            <span class="title function_">wait</span><span class="params">(e)</span>;</span><br><span class="line">            wait(f);</span><br><span class="line">            wait(g);</span><br><span class="line">            S6;</span><br><span class="line">        end;</span><br><span class="line">    parend;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h3 id="经典同步问题">经典同步问题</h3><p>生产者-消费者问题，多生产者-多消费者问题，吸烟者问题，读者写者问题，哲学家进餐问题。这些问题都是采用信号量机制解决的<br><strong>互斥信号量初值一般为1，同步信号量初值是资源初始值</strong></p><h4 id="生产者——消费者问题">生产者——消费者问题</h4><p><strong>生产者与生产者存在互斥关系、消费者与消费者之间存在互斥关系、生产者与消费者之间存在同步与互斥关系</strong></p><h5 id="问题描述">问题描述</h5><ul><li>一组生产者进程和一组消费者进程共享一个<strong>初始为空、大小为 n 的缓冲区</strong></li><li>进程每次从缓冲区中取出一个产品并使用</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</li><li>缓冲区是临界资源，各进程必须<strong>互斥地访问</strong></li></ul><h5 id="问题分析">问题分析</h5><ul><li><strong>关系分析</strong>：<ul><li>生产者和消费者对缓冲区的互斥访问是互斥关系</li><li>生产者和消费者之间相互协作，是同步关系</li></ul></li><li><strong>整理思路</strong>：确定 P、V 操作的大致顺序<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512183649.png" alt="image.png"></li></ul><ol><li><strong><code>mutex</code></strong> ：互斥信号量，初始值为 1 。用于实现对缓冲区的互斥访问，确保同一时刻只有一个进程（生产者或消费者）能访问缓冲区，避免数据竞争<br>P(mutex)就像是上锁，如果没有V(mutex)，就没有进程可以访问缓冲区</li><li><strong><code>empty</code></strong> ：同步信号量，初始值为 <strong>n</strong>（<code>n</code> 为缓冲区容量） 。表示<strong>空闲缓冲区</strong>的数量，用于控制<strong>生产者能否生产产品并放入缓冲区</strong>。</li><li><strong><code>full</code></strong> ：同步信号量，初始值为 <strong>0</strong> 。表示产品的数量，即<strong>非空缓冲区</strong>的数量，用于控制<strong>消费者能否从缓冲区取出产品</strong>。</li><li>互斥的是缓冲区，同步的是空闲缓冲区资源和产品</li><li>对于producer：先P(empty),再P(mutex)，再V(mutex)，再V(full).</li><li>对于consumer：先P(full),再P(mutex)，再V(mutex)，再V(empty)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">producer ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty); <span class="comment">// 消耗一个空闲缓冲区（同步）</span></span><br><span class="line">        P(mutex); <span class="comment">// 进入临界区（互斥）</span></span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex); <span class="comment">// 离开临界区（互斥）</span></span><br><span class="line">        V(full); <span class="comment">// 增加一个产品（同步）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full); <span class="comment">// 消耗一个非空缓冲区（同步）</span></span><br><span class="line">        P(mutex); <span class="comment">// 进入临界区（互斥）</span></span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex); <span class="comment">// 离开临界区（互斥）</span></span><br><span class="line">        V(empty); <span class="comment">// 增加一个空闲缓冲区（同步）</span></span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>生产者</strong>：<ul><li>生产产品前，先执行 <code>P(empty)</code> ，检查是否有空闲缓冲区。若 <code>empty</code> 大于 0 ，表示有空闲缓冲区，可继续操作；否则，生产者进程阻塞等待。</li><li>执行 <code>P(mutex)</code> ，获取对缓冲区的访问权。若 <code>mutex</code> 为 1 ，可进入临界区（访问缓冲区）；若为 0 ，表示已有进程在访问缓冲区，生产者进程阻塞等待。</li><li>将产品放入缓冲区后，执行 <code>V(mutex)</code> ，释放对缓冲区的访问权。</li><li>执行 <code>V(full)</code> ，表示缓冲区中有了产品，唤醒可能因等待产品而阻塞的消费者进程。</li></ul></li><li><strong>消费者</strong>：<ul><li>消费产品前，先执行 <code>P(full)</code> ，检查是否有产品。若 <code>full</code> 大于 0 ，表示有产品，可继续操作；否则，消费者进程阻塞等待。</li><li>执行 <code>P(mutex)</code> ，获取对缓冲区的访问权。若 <code>mutex</code> 为 1 ，可进入临界区（访问缓冲区）；若为 0 ，表示已有进程在访问缓冲区，消费者进程阻塞等待。</li><li>从缓冲区取出产品后，执行 <code>V(mutex)</code> ，释放对缓冲区的访问权。</li><li>执行 <code>V(empty)</code> ，表示缓冲区空出了一个位置，唤醒可能因等待空闲缓冲区而阻塞的生产者进程。<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512184149.png" alt="image.png"></li></ul></li></ul><p>改变相邻的P、V操作的顺序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">producer ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(mutex);  <span class="comment">// ①</span></span><br><span class="line">        P(empty);  <span class="comment">// ②</span></span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);  <span class="comment">// ③</span></span><br><span class="line">        P(full);   <span class="comment">// ④</span></span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>初始状态</strong>：若缓冲区内放满产品，此时 <code>empty = 0</code>，<code>full = n</code>（<code>n</code> 为缓冲区容量）。</li><li><strong>生产者进程执行</strong>：<ul><li>执行 <code>P(mutex)</code>（①），将 <code>mutex</code> 变为 0 ，获取对临界资源（缓冲区）的 “锁”。</li><li>执行 <code>P(empty)</code>（②），由于 <code>empty = 0</code>，表示没有空闲缓冲区，生产者进程被阻塞。</li></ul></li><li><strong>消费者进程执行</strong>：<ul><li>由于生产者阻塞，系统切换到消费者进程。消费者进程执行 <code>P(mutex)</code>（③），但此时 <code>mutex</code> 为 0 ，意味着生产者还未释放对临界资源的 “锁”，所以消费者进程也被阻塞。</li></ul></li></ol><p><strong>注意</strong>：</p><ul><li><font color="#ff0000">实现互斥的 P 操作一定要在实现同步的 P 操作之后</font></li><li><strong>V 操作不会导致进程阻塞</strong>，因此<font color="#ff0000">两个 V 操作顺序可以互换</font></li><li><strong>互斥实现</strong>：在同一进程（生产者或消费者自身）中，通过一对 <code>P-V</code> 操作（<code>P(mutex)</code> 和 <code>V(mutex)</code> ）实现对缓冲区的互斥访问。</li><li><strong>同步实现</strong>：在生产者和消费者两个进程间，通过在一个进程中执行 <code>P</code> 操作（如生产者的 <code>P(empty)</code> 、消费者的 <code>P(full)</code> ） ，在另一个进程中执行对应的 <code>V</code> 操作（生产者的 <code>V(full)</code> 、消费者的 <code>V(empty)</code> ） ，来实现进程间的同步关系。</li></ul><h4 id="多生产者——多消费者问题">多生产者——多消费者问题</h4><p>多：多类<br>涉及多个生产者进程和多个消费者进程对共享缓冲区的操作</p><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><ul><li>semaphore mutex = 1; ：实现互斥访问盘子（缓冲区）</li><li>semaphore apple = 0; ：表示盘子中有几个苹果</li><li>semaphore orange = 0; ：表示盘子中有几个橘子</li><li>semaphore plate = 1; ：表示盘子中还可以放多少个水果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">dad ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个苹果;</span><br><span class="line">        P(plate);</span><br><span class="line">        P(mutex);</span><br><span class="line">        把苹果放入盘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个橘子;</span><br><span class="line">        P(plate);</span><br><span class="line">        P(mutex);</span><br><span class="line">        把橘子放入盘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple);</span><br><span class="line">        P(mutex);</span><br><span class="line">        从盘中取出苹果;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);</span><br><span class="line">        吃掉苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        P(mutex);</span><br><span class="line">        从盘中取出橘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);</span><br><span class="line">        吃掉橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果缓冲区大小为1，有可能不用互斥信号量（最好还是加上），本问题可以不加</p><p>三个进程P₁、P₂、P;互斥使用一个包含N(N&gt;0)个单元的缓冲区。P每次用produce()生成一个正整数，并用put()送入缓冲区某一空单元汇中;P,每次用getodd()从该缓冲区中取出一个奇数，并用countodd()统计奇数个数;P;每次用geteven()从该缓冲区中取出一个偶数，并用counteven()统计偶数个数。<br>请用信号量机制实现这三个进程的同步和互斥活动，并说明所定义信号量的含义。要求用伪代码描述。<br>P₁为生产者，P₂、P3为消费者。<br>P₁、P₂共享缓冲区的奇数部分，故设置同步信号量odd；<br>P₁、P3共享缓冲区的偶数部分，故设置同步信号量even；<br>P₁、P₂、P3共享整个缓冲区，用一个互斥mutex来保护，再设置同步信号量empty，表示缓冲区空位资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥访问共享缓冲区;</span></span><br><span class="line">semaphore empty=N;<span class="comment">//共享缓冲区同步信号量</span></span><br><span class="line">semaphore odd=<span class="number">0</span>;<span class="comment">//奇数缓冲区同步信号量</span></span><br><span class="line">semaphore even=<span class="number">0</span>;<span class="comment">//偶数缓冲区同步信号量</span></span><br><span class="line">Process <span class="title function_">prodeceri</span><span class="params">(i=<span class="number">1</span>,<span class="number">2</span>…)</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num=produce();<span class="comment">//生产一个数据num</span></span><br><span class="line">        wait(empty);<span class="comment">//消耗掉一个空单元</span></span><br><span class="line">        wait(mutex);<span class="comment">//互斥访问缓冲区;</span></span><br><span class="line">        put(num);<span class="comment">//将数据num放入缓冲区</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>!=<span class="number">0</span>)<span class="comment">//奇数</span></span><br><span class="line">            signal(odd);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//偶数</span></span><br><span class="line">            signal(even);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        wait(odd);<span class="comment">//有奇数时才能取出奇数</span></span><br><span class="line">  wait(mutex);<span class="comment">//互斥访问缓冲区</span></span><br><span class="line">        getodd();<span class="comment">//取出奇数</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);<span class="comment">//产生一个空单元</span></span><br><span class="line">        countodd();<span class="comment">//奇数个数加一</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        wait(even);<span class="comment">//有偶数时才能取出偶数</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        geteven();</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">        counteven();</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="读者写者问题">读者写者问题</h4><p>要求：<br>①允许多个读者可以同时对文件执行读操作；<br>②只允许一个写者往文件中写信息；<br>③任一写者在完成写操作之前不允许其他读者或写者工作；<br>④写者执行写操作前，应让已有的读者和写者全部退出<br>即只有一个人写，大家都可以读</p><p>读——写、写——写：互斥<br>读——读：可以同时访问，不存在互斥问题</p><p>第一个进来的读者申请资源，最后一个走的读者释放资源</p><ol><li>互斥信号量<code>rmutex</code>用于读者互斥地访问共享变量<code>readcont</code>，而<code>readcont</code>是记录有多少读者正在读；</li><li>互斥信号量<code>wmutex</code>用于实现读写互斥</li><li>互斥信号量<code>mutex</code> 用于互斥访问临界资源readcount</li><li><code>readcont</code> 读者计数，初值为0</li></ol><h5 id="读者优先问题">读者优先问题:</h5><p>即只要一个读者在读，后续的其他读者无论是否在写者后面都可以读<br>写者必须等待，必须等所有读者都读完才能写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥读者与读者</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 互斥读者与写者，写者与写者</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示读者数量，需看成临界资源，即进来一个读者就+1操作</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 读者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line"><span class="comment">// 互斥其他读者，只允许一个读者进入</span></span><br><span class="line">P(rmutex);</span><br><span class="line"><span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 如果读者数目为0，所以就必须互斥写者</span></span><br><span class="line">P(mutex);</span><br><span class="line"><span class="comment">// 读者数+1</span></span><br><span class="line">readcount++;</span><br><span class="line"><span class="comment">// 释放，让其他读者进来修改readcount</span></span><br><span class="line">V(rmutex);</span><br><span class="line"><span class="comment">/* 读操作 */</span></span><br><span class="line"><span class="comment">// 读者离开，需要访问readcount</span></span><br><span class="line">P(rmutex);</span><br><span class="line">readcount--;</span><br><span class="line"><span class="comment">// 如果此时没有读者了，表示写者可以进行写了</span></span><br><span class="line"><span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="comment">// 释放readcount资源</span></span><br><span class="line">V(rmutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 写者和一般消费者进程一样，获取信号量值</span></span><br><span class="line">P(mutex);</span><br><span class="line"><span class="comment">/* 写操作 */</span></span><br><span class="line"><span class="comment">// 让文件可读和可写</span></span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">reader();</span><br><span class="line">writer();</span><br><span class="line">reader();</span><br><span class="line"><span class="comment">/*.......*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写者优先问题">写者优先问题</h5><p>即只要有写者在写，无论后续写者在哪都可以写，读者必须等所有写者写完才能读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥读者与写者</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 互斥读者</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 互斥写者</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示是否还有写者</span></span><br><span class="line">semaphore readable = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 读者数量，写者数量</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>, writecount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 先看是否可读</span></span><br><span class="line">P(readable);</span><br><span class="line"><span class="comment">// 互斥其他读者修改readcount</span></span><br><span class="line">P(rmutex);</span><br><span class="line"><span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 如果没有读者，需要互斥写者</span></span><br><span class="line">P(mutex);</span><br><span class="line">readcount++;</span><br><span class="line">V(rmutex);</span><br><span class="line">V(readable);</span><br><span class="line"><span class="comment">/* 读取中 */</span></span><br><span class="line">P(rmutex);</span><br><span class="line">readcount--;</span><br><span class="line"><span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">V(mutex);</span><br><span class="line">V(rmutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 互斥其他写者，写入writecount</span></span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">if</span>(writecount == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 此时不能让写者以后的读者进去</span></span><br><span class="line">P(readable)</span><br><span class="line">writecount++;</span><br><span class="line">V(wmutex);</span><br><span class="line"><span class="comment">// 互斥在写者之前的读者</span></span><br><span class="line">P(mutex);</span><br><span class="line"><span class="comment">/* 写入中 */</span></span><br><span class="line"><span class="comment">// 写入完成离开</span></span><br><span class="line">V(mutex);</span><br><span class="line">P(wmutex);</span><br><span class="line">writecount--;</span><br><span class="line"><span class="keyword">if</span>(writecount == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 让写者以后的读者可读</span></span><br><span class="line">V(readable);</span><br><span class="line">V(wmutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">reader();</span><br><span class="line">writer();</span><br><span class="line">reader();</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读写公平">读写公平:</h5><p>即按照读者写者的先后顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥读者与写者</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 互斥读者</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 只检测临界区是否还有写者</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查是否有写者</span></span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="comment">// 互斥其他读者</span></span><br><span class="line">P(rmutex);</span><br><span class="line"><span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 互斥写者</span></span><br><span class="line">P(mutex);</span><br><span class="line">readcount++;</span><br><span class="line">V(rmutex);</span><br><span class="line"><span class="comment">// 让写者也能进入</span></span><br><span class="line">V(wmutex);</span><br><span class="line"><span class="comment">/* 读取中 */</span></span><br><span class="line">P(rmutex);</span><br><span class="line">readcount--;</span><br><span class="line"><span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">V(mutex);</span><br><span class="line">V(rmutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line"><span class="comment">// 如果后续的写者进来，申请到wmutex，则等读者释放后进入第二步申请mutex</span></span><br><span class="line"><span class="comment">// 此时如果有后来读者想进入，但wmutex已经为0，明显不能进来</span></span><br><span class="line"><span class="comment">// 所以此时只能是写者等到上一个读者释放mutex并获取后进入写操作，最后释放wmutex后才能让后来的读者进入</span></span><br><span class="line">P(wmutex);</span><br><span class="line">P(mutex);</span><br><span class="line"><span class="comment">/* 写入中*/</span></span><br><span class="line">V(mutex);</span><br><span class="line">V(wmutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">reader();</span><br><span class="line">writer();</span><br><span class="line">reader();</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥问题使用读者——写者问题思想<br>同步问题使用生产者——消费者问题思想</p><h4 id="哲学家就餐问题">哲学家就餐问题</h4><p>只有<strong>互斥</strong>关系<br>哲学家——5个进程<br>桌子——可同时共享<br>饭——独占，不需共享<br>椅子——独占，不需共享<br>筷子——互斥共享（每只筷子都是一个<mark>临界资源</mark>）</p><p>① 限制最多 4 人同时进餐</p><ul><li><strong>核心思路</strong>：通过限制并发进餐人数，确保至少 1 人能拿到左右筷子，破坏 “循环等待” 条件。</li><li><strong>原理</strong>：5 根筷子分配给 4 人时，必然存在 1 人可同时获取两根筷子（因总资源数 &gt; 并发数），用完释放后其他哲学家可依次进餐，避免所有人陷入等待环。</li><li><strong>关键操作</strong>：<ul><li>引入 “进餐名额” 作为临界资源（信号量初始值为 4）。</li><li>哲学家需先获取名额，再拿筷子，确保同时拿筷的人数≤4。</li></ul></li></ul><p>② 奇偶编号法（改变拿筷顺序）</p><ul><li><strong>核心思路</strong>：对哲学家（或椅子）编号，奇数号先拿左筷子，偶数号先拿右筷子，破坏 “循环等待” 条件。</li><li><strong>原理</strong>：相邻哲学家的拿筷顺序冲突（如 1 号先左，2 号先右），导致无法形成环形等待链。例如，哲学家 1 拿左筷子 1，哲学家 2 拿右筷子 1，两者竞争同一资源，但至少一人能优先获取，打破循环。</li><li><strong>关键操作</strong>：<ul><li>按编号决定拿筷顺序，奇数先左后右，偶数先右后左。</li><li>利用顺序冲突避免相邻哲学家同时等待对方的筷子。</li></ul></li></ul><p>③ 双筷子同时检查机制</p><ul><li><strong>核心思路</strong>：仅当左右筷子都可用时，才允许哲学家拿起筷子，破坏 “请求与保持” 条件。</li><li><strong>原理</strong>：避免哲学家持有左筷子后等待右筷子的情况（即不允许 “持有并请求”），确保资源获取的原子性。</li><li><strong>关键操作</strong>：<ul><li>使用互斥信号量确保检查和拿筷子的操作原子化，防止中间状态（如检查时筷子被其他哲学家拿走）。</li><li>若筷子不全可用，则哲学家放弃并重新尝试，避免长期等待。</li></ul></li></ul><p><strong>各方案对应的死锁预防条件</strong></p><table><thead><tr><th>解决方案</th><th>破坏的死锁必要条件</th><th>核心逻辑</th></tr></thead><tbody><tr><td>限制 4 人进餐</td><td>循环等待</td><td>控制并发数，打破资源分配的环形依赖链。</td></tr><tr><td>奇偶编号法</td><td>循环等待</td><td>改变拿筷顺序，破坏相邻哲学家间的等待循环。</td></tr><tr><td>双筷子同时检查</td><td>请求与保持</td><td>禁止 “持有资源并请求其他资源”，确保一次获取全部所需资源。</td></tr></tbody></table><p>需要设计一种新的信号量机制——信号量集机制</p><ul><li>用一个P操作，可以同时申请到两个或多个临界资源</li><li>用一个V操作，可以释放两个或多个临界资源</li></ul><h3 id="管程">管程</h3><p><strong>管程的定义</strong>：管程是一种同步机制，它将共享资源以及对资源的操作进行封装，集中管理对共享资源的访问，简化并发编程。可以类比为餐厅中的服务员，顾客（进程）无需自行协调共享资源，只需向管程请求，管程会确保资源正确分配和回收，保证同一时刻只有一个进程能使用特定资源。</p><ul><li><strong>引入管程的原因</strong>：<ul><li>信号量机制存在的问题：编写程序困难、易出错</li><li>管程的特性<strong>保证了互斥</strong>，程序员无须自己实现，并提供条件变量，更灵活地<strong>实现进程同步</strong></li></ul></li><li><strong>管程</strong>：定义了<strong>共享数据结构</strong>和能为并发进程执行（在该数据结构上）的一组操作</li><li><strong>管程的组成</strong>：<ul><li><strong>管程的名称</strong>：用于标识管程，如 “monitor Demo” 中的 “Demo” 。</li><li><strong>局部于管程内部的共享数据结构说明</strong>：定义管程所管理的共享资源的数据结构，示例中为 “共享数据结构 S” ，对应系统中的某种共享资源 。</li><li><strong>对局部于管程内部的共享数据设置初始值的语句</strong>：对共享数据结构进行初始化，如 “init () {S = 5;}” ，表示将共享资源 S 初始化为 5 。</li><li><strong>对该数据结构进行操作的一组过程 (或函数)</strong> ：包含对共享数据结构进行操作的具体过程，如 “take_away ()” 过程用于申请资源（使可用资源数 S 减 1 ），“give_back ()” 过程用于归还资源（使可用资源数 S 加 1 ） 。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo &#123;</span><br><span class="line">    <span class="comment">//②定义共享数据结构，对应系统中的某种共享资源</span></span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    <span class="comment">//④对共享数据结构初始化的语句</span></span><br><span class="line">    init_code()&#123;</span><br><span class="line">        S=<span class="number">5</span>; <span class="comment">//初始资源数等于5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//③过程1：申请一个资源</span></span><br><span class="line">    take_away()&#123;</span><br><span class="line">        对共享数据结构 x 的一系列处理;</span><br><span class="line">        S--; <span class="comment">//可用资源数-1</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//③过程2：归还一个资源</span></span><br><span class="line">    give_back()&#123;</span><br><span class="line">        对共享数据结构 x 的一系列处理;</span><br><span class="line">        S++; <span class="comment">//可用资源数+1</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>管程的基本特征</strong>：<ul><li><strong>局部</strong>于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过<strong>调用</strong>管程内的过程才能进入管程访问共享数据</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>，从而实现<strong>互斥</strong>【<strong>编译器实现该特性</strong>】</li></ul></li></ul><h4 id="管程解决生产者-消费者问题核心要点">管程解决生产者 - 消费者问题核心要点</h4><ol><li><strong>共享数据定义</strong>：在管程内设定共享数据结构，像生产者 - 消费者问题里的缓冲区，用于暂存生产的产品，是进程间数据交互的关键区域 。</li><li><strong>访问函数（入口）定义</strong><ul><li>设计专门函数作为访问共享数据的 “入口” 。例如生产者 - 消费者场景中，有函数负责将产品放入缓冲区（生产者操作 ），还有函数用于从缓冲区取出产品（消费者操作 ）。</li><li><strong>严格规定仅能通过这些特定函数来访问共享数据</strong>，以此规范对共享资源的操作，避免混乱和错误访问。</li></ul></li><li><strong>互斥特性</strong><ul><li>管程虽存在多个 “入口”，但<strong>任一时刻仅开放一个</strong>，且<strong>只允许一个进程或线程进入访问共享数据</strong> 。以生产者 - 消费者问题为例，各进程对共享缓冲区的访问需互斥进行，防止数据竞争和不一致 。</li><li>值得强调的是，<strong>这种互斥机制由编译器实现</strong>，减轻了程序员的负担，使其无需手动编写复杂互斥代码 。</li></ul></li><li><strong>同步机制</strong><ul><li>引入条件变量，配合<strong>等待 / 唤醒操作</strong>处理同步问题 。当进程不满足执行条件（如缓冲区满生产者需等待，或缓冲区空消费者需等待 ）时，可在条件变量上等待 。此时，<strong>该进程释放管程使用权</strong>（让出 “入口” ），以便其他进程能访问管程内共享数据 。</li><li>当条件满足时（如缓冲区有空间生产者可生产，或缓冲区有产品消费者可消费 ），通过唤醒操作激活等待在条件变量上的进程或线程，使其继续执行 。</li></ul></li><li><strong>管程定义语法</strong>：程序员可借助特殊语法（如 <code>monitor ProducerConsumer …… end monitor;</code> ）来定义管程 。如此一来，其他程序员能直接利用该管程提供的 “入口”，便捷地实现进程同步与互斥，提升开发效率与代码可靠性 。【封装思想】</li></ol><h4 id="管程中设置的条件变量">管程中设置的条件变量</h4><ul><li><strong>定义</strong>：将一个进程进入管程后被阻塞的原因定义为<strong>条件变量 condition</strong></li><li>管程中设置了多个条件变量，每个条件变量保存了一个等待队列【记录因该条件变量而阻塞的所用进程】</li><li>两种操作：<ul><li><strong>x.wait</strong>：x 对应的条件不满足，将正在调用管程的进程插入到 x 条件的等待队列，并释放管程</li><li><strong>x.signal</strong>：唤醒一个因 x 条件而阻塞的进程</li></ul></li><li><strong>与信号量的相似点</strong>：<ul><li>wait/signal 类似于信号量的 P/V 操作，实现进程的阻塞/唤醒，但不能说和 PV 操作相同</li></ul></li><li><strong>与信号量的不同点</strong>：<ul><li>条件变量没有值，仅实现“排队等待”功能</li><li>信号量有值，这个值反映了剩余资源数</li><li>在管程中，剩余资源数用共享数据结构记录</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;</span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    condition x;                <span class="comment">//定义一个条件变量x</span></span><br><span class="line">    init_code()&#123;... &#125;</span><br><span class="line">    take_away()&#123;</span><br><span class="line">        <span class="keyword">if</span>(S&lt;=<span class="number">0</span>) x.wait();      <span class="comment">//资源不够，在条件变量x上阻塞等待</span></span><br><span class="line">        资源足够，分配资源，做一系列相应处理;</span><br><span class="line">    &#125;</span><br><span class="line">    give_back()&#123;</span><br><span class="line">        归还资源，做一系列相应处理;</span><br><span class="line">        <span class="keyword">if</span>(有进程在等待) x.signal();<span class="comment">//唤醒一个阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><h3 id="死锁的概念">死锁的概念</h3><ul><li><strong>死锁</strong>：指多个进程因为竞争资源而造成的一种僵局【互相等待对方手里的资源】</li><li><strong>死锁的充分条件</strong>：资源分配图中<strong>每种资源只有 1 个</strong>，出现了<strong>环路</strong></li><li><strong>死锁和饥饿的共同点</strong>：都是进程无法顺利向前推进的现象</li><li><strong>死锁和饥饿的不同点</strong>：<ul><li>发生饥饿的进程可以只有 1个；发生死锁的进程必然<strong>≥ 2 个</strong></li><li>发生<font color="#ff0000">饥饿</font>的进程能处于<strong>就绪态</strong>【长期得不到 CPU】，也可能处于<strong>阻塞态</strong>【长期得不到 I/O 设备】；发生<font color="#ff0000">死锁</font>的进程必然处于<strong>阻塞态</strong>【等待其他进程释放资源，而非等待 CPU】</li></ul></li></ul><h4 id="死锁-VS-饥饿-VS-死循环">死锁 VS 饥饿 VS 死循环</h4><p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）</p><table><thead><tr><th></th><th>概念</th><th>区别</th></tr></thead><tbody><tr><td><strong>死锁</strong></td><td>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</td><td>由循环等待对方资源导致，<strong>至少两个进程同时发生</strong>，进程处于<strong>阻塞态</strong>，是<strong>操作系统</strong>分配资源策略不合理问题</td></tr><tr><td><strong>饥饿</strong></td><td>由于长期得不到想要的资源，某进程无法向前推进的现象</td><td>可能<strong>单个进程发生</strong>，进程可能处于<strong>阻塞态或就绪态</strong> ，因长期得不到资源，是<strong>操作系统</strong>分配资源策略不合理问题</td></tr><tr><td><strong>死循环</strong></td><td>某进程执行过程中一直跳不出某个循环的现象</td><td>可能<strong>单个进程发生</strong>，进程可处于<strong>运行态</strong>，因代码逻辑错误导致，是<strong>被管理者</strong>（代码层面）问题</td></tr><tr><td>死锁和饥饿是操作系统要解决的问题，死循环是应用程序员要解决的</td><td></td><td></td></tr></tbody></table><h4 id="死锁产生的原因">死锁产生的原因</h4><ol><li><strong>系统资源的竞争</strong>【空间上】：<ul><li>系统中不可剥夺资源（磁带机、打印机等）不足以满足多个进程</li><li>只有对<strong>不可剥夺资源的竞争</strong>才可能产生死锁</li></ul></li><li><strong>进程推进顺序非法</strong>【时间上】：<ul><li><strong>请求和释放资源的不当</strong>，会导致死锁</li><li><strong>信号量使用不当</strong>，会导致死锁</li></ul></li></ol><h4 id="死锁产生的必要条件">死锁产生的必要条件</h4><p>产生死锁必须<strong>同时</strong>满足以下四个条件：</p><ul><li><strong>互斥条件</strong>【等别人用厕所】：<ul><li>只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）<ul><li>像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</li></ul></li></ul></li><li><strong>不可剥夺条件</strong>【等我用完，不可抢占】：<ul><li>进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放</li></ul></li><li><strong>请求并保持条件</strong>【哲学家就餐，拿着一根筷子不放，请求另一根筷子】：<ul><li>进程<strong>已经保持了至少一个资源</strong>，但又提出了<strong>新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己<strong>已有的资源保持不放</strong></li></ul></li><li><strong>循环等待条件</strong>【我等你，你等他，他等我】：<ul><li>存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求</li><li>发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</li><li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。<br>但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</li></ul></li></ul><h4 id="死锁的处理策略">死锁的处理策略</h4><ul><li><p><strong>死锁预防</strong>：破坏死锁产生的四个必要条件中的一个或几个</p><ul><li>提前设置规则，<strong>不让死锁发生</strong>，哪怕牺牲效率。</li><li>具体方法：<ul><li><strong>一次申请所有资源</strong>：进程必须一次性说出所有需要的资源（如打印机、内存），否则不给。</li><li><strong>资源剥夺</strong>：如果进程A占着打印机，进程B急需，直接抢走给B。</li><li><strong>按序分配资源</strong>：所有资源编号，<strong>进程必须按顺序申请</strong>（如先申请键盘再申请鼠标）。</li></ul></li><li><strong>优点</strong>：绝对安全，适合<strong>突发任务</strong>（如急救车优先通行）。</li><li><strong>缺点</strong>：<ul><li><strong>资源浪费</strong>：打印机空闲也不给别人用。</li><li><strong>不灵活</strong>：进程中途想申请新资源？不行！</li></ul></li></ul></li><li><p><strong>死锁避免</strong>：用某种方法防止系统进入不安全状态，从而避免死锁</p><ul><li>运行时<strong>动态</strong>判断分配资源是否会导致死锁，<strong>只允许安全的分配</strong>。</li><li>要避免死锁，需确保系统<strong>始终至少有一个进程能获得全部所需资源</strong>，从而执行完成后释放资源供其他进程使用。</li><li>具体方法：<ul><li><strong>银行家算法</strong>：系统模拟分配资源后是否所有进程都能完成，否则拒绝分配。<br><strong>系统剩余资源 ≥ 某个进程尚需资源的最大可能总和（其他进程已占用的资源）</strong></li><li><strong>安全序列</strong>：找出一条能让所有进程顺利完成的资源分配顺序。</li></ul></li><li>优点：<strong>不用抢资源</strong>（避免剥夺），平衡安全与效率。</li><li>缺点：</li><li>预知未来：必须提前知道进程需要多少资源（现实中难实现）。</li><li>不能等太久：进程申请资源时若被拒绝，可能<strong>一直阻塞</strong>。</li></ul></li><li><p><strong>死锁检测和解除</strong>：<strong>允许死锁的发生</strong>，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</p><ul><li>先随便分配资源，定期检查是否死锁，发生了再解决。</li><li>具体方法：<ul><li><strong>定期检测</strong>：系统画一张资源分配图，发现有环路（A等B，B等A）就是死锁。</li><li><strong>解除死锁</strong>：强行杀掉某个进程或剥夺资源（损失已计算到一半的数据）。</li></ul></li><li>优点：灵活高效：资源利用率高，适合<strong>交互式系</strong>统（如电脑桌面）。</li><li>缺点：善后麻烦：死锁后只能“砸锅卖铁”解决（如强制关闭程序）。</li></ul></li></ul><table><thead><tr><th>资源分配策略</th><th>各种可能模式</th><th>主要优点</th><th>主要缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>死锁<strong>预防</strong></td><td>保守，宁可资源闲置；<strong>一</strong>次请求所有资源，资源<strong>剥夺</strong>，资源按序分配</td><td>适用于<strong>突发式</strong>处理的进程，不必进行剥夺</td><td>效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td><td>实时系统（火箭控制）</td></tr><tr><td>死锁<strong>避免</strong></td><td>是 “预防” 和 “检测” 的折中（在运行时判断是否可能死锁）；寻找可能的安全允许顺序</td><td><strong>不必进行剥夺</strong></td><td>必须知道将来的资源需求；进程不能被长时间阻塞</td><td>长期运行的服务器</td></tr><tr><td>死锁<strong>检测</strong></td><td>宽松，只要允许就分配资源；定期检查死锁是否已经发生</td><td>不延长进程初始化时间，允许对死锁进行现场处理</td><td>通过剥夺解除死锁，造成损失</td><td>个人电脑、交互式系统</td></tr></tbody></table><table><thead><tr><th>处理思路</th><th>具体策略</th><th>相关要点</th></tr></thead><tbody><tr><td>不允许死锁发生</td><td><strong>静态</strong>策略：预防死锁</td><td>破坏互斥条件<br>破坏不剥夺条件<br>破坏请求和保持条件<br>破坏循环等待条件</td></tr><tr><td></td><td><strong>动态</strong>策略：避免死锁</td><td>1. 什么是安全序列  <br>2. 什么是系统的不安全状态，与死锁有何联系  <br>3. 如何避免系统进入不安全状态 —— 银行家算法</td></tr><tr><td>允许死锁发生</td><td>死锁的检测和解除</td><td>-</td></tr></tbody></table><p><strong>死锁预防</strong>是提前设置规则防止死锁，作用于<strong>整个系统</strong><br><strong>死锁避免</strong>是在运行时针对<strong>单个进程</strong>资源申请判断是否会导致死锁</p><p>预防死锁→避免死锁→检测死锁→解除死锁<br>防范强度（强→弱）<br>资源利用率（低→高）</p><h3 id="死锁预防">死锁预防</h3><p>请求保持：一次性、静态<br>循环等待：编号、按序申请、同类资源</p><ol><li><p><strong>破坏互斥条件</strong>：×</p><ul><li>不可行</li><li>有些资源（打印机等临界资源）根本不能同时访问</li><li>为了系统安全，很多时候必须保护这种互斥性</li><li>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。<br>比如：SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备</li></ul></li><li><p><strong>破坏不可剥夺条件</strong>：×</p><ul><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺</li><li><strong>缺点</strong>：<ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如 CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程<strong>饥饿</strong></li></ul></li><li>适用场景<ul><li><strong>易恢复的资源</strong>：如CPU（剥夺后只需保存寄存器状态）</li><li><strong>临时性资源</strong>：如内存缓冲区（数据可重建）</li></ul></li></ul></li><li><p><strong>破坏请求并保持条件</strong>：√<br>进程必须<strong>一次性申请所有资源</strong>，运行期间不再申请新资源。</p><ul><li>采用预先<strong>静态</strong>分配法：<ul><li>进程在运行前<strong>一次</strong>申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行</li><li>一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了</li></ul></li><li><strong>缺点</strong>：资源利用率低，可能导致饥饿，并发性下降，资源浪费严重</li><li>改进：允许进程<strong>只获得运行初期所需的资源</strong>后，便可<strong>开始运行</strong></li></ul></li><li><p><strong>破坏循环等待条件</strong>：√</p><ul><li>采用<strong>顺序资源分配法</strong>：<ul><li>首先给系统中的各类资源<strong>编号</strong>，进程必须按序申请（如键盘=1，鼠标=2，打印机=3）</li><li>同类资源（编号相同）一次申请完</li></ul></li><li>原理分析：<ul><li>进程必须先申请小编号资源，再申请大编号资源</li><li>若进程A持有资源3（打印机），它不能回头申请资源1（键盘），打破循环等待链</li></ul></li><li><strong>缺点</strong>：<ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ul></li></ul></li></ol><h3 id="死锁避免">死锁避免</h3><h4 id="系统安全状态">系统安全状态</h4><ul><li><strong>安全序列</strong>：<ul><li>指如果系统按照这种序列分配资源，则每个进程都能顺利完成</li><li><strong>只要能找出一个安全序列</strong>，系统就是<strong>安全状态</strong></li><li>安全序列可能有<strong>多个</strong></li><li>前提：采用动态资源分配策略</li></ul></li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>，这就意味着之后<strong>可能所有进程都无法顺利的执行</strong>下去【如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态】</li><li><strong>处于不安全状态未必发生死锁</strong></li><li><strong>发生死锁时一定是处于不安全状态</strong></li><li><strong>安全状态一定不会发生死锁</strong></li></ul><h4 id="银行家算法">银行家算法</h4><p>判断是否为不安全状态<br>表示出每个进程最多还需要多少资源，每个资源都还剩多少<br>在资源分配前先预先判断此次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求<br>措施：对每个进程的每次<mark>动态资源请求</mark>加设银行家算法，以决定是否满足该请求</p><h3 id="数据结构">数据结构</h3><ul><li>长度为 m 的一维数组 <strong>Available</strong>：表示<strong>还有多少可用资源</strong>。</li><li>n * m 矩阵 <strong>Max</strong>：表示各进程对资源的<strong>最大需求数</strong>。</li><li>n * m 矩阵 <strong>Allocation</strong>：表示已经给各进程<strong>分配了多少资源</strong>。</li><li><strong>Max - Allocation</strong> = <strong>Need</strong> 矩阵：表示各进程<strong>还需要多少资源</strong>。</li><li>长度为 m 的一位数组 <strong>Request</strong>：表示进程此次申请的各种资源数。</li><li>Work：系统可提供的资源数量（初始Work=Available，随后改变）</li><li>Finish：未完成false，完成了true</li></ul><h3 id="银行家算法步骤">银行家算法步骤</h3><ol><li>检查此次申请是否超过了之前声明的最大需求数。</li><li>检查此时系统剩余的可用资源是否还能满足这次请求。</li><li>试探着分配，更改各数据结构。</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态。</li></ol><h3 id="安全性算法步骤">安全性算法步骤</h3><p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。<br>eg1. <strong>某系统有 A、B、C、D 四类资源可供五个进程 P₁、P₂、P3、P4、P5 共享。系统对这四类资源的拥有量为：A 类 3 个、B 类 14 个、C 类 12 个、D 类 12 个。进程对资源的需求和分配情况如下</strong></p><table><thead><tr><th>进程</th><th>已占有资源</th><th>最大需求数</th></tr></thead><tbody><tr><td></td><td>A B C D</td><td>A B C D</td></tr><tr><td>P₁</td><td>0 0 1 2</td><td>0 0 1 2</td></tr><tr><td>P₂</td><td>1 0 0 0</td><td>1 7 5 0</td></tr><tr><td>P3</td><td>1 3 5 4</td><td>2 3 5 6</td></tr><tr><td>P4</td><td>0 6 3 2</td><td>0 6 5 2</td></tr><tr><td>P5</td><td>0 0 1 4</td><td>0 6 5 6</td></tr><tr><td><strong>(1) 现在系统中的各类资源还剩余多少？</strong></td><td></td><td></td></tr><tr><td><strong>(2) 现在系统是否处于安全状态？为什么？</strong></td><td></td><td></td></tr><tr><td><strong>(3) 如果现在进程 P₂ 提出需要 A 类资源 0 个、B 类资源 4 个、C 类资源 2 个和 D 类资源 0 个，系统能否去满足它的请求？请说明原因。</strong></td><td></td><td></td></tr></tbody></table><ol><li>计算系统中各类资源剩余量<br>A 类 1 个、B 类 5 个、C 类 2 个、D 类 0 个</li><li>判断系统是否处于安全状态</li></ol><table><thead><tr><th>进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+Allocation</th></tr></thead><tbody><tr><td>P₁</td><td>(1, 5, 2, 0)</td><td>(0, 0, 0, 0)</td><td>(0, 0, 1, 2)</td><td>(1, 5, 3, 2)</td></tr><tr><td>P4</td><td>(1, 5, 3, 2)</td><td>(0, 0, 2, 0)</td><td>(0, 6, 3, 2)</td><td>(1, 11, 6, 4)</td></tr><tr><td>P3</td><td>(1, 11, 6, 4)</td><td>(1, 0, 0, 2)</td><td>(1, 3, 5, 4)</td><td>(2, 14, 11, 8)</td></tr><tr><td>P5</td><td>(2, 14, 11, 8)</td><td>(0, 6, 4, 2)</td><td>(0, 0, 1, 4)</td><td>(2, 14, 12, 12)</td></tr><tr><td>P₂</td><td>(2, 14, 12, 12)</td><td>(0, 7, 5, 0)</td><td>(1, 0, 0, 0)</td><td>(3, 14, 12, 12)</td></tr><tr><td>处于安全状态，安全序列P₁ P4 P3 P5 P₂</td><td></td><td></td><td></td><td></td></tr></tbody></table><ol start="3"><li>判断能否满足 P₂ 的请求</li></ol><ul><li>P₂提出请求(0,4,2,0)</li><li>首先检查请求是否超过需求【<strong>Request ≤ Need</strong>】：P₂需求为(0,7,5,0) ，请求(0,4,2,0)未超过需求</li><li>再检查请求是否超过可用资源【<strong>Request ≤ Available</strong>】：当前可用资源为(1,5,2,0) ，请求(0,4,2,0)，可以分配</li><li>假设分配后，系统可用资源变为(1,1,0,0) ，P₂已占有资源变为(1,4,2,0) ，需求变为(0,3,3,0)</li></ul><table><thead><tr><th>进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+Allocation</th></tr></thead><tbody><tr><td>P₁</td><td>(1, 1, 0, 0)</td><td>(0, 0, 0, 0)</td><td>(0, 0, 1, 2)</td><td>(1, 1, 1, 2)</td></tr><tr><td>P4</td><td>(1, 1, 1, 2)</td><td>(0, 0, 2, 0)</td><td>(0, 6, 3, 2)</td><td>(1, 7, 4, 4)</td></tr><tr><td>P3</td><td>(1, 7, 4, 4)</td><td>(1, 0, 0, 2)</td><td>(1, 3, 5, 4)</td><td>(2, 10, 9, 8)</td></tr><tr><td>P5</td><td>(2, 10, 9, 8)</td><td>(0, 6, 4, 2)</td><td>(0, 0, 1, 4)</td><td>(2, 10, 10, 12)</td></tr><tr><td>P₂</td><td>(2, 10, 10, 12)</td><td>(0, 3, 3, 0)</td><td>(1, 0, 0, 0)</td><td>-</td></tr><tr><td>存在安全序列，所以系统能满足P₂的请求。</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>eg2. <strong>系统中有五个进程{P0, P₁, P₂, P3, P4}和三类资源{A, B, C}，资源数量分别为A类10个、B类5个、C类7个。T0时刻资源分配情况如下：</strong></p><table><thead><tr><th>进程名</th><th>Max</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td>P0</td><td>7 5 3</td><td>0 1 0</td><td>7 4 3</td><td>3 3 2</td></tr><tr><td>P₁</td><td>3 2 2</td><td>2 0 0</td><td>1 2 2</td><td></td></tr><tr><td>P₂</td><td>9 0 2</td><td>3 0 2</td><td>6 0 0</td><td></td></tr><tr><td>P3</td><td>2 2 2</td><td>2 1 1</td><td>0 1 1</td><td></td></tr><tr><td>P4</td><td>4 3 3</td><td>0 0 2</td><td>4 3 1</td><td></td></tr><tr><td>判断T0时刻的安全性，结果如下：</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>进程名</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+Allocation</th><th>finish</th></tr></thead><tbody><tr><td>P₁</td><td>3 3 2</td><td>1 2 2</td><td>2 0 0</td><td>5 3 2</td><td>true</td></tr><tr><td>P3</td><td>5 3 2</td><td>0 1 1</td><td>2 1 1</td><td>7 4 3</td><td>true</td></tr><tr><td>P0</td><td>7 4 3</td><td>7 4 3</td><td>0 1 0</td><td>7 5 3</td><td>true</td></tr><tr><td>P₂</td><td>7 5 3</td><td>6 0 0</td><td>3 0 2</td><td>10 5 5</td><td>true</td></tr><tr><td>P4</td><td>10 5 5</td><td>4 3 1</td><td>0 0 2</td><td>10 5 7</td><td>true</td></tr><tr><td>在T0时刻存在安全序列P₁、P3、P0、P₂、P4 ，系统处于安全状态。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>eg3. <strong>有 5 个进程{P0,P₁,P₂,P3,P4}和三类资源{A,B,C}，T0时刻资源分配情况如下：</strong></p><table><thead><tr><th>进程</th><th>Max（最大需求）</th><th>Allocation（已分配）</th><th>Available（可用资源）</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td>P0</td><td>7 5 3</td><td>0 1 0</td><td>3 3 2</td></tr><tr><td>P₁</td><td>3 2 2</td><td>2 0 0</td><td></td></tr><tr><td>P₂</td><td>9 0 2</td><td>3 0 2</td><td></td></tr><tr><td>P3</td><td>2 2 2</td><td>2 1 1</td><td></td></tr><tr><td>P4</td><td>4 3 3</td><td>0 0 2</td><td></td></tr><tr><td><strong>(1) T0时刻是否安全？若安全，则安全序列是什么？</strong></td><td></td><td></td><td></td></tr><tr><td><strong>(2) 若P₁请求资源Request​(1,0,2)，系统能否将资源分配给他？</strong></td><td></td><td></td><td></td></tr></tbody></table><p>(1) T0时刻安全性判断</p><table><thead><tr><th>进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+Allocation</th></tr></thead><tbody><tr><td>P₁</td><td>(3, 3, 2)</td><td>(1, 2, 2)</td><td>(2, 0, 0)</td><td>(5, 3, 2)</td></tr><tr><td>P3</td><td>(5, 3, 2)</td><td>(0, 1, 1)</td><td>(2, 1, 1)</td><td>(7, 4, 3)</td></tr><tr><td>P4</td><td>(7, 4, 3)</td><td>(4, 3, 1)</td><td>(0, 0, 2)</td><td>(7, 4, 5)</td></tr><tr><td>P₂</td><td>(7, 4, 5)</td><td>(6, 0, 0)</td><td>(3, 0, 2)</td><td>(10, 4, 7)</td></tr><tr><td>P0</td><td>(10, 4, 7)</td><td>(7, 4, 3)</td><td>(0, 1, 0)</td><td>(10, 5, 7)</td></tr><tr><td>依次找到可执行进程，最终得到安全序列为{P₁,P3,P4,P₂,P0} 。所以T0时刻系统是安全的。</td><td></td><td></td><td></td><td></td></tr><tr><td>(2) P₁请求资源处理</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+Allocation</th></tr></thead><tbody><tr><td>P₁</td><td>(2, 3, 0)</td><td>(0, 2, 0)</td><td>(3, 0, 2)</td><td>(5, 3, 2)</td></tr><tr><td>P3</td><td>(5, 3, 2)</td><td>(0, 1, 1)</td><td>(2, 1, 1)</td><td>(7, 4, 3)</td></tr><tr><td>P4</td><td>(7, 4, 3)</td><td>(4, 3, 1)</td><td>(0, 0, 2)</td><td>(7, 4, 5)</td></tr><tr><td>P₂</td><td>(7, 4, 5)</td><td>(7, 4, 3)</td><td>(3, 0, 2)</td><td>(10, 4, 7)</td></tr><tr><td>P0</td><td>(10, 4, 7)</td><td>(6, 0, 0)</td><td>(0, 1, 0)</td><td>(10, 5, 7)</td></tr><tr><td>系统是安全的，可以将P₁申请的资源分配给它 ，分配后的资源情况如下：</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>进程</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td></td><td>A B C</td><td>A B C</td><td>A B C</td></tr><tr><td>P0</td><td>0 1 0</td><td>7 4 3</td><td>2 3 0</td></tr><tr><td>P₁</td><td>3 0 2</td><td>0 2 0</td><td></td></tr><tr><td>P₂</td><td>3 0 2</td><td>6 0 0</td><td></td></tr><tr><td>P3</td><td>2 1 1</td><td>0 1 1</td><td></td></tr><tr><td>P4</td><td>0 0 2</td><td>4 3 1</td><td></td></tr></tbody></table><p>eg4. 已知资源分配情况如下表：</p><table><thead><tr><th>请求顺序</th><th>请求者</th><th>Max</th><th>Allocation</th><th>Need</th><th>可用资源</th></tr></thead><tbody><tr><td></td><td></td><td>1 2 3</td><td>1 2 3</td><td>1 2 3</td><td>1 2 3</td></tr><tr><td>1</td><td>P₁​</td><td>7 5 3</td><td>0 1 0</td><td>7 4 3</td><td>2 3 0</td></tr><tr><td>2</td><td>P₂​</td><td>3 2 2</td><td>3 0 2</td><td>0 2 0</td><td></td></tr><tr><td>3</td><td>P3​</td><td>9 0 2</td><td>3 0 2</td><td>6 0 0</td><td></td></tr><tr><td>4</td><td>P4​</td><td>2 2 2</td><td>2 1 1</td><td>0 1 1</td><td></td></tr><tr><td>5</td><td>P5​</td><td>4 3 3</td><td>0 0 2</td><td>4 3 1</td><td></td></tr><tr><td>此时，进程P5​发出请求向量Request5​(2,2,0)，能否满足？</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+Allocation</th></tr></thead><tbody><tr><td>P5​</td><td>(0, 1, 0)</td><td>(2, 1, 1)</td><td>(2, 2, 2)</td><td>(2, 3, 2)</td></tr><tr><td>P4​</td><td>(2, 3, 2)</td><td>(0, 1, 1)</td><td>(2, 1, 1)</td><td>(4, 4, 3)</td></tr><tr><td>P₂​</td><td>(4, 4, 3)</td><td>(0, 2, 0)</td><td>(3, 0, 2)</td><td>(7, 4, 5)</td></tr><tr><td>P₁​</td><td>(7, 4, 5)</td><td>(7, 4, 3)</td><td>(0, 1, 0)</td><td>(7, 5, 5)</td></tr><tr><td>P3​</td><td>(7, 5, 5)</td><td>(6, 0, 0)</td><td>(3, 0, 2)</td><td>(10, 5, 7)</td></tr></tbody></table><p>eg5. 某系统有n台互斥使用的同类设备，三个并发进程分别需要3、4、5台设备，可确保系统不发生死锁的设备数n最小为（ ）。A. 9B. 10C. 11D. 12</p><ul><li>每个进程都只差一台设备就能完成任务，此时资源分配如下：<ul><li>进程1：已占用 <code>2</code> 台（还需 <code>1</code> 台）。</li><li>进程2：已占用 <code>3</code> 台（还需 <code>1</code> 台）。</li><li>进程3：已占用 <code>4</code> 台（还需 <code>1</code> 台）。</li></ul></li><li>此时系统已分配设备总数：<code>2 + 3 + 4 = 9</code> 台。</li><li>避免死锁：剩余设备数必须能满足至少一个进程的需求（即至少 <code>1</code> 台）：<br>n−9≥1  ⟹  n≥10n−9≥1⟹n≥10</li><li>因此，<strong>最小 <code>n</code> 值为 10</strong>。<br>$n = \sum_{i = 1}^{k}(m_i - 1)+1$</li></ul><h3 id="死锁检测和解除">死锁检测和解除</h3><p>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施接触死锁<br>前两种方法是<mark>事前</mark>处理措施，最后一种是<mark>事后</mark><br>即假定死锁不可能在系统内发生而忽略死锁）</p><h4 id="死锁的检测">死锁的检测</h4><p>依次消除与不阻塞进程相连的边，直到无边可消<br>不阻塞进程指的是申请资源数还足够的进程</p><ul><li><strong>资源分配图</strong>：<strong>一个进程一个进程看，先分配，再满足进程的请求，进程可以满足就将该进程及相关的边删掉，继续讨论其他进程</strong><ul><li>圆圈代表进程，框表示一类资源</li><li>从进程到资源的有向边称为<strong>请求边</strong>【进程→资源】，表示该进程申请一个单位的该类资源</li><li>从资源到进程的有向边称为<strong>分配边</strong>【资源→进程】，表示该类资源已有一个资源分配给该进程<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240512150402.png" alt="image.png"></li></ul></li><li>简化资源分配图可检测系统状态是否为死锁：<ul><li>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi【即找出一条有向边与它相连，且该有向边对应<strong>资源的申请数量小于等于系统中已有空闲资源数量</strong>】</li><li>然后消去该进程所有请求边和分配边</li><li>若能消去图中所有的边，则该图<strong>可完全简化</strong></li></ul></li><li><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统<strong>死锁</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250527201707919.png" alt="2c22162f38599458966c7f18d1aa234.jpg"></li><li>若给p4分配了资源，p4就不会参与到死锁循环中，此时死锁进程为P₁、P₂、p3，共3个。</li><li>若没有给p4分配资源，p4也会处于等待资源状态，加入到循环等待链中，此时4个进程都处于死锁状态。</li></ul><h4 id="死锁的解除">死锁的解除</h4><ol><li><strong>资源剥夺法</strong>：挂起<strong>某些</strong>死锁进程，并抢占它的资源</li><li><strong>撤销进程法</strong>：强制撤销<strong>部分、甚至全部</strong>死锁进程并剥夺这些进程的资源</li><li><strong>进程回退法</strong>：让一个或多个进程回退到足以回避死锁的地步，进程回退时<strong>自愿释放资源而非剥夺</strong></li></ol><p><strong>决定解除操作对象的考量因素</strong>：</p><ol><li><strong>进程优先级</strong>：倾向选择<strong>优先级低</strong>的进程进行解除操作，这样对高优先级、更重要进程的正常运行影响相对较小，保障关键任务的执行。</li><li><strong>已执行时长</strong>：选择<strong>已执行时间短</strong>的进程。因其投入运行的时间不长，撤销或回退等操作造成的损失相对较小，避免中断已长时间运行、接近完成的进程。</li><li><strong>预计完成时间</strong>：挑选<strong>剩余预计完成时间短</strong>的进程。优先处理剩余工作量少的进程，可减少资源浪费和系统性能损失，避免长时间等待不必要的进程执行。</li><li><strong>已使用资源量</strong>：选择<strong>已使用资源量多</strong>的进程。此类进程占用资源多，解除其死锁能释放更多资源，利于其他进程运行，缓解资源紧张状况。</li><li><strong>进程交互或批处理属性</strong>：优先选择<strong>批处理</strong>进程。批处理进程通常无需实时交互，对其进行解除死锁操作，不易影响用户实时交互体验，且其相对独立，操作对系统整体影响较小。</li></ol><h1>错题</h1><ol><li><strong>下列关于进程的叙述中，正确的是()。<br>A.进程获得处理器运行是通过调度得到的<br>B.优先级是进程调度的重要依据，一旦确定就不能改动<br>C.在单处理器系统中，任何时刻都只有一个进程处于运行态<br>D.进程申请处理器而得不到满足时，其状态变为阻塞态</strong><br>B错在优先级分静态和动态两种，动态优先级是根据运行情况而随时调整的。C错在系统发生死锁时有可能进程全部都处于阻塞态，CPU空闲。D错在进程申请处理器得不到满足时就处于就绪态，等待处理器的调度。</li><li><strong>下列关于进程和程序的叙述中，错误的是()。<br>A.一个进程在其生命周期中可执行多个程序<br>B.一个进程在同一时刻可执行多个程序<br>C.一个程序的多次运行可形成多个不同的进程<br>D.一个程序的一次执行可产生多个进程</strong><br>A.在操作系统中，一个进程可以先执行初始化程序，然后再执行其他业务逻辑程序等 。B错误，一个进程在同一时刻只能执行一个程序。进程是程序的一次执行过程，它具有一定的独立性和并发性，但在同一时刻，一个进程只能专注于一个程序的执行，因为 CPU 在某一时刻只能执行一条指令流。如果要执行多个程序，需要通过进程切换等方式来实现，而不是在同一时刻同时执行多个程序。C.多次双击同一个应用程序图标（如浏览器程序 ），系统会为每次运行创建一个新的进程，这些进程虽然执行的是同一个程序，但它们各自拥有独立的运行环境、资源等，是不同的进程实例。D.一个程序的一次执行过程中，可能会因为程序内部的逻辑（如多线程编程中创建新线程进而可能产生新进程 ，或者调用系统函数创建子进程等 ）而产生多个进程。例如，在 Linux 系统中，一个父进程可以通过<code>fork()</code>函数创建子进程，即使父进程执行的是同一个程序，也会产生多个进程。</li><li><strong>在任何时刻，一个进程的状态变化()引起另一个进程的状态变化。<br>A. 必定   B.一定不   C.不一定   D.不可能</strong><br>一个进程的状态变化可能引起另一个进程的状态变化。例如，一个进程时间片用完，可能引起另一个就绪进程的运行。同时，一个进程的状态变化也可能不会引起另一个进程的状态变化。例如，一个进程由阻塞态转变为就绪态就不会引起其他进程的状态变化。C</li><li><strong>一个进程的基本状态可以从其他两种基本状态转变过去，这个基本的状态一定是()。<br>A.运行态   B.阻塞态   C.就绪态   D.终止态</strong><br>只有就绪态可以既由运行态转变过去又能由阻塞态转变过去。时间片到,运行态变为就绪态;当所需要资源到达时，进程由阻塞态转变为就绪态。</li><li><strong>在分时系统中，通常处于()的进程最多。<br>A.运行态   B.就绪态   C.阻塞态   D.终止态</strong><br>分时系统中处于就绪态的进程最多，这些进程都在争夺CPU 的使用权，而 CPU 的数量是有限的。处于运行态的进程只能有一个或少数几个。处于阻塞态的进程也不会太多，阻塞事件的发生频率不会太高。处于终止态的进程也不多，这些进程已释放资源，不再占用内存空间。</li><li><strong>并发进程失去封闭性，是指()。<br>A.多个相对独立的进程以各自的速度向前推进<br>B.并发进程的执行结果与速度无关<br>C.并发进程执行时，在不同时刻发生的错误<br>D.并发进程共享变量，其执行结果与速度有关</strong><br>程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响，即程序结果唯一确定，不受执行速度影响。失去封闭性后，因共享资源导致结果依赖执行顺序（速度），当多个进程共享变量时，由于执行速度差异导致最终结果不确定D</li><li><strong>若一个进程实体由 PCB、共享正文段、数据堆段和数据栈段组成，请指出下列 C 语言程序中的内容及相关数据结构各位于哪一段中。</strong><br><strong>I. 全局赋值变量</strong>                             <strong>II. 未赋值的局部变量</strong><br><strong>III. 函数调用实参传递值</strong>                <strong>IV. 用 malloc () 要求动态分配的存储区</strong><br><strong>V. 常量值（如 1995、“string”）</strong>   <strong>VI. 进程的优先级</strong><br><strong>A. PCB</strong>    <strong>B. 正文段</strong>    <strong>C. 堆段</strong>    <strong>D. 栈段</strong><br>I. 全局赋值变量：全局变量存放在静态存储区，在进程中属于数据段相关，这里应选 B。全局变量在程序运行期间一直存在，存储已初始化的值。<br>II. 未赋值的局部变量：局部变量在函数调用时在栈上分配空间，未赋值的局部变量也在栈段，选 D 。函数调用结束，其占用栈空间会被释放。<br>III. 函数调用实参传递值：函数调用时，实参传递值是在栈上进行压栈操作来传递数据的，位于栈段，选 D 。<br>IV. 用 malloc () 要求动态分配的存储区：<code>malloc()</code> 函数用于在堆上动态分配内存空间，所以选 C 。动态分配的内存生命周期由程序员手动管理，通过 <code>free()</code> 函数释放。<br>V. 常量值（如 1995、“string”）：常量值存放在正文段，正文段存放程序的代码和只读数据（常量 ），选 B 。<br>VI. 进程的优先级：进程的优先级是进程控制块（PCB）中的一个属性，用于进程调度等，选 A</li><li><strong>下面的叙述中，正确的是()。<br>A.引入线程后，处理器只能在线程间切换<br>B.引入线程后，处理器仍在进程间切换<br>C.线程的切换，不会引起进程的切换<br>D.线程的切换，可能引起进程的切换</strong><br>在同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换，因此选项 A、B、C 错误。</li><li><strong>下列选项中，()不是线程的优点<br>A.提高系统并发性   B.节约系统资源   C.便于进程通信   D.增强进程安全性</strong><br>线程的优点有提高系统并发性、节约系统资源、便于进程通信等，但线程并不能增强进程安全性，因为线程共享进程的地址空间和资源，若一个线程出错，则可能影响整个进程的运行。</li><li><strong>在下列描述中，()并不是多线程系统的特长。<br>A.利用线程并行地执行矩阵乘法运算<br><a href="http://B.Web">B.Web</a> 服务器利用线程响应 HTTP 请求<br>C.键盘驱动程序为每个正在运行的应用配备一个线程，用以响应该应用的键盘输入<br>D.基于 GUI的调试程序用不同的线程分别处理用户输入、计算和跟踪等操作</strong><br>整个系统只有一个键盘，而且键盘输入是人的操作，速度比较慢，完全可以使用一个线程来处理整个系统的键盘输入。</li><li><strong>()必会引起进程切换，<br>A.一个进程创建后，进入就绪态   B.一个进程从运行态变为就绪态<br>C.一个进程从阻塞态变为就绪态   D.以上答案都不对</strong><br>进程切换是指 CPU 调度不同的进程执行，当一个进程从运行态变为就绪态时，CPU 调度另一个进程执行，引起进程切换。</li><li><strong>进程处于( )时，它处于非阻塞态<br>A.等待从键盘输入数据                     B等待协作进程的一个信号<br>C.等待操作系统分配 CPU 时间   D.等待网络数据进入内存</strong><br>进程有三种基本状态，处于阻塞态的进程由于某个事件不满足而等待。这样的事件一般是 IO 操作，如键盘等，或是因互斥或同步数据引起的等待，如等待信号或等待进入互斥临界区代码段等，等待网络数据进入内存是为了进程同步。而等待CPU 调度的进程处于就绪态，只有它是非阻塞态。</li><li><strong>下面关于用户级线程和内核级线程的描述中，错误的是<br>A.采用轮转调度算法，进程中设置内核级线程和用户级线程的效果完全不同<br>B.跨进程的用户级线程调度也不需要内核参与，控制简单<br>C.用户级线程可以在任何操作系统中运行<br>D.若系统中只有用户级线程，则CPU的调度对象是进程</strong><br>A.轮转调度时，用户级线程以进程为调度单位，内核级线程以线程为调度单位，二者效果不同，该选项正确。<br>B.用户级线程调度单位是进程，跨进程调度需内核参与，此选项说不需要内核参与错误。<br>C.用户级线程由用户程序或函数库实现，不依赖操作系统，可在任何系统运行，该选项正确。<br>D.用户级线程对操作系统透明，CPU 调度对象是进程，该选项正确。</li><li><strong>在内核级线程相对于用户级线程的优点的如下描述中，错误的是()<br>A.同一进程内的线程切换，系统开销小<br>B.当内核线程阻塞时，CPU将调度同一进程中的其他内核线程执行<br>C.内核级线程的程序实体可以在内核态运行<br>D.对多处理器系统，核心可以同时调度同一进程的多个线程并行运行</strong><br>A：同一进程内的内核级线程切换需从用户态转内核态，系统开销大，此选项说开销小错误。<br>B：内核级线程调度以线程为单位，内核可在某线程阻塞时调度同进程其他线程执行，该选项正确。<br>C：内核级线程能在内核态执行系统调用子程序，可直接获内核服务，该选项正确。<br>D：多处理器系统中，内核可同时调度同一进程多个内核线程并行运行，该选项正确。</li><li><strong>下列关于用户级线程的优点的描述中，不正确的是()。<br>A.线程切换不需要切换到内核态<br>B.支持不同的应用程序采用不同的调度算法<br>C.在不同操作系统上不经修改就可直接运行<br>D.同一个进程内的多个线程可以同时调度到多个处理器上执行</strong><br>D用户级线程是不需要内核支持而在用户程序中实现的线程，不能利用多处理器的并行性，因为操作系统只能看到进程。其余说法均正确。</li><li><strong>下列选项中，可能导致用户级线程切换的事件是()<br>A.系统调用   B. I/O 请求   C.异常处理   D.线程同步</strong><br>本题可用排除法。用户级线程的切换是由应用程序自己控制的，不需要操作系统的干预，操作系统感受不到用户级线程的存在。因此，系统调用、IO请求和异常处理这些涉及内核态的事件都不会导致用户级线程切换，但会导致内核级线程切换。<br>线程同步是指多个线程之间协调执行顺序的机制，如互斥锁、信号量、条件变量等。当一个线程在等待同步条件时，应用程序可以选择切换到另一个就绪的用户级线程，以提高CPU的利用率。</li><li><strong>下列关于用户级线程的描述中，错误的是()。<br>A.用户级线程由线程库进行管理<br>B.用户级线程只有在创建和调度时需要内核的干预<br>C.操作系统无法直接调度用户级线程<br>D.线程库中线程的切换不会导致进程切换</strong><br>用户级线程不依赖于操作系统内核，而是由用户程序自己实现的，选项A正确。用户级线程的创建和调度都是在用户态下实现的，不需要切换到内核态，选项B错误。操作系统只能看到一个单线程进程，而不知道进程内部有多个用户级线程，选项C正确。线程库中线程的切换只涉及用户栈和寄存器等上下文的保存和恢复，不涉及内核栈和页表等内核上下文的切换,选项D正确。</li><li><strong>【2010统考真题】下列选项中，导致创建新进程的操作是()。<br>I.用户登录成功   II.启动程序执行   III.设备分配<br>A.仅I和II   B.仅II和III   C.仅I和III   D.I、II、III</strong><br>创建进程的原因主要有：①用户登录②高级调度③系统处理用户程序的请求④用户程序的应用请求。设备分配是通过在系统中设置相应的数据结构实现的，不需要创建进程，这是操作系统中I/O核心子系统的内容。C</li><li><strong>【2011统考真题】在支持多线程的系统中，进程P创建的若干线程不能共享的是( )。<br>A.进程P的代码段   B.进程P中打开的文件<br>C.进程P的全局变量   D.进程P中某线程的栈指针</strong><br>进程是资源分配的基本单位，线程是CPU 调度的基本单位。进程的代码段、进程打开的文件、进程的全局变量等都是进程的资源，唯有进程中某线程的栈指针(包含在线程 TCB 中)是属于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明。</li><li><strong>【2014 统考真题】一个进程的读磁盘操作完成后，操作系统针对该进程必做的是<br>A.修改进程状态为就绪态         B.降低进程优先级<br>C.给进程分配用户内存空间     D.增加进程时间片大小</strong><br>进程申请读磁盘操作时，因为要等待I/O操作完成，会把自身阻塞，此时进程变为阻塞态；IO 操作完成后，进程得到了想要的资源，会从阻塞态转换到就绪态（这是操作系统的行为）。而降低进程优先级、分配用户内存空间和增加进程的时间片大小都不一定会发生，选择 A。</li><li><strong>【2024 统考真题】下列选项中，操作系统在终止进程时不一定执行的是()<br>A.终止子进程   B.回收进程占用的设备<br>C.释放进程控制块   D.回收为进程分配的内存</strong><br>当操作系统终止进程时，所有的进程资源（如内存空间、进程控制块、设备、打开文件、I/O缓冲区等）都会被释放。有些系统不允许子进程在父进程已终止的情况下存在，对于这类系统，若一个进程终止，则它的所有子进程也终止，这种现象称为级联终止。但是，不是所有操作系统都是这么设计的，因此终止子进程不一定在终止进程时执行。</li><li><strong>【2024 统考真题】若进程P中的线程T先打开文件，得到文件描述符fd，再创建两个线程Ta和 Tb，则在下列资源中，Ta与Tb 可共享的是()。<br>I.进程P的地址空间   II.线程T的栈   III.文件描述符 fd<br>A. 仅I   B.仅I、III   C.仅II、III   D.I、II、III</strong><br>线程可理解为轻量级进程，仅拥有一点必不可少、能保证独立运行的资源。例如，在每个线程中都有一个用于控制线程运行的线程控制块(TCB)、用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。因此，线程T的栈空间是线程T所独有的，不会被线程Ta和Tb共享。多个线程共享所属进程所拥有的资源，进程P的线程可以访问进程P的全部地址空间和资源(如已打开的文件、定时器、信号量机构等)以及它申请到的 IO 设备等。综上所述，Ta 和 Tb 可共享的是进程P的地址空间和文件描述符。</li><li><strong>进程从创建态转换到就绪态的工作由()完成。<br>A.进程调度   B.中级调度   C.高级调度   D.低级调度</strong><br>高级调度（作业调度）从外存中的等待队列中选出一个或多个作业，创建对应进程，并把创建成功的进程插入到就绪队列中，进程从创建态变成就绪态。C</li><li><strong>下列哪些指标是调度算法设计时应该考虑的?<br>I.公平性   II.资源利用率   III.互斥性   IV.平均周转时间<br>A. I、II   B. I、II、IV   C.I、III、IV   D.全部都是</strong><br>可以量化的指标：资源利用率、周转时间、平均周转时间（带有“平均”的指标，都是用来描述算法的整体性能的）<br>不可以量化的指标：公平性、平衡性<br>B</li><li><strong>时间片轮转调度算法是为了<br>A.多个用户能及时干预系统               B.使系统变得高效<br>C.优先级较高的进程得到及时响应   D.需要 CPU 时间最少的进程最先做</strong><br>时间片轮转的主要目的是，使得多个交互的用户能够得到及时响应，使得每个用户以为“独占”计算机的使用，因此它并没有偏好，也不会对特殊进程做特殊服务。时间片轮转增加了系统开销，所以不会使得系统高效运转，吞吐量和周转时间均不如批处理。但其较快速的响应时间使得用户能够与计算机进行交互，改善了人机环境，满足用户需求。</li><li><strong>在某单处理器系统中，若此刻有多个就绪态进程，则下列叙述中错误的是()。<br>A.进程调度的目标是让进程轮流使用处理器<br>B.当一个进程运行结束后，会调度下一个就绪进程运行<br>C.上下文切换是进程调度的实现手段<br>D.处于临界区的进程在退出临界区前，无法被调度</strong><br>大多数情况下，调度和进程切换都会立即执行，但是在 中断处理过程中 和 原语执行过程中 ，需要等待对应事件结束后才能进行调度和切换。内核临界区不可以调度，普通临界区可以调度。</li><li><strong>在支持页式存储管理和多线程技术的系统中，当一个进程中的线程T1切换到同一个进程中的线程T2执行时，操作系统需要执行的操作是()。<br>I.更新程序计数器的值          II.更新栈基址寄存器的值<br>III.更新页基址寄存器的值    IV.更新进程打开文件表<br>A.全部   B. II、IV    C.I、II   D.I、III、IV</strong><br>不同进程切换，才需要切换页表，文件资源是共享的。每个线程的栈时独享的，选C</li><li><strong>支持多道程序设计的操作系统在运行过程中，不断地选择新进程运行来实现CPU 的共享，但其中()不是引起操作系统选择新进程的直接原因。<br>A.运行进程的时间片用完              B.运行进程出错<br>C.运行进程要等待某一事件发生   D.有新进程被创建进入就绪态</strong><br>发生进程调度的情况：<ol><li>创建一个新进程 2. 一个进程运行完毕 3. 一个进程由于I/O操作、信号量及其他某个原因被阻塞时 4. 进程时间片用尽 5. 可抢占优先级中，有优先级更高的进程进入就绪队列 6. I/O中断发生时<br>D</li></ol></li><li><strong>作业是用户提交的，进程是由系统自动生成的，除此之外，两者的区别是()。<br>A.两者执行不同的程序段<br>B.前者以用户任务为单位，后者以操作系统控制为单位<br>C.前者是批处理的，后者是分时的<br>D.后者是可并发执行，前者则不同</strong><br>作业是从用户角度出发的，它由用户提交，以用户任务为单位；进程是从操作系统出发的，由系统生成，是操作系统的资源分配和独立运行的基本单位。B</li><li><strong>系统采用多级反馈队列调度算法，系统中设置了三个不同优先级的队列 A、B 和 C，优先级 A &gt; B &gt; C，A 的时间片为 10ms，B 的时间片为 20ms，C 的时间片为 30ms。当 t = 0 时，进程 P₁到达，P₁所需的运行时间为 90ms；当 t = 30ms 时，进程 P₂到达，P₂所需的运行时间为 30ms，不考虑任何其他系统开销，进程 P₁的周转时间为（ ）A. 90ms    B. 100ms    C. 110ms    D. 120ms</strong><br>新进程总是先进入第一级队列的队尾。在 0~10ms 时段，P₁在队列 A 上运行；在 10~30ms 时段，P₁在队列 B 上运行；当 t = 30ms 时，P₂进入队列 A，因此在 30~40ms 时段，P₂在队列 A 上运行；在 40~60ms 时段，P₂在队列 B 上运行，此时 P₂运行结束；最后 P₁在 60~90ms 和 90~120ms 时段内，于队列 C 上运行 2 个时间片，因此 P₁的总周转时间为 120ms。</li><li><strong>【2010统考真题】下列选项中，降低进程优先级的合理时机是()<br>A.进程时间片用完              B.进程刚完成 I/O 操作，进入就绪队列<br>C.进程长期处于就绪队列   D.进程从就绪态转为运行态</strong><br>选项 A 中进程时间片用完，可降低其优先级以让其他进程被调度进入执行状态。选项B中进程刚完成 I/O，进入就绪队列等待被 CPU 调度，为了让其尽快处理 I/O 结果，因此应提高优先级。选项C中进程长期处于就绪队列，为不至于产生饥饿现象，也应适当提高优先级。选项D中进程的优先级不应该在此时降低，而应在时间片用完后再降低。</li><li><strong>【2012 统考真题】一个多道批处理系统中仅有P₁和P₂两个作业，P₂比P₁晚5ms到达，它的计算和I/O操作顺序如下：<br>P₁：计算60ms，I/O 80ms，计算20ms<br>P₂：计算120ms，I/O 40ms，计算40ms<br>若不考虑调度和切换时间，则完成两个作业需要的时间最少是（ ）。<br>A. 240ms   B. 260ms   C. 340ms   D. 360ms</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250512210703046.png" alt="image.png|500">B</li><li><strong>【2016 统考真题】某单 CPU 系统中有输入和输出设备各 1 台，现有 3 个并发执行的作业，每个作业的输入、计算和输出时间均分别为 2ms、3ms 和 4ms，且都按输入、计算和输出的顺序执行，则执行完 3 个作业需要的时间最少是（ ）。<br>A. 15ms    B. 17ms    C. 22ms    D. 27ms</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250512211604184.png" alt="image.png|500">B</li><li>**【2018 统考真题】某系统采用基于优先权的非抢占式进程调度策略，完成一次进程调度和进程切换的系统时间开销为1μs。在T时刻就绪队列中有3个进程P₁​、P₂​和P3​，<br>进程P₁：在就绪队列中的等待时间为30\mu s ，需要的CPU时间为12\mu s ，优先权为10。<br>进程P₂：在就绪队列中的等待时间为15\mu s ，需要的CPU时间为24\mu s ，优先权为30。<br>进程P_3：在就绪队列中的等待时间为18\mu s ，需要的CPU时间为36\mu s ，优先权为20。<br><strong>若优先权值大的进程优先获得CPU，从T时刻起系统开始进程调度，则系统的平均周转时间为（ ）。</strong><br><strong>A. 54μs</strong>    <strong>B. 73μs</strong>    <strong>C. 74μs</strong>    <strong>D. 75μs</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250512212758232.png" alt="image.png"></li><li><strong>【2019 统考真题】系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10ms；就绪队列Q2采用短进程优先调度算法；系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1，Q2为空，系统依次创建进程P₁，P₂后即开始进程调度，P₁，P₂需要的CPU时间分别为30ms和20ms，则进程P₁，P₂在系统中的平均等待时间为<br>A. 25ms    B. 20ms    C. 15ms    D. 10ms</strong><br>开始调度时，先调度Q1中的进程，P₁先获得时间片，P₁执行10ms（一个时间片）后，还需30 - 10 = 20ms ，此时P₁转入Q2 。<br>接着调度P₂，P₂执行10ms（一个时间片）后，还需20 - 10 = 10ms ，此时P₂也转入Q2 。<br>此时Q1为空，开始调度Q2中的进程。在Q2中采用短进程优先调度算法，P₂剩余10ms ，P₁剩余20ms ，所以先调度P₂执行剩余的10ms ，P₂完成。<br>最后调度P₁执行剩余的20ms ，P₁完成。<br><strong>P₁的等待时间</strong>： P₁在Q1中执行10ms ，这期间P₂等待10ms ，然后P₂在Q1中执行10ms ，此时P₁在Q2中等待10ms ，接着P₂在Q2中执行10ms ，P₁又等待10ms ，所以P₁的等待时间为10 + 10 = 20ms 。<br><strong>P₂的等待时间</strong>： P₂在Q1中等待P₁执行10ms ，所以P₂的等待时间为10ms 。平均等待时间 =$\frac{20 + 10}{2}=\frac{30}{2}=15ms$</li><li><strong>【2021统考真题】在下列内核的数据结构或程序中，分时系统实现时间片轮转调度需要使用的是( )。<br>I.进程控制块  II.时钟中断处理程序  III.进程就绪队列  IV.进程阻塞队列<br>A.仅II、III   B.仅I、IV   C.仅I、II、III   D.仅I、II、IV</strong><br>该算法下，处理器使用时间被划分成一个个时间片，公平地分给每一个等待处理器资源的就绪进程。<br>时钟中断发生时，系统会修改当前进程在时间片内的剩余时间，当一个进程分配的时间片耗尽后，它会重新进入就绪队列等待下一次分配时间片。<br>该算法可用于分时操作系统中的进程调度。系统会将所有就绪进程按照 FCFS（先来先服务）算法来维护就绪队列，每个时间片结束时操作系统都会结束当前进程，并调度下一个就绪程序运行。<br>在这种策略下，每个进程都能公平地使用处理器资源，也保证了进程的响应时间。<br>不需要阻塞队列，因为此时从运行态到就绪态的转换，er而不是运行态到阻塞态的转换，阻塞态是用来存放那些因为等待某个事件（如 I/O 操作完成等）而被阻塞的进程。时间片轮转调度主要关注的是就绪进程获取 CPU 的调度方式，与处于阻塞状态的进程并无直接关联，所以进程阻塞队列不是实现时间片轮转调度所必需的 。<br>C</li><li><strong>【2024 统考真题】假设某系统使用时间片轮转调度算法进行 CPU 调度，时间片大小为5ms,系统共有 10个进程，初始时均处于就绪队列,执行结束前仅处于执行态或就绪态。若队尾的进程P所需的CPU 时间最短，时间为25ms，不考虑系统开销，则进程P的周转时间为()。<br>A.200ms   B. 205ms   C.250ms   D.295ms</strong><br>翻译：一共十个进程，初始都在就绪队列中排队，每个进程每次最多运行5ms，进程P排在队尾，需要25ms的CPU时间才能完成任务，计算进程P从开始到结束的总时间<br>每一轮调度，10个进程各执行一个时间片（5ms），一轮下来共花费$10\times5 = 50ms$。进程P所需的 CPU 时间为25ms，则进程P需要完整执行$25\div5 = 5$个时间片才能结束。5轮 × 50ms/轮 = 250ms</li><li><strong>一个正在访问临界资源的进程由于申请等待I/O操作而被中断时，它()。<br>A.允许其他进程进入与该进程相关的临界区<br>B.不允许其他进程进入任何临界区<br>C.允许其他进程抢占处理器，但不得进入该进程的临界区<br>D.不允许任何进程抢占处理器</strong><br>进程进入临界区必须满足互斥条件，当进程进入临界区但尚未离开时就被迫进入阻塞是可以的，系统中经常出现这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的临界区，就应允许其运行，即分配CPU。该进程所锁定的临界区是不允许其他进程访问的，其他进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交给它。所以正确答案为选项C。</li><li><strong>两个旅行社甲和乙为旅客到某航空公司订飞机票，形成互斥资源的是()。<br>A.旅行社   B.航空公司   C.飞机票   D.旅行社与航空公司</strong><br>一张飞机票不能售给不同的旅客，因此飞机票是互斥资源，其他因素只是为完成飞机票订票的中间过程，与互斥资源无关。</li><li><strong>在操作系统中，要对并发进程进行同步的原因是()。<br>A.进程必须在有限的时间内完成   B.进程具有动态性<br>C.并发进程是异步的                      D.进程具有结构性</strong><br>同步是指为了完成某项任务而建立的多个进程的相互合作关系，由于并发进程的执行是异步的（按各自独立的、不可预知的速度向前推进），需要保证进程之间操作的先后次序的约束。例读进程和写进程对同一段缓冲区的读和写就需要进行同步，以保证正确的执行顺序。</li><li><strong>在操作系统中，PV操作是一种()。</strong><br><strong>A.机器指令   B.系统调用命令   C.作业控制命令   D.低级进程通信原语</strong><br>P、V操作是一种低级的进程通信原语，它是不能被中断的。</li><li><strong>可以被多个进程在任意时刻共享的代码必须是()。<br>A.顺序代码   B.机器语言代码   C.不允许任何修改的代码   D.无转移指令代码</strong><br>若代码可被多个进程在任意时刻共享，则要求任意一个进程在调用此段代码时都以同样的方式运行:而且进程在运行过程中被中断后再继续执行，其执行结果不受影响。这必然要求代码不能被任何进程修改，否则无法满足共享的要求。这样的代码就是<strong>可重入代码</strong>，也称纯代码，即允许多个进程同时访问的代码。</li><li><strong>下列关于互斥锁的说法中，正确的是()。<br>A.互斥锁只能用于多线程之间，不能用于多进程之间<br>B.互斥锁只能用于多进程之间，不能用于多线程之间<br>C.互斥锁可用于多线程或多进程之间，但只能由创建它的线程或进程来加锁和解锁<br>D.斥锁可用于多线程或多进程之间，但只能由对它加锁的线程或进程来解锁</strong><br>互斥锁可用于多线程或多进程之间，但只有对它加锁的线程或进程才能解锁它。若一个线程或进程试图解锁一个不属于它(加锁)的互斥锁，则返回错误码。D</li><li><strong>在使用互斥锁进行同步互斥时，下列()情况会导致死锁<br>A.一个线程对同一个互斥锁连续加锁两次<br>B.一个线程尝试对一个已加锁的互斥锁再次加锁<br>C.两个线程分别对两个不同的互斥锁先后加锁，但顺序相反<br>D.一个线程对一个互斥锁加锁后忘记解锁</strong><br>死锁是多个线程之间的，D错。若两个线程分别对两个不同的互斥锁先后加锁，但顺序相反，则可能导致死锁，这是典型的循环等待现象。例如，线程1先对互斥锁A 加锁，然后尝试对互斥锁B加锁;同时，线程2先对B加锁，然后尝试对A加锁，两个线程都在等待对方释放资源，从而无法继续推进。</li><li><strong>用来实现进程同步与互斥的 PV 操作实际上是由( )过程组成的。<br>A.一个可被中断的   B.一个不可被中断的   C.两个可被中断的   D.两个不可被中断的</strong><br>D</li><li><strong>一个系统中共有5个并发进程涉及某个相同的变量 A，变量 A的相关临界区是由（）个临界区构成的。1/3/5/6</strong><br>这里的临界区是指访问临界资源A的那段代码(临界区的定义)。那么5个并发进程共有5个操作共享变量 A 的代码段。</li><li><strong>下列关于临界区和临界资源的说法中，正确的是()<br>I.银行家算法可以用来解决临界区(Critical Section)问题<br>II.临界区是指进程中用于实现进程互斥的那段代码<br>III.公用队列属于临界资源<br>IV.私用数据属于临界资源<br>A. I、II   B.I、IV   C.仅III   D.以上答案都错误</strong><br>银行家算法用于避免死锁，并非解决临界区问题，说法 I 错误。<br>临界区是进程中访问临界资源的代码段，不是实现进程互斥的代码，说法 II 错误。<br>公用队列可被多个进程访问操作，属于临界资源，说法 III 正确。<br>私用数据为进程私有，无竞争访问情况，不属于临界资源，说法 IV 错误。</li><li>**两个进程P0、P₁互斥的 Peterson 算法描述如下：<br>进程P0：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[0]=1;</span><br><span class="line">(1);</span><br><span class="line">while(flag[1]&amp;&amp;turn==1);</span><br><span class="line">临界区;</span><br><span class="line">flag[0]=0;</span><br><span class="line">其余代码;</span><br></pre></td></tr></table></figure>进程P₁：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[1]=1;</span><br><span class="line">(2);</span><br><span class="line">while(flag[0]&amp;&amp;turn==0);</span><br><span class="line">临界区;</span><br><span class="line">flag[1]=0;</span><br><span class="line">其余代码;</span><br></pre></td></tr></table></figure>其中，(1) 和 (2) 处的代码分别为（ ）。<br>A. turn = 0，turn = 0 B. turn = 0，turn = 1 C. turn = 1，turn = 0 D. turn = 1，turn = 1**<br>C</li><li><strong>在 Peterson 算法中，flag 数组的作用是（ ）。</strong><br><strong>A. 表示每个线程是否想进入临界区</strong><br><strong>B. 表示每个线程是否已进入临界区</strong><br><strong>C. 表示每个线程是否已退出临界区</strong><br><strong>D. 表示每个线程是否已完成任务</strong><br>A</li><li><strong>在 Peterson 算法中，turn 变量的作用是（ ）。</strong><br><strong>A. 表示轮到哪个线程进入临界区</strong><br><strong>B. 表示哪个线程先发出访问请求</strong><br><strong>C. 表示哪个线程后发出访问请求</strong><br><strong>D. 表示哪个线程已进入临界区</strong><br>A</li><li><strong>在 9 个生产者、6 个消费者共享容量为 8 的缓冲区的生产者 - 消费者问题中，互斥使用缓冲区的信号量初始值为（ ）。<br>A. 1  B. 6  C. 8  D. 9</strong><br>A。所谓互斥使用某临界资源，是指在同一时间段只允许一个进程使用此资源，所以互斥信号量的初值都为1。</li><li><strong>消费者进程阻塞在 wait (m)（m 是互斥信号量）的条件是（ ）。<br>I. 没有空缓冲区<br>II. 没有满缓冲区<br>III. 有其他生产者已进入临界区<br>IV. 有其他消费者已进入临界区<br>A. I 和 II      B. III 和 IV      C. I 和 III      D. II 和 IV</strong><br>B。在生产者-消费者问题中，每次只能有一个生产者或消费者进入缓冲区，需要用一个互斥信号量来控制，当有一个生产者或消费者进入缓冲区时，其他申请进入缓冲区的消费者会被阻塞。</li><li>**哲学家就餐问题的解决方案如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore *chopstick[5];</span><br><span class="line">semaphore *seat;</span><br><span class="line">哲学家i:</span><br><span class="line">...</span><br><span class="line">P(seat);</span><br><span class="line">P(chopStick[i]);</span><br><span class="line">P(chopStick[(i+1)%5]);</span><br><span class="line">吃饭</span><br><span class="line">V(chopStick[i]);</span><br><span class="line">V(chopStick[(i+1)%5]);</span><br><span class="line">V(seat)</span><br></pre></td></tr></table></figure>其中，信号量 seat 的初始值为（ ）。  A. 0  B. 1  C. 4  D. 5**<br>seat限制同时就餐的哲学家数量，从而打破死锁的必要条件<br>当 seat 的初始值为 4 时，最多允许 4 个哲学家同时坐下<br>由于只有 5 根筷子，4 个哲学家最多占用 4 根筷子，必然有 1 根筷子未被占用<br>因此，第 5 个哲学家无法坐下，避免了所有哲学家同时持有一根筷子的情况，从而防止死锁<br>seat可以等1，但是仅允许 1 个哲学家就餐，效率过低</li><li><strong>【2010 统考真题】设与某资源关联的信号量初值为 3，当前值为 1。若 M 表示该资源的可用个数，N 表示等待该资源的进程数，则 M、N 分别是（ ）。<br>A. 0,1  B. 1,0  C. 1,2  D. 2,0</strong><br>B</li><li><strong>共享变量定义及初值：</strong><br><strong><code>boolean flag[2];</code></strong><br><strong><code>int turn = 0;</code></strong><br><strong><code>flag[0]=false; flag[1]=false;</code></strong><br><strong>进程P0：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">  turn = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (flag[<span class="number">1</span>]&amp;&amp;(turn == <span class="number">1</span>));</span><br><span class="line">  临界区;</span><br><span class="line">  flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><strong>进程P₁：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> P₁() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">  turn = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (flag[<span class="number">0</span>]&amp;&amp;(turn == <span class="number">0</span>));</span><br><span class="line">  临界区;</span><br><span class="line">    flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><strong>并发执行进程P0和进程P₁时产生的情况是（ ）。</strong><br><strong>A. 不能保证进程互斥进入临界区，会出现 “饥饿” 现象</strong><br><strong>B. 不能保证进程互斥进入临界区，不会出现 “饥饿” 现象</strong><br><strong>C. 能保证进程互斥进入临界区，会出现 “饥饿” 现象</strong><br><strong>D. 能保证进程互斥进入临界区，不会出现 “饥饿” 现象</strong><br>这是Peterson算法的实际实现，保证进入临界区的进程合理安全。<br><strong>互斥性</strong>：通过flag数组和turn变量的组合确保互斥。当进程 P0 设置<code>flag[0]=true</code>并将turn设为 1 后，若 P₁ 也想进入临界区，会将turn设为 0。此时：<br>若 P0 先进入循环检查，发现<code>flag[1]=true</code>且turn=0，则等待；<br>若 P₁ 先进入循环检查，发现<code>flag[0]=true</code>且turn=0，则 P0 会被允许进入。<br>因此，两个进程无法同时进入临界区，互斥性成立。<br><strong>无饥饿性</strong>：若 P0 先访问临界区，P₁ 卡在<code>while(flag[0]&amp;&amp;turn==0)</code>时，进程 P₁ 无法再修改<code>flag[1]</code>以及<code>turn</code>的值，这就意味着他在表达自身想使用临界资源的基础上，又无法做到把资源让给进程 P0，因此一定会轮到 P₁ 执行</li><li><strong>有两个并发执行的进程P₁和P₂，共享初值为1的变量x 。<br>P₁对x执行加1操作（指令序列为load R₁,x；inc R₁；store x,R₁ ）<br>P₂对x执行减1操作（指令序列为load R₂,x；dec R₂；store x,R₂ ）<br>需要分析两个操作完成后x的值。</strong><br>情况一：P₁先完整执行，再执行P₂<br>P₁执行：load R₁,x(R₁ = 1），inc R₁(R₁ = 2），store x,R₁(x = 2）；<br>P₂执行：load R₂,x(R₂ = 2），dec R₂(R₂ = 1），store x,R₂(x = 1）。<br>情况二：P₂先完整执行，再执行P₁<br>P₂执行：load R₂,x(R₂ = 1），dec R₂(R₂ = 0），store x,R₂(x = 0）；<br>P₁执行：load R₁,x(R₁ = 0），inc R₁(R₁ = 1），store x,R₁(x = 1）。<br>情况三：P₁和P₂交叉执行<br>假设P₁执行load R₁,x(R₁ = 1），然后P₂执行load R₂,x(R₂ = 1），接着P₁执行inc R₁(R₁ = 2），P₂执行dec R₂(R₂ = 0），之后P₂执行store x,R₂(x = 0），最后P₁执行store x,R₁(x = 2）。<br>假设P₁执行load R₁,x(R₁ = 1），然后P₂执行load R₂,x(R₂ = 1），接着P₂执行dec R₂(R₂ = 0），P₁执行inc R₁(R₁ = 2），之后P₁执行store x,R₁(x = 2），最后P₂执行store x,R₂(x = 0）。<br>假设P₂执行load R₂,x(R₂ = 1），然后P₁执行load R₁,x(R₁ = 1），接着P₂执行dec R₂(R₂ = 0），P₁执行inc R₁(R₁ = 2），之后P₁执行store x,R₁(x = 2），最后P₂执行store x,R₂(x = 0）。<br>假设P₂执行load R₂,x(R₂ = 1），然后P₁执行load R₁,x(R₁ = 1），接着P₁执行inc R₁(R₁ = 2），P₂执行dec R₂(R₂ = 0），之后P₂执行store x,R₂(x = 0），最后P₁执行store x,R₁(x = 2）。<br>C。</li><li><strong>【2016 统考真题】进程P₁和P₂均包含并发执行的线程，部分伪代码描述如下所示。</strong><br><strong>进程P₁：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x=1;</span><br><span class="line">Thread1() &#123;</span><br><span class="line"> int a;</span><br><span class="line"> a=1; x += 1;</span><br><span class="line">&#125;</span><br><span class="line">Thread2() &#123;</span><br><span class="line"> int a;</span><br><span class="line"> a=2; x += 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>进程P₂：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x=3;</span><br><span class="line">Thread3() &#123;</span><br><span class="line"> int a;</span><br><span class="line"> a=x; x += 3;</span><br><span class="line">&#125;</span><br><span class="line">Thread4() &#123;</span><br><span class="line"> int b;</span><br><span class="line"> b=x; x += 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>下列选项中，需要互斥执行的操作是（ ）。 A. a = 1与a = 2 B. a = x与b = x C. x += 1与x += 2 D. x += 1与x += 3</strong><br>C。需要进行互斥的操作是对临界资源的访问，也就是不同线程对同一个进程内部的共享变量的访问才有可能需要进行互斥。选项 A 中a是线程内部的局部变量，不需要互斥访问；选项 D 是不同进程的线程代码段，不存在互斥访问的问题。就像两本书，不同书之间的修改操作不会相互干扰，所以不存在互斥访问的问题 。；选项 B 是对进程内部的共享变量x的读操作，不互斥也不影响执行结果，所以不需要互斥访问，但是可能需要同步操作；选项 C 是不同线程对同一个进程内部的共享变量的写操作，需要互斥访问（类似于读者 - 写者问题），同时，也需要考虑同步。这类似于多个写者同时修改一本书的内容，会导致内容混乱，所以需要互斥执行，以保证x的值能正确更新 。</li><li>**【2016 统考真题】使用 TSL（Test and Set Lock）指令实现进程互斥的伪代码如下所示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"> ...</span><br><span class="line"> while(TSL(&amp;lock));</span><br><span class="line"> critical section;</span><br><span class="line"> lock=FALSE;</span><br><span class="line"> ...</span><br><span class="line">&#125; while(TRUE);</span><br></pre></td></tr></table></figure>下列与该实现机制相关的叙述中，正确的是（ ）。<br>A. 退出临界区的进程负责唤醒阻塞态进程<br>B. 等待进入临界区的进程不会主动放弃 CPU<br>C. 上述伪代码满足 “让权等待” 的同步准则<br>D. <code>while(TSL(&amp;lock))</code>语句应在关中断状态下执行**<br>选项 A：退出临界区的进程负责唤醒阻塞态进程<br>错误。在 TSL 实现中，没有显式的 “阻塞 - 唤醒” 机制。等待进入临界区的进程通过忙等待（spin-waiting）方式循环检查锁变量，而非进入阻塞状态。因此，退出临界区的进程只需将锁变量置为 0（解锁），无需唤醒任何进程。<br>选项 B：等待进入临界区的进程不会主动放弃 CPU<br>正确。当进程执行while(TSL(&amp;lock))时，若锁已被占用（TSL 返回 1），进程会持续执行该循环（忙等待），不会主动放弃 CPU。只有当时间片用完时，操作系统才会强制剥夺 CPU，将进程转为就绪态。<br>选项 C：上述伪代码满足 “让权等待” 的同步准则<br>错误。“让权等待” 指当进程无法进入临界区时，应释放 CPU 资源，避免忙等待。但 TSL 实现中，进程在锁被占用时会持续占用 CPU 循环检查，导致 CPU 资源浪费，因此不满足 “让权等待” 原则。<br>选项 D：while(TSL(&amp;lock))语句应在关中断状态下执行<br>错误。TSL 指令本身是原子操作，通过硬件机制（如锁住内存总线）确保其执行过程不被中断，无需额外关中断。若在关中断状态下执行循环，且锁长期被占用，可能导致系统无法响应中断（如时钟中断），引发系统崩溃。</li><li><strong>【2018 统考真题】属于同一进程的两个线程 thread1 和 thread2 并发执行，共享初值为 0 的全局变量 x。thread1 和 thread2 实现对全局变量 x 加 1 的机器级代码描述如下。</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Thread1</span><br><span class="line">①mov R₁, x    # 加载x到寄存器R₁</span><br><span class="line">②inc R₁       # R₁加1</span><br><span class="line">③mov x, R₁    # 将R₁的值存回x</span><br><span class="line"></span><br><span class="line"># Thread2</span><br><span class="line">④mov R₂, x    # 加载x到寄存器R₂</span><br><span class="line">⑤inc R₂       # R₂加1</span><br><span class="line">⑥mov x, R₂    # 将R₂的值存回x</span><br></pre></td></tr></table></figure><strong>在所有可能的指令执行序列中，使 x 的值为 2 的序列个数是（ ）。</strong><br><strong>A. 1</strong><br><strong>B. 2</strong><br><strong>C. 3</strong><br><strong>D. 4</strong><br>T1 完整执行后 T2 完整执行：<br>① → ② → ③ → ④ → ⑤ → ⑥<br>T2 完整执行后 T1 完整执行：<br>④ → ⑤ → ⑥ → ① → ② → ③<br>T1 的③（写回）必须在 T2 的④（加载）之前，或T2 的⑥（写回）必须在 T1 的①（加载）之前。否则会导致覆盖写（如 T1 和 T2 都基于 x=0 执行加 1，最终 x=1）。B</li><li>**【2018 统考真题】在下列同步机制中，可以实现让权等待的是（ ）。<br>A. Peterson 方法<br>B. swap 指令<br>C. 信号量方法<br>D. TestAndSet 指令<br>C</li><li><strong>【2020 统考真题】下列准则中，实现临界区互斥机制必须遵循的是（ ）。<br>I. 两个进程不能同时进入临界区<br>II. 允许进程访问空闲的临界资源<br>III. 进程等待进入临界区的时间是有限的<br>IV. 不能进入临界区的执行态进程立即放弃 CPU<br>A. 仅 I、IV<br>B. 仅 II、III<br>C. 仅 I、II、III<br>D. 仅 I、III、IV</strong><br>让全等待不是必须满足的，C<br>I.忙则等待 II.空闲让进 III.有限等待</li><li><strong>在哲学家进餐问题中，若所有哲学家同时拿起左筷子，则发生死锁，因为他们都需要右筷子才能用餐。为了让尽可能多的哲学家可以同时用餐，并且不发生死锁，可以利用信号量 PV 操作实现同步互斥，下列说法中正确的是（ ）。</strong><br><strong>A. 使用信号量进行控制的方法一定可以避免死锁</strong><br><strong>B. 同时检查两支筷子是否可用的方法可以预防死锁，但是会导致饥饿问题</strong><br><strong>C. 限制允许拿起筷子的哲学家数量可以预防死锁，它破坏了 “循环等待” 条件</strong><br><strong>D. 对哲学家顺序编号，奇数号哲学家先拿左筷子，然后拿右筷子，而偶数号哲学家刚好相反，可以预防死锁，它破坏了 “互斥” 条件</strong><br>A错，信号量机制虽能确保临界资源（如筷子）的互斥访问，但如果设计不当（如所有哲学家同时拿左筷子），仍可能因循环等待导致死锁。信号量仅保证互斥，无法完全消除死锁的所有必要条件。<br>B错，可以预防死锁（破坏 “请求与保持” 条件），但不会导致饥饿。因为当哲学家用完餐后会释放筷子，其他等待的哲学家可按规则获取资源，不存在某哲学家始终无法获得资源的情况，可能存在的是资源浪费（部分筷子空闲但无法被单独使用）。<br>C对，限制同时拿筷子的哲学家数量（如最多 4 人），可确保至少有 1 人能同时拿到左右筷子（因总共有 5 根筷子，4 人拿左筷子时，剩余 1 根右筷子必可被某一人获取），从而打破 “循环等待” 链。例如，当 5 人中最多 4 人允许拿筷子时，剩下的 1 人无法形成循环等待的闭环。<br>D错，该方法通过改变拿筷子的顺序（奇数先左后右，偶数先右后左），使相邻哲学家的拿筷顺序冲突，从而打破 “循环等待” 条件（无法形成环形等待链），而非破坏 “互斥条件”（筷子本身仍需互斥访问）。</li><li><strong>下列关于进程死锁的描述中，错误的是()。<br>A.若每个进程只能同时申请或拥有一个资源，则不会发生死锁<br>B.若多个进程可以无冲突共享访问所有资源，则不会发生死锁<br>C若所有进程的执行严格区分优先级，则不会发生死锁<br>D.若进程资源请求之间不存在循环等待，则不会发生死锁</strong><br>选C。A破坏请求保持，B破坏互斥，D破坏循环等待</li><li><strong>一次分配所有资源的方法可以预防死锁的发生，它破坏死锁4个必要条件中的()。<br>A.互斥   B.占有并请求   C.非剥夺   D.循环等待</strong><br>B</li><li><strong>系统产生死锁的可能原因是()。<br>A.独占资源分配不当   B. 系统资源不足<br>C.进程运行太快          D.CPU 内核太多</strong><br>A<br>死锁的主要原因分为时间维度（进程推进顺序不当，导致相互等待资源）和空间维度（独占资源分配策略缺陷，满足死锁四条件）<br>资源不足非死锁主因，系统资源不足只会对进程造成“饥饿”。例如，某系统只有三台打印机，若进程运行中要申请四台，显然不能满足，该进程会永远等待下去。若该进程在创建时便声明需要四台打印机，则操作系统立即就会拒绝，这实际上是资源分配不当的一种表现。不能以系统资源不足来描述剩余资源不足的情形。</li><li><strong>可以防止系统出现死锁的手段是()。<br>A.用 PV 操作管理共享资源    B.使进程互斥地使用共享资源<br>C.采用资源静态分配策略       D.定时运行死锁检测程序</strong><br>PV操作不能破坏死锁条件，反而可能加强互斥和占有并等待条件。选项B同理。选项C可以破坏请求并保持条件。选项D只能在系统出现死锁时检测，却不能防止系统出现死锁。</li><li><strong>若系统中有 5 个某类资源供若干进程共享，则不会引起死锁的情况是（ ）。<br>A. 有 6 个进程，每个进程需 1 个资源<br>B. 有 5 个进程，每个进程需 2 个资源<br>C. 有 4 个进程，每个进程需 3 个资源<br>D. 有 3 个进程，每个进程需 4 个资源</strong><br>A 项的每个进程只申请一个资源，破坏了请求并保持条件，必然不会发生死锁</li><li><strong>三个进程共享四个同类资源，这些资源的分配与释放只能一次一个。已知每个进程最多需要两个该类资源，则该系统（ ）。<br>A. 有些进程可能永远得不到该类资源<br>B. 必然有死锁<br>C. 进程请求该类资源必然能得到<br>D. 必然是死锁</strong><br>不会发生死锁。因为每个进程都分得一个资源时，还有一个资源可以让任意一个进程满足，这样这个进程可以顺利运行完成进而释放它的资源。</li><li><strong>以下有关资源分配图的描述中，正确的是()。<br>A.有向边包括进程指向资源类的分配边和资源类指向进程申请边两类<br>B.矩形框表示进程，其中圆点表示申请同一类资源的各个进程<br>C.圆圈节点表示资源类<br>D.资源分配图是一个有向图，用于表示某时刻系统资源与进程之间的状态</strong><br>A反了；矩形框表示资源，其中的圆点表示资源的数量，B错；圆圈节点表示进程，选项C错;选项D 的说法是正确的。</li><li><strong>某个系统采用下列资源分配策略。<br>若一个进程提出资源请求得不到满足，而此时没有由于等待资源而被阻塞的进程，则自己就被阻塞。<br>而当此时已有等待资源而被阻塞的进程，则检查所有由于等待资源而被阻塞的进程。<br>若它们有申请进程所需要的资源，则将这些资源取出并分配给申请进程。这种分配策略会导致()<br>A.死锁   B. 颠簸   C.回退   D.饥饿</strong><br>某个进程主动释放资源不会导致死锁，因为破坏了请求并保持条件，选项A错。颠簸也就是抖动，这是请求分页系统中页面调度不当而导致的现象，是下一章讨论的问题，这里权且断定选项B是错的。回退是指从此时此刻的状态退回到一分钟之前的状态，假如一分钟之前拥有资源 X，它有可能释放了资源X，那就不称回到一分钟之前的状态，也就不是回退，选项C错。因为进程过于“慷慨”，不断把自己已得到的资源送给别人，导致自己长期无法完成，所以是饥饿，选项D 正确。</li><li><strong>系统的资源分配图在下列情况下，无法判断是否处于死锁状态的有（ ）。<br>I. 出现了环路                                        II. 没有环路<br>III. 每种资源只有一个，并出现环路    IV. 每个进程节点至少有一条请求边<br>A. I、II、III、IV  B. I、III、IV  C. I、IV  D. 以上答案都不正确</strong><br>出现了环路，只是满足了循环等待的必要条件，而满足必要条件不一定会导致死锁，选项 I 对；没有环路，破坏了循环等待条件，一定不会发生死锁，选项 II 错；每种资源只有一个，又出现了环路，这是死锁的充分条件，可以确定是否有死锁，选项 III 错；即使每个进程至少有一条请求边，若资源足够，则不会发生死锁，但若资源不充足，则有发生死锁的可能，选项 IV 对。</li><li><strong>有并发进程<code>P₁</code>和<code>P₂</code>的代码如下：</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Semaphore x1=x2=y=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c1=c2=<span class="number">0</span>;</span><br><span class="line">P₁ () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ①P(x1);</span><br><span class="line">        ②<span class="keyword">if</span> (++c1==<span class="number">1</span>) ③P(y);</span><br><span class="line">        ④V(x1);</span><br><span class="line">        ⑤computer(A);</span><br><span class="line">        ⑥P(x1);</span><br><span class="line">        ⑦<span class="keyword">if</span> (--c1==<span class="number">0</span>) ⑧V(y);</span><br><span class="line">        ⑨V(x1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P₂ () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ⑩P(x2);</span><br><span class="line">        ⑪<span class="keyword">if</span> (++c2==<span class="number">1</span>) ⑫P(y);</span><br><span class="line">        ⑬V(x2);</span><br><span class="line">        ⑭computer(B);</span><br><span class="line">        ⑮P(x2);</span><br><span class="line">        ⑯<span class="keyword">if</span> (--c2==<span class="number">0</span>) ⑰V(y);</span><br><span class="line">        ⑱V(x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以下关于这两个并发进程的说法正确的是（ ）。</strong><br><strong>A. 进程不会死锁，也不会 “饥饿”</strong><br><strong>B. 进程不会死锁，但是会 “饥饿”</strong><br><strong>C. 进程会死锁，但是不会 “饥饿”</strong><br><strong>D. 进程会死锁，也会 “饥饿”</strong><br>将进程<code>P₁</code>、<code>P₂</code>比作两拨想过单行道的车，信号量<code>x1</code>、<code>x2</code>、<code>y</code>和变量<code>c1</code>、<code>c2</code>比作交通规则相关要素。因<code>y</code>限制，两拨车不会同时卡死在入口，即进程不会死锁；但<code>P₁</code>车若频繁来占单行道，就会一直占着单行道的使用权（<code>y</code> ），<code>P₂</code>车就只能一直等过不了道，即进程会“饥饿” ，所以答案是B 。<br>73. <strong>有两个并发进程，对于如下这段程序的运行，正确的说法是 ( )。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z,t,u;</span><br><span class="line">P₁()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ①x=<span class="number">1</span>;</span><br><span class="line">        ②y=<span class="number">0</span>;</span><br><span class="line">        ③<span class="keyword">if</span> x&gt;=<span class="number">1</span> then ④y=y+<span class="number">1</span>;</span><br><span class="line">        ⑤z=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P₂()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ⑥x=<span class="number">0</span>;</span><br><span class="line">        ⑦t=<span class="number">0</span>;</span><br><span class="line">        ⑧<span class="keyword">if</span> x&lt;=<span class="number">1</span> then ⑨t=t+<span class="number">2</span>;</span><br><span class="line">        ⑩u=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>A. 程序能正确运行，结果唯一<br>B. 程序不能正确运行，可能有两种结果<br>C. 程序不能正确运行，结果不确定<br>D. 程序不能正确运行，可能会死锁</strong><br>P₁控制x、y、z，P₂控制x、t、u，二者对x的写操作冲突。<br>若①前，⑥后，t=2；若⑥前，①后，t也等于2，且u都等于2，所以不影响t，u的值，忽略t，u。<br>z只受y影响，y=1=z，故只考虑P₁的x，y，P₂的x。<br>情况 1：P₁ 执行①②③（x=1, y=0, y=1）→ P₂ 执行⑥（x=0）→ z=1。<br>情况 2：P₂ 执行⑥（x=0）→ P₁ 执行①②③（x=1, y=0, y=1）→ z=1。<br>情况 3：P₁ 执行①（x=1）→ P₂ 执行⑥（x=0）→ P₁ 执行③（x=0，y=0）→ z=0。选C<br>74. <strong>死锁定理是用于处理死锁的（ ）方法。<br>A. 预防死锁  B. 避免死锁  C. 检测死锁  D. 解除死锁</strong><br>死锁定理是通过分析资源分配图来判断系统是否处于死锁状态，属于检测死锁的方法。预防死锁是通过设置一些限制条件，破坏死锁产生的必要条件来防止死锁发生；避免死锁是在资源分配过程中，通过某种算法判断此次分配是否会导致死锁，从而避免死锁；解除死锁是在检测到死锁发生后，采取措施（如剥夺资源、终止进程等 ）来消除死锁。所以死锁定理用于检测死锁 ，选 C。<br>75. <strong>某系统有m个同类资源供n个进程共享，若每个进程最多申请k个资源（k≥1），采用银行家算法分配资源，为保证系统不发生死锁，则各进程的最大需求量之和应（ ）。 A. 等于m B. 等于m + n C. 小于m + n D. 大于m + n</strong><br>n(k - 1)+1 ≤ m，可得nk &lt; m + n ，也就是各进程的最大需求量之和小于m + n 。若等于m + n ，可能会出现死锁情况；等于m ，资源可能无法满足进程需求；大于m + n ，必然会发生死锁。所以选 C。<br>76. <strong>采用银行家算法可以避免死锁的发生，这是因为该算法（ ）。<br>A. 可以抢夺已分配的资源<br>B. 能及时为各进程分配资源<br>C. 任何时刻都能保证每个进程能得到所需的资源<br>D. 任何时刻都能保证至少有一个进程可以得到所需的全部资源</strong><br>A 选项：银行家算法是在资源分配前进行安全性检查，并不会抢夺已分配的资源 ，所以 A 错误。<br>B 选项：银行家算法不是单纯强调及时分配资源，而是在分配资源时判断是否会导致系统进入不安全状态，避免因资源分配不当产生死锁，所以 B 错误。<br>C 选项：银行家算法不能保证任何时刻每个进程都能得到所需资源，因为系统资源有限，可能无法满足所有进程的最大需求，所以 C 错误。<br>D 选项：银行家算法通过检查资源分配情况，确保在任何时刻至少有一个进程可以获得其所需的全部资源并运行完成，从而避免死锁发生 。当一个进程获得全部资源运行结束后，会释放资源，其他进程就有可能获得足够资源继续运行，所以 D 正确。<br>77. <strong>用银行家算法避免死锁时，检测到 ( ) 时才分配资源。</strong><br><strong>A. 进程首次申请资源时对资源的最大需求量超过系统现存的资源量</strong><br><strong>B. 进程已占有的资源数与本次申请的资源数之和超过对资源的最大需求量</strong><br><strong>C. 进程已占有的资源数与本次申请的资源数之和不超过对资源的最大需求量，且现存资源量能满足尚需的最大资源量</strong><br><strong>D. 进程已占有的资源数与本次申请的资源数之和不超过对资源的最大需求量，且现存资源量能满足本次申请量，但不能满足尚需的最大资源量</strong><br>选项 A：如果进程首次申请资源时对资源的最大需求量超过系统现存的资源量，说明系统根本无法满足该进程的需求，肯定不会分配资源，A 错误。<br>选项 B：进程已占有的资源数与本次申请的资源数之和超过对资源的最大需求量，这不符合资源申请的逻辑，是不合理的申请，不会分配资源，B 错误。<br>选项 C：当进程已占有的资源数与本次申请的资源数之和不超过对资源的最大需求量，说明申请合理；且现存资源量能满足尚需的最大资源量，意味着分配资源后系统仍处于安全状态，此时才会分配资源，C 正确。<br>选项 D：但不能满足尚需的最大资源量是指“但满足不了它以后还需要的最多资源量 ”，有发生死锁的风险，不会分配资源，D 错误。<br>78. <strong>下列各种方法中，可用于解除已发生死锁的是()。<br>A.撤销部分或全部死锁进程                B.剥夺部分或全部死锁进程的资源<br>C.降低部分或全部死锁进程的优先级 D.A和B都可以</strong><br>D<br>79. <strong>假定某计算机系统有R₁和R₂两类可使用资源（其中R₁有两个单位，R₂有一个单位），它们被进程P₁和P₂所共享，且已知两个进程均按下列顺序使用两类资源：申请R₁→申请R₂→申请R₁→释放R₁→释放R₂→释放R₁ ，则在系统运行过程中，（ ）。<br>A. 不可能产生死锁，因为R₂资源不足<br>B. 有可能产生死锁，因为R₁资源不足<br>C. 有可能产生死锁，因为R₂资源不足<br>D. 只有一种进程执行序列可能导致死锁</strong><br>假设资源分配初始：P₁和P₂各申请 1 个R₁，耗尽R₁（剩余 0）<br>执行第二步：P₁申请到R₂（剩余 0），P₂申请R₂失败阻塞<br>执行第三步：P₁申请R₁失败阻塞，此时P₁持有R₁和R₂等待R₁，P₂持有R₁等待R₂，形成循环等待死锁<br>核心原因：R₁资源不足（仅 2 个），两进程各占 1 个后无法满足后续申请，触发死锁必要条件。<br>R₂的不足仅让 P₂处于 “等待 R₂” 的阻塞状态，但并未形成 “循环等待”—— 死锁的必要条件之一。P₁等 P₂释放 R₁，P₂等 P₁释放 R₂，两者互相等待，满足死锁的 “循环等待” 条件。<br>B<br>80. **【2015 统考真题】<strong>系统S1​采用死锁避免方法，S2​采用死锁检测方法。下列叙述中，正确的是（ ）。</strong><br><strong>I. S1​会限制用户申请资源的顺序，而S2​不会</strong><br><strong>II. S1​需要进程运行所需的资源总量信息，而S2​不需要</strong><br><strong>III. S1​不会给可能导致死锁的进程分配资源，而S2​会</strong><br><strong>A. 仅 I、II B. 仅 II、III C. 仅 I、III D. I、II、III</strong><br>对于 I：死锁避免方法（如银行家算法）重点是通过资源分配前的计算判断是否安全，并不限制资源申请顺序；死锁检测方法也不限制申请顺序，所以 I 错误。<br>对于 II：死锁避免方法（如银行家算法）需要知道进程运行所需资源总量、已分配量等信息来判断安全性；死锁检测方法主要检测资源分配图是否存在死锁环，不需要进程资源总量信息，所以 II 正确。<br>对于 III：死锁避免方法会判断资源分配是否导致死锁，不会给可能导致死锁的进程分配资源；死锁检测方法是在检测到死锁后才处理，之前会正常分配资源，所以 III 正确。<br>81. <strong>【2016 统考真题】系统中有3个不同的临界资源R₁、R₂和R₃，被4个进程P₁、P₂、P₃、P₄共享。各进程对资源的需求为：P₁申请R₁和R₂，P₂申请R₂和R₃，P₃申请R₁和R₃，P₄申请R₂。若系统出现死锁，则处于死锁状态的进程数至少是（ ）A. 1 B. 2 C. 3 D. 4</strong><br>临界资源一次只能被一个进程使用。假设只有1个或2个进程处于死锁状态。若只有1个进程死锁，其他进程可正常运行并释放资源，死锁进程就能获得资源继续运行，不符合死锁定义。若有2个进程死锁，比如P₁和P₂死锁，P₃和P₄正常运行，P₃和P₄运行完释放资源后，P₁和P₂也能继续运行，不符合死锁定义。当有3个进程时，比如P₁、P₂、P₃，P₁占有R₁等待R₂，P₂占有R₂等待R₃，P₃占有R₃等待R₁，形成循环等待，满足死锁条件，所以处于死锁状态的进程数至少是3个。<br>82. <strong>【2018 统考真题】假设系统中有4个同类资源，进程P₁，P₂和P₃需要的资源数分别为4，3和1，P₁，P₂和P₃已申请到的资源数分别为2，1和0，则执行安全性检测算法的结果是（ ）。</strong><br><strong>A. 不存在安全序列，系统处于不安全状态</strong><br><strong>B. 存在多个安全序列，系统处于安全状态</strong><br><strong>C. 存在唯一安全序列P₃，P₁，P₂，系统处于安全状态</strong><br><strong>D. 存在唯一安全序列P₃，P₂，P₁，系统处于安全状态</strong><br>A<br>83. <strong>【2019 统考真题】下列关于死锁的叙述中，正确的是（ ）。</strong><br><strong>I. 可以通过剥夺进程资源解除死锁</strong><br><strong>II. 死锁的预防方法能确保系统不发生死锁</strong><br><strong>III. 银行家算法可以判断系统是否处于死锁状态</strong><br><strong>IV. 当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态</strong><br><strong>A. 仅 II、III   B. 仅 I、II、IV   C. 仅 I、II、III   D. 仅 I、III、IV</strong><br>银行家算法判断是否处于安全状态，错。死锁状态用死锁检测方法。B<br>84.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程状态（运行 / 就绪 / 阻塞） </tag>
            
            <tag> 线程类型（用户级 / 内核级） </tag>
            
            <tag> 进程调度算法（FCFS/SJF/RR/ 高响应比） </tag>
            
            <tag> PV 操作 </tag>
            
            <tag> 临界资源 </tag>
            
            <tag> 死锁处理（预防 / 避免 / 检测） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 1 章 计算机系统概述</title>
      <link href="/post/c45d1e8a.html"/>
      <url>/post/c45d1e8a.html</url>
      
        <content type="html"><![CDATA[<h1>计算机系统概述</h1><h2 id="计算机系统的组成">计算机系统的组成</h2><p>计算机系统由<strong>硬件系统</strong>和<strong>软件系统</strong>共同组成，两者协同工作。<br>系统性能取决于<strong>硬件与软件的综合能力</strong><br>结构：</p><ul><li>软件<ul><li><p><strong>系统软件（中间层）</strong></p><ul><li>管理硬件资源，为应用软件提供运行环境。</li><li><strong>分类</strong>：<ul><li><strong>操作系统</strong>：Windows、Linux、macOS（资源调度核心）</li><li><strong>语言处理程序</strong>：编译器（GCC）、解释器（Python）、汇编器</li><li><strong>数据库管理系统（DBMS）</strong>：MySQL、Oracle</li><li><strong>服务程序</strong>：调试工具、磁盘清理工具、诊断程序</li><li><strong>网络系统</strong>：网络协议栈、通信管理软件、路由器固件</li></ul></li></ul></li><li><p><strong>应用软件（最上层）</strong></p><ul><li>面向用户解决特定领域的问题</li><li><strong>分类</strong>：<ul><li><strong>通用软件</strong>：Office（文字/表格处理）、Photoshop（图像处理）</li><li><strong>行业软件</strong>：AutoCAD（工程设计）、MATLAB（科学计算）</li><li><strong>事务管理</strong>：ERP系统、财务软件</li></ul></li></ul></li></ul></li><li><strong>硬件系统（最底层）</strong><ul><li><strong>主机</strong><ul><li><strong>中央处理器（CPU）</strong>：运算器、控制器、寄存器</li><li><strong>主存储器（内存）</strong>：RAM、ROM</li><li><strong>系统总线</strong>：数据总线、地址总线、控制总线</li></ul></li><li><strong>外部设备</strong></li><li><strong>输入设备</strong>：键盘、鼠标、摄像头</li><li><strong>输出设备</strong>：显示器、打印机</li><li><strong>辅助存储器</strong>：硬盘、SSD、U盘</li></ul></li></ul><blockquote><p>计算机系统性能的好坏，取决于硬件和软件功能的总和。<br>计算机的工作特点是<mark>快速性、准确性、通用性、逻辑性</mark><br>当前世界上计算机用途中领域的<mark>应用数据处理</mark>占的比例最大<br>微型计算机的发展以<mark>微处理器</mark>技术为标志<br>v：寄存器 &gt;Cache&gt;内存</p></blockquote><h2 id="计算机的发展">计算机的发展</h2><p>第一台真正意义上的电子数字计算机——ABC<br>第一台实用的电子数字计算机——ENIAC</p><h3 id="计算机硬件的发展">计算机硬件的发展</h3><p>计算机的逻辑器件：<mark>电子管(真空管)→晶体管→中小规模集成电路→大规模、超大规模集成电路</mark><br>以<mark>元器件的更新</mark>作为计算机技术进步和划分时代的主要标志<br>体积越小，功耗越低，可靠性越高，速度越快<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326084316978.png" alt="image.png"></p><table><thead><tr><th>发展阶段</th><th>使用器件</th><th>运算速度（次 / 秒）</th><th>主存（内存）</th><th>辅存（外存）</th><th>特点</th></tr></thead><tbody><tr><td>第 1 代（1946-1957 年）</td><td>电子管（真空管）</td><td>几千～几万</td><td>水银延迟线、磁鼓、磁芯</td><td>穿孔卡片、穿孔纸带</td><td>使用机器语言编程，无操作系统</td></tr><tr><td>第 2 代（1958-1964 年）</td><td>晶体管</td><td>几十万～几百万</td><td>磁芯</td><td>磁鼓、磁带、磁盘</td><td>主要用汇编语言，开始使用 FORTRAN、COBOL 等高级语言，单道批处理系统</td></tr><tr><td>第 3 代（1965-1971 年）</td><td>集成电路</td><td>几百万～几千万</td><td>半导体存储器</td><td>磁带、磁盘</td><td>高级语言发展，出现 B 语言，多道批处理系统、分时系统</td></tr><tr><td>第 4 代（1972 至今）</td><td>超大规模集成电路</td><td>几十亿～几千亿</td><td>半导体存储器</td><td>磁盘、磁带、光盘、半导体存储器</td><td>各种高级语言（如 C/C++、Java、Python），现代操作系统</td></tr></tbody></table><h3 id="计算机软件的发展">计算机软件的发展</h3><ul><li><strong>编程语言</strong><ul><li><strong>机器语言</strong><br>用<mark>二进制代码</mark>表示的计算机能<mark>直接</mark>识别和执行的一种机器指令的集合。唯一能被硬件直接执行的语言，成为目标程序</li><li><strong>汇编语言</strong><br>用<strong>助记符</strong>（如<code>MOV</code>, <code>ADD</code>）代替机器指令，与机器码<strong>一一对应</strong>，基本保留了机器语言的灵活性，但仍依赖硬件架构</li><li><strong>高级语言</strong><br>面向用户的语言，通过<strong>抽象</strong>隐藏硬件细节，与具体机器无关<ul><li><strong>编译型</strong>（如C/C++）：<br>源代码 → <strong>编译器</strong> → 直接生成<strong>机器码</strong>（或先转为汇编代码再汇编） → 链接为可执行文件（如.exe）。</li><li><strong>解释型</strong>（如Python、JavaScript）：<br>解释器逐行翻译并<strong>边解释边执行</strong>，无独立机器码文件。</li><li><strong>混合型</strong>（如Java）：<br>源代码 → 编译为<strong>中间码</strong>（如字节码） → 由虚拟机（JVM）解释/即时编译（JIT）执行。</li></ul></li><li><strong>面向对象</strong><br>高级语言的<strong>范式演进</strong>，以“对象”为核心组织代码（如C++、Java）</li></ul></li><li><strong>操作系统</strong><ul><li>提供了<strong>在汇编语言和高级语言的使用和实现过程中所需的某些基本操作</strong></li><li>负责<strong>控制并管理计算机系统的全部硬件资源</strong>（eg.CPU、内存、外部设备）和<strong>软件资源</strong>（eg.编译程序、应用程序）</li></ul></li></ul><p>程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器指令，由计算机最终执行。</p><p>高级语言程序转换为机器语言程序，即<strong>翻译程序</strong>：<br>编译、汇编、解释程序可统称翻译程序</p><table><thead><tr><th><strong>类型</strong></th><th><strong>输入</strong></th><th><strong>输出</strong></th><th><strong>特点</strong></th><th><strong>示例语言</strong></th></tr></thead><tbody><tr><td><strong>汇编程序</strong></td><td>汇编语言源代码</td><td>机器码目标文件</td><td>一对一翻译，依赖硬件架构</td><td>x86汇编、ARM汇编</td></tr><tr><td><strong>编译程序</strong></td><td>高级语言源代码</td><td>汇编/机器码文件</td><td>整体翻译，生成独立可执行文件.exe</td><td>C、C++、Go</td></tr><tr><td><strong>解释程序</strong></td><td>高级语言源代码</td><td>直接执行</td><td>逐行翻译，无独立机器码</td><td>Python、JavaScript</td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327160427749.png" alt="image.png"></td><td></td><td></td><td></td><td></td></tr><tr><td><font color="#ff0000">预处理→编译→汇编→链接</font></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><strong>预处理（Preprocessing）</strong><ul><li>预处理器(cpp)对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以i为扩展名的源程序 hello.i。</li></ul></li><li><strong>编译（Compilation）</strong><ul><li>编译器(ccl)对预处理后的源程序进行编译，生成一个<strong>汇编语言源程序</strong> hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。</li></ul></li><li><strong>汇编（Assembly）</strong><ul><li>汇编器将汇编代码转为<strong>机器码目标文件</strong>（<code>.o</code>或<code>.obj</code>）。汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一个称为可重定位目标代码文件 hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。</li></ul></li><li><strong>链接（Linking）</strong><ul><li>链接器(ld)将多个可重定位目标代码文件和标准库函数合并为一个可执行目标文件，简称可执行文件。本例中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。</li></ul></li></ol><p>注：</p><ul><li>v:<mark>编译程序&gt;解释程序</mark><br>解释程序需要便翻译成机器语言边执行，故速度比机器语言慢</li></ul><p>当前计算机的发展趋势</p><ul><li>更微型化：低耗能，较高性能，多用途</li><li>更巨型化：超高速，并行处理，智能化</li></ul><h2 id="计算机硬件">计算机硬件</h2><p>冯·诺依曼结构（也称普林斯顿结构）是计算机设计的理论基础，其核心思想是“<strong>存储程序</strong>”，即程序指令和数据共同存储在存储器中，由控制器按顺序自动执行。<br><strong>存储程序原理</strong>：</p><ul><li><strong>核心思想</strong>：<ul><li>程序与数据<strong>预先存入主存</strong>，启动后计算机自动逐条执行指令，无需人工干预。</li><li><strong>按地址访问</strong>：通过指令中的地址码定位存储单元，而非按内容寻址（相联存储器为特例，按内容或地址选择地址，成为按内容寻址的寄存器，不属冯氏结构基础）</li></ul></li></ul><p>冯诺依曼计算机主要特点：</p><ol><li>指令和数据均采用二进制表示<ul><li><strong>形式无区分</strong>：指令和数据均以<strong>二进制形式</strong>存储在<strong>存储器</strong>中，计算机通过<strong>执行阶段</strong>区分二者。【指令和数据在内存中可以有各种进制<mark>表示</mark>，但是<mark>存放</mark>的必须是二进制】<br>在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。<br>1)二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位制造成本比较低，例如用高、低电平或电荷的正、负极性都可以很方便地表示0和1。<br>2)二进制位 1和 0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。<br>3)进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</li></ul></li></ol><ul><li><strong>取指阶段</strong>：从存储器中读取的是<strong>指令</strong>（由操作码和地址码组成）。</li><li><strong>执行阶段</strong>：根据指令中的地址码访问<strong>数据</strong>或目标地址。</li></ul><ol start="2"><li>指令和数据存放在存储器中，按地址访问。</li><li>指令在存储器中按<strong>顺序</strong>存放。一般情况下，指令是顺序执行的。<ul><li><strong>指令结构</strong>：</li></ul></li></ol><ul><li><strong>操作码</strong>：指明操作类型（如取数、存数、加、减、乘、除、跳转）。</li><li><strong>地址码</strong>：指明操作数在存储器中的位置（地址）或直接数据。</li></ul><ol start="6"><li>机器以<strong>运算器</strong>为中心，输入/输出设备与存储器间的数据传送通过运算器完成，浪费很多可以用于运算的时间<br><strong>现代改进</strong>：当代计算机以<strong>存储器为中心</strong>，输入/输出可通过<strong>DMA（直接内存访问）</strong> 绕过CPU，提升效率。</li><li>计算机硬件由<strong>运算器、控制器、存储器、输入设备/输出设备</strong>5大部件组成。<blockquote><p><strong>注</strong>：现代计算机中，运算器与控制器集成在<strong>CPU</strong>中，存储器主要指<strong>主存（内存）</strong>。<br><strong>内存由存储单元组成</strong>，每个单元有唯一地址，而非由寄存器构成。<br>存储器中可存地址（如指针变量），但地址本质是存储单元的编号。</p></blockquote></li><li><strong>指令流驱动</strong>：程序执行流程由指令序列控制，PC指向当前指令地址，顺序执行或跳转。</li></ol><p>控制器与其他部件之间通过控制器和反馈线相连，这些部件需要在控制器的控制下协调工作<br>图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制ALU 执行什么运算，可以控制主存是进行读操作还是写操作(读/写控制信号)。<br>但是这种设计，每次IO操作都需要运算器参与，浪费了很多可以用于运算的时间<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093328099.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326094434509.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093400793.png" alt="image.png"><br>现代计算机以存储器为核心<br>可以让IO设备直接与存储器交换数据，以提高整体效率<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326094617374.png" alt="image.png">控制器核心为控制单元CU(Control Unit)，主要功能如下：</p><ul><li>用于解释存储器中的指令，并发出各种操作命令来执行指令。</li><li>I/O设备也受CU控制，用于完成相应的输入/输出操作。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093441775.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093454858.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326095110873.png" alt="image.png">主机细化：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327101101923.png" alt="image.png"></li></ul><h3 id="相关术语">相关术语</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326112214285.png" alt="image.png|350"></p><ol><li><p><font color="#ff0000">主机</font> = <strong>CPU + 内存 + 系统总线</strong>（部分定义包含I/O接口）<br><strong>输入输出接口（I/O接口）</strong>：属于主机与外部设备（如键盘、打印机）的<strong>桥梁</strong>，严格来说属于主机的一部分，但外设本身（如硬盘、显示器）不算主机。</p></li><li><p><strong><font color="#ff0000">存储器</font></strong></p><ul><li><strong>内存（主存、主存储器）</strong>： 临时存储正在运行的程序和数据（断电丢失），相当于办公桌。CPU可以直接访问主存储器<ul><li>存储体</li><li>MAR</li><li>MDR<br>随着硬件技术的发展，内存都制成大规模集成电路芯片，而将<mark>MAR和MDR集成到了CPU芯片中</mark></li></ul></li><li><strong>外存（辅助存储器、外存储器）</strong>：例如硬盘、U盘，长期保存文件（断电不丢），相当于文件柜。<br>辅助存储器中的信息必须调入主存后，才能为CPU所访问。</li></ul></li><li><p><strong><font color="#ff0000">CPU</font>（中央处理器）</strong>：计算机的“大脑”，负责计算和控制，核心由<strong>运算器（ALU）</strong> 和 <strong>控制器（CU）</strong> 组成，通过<strong>寄存器</strong>实现高速数据存取【运算器和控制器中都有寄存器】</p><ul><li><strong><font color="#ff0000">运算器</font></strong>：<ul><li><strong>算术逻辑单元ALU</strong>：执行定点或浮点的算术==运算操作（加减乘除）及逻辑操作（与、或、非、异或、比较、移位），也可执行地址的运算和转换。==属于组合逻辑电路<ul><li>结构<ul><li><strong>加法器</strong>：实现二进制加法，是ALU的基础单元。</li><li><strong>选择逻辑</strong>：通过控制信号选择输入数据（如两个操作数），决定执行何种运算。</li><li><strong>输出控制</strong>：支持结果直接传输或移位（如左移、右移）。</li></ul></li><li><strong>重要性</strong>：计算机性能的关键，因为大部分数据处理依赖ALU的运算速度。</li></ul></li><li>相关寄存器<ul><li><strong>累加器ACC</strong>，一种<strong>专用寄存器</strong>（非ALU直接部件），用于暂存ALU<strong>前一次运算的结果</strong>或<strong>初始操作数（被加数/被减数）</strong>，在加减法中作为运算的基准值。（例如：执行<code>A = A + B</code>时，累加器存放<code>A</code>的值）</li><li><strong>乘商寄存器MQ</strong>：在乘法和除法运算中，存储乘数、商或中间结果。</li><li><strong>操作数寄存器X</strong>：用于临时存储<strong>从主存或指令中获取的第二个操作数（加数、减数、乘数）</strong></li><li><strong>标志寄存器PSW</strong>：也称程序状态寄存器，存放ALU运算得到的一些标志信息或处理机的状态信息，如溢出、进位或借位、结果正负、零标志，是条件执行的基础<ul><li><strong>进位标志</strong>：加法结果超过位数时标记（如99+1=100，进位了）</li><li><strong>零标志</strong>：结果是否为0。</li></ul></li><li>变址寄存器IX</li><li>基址寄存器BR<br>前三个是必备的</li></ul></li></ul></li><li><strong><font color="#ff0000">控制器</font></strong>：计算机的神经中枢，指挥各个部件自动协调工作。<br>核心流程为<strong>1. 从内存取指令（取指） → 2. 分析指令（分析） → 3. 发信号让运算器/内存干活（执行）</strong><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326112932395.png" alt="image.png|350"><ul><li><strong>核心组件</strong>：<ul><li><strong>程序计数器（PC）</strong>：存放下一条指令的<mark>地址</mark>，有自动+1功能（指令长度）<u>与主存的MAR间有一条直接通路</u> 寄存信息、计数功能</li><li><strong>指令寄存器（IR）</strong>：==存放从存储器取出的当前指令，内容来自主存的MDR。==指令中的操作码（用OP(IR)表示）送至 CU（OP(IR)→CU），用以<strong>分析指令</strong>并发出各种微操作命令序列；而地址码 Ad(IR)送往MAR，用以取操作数。<ul><li>暂存当前执行的指令<ul><li>分离 操作码OP和地址码 Ad<ul><li>OP送入控制单元CU，解码</li><li>Ad用于定位操作数在内存中的地址</li></ul></li><li><strong>取指阶段</strong>：IR 接收从内存读取的指令。</li><li><strong>执行阶段</strong>：IR 提供操作码和地址码，驱动 CPU 完成操作（如运算、存数等）<br>注：<br>IR指令寄存器IR用来存放<strong>当前的指令</strong>，IR的内容来自存储器数据寄存器MDR。<br>程序计数器PC用来存放<strong>当前欲执行指令的地址</strong>，PC与存储器地址寄存器MAR之间有一条直接通路。PC自动形成下一条指令的地址(“自动加1”功能)</li></ul></li></ul></li><li><strong>控制单元（CU）</strong>：<mark>分析</mark>存储器中的指令，并发出各种操作命令来执行指令。</li><li><strong>指令译码器</strong>：解析指令的操作码（如“加法”）和地址码（如“操作数位置”）。</li><li><strong>时序部件</strong>：生成时钟信号，同步各操作步骤。</li><li><strong>操作控制部件</strong>：根据译码结果，向ALU、内存等发送控制信号（如“开始加法运算”）。</li><li><strong>中断机构</strong>：处理外部紧急事件（如用户按下键盘）。</li></ul></li><li>相关寄存器</li></ul></li><li><font color="#ff0000">寄存器</font>：CPU内部的“高速临时存储单元”，直接参与运算和控制，速度远快于内存。<ul><li><strong>分类</strong>：</li><li><strong>通用寄存器（GPRs）</strong>：由若干个寄存器组成，早期就是累加器<ul><li>存储临时数据或中间结果（如计算<code>(a+b)*c</code>时，存放<code>a+b</code>的结果）。</li><li>用户可通过编程直接访问（如x86中的<code>EAX</code>、<code>EBX</code>）。</li></ul></li></ul></li></ul></li><li><p><strong><font color="#ff0000">总线</font>（Bus）</strong>：在计算机中连接CPU和其他芯片的导线的集合</p><ul><li><ol><li><strong>地址总线AB</strong></li></ol><ul><li><strong>寻址空间</strong>：地址总线的位数（宽度）决定了CPU可访问的<strong>内存地址空间</strong>。</li><li>若地址总线为 n 位，则寻址空间为 2^n <strong>个存储单元</strong>。</li><li><strong>示例</strong>：<ul><li>20位地址总线 → 2^{20} = 1,048,576 个存储单元（即1MB，若每个单元为1字节）。</li></ul></li><li><strong>存储容量</strong>：存储器的总容量由<strong>地址空间 × 存储单元大小</strong>决定<ul><li>若地址总线为16位（2^{16}=65536 单元），且每个单元为8位（1字节），则总容量为 <strong>64KB</strong>。</li></ul></li><li><strong>CPU操作</strong>：CPU通过地址总线发送地址信号，选中目标存储单元或I/O设备。</li></ul></li><li><strong>2. 数据总线（Data Bus, DB）</strong><ul><li><strong>机器字长</strong>：数据总线的宽度通常等于CPU的<strong>机器字长</strong>，即一次能处理的二进制位数（如32位、64位）。<ul><li>机器字长决定了通用寄存器的位数和ALU的运算能力（如64位CPU可一次处理64位数据）。</li></ul></li><li><strong>并行传输能力</strong>：数据总线的宽度直接影响CPU与外界的数据传输速度。<ul><li><strong>示例</strong>：<ul><li>16位数据总线 → 一次传输2字节。</li><li>32位数据总线 → 一次传输4字节。</li></ul></li></ul></li><li><strong>速度影响</strong>：数据总线越宽，单次传输数据量越大，整体传输速率越高（速率 = 总线宽度 × 时钟频率）。</li></ul></li><li><strong>3. 控制总线（Control Bus, CB）</strong><ul><li><strong>控制信号传输</strong>：负责传递CPU与外部设备间的控制信号，包括：<ul><li><strong>读写命令</strong>：如内存读（MEMR）、内存写（MEMW）。</li><li><strong>中断请求</strong>：如IRQ（中断请求）、NMI（不可屏蔽中断）。</li><li><strong>总线仲裁</strong>：如总线请求（BUSRQ）、总线响应（BUSAK）。</li><li><strong>状态信号</strong>：如就绪（READY）、复位（RESET）。</li></ul></li><li><strong>控制能力</strong>：控制总线的宽度决定了可独立传输的控制信号种类数量。<ul><li>更多的控制线允许更复杂的协调操作（如多设备并行管理）。</li></ul></li></ul></li></ul></li></ol><p>注：<br><strong>地址总线位数</strong>决定可寻址的<strong>存储单元数量</strong>（2^n），而<strong>数据总线宽度</strong>决定每个单元的<strong>数据位宽</strong>（如8位、16位）。</p><ul><li><strong>示例</strong>：<ul><li>16位地址总线 + 8位数据总线 → 地址空间为 2^{16}=65536 单元，每个单元8位，总容量为 <strong>64KB</strong>。</li><li>16位地址总线 + 32位数据总线 → 地址空间仍为65536单元，但每个单元32位，总容量为 <strong>256KB</strong>。</li></ul></li><li><strong>结论</strong>：地址空间仅由地址总线位数决定，与数据总线宽度无关。</li></ul><table><thead><tr><th><strong>总线类型</strong></th><th><strong>核心作用</strong></th><th><strong>决定因素</strong></th><th><strong>典型关联概念</strong></th></tr></thead><tbody><tr><td><strong>地址总线</strong></td><td>指定存储单元位置</td><td>寻址空间（2^n 单元）</td><td>存储容量、内存地址范围</td></tr><tr><td><strong>数据总线</strong></td><td>传输操作数/结果</td><td>机器字长、数据传输速度</td><td>通用寄存器、ALU运算能力</td></tr><tr><td><strong>控制总线</strong></td><td>协调操作与状态同步</td><td>控制信号种类与复杂度</td><td>中断管理、总线仲裁</td></tr></tbody></table><ul><li><strong>AB、DB、CB协同工作</strong>：地址总线定位数据位置，数据总线传输数据内容，控制总线确保操作时序与协调。</li><li><strong>性能平衡</strong>：地址总线宽度决定内存容量，数据总线宽度影响处理速度，控制总线复杂度决定系统灵活性。</li></ul><ol start="5"><li><strong>指令集体系结构</strong>（ISA）：<ul><li><strong>核心作用</strong>：</li><li><strong>硬件与软件的接口</strong>，定义计算机可执行的所有指令集合。</li><li>规定指令的操作类型、操作数地址空间及数据类型（如x86、ARM指令集）。</li><li><strong>层级位置</strong>：</li><li>位于计算机系统层次结构的<strong>软件与硬件之间</strong>，是软件可见的最低层。</li></ul></li></ol><ul><li><strong>关键特性</strong>：<ul><li><strong>软件可见性</strong>：程序员通过ISA编写代码，无需关心底层硬件细节。</li></ul></li></ul><table><thead><tr><th><strong>寄存器/部件</strong></th><th><strong>可见性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>MAR、MDR、IR</strong></td><td>不可见（对程序员透明）</td><td>由硬件自动控制，用户无法直接访问。</td></tr><tr><td><strong>PC（程序计数器）</strong></td><td>部分可见（汇编程序员可见）</td><td>可通过分支指令间接操作（如JMP）。</td></tr><tr><td><strong>状态寄存器（Flag）</strong></td><td>汇编程序员可见</td><td>通过条件码控制程序流程（如JZ、JC）。</td></tr><tr><td><strong>通用寄存器（GPRs）</strong></td><td>汇编程序员可见</td><td>直接参与数据运算（如ADD R1, R2）。</td></tr><tr><td>计算机基本的结构模型</td><td></td><td></td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327122211999.png" alt="image.png"></td><td></td><td></td></tr><tr><td>设主存储器容量为 64Kx32位，且指令字长、存储字长、机器字长三者相等。写出各寄存器的位数，并指出哪些寄存器之间有信息通路。</td><td></td><td></td></tr><tr><td><strong>各寄存器位数分析</strong>：</td><td></td><td></td></tr></tbody></table><ol><li><p><strong>与地址相关的寄存器</strong>：</p><ul><li><strong>MAR（存储器地址寄存器）</strong>：主存容量为64K（$2^{16}$），地址总线宽度为 <strong>16位</strong>。</li><li><strong>PC（程序计数器）</strong>：存放指令地址，与MAR一致，为 <strong>16位</strong>。</li></ul></li><li><p><strong>与数据相关的寄存器</strong>：</p><ul><li><strong>MDR（存储器数据寄存器）</strong>：存储字长为32位，数据总线宽度为32位，故MDR为 <strong>32位</strong>。</li><li><strong>IR（指令寄存器）</strong>：指令字长=存储字长=32位，故IR为 <strong>32位</strong>。</li><li><strong>ACC（累加器）、MQ（乘商寄存器）、X（操作数寄存器）</strong>：机器字长=32位，均为 <strong>32位</strong>。</li></ul></li></ol><p><strong>寄存器间的信息通路</strong>：</p><ol><li><p><strong>取指令阶段</strong>：</p><ul><li><strong>PC → MAR</strong>：程序计数器将指令地址发送至MAR，用于访存取指。</li><li><strong>MDR → IR</strong>：从内存取出的指令通过MDR传送到IR。</li></ul></li><li><p><strong>执行阶段</strong>：</p><ul><li><strong>Ad(IR) → MAR</strong>：指令中的地址字段（如访存地址）从IR提取后发送至MAR。</li><li><strong>MDR → ACC</strong>（取数操作）：内存读取的数据通过MDR传送到ACC。</li><li><strong>ACC → MDR</strong>（存数操作）：ACC中的数据通过MDR写入内存。</li></ul></li></ol><h2 id="计算机系统的层次结构">计算机系统的层次结构</h2><p>系统中的每一层都向其上层提供一个简洁和抽象的接口<br>每一层的实现细节对其上层而言都是“看不见”的，也就是透明的。<br>计算机解决问题的过程就是层次结构中的各层逐层转换的过程。</p><ul><li><strong>下层是上层的基础</strong>（硬件 → 系统软件 → 应用软件）</li><li><strong>上层拓展下层功能</strong>（应用软件通过系统软件操作硬件）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326085951572.png" alt="image.png"></li></ul><hr><p><strong>1. 硬件层（最底层）</strong></p><ul><li><strong>组成</strong>：由逻辑门、寄存器、ALU、总线等物理电路构成。</li><li><strong>功能</strong>：直接执行二进制指令（机器码），完成基本逻辑运算与数据存储。</li><li><strong>特点</strong>：完全依赖物理硬件，无抽象接口。</li></ul><p><strong>2. 微程序层</strong></p><ul><li><strong>组成</strong>：微程序控制器，包含微指令序列。</li><li><strong>功能</strong>：<ul><li>将复杂机器指令分解为<strong>微操作</strong>（如取数、运算、存数）。</li><li>通过微指令控制硬件电路的时序与动作。</li></ul></li><li><strong>示例</strong>：一条<code>ADD</code>指令可能对应多步微操作（从寄存器取数 → ALU计算 → 结果写回）。</li></ul><p><strong>3. 指令系统层（机器语言层）</strong></p><ul><li><strong>组成</strong>：机器指令集（如x86、ARM指令集）。</li><li><strong>功能</strong>：<ul><li>定义计算机可执行的所有机器指令（如<code>MOV</code>, <code>JMP</code>）。</li><li>规定指令的操作类型、操作数位置及数据类型。</li></ul></li><li><strong>特点</strong>：程序员需熟悉具体机器的指令格式与硬件结构。</li></ul><p><strong>4. 操作系统层</strong></p><ul><li><strong>组成</strong>：内核、设备驱动、系统调用接口。</li><li><strong>功能</strong>：<ul><li>管理硬件资源（CPU调度、内存分配、I/O控制）。</li><li>为上层应用提供统一的系统服务（如文件读写、进程管理）。</li></ul></li><li><strong>开发要求</strong>：<ul><li>需深入理解指令集、汇编语言及系统级编程语言（如C）。</li></ul></li></ul><p><strong>5. 汇编语言层</strong></p><ul><li><strong>组成</strong>：助记符（如<code>ADD</code>, <code>MOV</code>）与目标机器指令一一对应。</li><li><strong>功能</strong>：<ul><li>提供机器指令的符号化表示，简化编程。</li><li>需通过<strong>汇编器</strong>转换为机器码。</li></ul></li><li><strong>特点</strong>：<ul><li>程序员仍需熟悉硬件细节（如寄存器布局、内存寻址）。</li></ul></li></ul><p><strong>6. 高级语言层（最顶层）</strong></p><ul><li><strong>组成</strong>：与机器无关的编程语言（如Python、Java、C++）。</li><li><strong>功能</strong>：<ul><li>通过抽象语法（如变量、循环）隐藏硬件细节。</li><li>程序通过<strong>编译器/解释器</strong>转换为机器码。</li></ul></li><li><strong>开发要求</strong>：<ul><li>仅需掌握语法规则、算法与数据结构，无需了解底层硬件。</li></ul></li></ul><p><strong>各层特点对比</strong></p><table><thead><tr><th><strong>层级</strong></th><th><strong>抽象程度</strong></th><th><strong>依赖硬件细节</strong></th><th><strong>开发复杂度</strong></th></tr></thead><tbody><tr><td>高级语言层</td><td>最高</td><td>无</td><td>最低</td></tr><tr><td>汇编语言层</td><td>低</td><td>高</td><td>高</td></tr><tr><td>操作系统层</td><td>中</td><td>中</td><td>中</td></tr><tr><td>指令系统层</td><td>低</td><td>极高</td><td>极高</td></tr><tr><td>硬件层</td><td>无</td><td>完全依赖</td><td>最高</td></tr></tbody></table><ul><li>硬件层与微程序层实现物理计算能力。</li><li>操作系统层管理资源并向上提供接口。</li><li>汇编/高级语言层构建用户可编程的软件生态。</li></ul><blockquote><p>硬件和软件<mark>逻辑</mark>上有等价性，硬件执行<strong>速度高</strong>，软件<strong>灵活</strong><br>软件的功能可以用硬件取代</p></blockquote><table><thead><tr><th><strong>特性</strong></th><th><strong>硬件实现</strong></th><th><strong>软件实现</strong></th></tr></thead><tbody><tr><td><strong>性能与速度</strong></td><td>高（专用电路并行处理，如ASIC、FPGA）</td><td>低（依赖通用CPU串行执行）</td></tr><tr><td><strong>灵活性</strong></td><td>低（功能固化，修改需重新设计电路）</td><td>高（代码可动态更新，适应新需求）</td></tr><tr><td><strong>开发成本</strong></td><td>高（需定制芯片设计、流片费用）</td><td>低（编写代码，复用通用硬件）</td></tr><tr><td><strong>适用场景</strong></td><td>高频交易、实时信号处理、密码学加速</td><td>操作系统、应用软件、动态调整功能的场景</td></tr></tbody></table><h3 id="存储过程">存储过程</h3><ul><li>主存储器：包含存储体、MAR、MDR<ul><li><strong>存储体</strong>：<ul><li>由若干个<strong>存储单元</strong>组成<ul><li>每个存储单元由若干个<strong>存储元件</strong>组成<ul><li>每个存储元件能存储1位二进制数0/1</li></ul></li><li>一个存储单元中可存储一串二进制信息，称这串二进制信息为一个<strong>存储字</strong>，这串二进制信息的位数称为<strong>存储字长</strong>（可以是8位、16位或32位等）</li></ul></li><li>给每个存储单元都赋予一个编号，称为<strong>存储单元的地址</strong></li></ul></li><li><strong>内存地址寄存器（MAR）</strong><ul><li>功能：</li><li>保存<strong>数据目标地址</strong>或<strong>数据源地址</strong>，用于寻址主存单元。</li><li><strong>连接存储器与地址总线</strong>，传递地址信号。</li><li>物理实现：</li><li>集成于CPU中，但逻辑上属于<strong>主存储器</strong>的组成部分。</li><li>位数与容量：</li><li><strong>位数 = 存储单元地址数量</strong>（如10位MAR支持2^10=1024个存储单元，即1KB），反应最多可寻址的存储单元个数<br>存储单元：存放一串二进制代码，存储器一次操作的基本单位。</li><li><mark>MAR长度与<strong>PC（程序计数器）</strong> 一致</mark>，决定寻址空间。</li></ul></li><li><strong>内存数据寄存器（MDR）</strong>：<br><strong>临时缓存从主存（内存）读取或写入的数据或指令</strong>，充当 CPU 与主存之间的<strong>数据中转站</strong><ul><li><strong>读取数据时</strong>：暂存从主存读取的指令或操作数。</li><li><strong>写入数据时</strong>：暂存待写入主存的数据。</li><li>功能：</li><li>是CPU与主存之间的<strong>唯一数据通道</strong></li><li><strong>连接存储器与数据总线</strong>，传输数据信号。</li><li>物理实现：<ul><li>集成于CPU中，逻辑上属于<strong>主存储器</strong>的组成部分。</li></ul></li><li>位数与字长：</li><li><strong>位数 = 存储字长</strong>（如32位MDR对应32位存储单元）。<br>存储字长：存储单元中二进制代码的位数每个存储单元赋予一个地址号</li><li>一般为字节（8位）的整数倍（如32位、64位）。</li></ul></li></ul></li></ul><p>eg1.MAR=4位，MDR=8位<br>存储单元个数16，存储字长8位<br>eg2.若存储字长为8位，MAR的位数(长度)为16位，则存储体的总容量<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327120211029.png" alt="image.png"></p><p><strong>主存储器的核心组件</strong><br>主存储器是计算机中用于存储程序和数据的关键部件，其核心功能是通过地址访问存储单元，完成数据的读写操作。<br><strong>主存储器按地址存取</strong>：通过MAR指定地址，MDR暂存数据，存储体存储二进制信息。</p><table><thead><tr><th><strong>组件</strong></th><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>存储体</strong></td><td>存储二进制数据，由多个存储单元构成，每个单元有唯一地址。</td><td>每个存储单元的大小通常为1字节（8位），地址范围由地址总线的宽度决定。</td></tr><tr><td><strong>地址寄存器MAR</strong></td><td>存放当前要访问的存储单元的地址。</td><td>MAR（Memory Address Register）接收来自CPU或总线的地址信号。</td></tr><tr><td><strong>数据寄存器MDR</strong></td><td>暂存从存储器读出的数据或待写入存储器的数据。</td><td>MDR（Memory Data Register）在读写操作中作为数据缓冲，确保数据稳定传输。</td></tr><tr><td><strong>时序控制逻辑</strong></td><td>产生存储器操作所需的控制信号（如读/写信号、片选信号），协调各部件时序。</td><td>控制逻辑根据CPU指令生成时序信号，确保操作按步骤执行。</td></tr><tr><td>![image.png</td><td>350](<a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326113413143.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326113413143.png</a>) <strong>读操作流程（MAR→存储体→MDR→CPU）</strong></td><td></td></tr></tbody></table><ol><li><strong>加载地址</strong>：CPU将目标地址送入<strong>MAR</strong>。</li><li><strong>发出读命令</strong>：时序控制逻辑生成<strong>读信号</strong>（Read Enable）。</li><li><strong>数据读取</strong>：存储体根据MAR中的地址定位存储单元，将数据送入<strong>MDR</strong>。</li><li><strong>数据传输</strong>：CPU从MDR中读取数据。</li></ol><p><strong>写操作流程（CPU→MDR→MAR→存储体）</strong></p><ol><li><strong>加载地址与数据</strong>：CPU将目标地址送入<strong>MAR</strong>，待写数据送入<strong>MDR</strong>。</li><li><strong>发出写命令</strong>：时序控制逻辑生成<strong>写信号</strong>（Write Enable）。</li><li><strong>数据写入</strong>：存储体根据MAR中的地址定位存储单元，将MDR中的数据写入该单元。</li></ol><p><strong>时序控制逻辑的作用</strong></p><ul><li><strong>同步操作</strong>：确保地址加载、数据读写等步骤按严格时序执行。<ul><li>例如：在读取时，MAR地址稳定后，才允许存储体输出数据到MDR。</li></ul></li><li><strong>信号生成</strong>：<ul><li><strong>读信号（RE）</strong>：允许存储体输出数据到MDR。</li><li><strong>写信号（WE）</strong>：允许MDR数据写入存储体。</li><li><strong>片选信号（CS）</strong>：在多存储器模块中选择目标模块。</li></ul></li></ul><p>eg.假设CPU执行指令 <code>LOAD [0x1000]</code>（读取地址0x1000的数据）：</p><ol><li>CPU将地址<code>0x1000</code>写入MAR。</li><li>时序逻辑发出读信号，存储体将地址<code>0x1000</code>对应的数据送入MDR。</li><li>CPU从MDR中读取数据并存入寄存器（如AX）。</li></ol><p>CPU通过PC和MAR向存储器发去取指令请求(发送指令地址)并且把读信号送到控制线上，一起告诉存储器要读哪一个地方的信息；<br>读出来的信息传到MDR，如果是指令则传到IR；如果是数据就送到寄存器，再送到ALU计算，或者直接送到ALU。</p><p><mark><strong>计算机如何分辨此时取出的是数据还是指令呢？</strong></mark><br>根据<mark>指令周期</mark>的不同阶段判断。<br>在<strong>取指令</strong>阶段取出的是<strong>指令</strong>，在<strong>执行</strong>指令阶段取出的是<strong>数据</strong>。</p><h2 id="计算机的基本工作原理">计算机的基本工作原理</h2><h3 id="计算机硬件组成的细化">计算机硬件组成的细化</h3><h4 id="加减乘除操作">加减乘除操作</h4><ul><li><strong>累加器ACC</strong>，一种<strong>专用寄存器</strong>（非ALU直接部件），用于暂存ALU<strong>前一次运算的结果</strong>或<strong>初始操作数（被加数/被减数/被乘数/乘机高位/被除数/余数）</strong>，在加减法中作为运算的基准值。（例如：执行<code>A = A + B</code>时，累加器存放<code>A</code>的值）</li><li><strong>乘商寄存器MQ</strong>：在乘法和除法运算中，存储<strong>乘数/商/乘积低位</strong>。<ul><li><strong>乘法存储逻辑</strong>：<ul><li>乘法结果的位数通常是操作数的两倍（如 8位 × 8位 → 16位），因此需两个寄存器存储。</li><li><strong>ACC存储高位，MQ存储低位</strong><br>例如：<code>5 (ACC) × 3 (MQ)</code> → 结果为 <code>15</code>，高位 <code>0</code>（若为 8位系统）存 <code>ACC</code>，低位 <code>15</code> 存 <code>MQ</code>。</li><li><strong>X存储被乘数</strong><br>在乘法前，<code>ACC</code> 的被乘数需暂存至 <code>X</code>，以便释放 <code>ACC</code> 存储结果高位。</li></ul></li><li><strong>除法存储逻辑</strong>：<ul><li><strong>ACC存储余数，MQ存储商</strong>：<br>例如：<code>15 ÷ 4</code> → 商为 <code>3</code>（存 <code>MQ</code>），余数 <code>3</code>（存 <code>ACC</code>）。</li><li><strong>X存储除数</strong>：从主存加载除数到 <code>X</code>，保证除法操作的稳定性。</li></ul></li></ul></li><li><strong>操作数寄存器X</strong>：用于临时存储<strong>从主存或指令中获取的第二个操作数（加数/减数/乘数/除数）</strong></li></ul><table><thead><tr><th>寄存器</th><th>加法</th><th>减法</th><th>乘法</th><th>除法</th></tr></thead><tbody><tr><td><strong>ACC</strong></td><td>被加数 → 和</td><td>被减数 → 差</td><td>被乘数（操作前）→ 乘积高位</td><td>被除数 → 余数</td></tr><tr><td><strong>MQ</strong></td><td>—</td><td>—</td><td>乘数（操作前）→ 乘积低位</td><td>→ 商</td></tr><tr><td><strong>X</strong></td><td>加数</td><td>减数</td><td>被乘数（从ACC复制）</td><td>除数</td></tr><tr><td>M 表示主存储器中某个存储单元的地址</td><td></td><td></td><td></td><td></td></tr><tr><td>(M)表示地址为M的存储单元中的内容</td><td></td><td></td><td></td><td></td></tr><tr><td>ACC 表示累加器</td><td></td><td></td><td></td><td></td></tr><tr><td>(ACC)表示累加器中的内容</td><td></td><td></td><td></td><td></td></tr><tr><td>MQ 表示乘商寄存器</td><td></td><td></td><td></td><td></td></tr><tr><td>(MQ)表示乘商寄存器中的内容</td><td></td><td></td><td></td><td></td></tr><tr><td>X表示操作数寄存器</td><td></td><td></td><td></td><td></td></tr><tr><td>(X)表示操作数寄存器中的内容</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>加法操作过程<ol><li>(M)→X：从主存地址 M 取出内容（加数），送入操作数寄存器 X</li><li>(ACC)+(X)→ACC：累加器 ACC 中的被加数与 X 中的加数相加，结果（和）存回 ACC。</li></ol></li><li>减法操作过程<ol><li>(M)→ X</li><li>(ACC)-(X)→ACC</li></ol></li><li>乘法操作过程<ol><li>(M) → MQ：取出存放在主存中地址为M的存储单元中的内容(M)(乘数)，送到乘商寄存器MQ中</li><li>(ACC)→X：将累加器ACC中的内容(ACC)(被乘数)，送到操作数寄存器X中</li><li>(X) x (MQ)→ ACC // MQ：将操作数寄存器X中的内容(X)(被乘数)与乘商寄存器MQ中的内容(MQ)(乘数)相乘结果(积)的高位保留在累加器ACC中，低位保留在乘商寄存器MQ中</li></ol></li><li>除法操作过程<ol><li>(M)-&gt;X</li><li>(ACC) ÷ (X)→ MQ</li></ol></li></ul><p>共同点：取出存放在主存储器中地址为M的存储单元中的内容(M)，送到某个寄存器中</p><p>y = a * b + c<br>a=2,b=3,c=1,y=0<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327101752137.png" alt="image.png"><br>注：</p><ol><li>程序执行前，由于冯诺依曼“存储程序”的思想，先将程序的机器指令序列（操作码+地址码）存放到存储体</li><li>程序执行前，先将程序的第一条指令的地址存放到PC中，PC=0，</li><li>任何指令的执行都从<strong>取指令</strong>开始，此时 CPU 需要从内存中读取指令。因此，取指令阶段固定为<strong>读操作</strong></li><li>执行阶段由操作码决定读/写</li><li><strong>MAR</strong>：仅用于存储地址，不参与数据处理。</li><li><strong>MDR</strong>：作为 CPU 与主存间的数据缓冲，所有读写均需经过 MDR。</li></ol><p><strong>执行流程</strong>：</p><ol><li><p>取数 <code>a</code> 至 ACC</p><ul><li><strong>指令地址</strong>：<code>0</code>（PC=0）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC=0) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，从内存地址 <code>0</code> 读取指令 <code>000001 0000000101</code>（操作码 <code>取数</code>，地址码 <code>5</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>1</code>。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327105809223.png" alt="image.png"></li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“取数”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=5 → MAR</code>，将IR中保存的指令地址码送至内存的MAR中，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，从地址 <code>5</code> 读取数据 <code>a=2</code>送入MDR。</li><li><code>(MDR) → ACC</code>，将 <code>a=2</code> 存入累加器 ACC。</li></ul></li></ol></li></ul></li><li><p>乘法 <code>a * b</code>，结果存于 ACC</p><ul><li><strong>指令地址</strong>：<code>1</code>（PC=1）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000100 0000000110</code>（操作码 <code>乘法</code>，地址码 <code>6</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>2</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“乘法”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=6 → MAR</code>，发送地址 <code>6</code> 到内存。</li><li><code>M(MAR) → MDR</code>，从地址 <code>6</code> 读取数据 <code>b=3</code>。</li><li><code>(MDR) → MQ</code>，将 <code>b=3</code> 存入乘商寄存器 MQ。</li><li><code>(ACC)=2 → X</code>，将 ACC 的值 <code>2</code> 送入 X 寄存器。</li><li><code>(MQ)*(X) → ACC</code>，ALU 执行 X * MQ，结果为 <code>6</code>，存入 ACC</li></ul></li></ol></li></ul></li><li><p>加法 <code>a * b + c</code>，结果存于 ACC</p><ul><li><strong>指令地址</strong>：<code>2</code>（PC=2）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC=2) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000011 0000000111</code>（操作码 <code>加法</code>，地址码 <code>7</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>3</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“加法”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=7 → MAR</code>，发送地址 <code>7</code> 到内存。</li><li><code>M(MAR) → MDR</code>，从地址 <code>7</code> 读取数据 <code>c=1</code>。</li><li><code>(MDR) → X</code>，将 <code>c=1</code> 送入 X 寄存器。</li><li><code>(ACC)+(X) → ACC</code>，ALU 执行 ACC + X，结果为 <code>6 + 1 = 7</code>，存入 ACC。</li></ul></li></ol></li></ul></li><li><p>存数 <code>a * b + c</code> 至主存单元 <code>y</code></p><ul><li><strong>指令地址</strong>：<code>3</code>（PC=3）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000010 0000001000</code>（操作码 <code>存数</code>，地址码 <code>8</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>4</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“存数”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=8 → MAR</code>，发送地址 <code>8</code> 到内存。</li><li><code>(ACC)=7 → MDR</code>，将 ACC 的值 <code>7</code> 存入 MDR。</li><li><code>(MDR) → M(MAR)</code>，将 <code>7</code> 写入内存地址 <code>8</code>（存储变量 <code>y</code>）。</li></ul></li></ol></li></ul></li><li><p>停机</p><ul><li><strong>指令地址</strong>：<code>4</code>（PC=4）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC=4) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000110 0000000000</code>（操作码 <code>停机</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>5</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“停机”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li>CPU 终止当前进程，结果 <code>y=7</code> 已存入内存地址 <code>8</code>。</li></ul></li></ol></li></ul></li></ol><p><strong>最终结果</strong></p><ul><li><strong>内存地址 <code>8</code></strong>：存储 <code>y=7</code>。</li><li><strong>寄存器状态</strong>：<ul><li><code>ACC=7</code>，<code>MQ=3</code>（乘法中间值），<code>X=1</code>（加法操作数）。</li><li><code>PC=5</code>，指向下一条指令地址（已停机）。</li></ul></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327110944602.png" alt="image.png"></p><h4 id="1-取指令阶段"><strong>1. 取指令阶段</strong></h4><p><strong>目标</strong>：将下一条指令从主存读取到指令寄存器（IR）。<br><strong>步骤</strong>：</p><ol><li><strong>PC → MAR</strong><ul><li><strong>操作</strong>：将程序计数器（PC）当前存储的指令地址送入内存地址寄存器（MAR）。</li><li><strong>说明</strong>：<code>PC→MAR</code> 表示 <code>(PC)</code>（PC 中存储的值）通过数据通路传递到 MAR。</li></ul></li><li><strong>MAR → 地址线，控制器发送读信号</strong><ul><li><strong>操作</strong>：MAR 的内容被送至地址线，控制器向主存发送读信号。</li><li><strong>说明</strong>：主存根据地址线上的地址和读信号，定位存储单元。</li></ul></li><li><strong>主存 → 数据线 → MDR</strong><ul><li><strong>操作</strong>：主存将指定地址的指令通过数据线传输到内存数据寄存器（MDR）。</li></ul></li><li><strong>MDR → IR</strong><ul><li><strong>操作</strong>：MDR 中的指令被送入指令寄存器（IR）。</li><li><strong>结果</strong>：IR 中存储当前待执行的指令。</li></ul></li><li><strong>更新 PC</strong><ul><li><strong>操作</strong>：<code>(PC) + 1 → PC</code>，为取下一条指令准备地址。</li><li><strong>注意</strong>：<ul><li><strong>括号不可省略</strong>：运算时必须写为 <code>(PC)+1→PC</code>，表示对 PC 的值进行运算。</li><li><strong>数据通路省略</strong>：<code>PC→MAR</code> 可简写，但运算表达式需严格保留括号。</li></ul></li></ul></li></ol><h4 id="2-分析指令阶段"><strong>2. 分析指令阶段</strong></h4><p><strong>目标</strong>：解码指令并生成控制信号。<br><strong>步骤</strong>：</p><ol><li><strong>OP(IR) → CU</strong><ul><li><strong>操作</strong>：从 IR 中提取操作码（OP），送入控制单元（CU）。</li></ul></li><li><strong>CU 译码与生成控制信号</strong><ul><li><strong>操作</strong>：CU 根据操作码生成对应的控制信号，分发到各执行部件。</li><li><strong>示例</strong>（取数指令）：<ul><li>CU 生成“读主存”信号，激活总线控制线，准备读取操作数。</li></ul></li></ul></li></ol><h4 id="3-执行指令阶段"><strong>3. 执行指令阶段</strong></h4><p><strong>目标</strong>：执行当前指令的操作（以取数指令为例）。<br><strong>步骤</strong>：</p><ol><li><strong>Ad(IR) → MAR</strong><ul><li><strong>操作</strong>：将 IR 中的地址码（操作数地址）送入 MAR。</li><li><strong>示例</strong>：若指令为 <code>取数a至ACC</code>，地址码指向变量 <code>a</code> 的存储地址。</li></ul></li><li><strong>MAR → 地址线，控制器发送读信号</strong><ul><li><strong>操作</strong>：主存根据 MAR 中的地址和读信号，定位操作数存储单元。</li></ul></li><li><strong>主存 → 数据线 → MDR</strong><ul><li><strong>操作</strong>：主存将操作数通过数据线传输到 MDR。</li></ul></li><li><strong>MDR → ACC</strong><ul><li><strong>操作</strong>：MDR 中的操作数被送入累加器（ACC）。</li><li><strong>结果</strong>：ACC 中存储了所需的数据（如 <code>a=2</code>）。</li></ul></li></ol><h3 id="常见指令">常见指令</h3><p><code>LOAD</code> 指令是计算机体系结构中的一种<strong>数据传输指令</strong>，其核心功能是<strong>将数据从内存（主存）加载到CPU的寄存器中</strong>。例如，在汇编语言中，<code>LOAD R1, [0x1000]</code> 表示将内存地址 <code>0x1000</code> 处的数据加载到寄存器 <code>R1</code> 中。<br><code>LOAD</code> 指令的执行遵循经典的 <strong>5 阶段指令周期</strong>：</p><ol><li><p><strong>取指（Fetch）</strong></p><ul><li>CPU 根据程序计数器（PC）的值，从内存中读取指令（如 <code>LOAD R1, [0x1000]</code>）到指令寄存器（IR）。</li><li>PC 自动递增，指向下一条指令地址。</li></ul></li><li><p><strong>译码（Decode）</strong></p><ul><li>控制单元（CU）解析指令的操作码（<code>LOAD</code>），确定操作类型。</li><li>提取目标寄存器（<code>R1</code>）和内存地址（<code>0x1000</code>）。</li></ul></li><li><p><strong>执行（Execute）</strong></p><ul><li>将内存地址 <code>0x1000</code> 写入存储器地址寄存器（MAR）。</li><li>生成读信号（Read Enable），通知内存准备数据。</li></ul></li><li><p><strong>访存（Memory Access）</strong></p><ul><li>内存根据 MAR 中的地址定位存储单元，将数据送至存储器数据寄存器（MDR）。</li></ul></li><li><p><strong>写回（Write Back）</strong></p><ul><li>将 MDR 中的数据写入目标寄存器 <code>R1</code>，完成加载操作。</li></ul></li><li><p><strong>不同寻址方式对 <code>LOAD</code> 指令的影响</strong><br><code>LOAD</code> 指令的具体行为取决于其使用的<strong>寻址方式</strong>：</p></li></ol><ul><li><p><strong>直接寻址</strong><br>指令中直接包含内存地址（如 <code>LOAD R1, [0x1000]</code>）。<br><strong>优点</strong>：简单直观。<br><strong>缺点</strong>：地址固定，灵活性低。</p></li><li><p><strong>间接寻址</strong><br>指令中的地址指向另一个内存地址（如 <code>LOAD R1, [[R2]]</code>）。<br><strong>优点</strong>：支持动态地址计算。<br><strong>缺点</strong>：需要多次访存，速度较慢。</p></li><li><p><strong>寄存器间接寻址</strong><br>地址存储在寄存器中（如 <code>LOAD R1, [R2]</code>）。<br><strong>优点</strong>：高效灵活，适合循环遍历数组。</p></li><li><p><strong>立即数寻址</strong><br>指令直接包含数据（如 <code>LOAD R1, #42</code>）。<br><strong>注</strong>：严格来说，这属于加载立即数到寄存器，而非内存操作。</p></li></ul><ol><li><p><strong><code>LAD X, ACC</code>（Load Address to ACC）</strong></p><ul><li><strong>功能</strong>：将主存地址 <code>X</code> 的内容加载到累加器 ACC。</li><li><strong>操作</strong>：<br>$R[\text{ACC}] \leftarrow M[X]$</li><li><strong>硬件流程</strong>：<ul><li>将 <code>X</code>（地址码）送入 MAR，读取主存数据到 MDR，再传输到 ACC。</li></ul></li></ul></li><li><p><strong><code>SUB ACC, Z</code>（Subtract）</strong></p><ul><li><strong>功能</strong>：从 ACC 中减去主存地址 <code>Z</code> 的值，结果存回 ACC。</li><li><strong>操作</strong>：<br>$R[\text{ACC}] \leftarrow R[\text{ACC}] - M[Z]$</li><li><strong>硬件流程</strong>：<ul><li>读取 <code>Z</code> 的值到 MDR → 送入 ALU 的 X 寄存器 → ALU 执行减法 → 结果存回 ACC。<br><strong>取值周期（Fetch Cycle）</strong><br><strong>目标</strong>：从主存中读取下一条指令到 IR，并更新 PC。<br><strong>步骤</strong>：</li></ul></li></ul></li><li><p><strong><code>PC → BUS → MAR</code></strong></p><ul><li>程序计数器（PC）的值通过总线送至内存地址寄存器（MAR）。</li></ul></li><li><p><strong><code>M(MAR) → 数据线 → MDR</code></strong></p><ul><li>主存根据 MAR 的地址，通过数据总线将指令送入内存数据寄存器（MDR）。</li><li><strong>控制信号</strong>：控制器发送 <strong>读信号（MemRead=1）</strong>。</li></ul></li><li><p><strong><code>MDR → BUS → IR</code></strong></p><ul><li>MDR 中的指令通过总线送入指令寄存器（IR）。</li></ul></li><li><p><strong><code>(PC) + 1 → PC</code></strong></p><ul><li>PC 自增，指向下一条指令的地址。</li></ul></li></ol><p><strong>执行周期（Execute Cycle）</strong></p><h5 id="1-LAD-X-ACC-的执行流程"><strong>1. <code>LAD X, ACC</code> 的执行流程</strong></h5><ol><li><strong><code>Ad(IR) → BUS → MAR</code></strong><ul><li>将 IR 中的地址码 <code>X</code> 送入 MAR。</li></ul></li><li><strong><code>M(MAR) → 数据线 → MDR</code></strong><ul><li>主存根据 MAR 的地址，通过数据总线将数据送入 MDR。</li><li><strong>控制信号</strong>：控制器发送 <strong>读信号（MemRead=1）</strong>。</li></ul></li><li><strong><code>MDR → BUS → ACC</code></strong><ul><li>MDR 中的数据通过总线送入累加器 ACC。</li></ul></li></ol><h5 id="2-SUB-ACC-Z-的执行流程"><strong>2. <code>SUB ACC, Z</code> 的执行流程</strong></h5><ol><li><strong><code>Ad(IR) → BUS → MAR</code></strong><ul><li>将 IR 中的地址码 <code>Z</code> 送入 MAR。</li></ul></li><li><strong><code>M(MAR) → 数据线 → MDR</code></strong><ul><li>主存根据 MAR 的地址，读取 <code>Z</code> 的值到 MDR。</li></ul></li><li><strong><code>MDR → X</code></strong><ul><li>MDR 的值送入 ALU 的输入寄存器 X。</li></ul></li><li><strong>`ALU 执行减法运算</strong><ul><li><p>ALU 计算 <code>ACC - X</code>，结果存回 ACC。</p><ul><li><code>LAD</code>、<code>SUB</code> 等涉及数据加载的指令 → 读操作（<code>MemRead=1</code>）。</li><li><code>STO</code>（存数指令） → 写操作（<code>MemWrite=1</code>）。</li></ul></li></ul></li><li><strong>总线控制</strong>：<ul><li>数据总线在取值和执行阶段分别传输指令和数据。</li><li>地址总线始终由 MAR 驱动。</li></ul></li></ol><h5 id="1-操作数的加载是否必须通过主存？"><strong>1. 操作数的加载是否必须通过主存？</strong></h5><ul><li><strong>否</strong>：<ul><li>操作数可直接来自寄存器（如 <code>ADD R1, R2</code>），无需访问主存。</li><li>若操作数在主存中（如 <code>ADD [M]</code>），则需通过 <code>X</code> 或 <code>MQ</code> 中转。</li></ul></li><li><strong>示例对比</strong>：<ul><li><strong>直接寄存器操作</strong>：<code>ADD ACC, X</code>（假设指令支持）。</li><li><strong>主存操作</strong>：<code>ADD [M]</code> → <code>(M)→X → (ACC)+(X)→ACC</code>。</li></ul></li></ul><h5 id="2-加法实例"><strong>2. 加法实例</strong></h5><ul><li><strong>指令</strong>：<code>ADD [0x1000]</code></li><li><strong>步骤</strong>：<ol><li>从主存地址 <code>0x1000</code> 加载数据到 <code>X</code>（如 <code>X=5</code>）。</li><li><code>ACC</code> 中的值（如 <code>ACC=10</code>）与 <code>X</code> 相加，结果存回 <code>ACC</code>（<code>ACC=15</code>）。</li></ol></li></ul><h5 id="3-乘法实例"><strong>3. 乘法实例</strong></h5><ul><li><strong>指令</strong>：<code>MUL [0x2000]</code></li><li><strong>步骤</strong>：<ol><li>从主存地址 <code>0x2000</code> 加载乘数到 <code>MQ</code>（如 <code>MQ=3</code>）。</li><li>将 <code>ACC</code> 中的被乘数（如 <code>ACC=5</code>）暂存到 <code>X</code>。</li><li>执行乘法：<code>X=5</code> × <code>MQ=3</code> → 结果高位 <code>0</code>（ACC）、低位 <code>15</code>（MQ）。</li></ol></li></ul><h5 id="4-除法实例"><strong>4. 除法实例</strong></h5><ul><li><strong>指令</strong>：<code>DIV [0x3000]</code></li><li><strong>步骤</strong>：<ol><li>从主存地址 <code>0x3000</code> 加载除数到 <code>X</code>（如 <code>X=4</code>）。</li><li><code>ACC</code> 中的被除数（如 <code>ACC=15</code>）除以 <code>X=4</code> → 商 <code>3</code>（MQ），余数 <code>3</code>（ACC）。</li></ol></li></ul><h2 id="计算机系统的性能指标">计算机系统的性能指标</h2><p>计算机系统的性能指标是用来衡量计算机系统在各种操作和任务中的<strong>工作效率、执行速度以及处理能力</strong>的标准。<br>计算机系统的性能指标可以<strong>帮助人们评估计算机系统</strong>的整体表现，从而更好地了解系统<strong>在不同方面的优势和限制</strong><br>计算机系统的性能指标与硬件和软件都有关</p><ul><li><p>硬件与计算机系统性能的关系</p><ul><li>硬件是构建计算机系统的<strong>物理组件</strong>(例如CPU、内存、外部设备等)。</li><li>硬件对于计算机系统的性能有着重要影响，因为它决定了系统的<font color="#ff0000">计算能力、数据传输速率和存储容量</font>。<ul><li>CPU的时钟频率决定了CPU每秒钟可以执行的指令数量。</li><li>内存带宽会影响数据的读写速率。</li></ul></li></ul></li><li><p>软件与计算机系统性能的关系</p><ul><li>软件包括用于控制、管理、应用计算机系统的各类系统软件和应用软件。</li><li>软件的优化可以显著影响计算机系统的性能，因为<strong>合理的算法和代码</strong>实现可以<strong>更有效地利用硬件资源</strong>。<ul><li>操作系统的调度算法会影响多任务处理的效率，从而影响系统的响应时间。</li><li>在图像处理任务中，优化的软件算法可以减轻CPU和内存的负担，提高图形处理速度。</li><li>软件层面的并行计算可以更好地利用多核处理器，提高吞吐量。</li></ul></li></ul></li><li><p><strong>硬件是性能的上限</strong>，决定了系统的理论能力。</p></li><li><p><strong>软件是性能的下限</strong>，决定了硬件的实际利用率。</p></li><li><p><strong>软硬件协同优化</strong>是提升计算机系统性能的核心路径。</p></li></ul><h3 id="计算机硬件相关性能指标">计算机硬件相关性能指标</h3><h4 id="基本性能指标">基本性能指标</h4><ol><li><strong>机器字长</strong></li><li><strong>主存容量</strong></li><li><strong>吞吐量</strong></li><li><strong>响应时间</strong></li></ol><h4 id="与运行速度相关的性能指标">与运行速度相关的性能指标</h4><ol><li><strong>CPU时钟频率和时钟周期</strong></li><li><strong>CPI</strong></li><li><strong>CPU执行时间</strong></li><li><strong>IPC</strong></li><li><strong>MIPS</strong></li><li><strong>MFLOPS</strong></li></ol><p>概念解释：</p><ol><li><p><strong>机器字长（字长）</strong></p><ul><li><strong>定义</strong>：计算机一次能处理的二进制位数（如32位、64位），即b的数量。<br><mark>机器字长 = 用于整数运算的ALU位数 = 通用寄存器宽度 = 数据总线宽度</mark><ul><li>数据总线宽度（数据字长）= 数据总线一次能并行传送信息的位数（如32位总线一次传输4字节）</li></ul></li><li>早期：指令字长（一个指令字中包含的二进制代码的位数）=存储字长（一个存储单元存储的二进制代码的长度）=机器字长<ul><li>随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。</li><li>若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令</li><li>若指令字长等于存储字长（如均为32位），单次访存即可取指，此时<strong>取指周期=机器周期</strong>。</li></ul></li><li><strong>影响</strong>：<ul><li>字长越长，<strong>数的表示范围</strong>就越大、<strong>精度</strong>也越高。<ul><li><strong>无符号整数</strong>：0∼2<sup>n</sup>−1（n 为字长）。</li><li><strong>有符号整数</strong>：−2<sup>n−1</sup>∼2<sup>n−1</sup>−1</li><li><strong>单精度（32位）</strong>：指数8位，尾数23位，范围约 ±10<sup>38</sup></li><li><strong>双精度（64位）</strong>：指数11位，尾数52位，范围约 ±10<sup>308</sup></li></ul></li><li>字长越长，<strong>计算精度</strong>也越高<br>字长越长，小数部分的位数越多，精度越高。</li><li>字长还会影响<strong>计算速度</strong></li><li><strong>数据处理能力</strong>：字长越大，单次处理的数据量越大。</li><li><strong>地址空间</strong>：32位系统最大支持4GB内存，64位系统支持更大内存。</li><li><strong>硬件复杂度</strong>：字长增加可能提高电路复杂度。</li></ul></li></ul></li><li><p><strong>主存容量</strong></p><ul><li><strong>定义</strong>：主存储器（内存）的总存储容量，通常以GB或TB为单位。</li><li><strong>公式</strong>：<br><strong>主存容量=N×M</strong>(位，即比特b)<br>M：主存中存储单元的总数量。<br>N：每个存储单元可存储的二进制位数（如8位、64位）。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327161644732.png" alt="image.png|400"><br>增加主存(内存)容量可以<strong>减少</strong>程序运行期间对<strong>辅存</strong>(外存)的访问，由于访问内存的速度远大于访问外存的速度，因此可以提高程序的<strong>执行速度</strong>，进而提高计算机系统的性能。</li></ul></li><li><p><strong>吞吐量</strong></p><ul><li><strong>定义</strong>：<font color="#ff0000">单位时间内系统完成的任务量</font>（如每秒处理请求数），系统吞吐量<font color="#f79646">主要取决于主存的存取周期</font>。</li><li><strong>影响因素</strong>：<ul><li>CPU的处理能力</li><li>内存（主存）的访问速度</li><li>外存的访问速度</li></ul></li></ul></li><li><p><strong>响应时间</strong></p><ul><li><strong>定义</strong>：从向计算机系统<font color="#ff0000">提交作业开始</font>，到系统<font color="#ff0000">完成作业为止所需要的时间</font>（包括CPU处理、I/O等待等）。</li><li>通常把用户感觉到的响应时间分成以下两个时间：<ul><li>CPU时间：运行一个程序所花费的时间<ul><li><strong>CPU执行时间</strong>：执行用户程序本身所花费的CPU时间（一般基于此对性能评价）</li><li>系统CPU时间：为执行用户程序而花费在操作系统上的时间</li></ul></li><li>其他时间（等待时间）：用户访问内存(主存)、外存(辅存)、其他外部设备所花费的时间</li></ul></li><li>系统性能和CPU性能有一定的区别：</li><li>系统性能：系统响应时间，与CPU外的其他部分也有关系</li><li>CPU性能：用户CPU时间，即CPU执行时间<br>主频、CPI和指令条数是相互制约的</li></ul></li><li><p><strong>CPU时钟频率与时钟周期</strong></p><ul><li><strong>时钟频率</strong>：CPU每秒的时钟周期数（单位：Hz，如3.0 GHz）<br>比喻：每秒敲鼓次数。<br>频率越高，CPU“敲鼓”越快，理论上干活速度更快。</li><li><strong>时钟周期</strong>：每个<strong>脉冲信号</strong>的时间，单个时钟周期的时间（$T = \frac{1}{\text{频率}}$），如3.0 GHz对应0.333 ns），是<mark>CPU中最小的时间单位</mark>，执行指令的每个动作至少需要1个时钟周期。<br>时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成。<br>时钟周期以相邻状态单元间组合逻辑电路的最大延迟时间为基准确定。<br>时钟周期也以指令流水线的每个流水段的最大延迟时间确定。<br>比喻：每次敲鼓的时间间隔，比如鼓手每0.3秒敲一次<br>周期越短，每个动作越快完成</li><li><strong>作用</strong>：对于同类型的计算机，同一指令执行所需的CPU时钟周期的数量是一样的，因此CPU的时钟频率越高，该指令的执行速度就越快。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327130641138.png" alt="image.png"></li></ul></li><li><p><strong>CPI（Cycles Per Instruction）</strong><br><a href="https://www.doc88.com/p-38199244559254.html">计算机组成原理作业- CPU性能含解答 - 道客巴巴 (doc88.com)</a></p><ul><li><strong>定义</strong>：<mark>执行一条指令所需的平均时钟周期数。</mark><br>不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其 CPI指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，即平均CPI。<br>比喻：炒一盘菜平均需要几次操作<br>CPI越低效率越高</li><li><strong>计算</strong>：<br>$\text{CPI} = \frac{\text{总时钟周期数}}{\text{总指令数}}$<br>$CPI = \sum_{i=1}^{n} (CPI_i \times P_i)$ Pi是相应指令所占比例<br>$总周期 = Σ(指令条数 × CPI)$</li><li><strong>优化</strong>：通过流水线、超标量等技术降低CPI。</li><li><strong>系统结构、指令集、计算机组织</strong>都会影响 CPI，而<strong>时钟频率</strong>并不会影响CPI，但缩短每个时钟周期的时间，可加快指令的执行速度。</li></ul></li><li><p><strong>CPU执行时间</strong><br>即运行一个程序所花费的时间</p><ul><li><strong>公式</strong>：<br>$\text{执行时间} = \text{总时钟周期数} \times \text{时钟周期}$<br>$\text{执行时间} = \text{总指令数} \times \text{CPI} \times \text{时钟周期}$<br>比喻：做一桌菜的总时间 = 菜的数量 × 每道菜的步骤 × 每步的时间</li><li>CPU性能（CPU执行时间）取决于：主频、CPI、指令条数【三者相互制约】</li><li><strong>缩短程序执行时间</strong>：<ul><li>减少指令数（算法优化）</li><li>降低CPI（架构优化）</li><li>提高频率（硬件升级）</li><li>优化数据通路结构，可以有效提高计算机系统的吞吐量</li><li>编译优化</li></ul></li></ul></li><li><p><strong>IPC</strong>（每个周期能做多少事，衡量指令执行速度）</p><ul><li><strong>定义</strong>：每个时钟周期执行的指令数，与CPI互为倒数（$\text{IPC} = \frac{1}{\text{CPI}}$）。<br>比喻：每个动作能炒几盘菜</li><li><strong>示例</strong>：CPI=0.5 → IPC=2，表示每个周期执行2条指令，高效。IPC越高，效率越高</li></ul></li><li><p><strong>IPS</strong>（每秒能做多少事，即）<br>IPC 表示每个时钟周期可运行的指令的数量，IPS 表示<strong>每秒可运行的指令的数量</strong>，$IPS = 频率 × IPC=频率  / 平均CPI$<br>IPS越高，说明CPU处理指令的速度越快</p></li><li><p><strong>MIPS（Million Instructions Per Second）</strong></p></li></ol><ul><li><strong>每秒执行百万条指令数</strong>，衡量CPU的<strong>整数运算吞吐量</strong>。<br>越大，性能越高</li><li><strong>公式</strong>： $\text{MIPS} = \frac{\text{时钟频率} \times \text{IPC}}{10^6} = \frac{\text{总指令数}}{\text{执行时间} \times 10^6}$</li><li>用MIPS对不同的机器进行性能比较有时是不准确的主要原因如下。<ul><li>不同机器的指令集不同，并且指令的功能也不同，在某种机器上的某一条指令的功能可能在另一种机器上需要用多条指令来实现,</li><li>不同机器的CPI和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同</li></ul></li></ul><ol start="10"><li><strong>MFLOPS（Million Floating-Point Operations Per Second）</strong></li></ol><ul><li><strong>每秒百万次浮点运算</strong>，衡量浮点计算能力。</li><li>用于==科学计算的计算机中，是标志系统性能最有用的参数 ==</li><li><strong>计算</strong>：$\text{MFLOPS} = \frac{\text{浮点操作总数}}{\text{执行时间} \times 10^6}$</li><li>MFLOPS不能全面反映计算机系统的性能。MFLOPS仅反映浮点运算速度，其值与所使用的测试程序相关。不同测试程序中包含的浮点运算量不同，测试得到的结果也不相同。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327153330760.png" alt="image.png">GTPEZ<br>采用并行技术是实现高性能计算的重要途径，现今超级计算机均采用多处理器来增强并行处理能力。</li></ul><h3 id="指标间的关系与权衡"><strong>指标间的关系与权衡</strong></h3><table><thead><tr><th><strong>指标</strong></th><th><strong>优化策略</strong></th><th><strong>实际应用中的权衡</strong></th></tr></thead><tbody><tr><td><strong>时钟频率</strong></td><td>提高制程工艺、优化散热</td><td>高频可能导致功耗和发热增加</td></tr><tr><td><strong>CPI/IPC</strong></td><td>改进微架构（如流水线、乱序执行）</td><td>复杂架构可能增加设计成本和延迟</td></tr><tr><td><strong>MIPS/MFLOPS</strong></td><td>优化指令集、并行计算</td><td>MIPS忽略指令类型差异，MFLOPS依赖任务特性</td></tr><tr><td><strong>吞吐量 vs 响应时间</strong></td><td>负载均衡、异步处理</td><td>高吞吐量可能牺牲单任务响应速度</td></tr></tbody></table><h3 id="使用基准程序进行性能评估">使用基准程序进行性能评估</h3><ul><li>基准程序(Benchmark)是一组特定的程序，专门用于评测计算机的性能。</li><li>这些程序能够有效地模拟计算机在处理实际任务时的表现。</li><li>在不同计算机上运行同样的基准程序，通过比较各计算机运行基准程序的时间，从而评测它们各自的性能不同基准程序的评测重点不同，例如CPU性能、图形性能、存储性能、浮点数计算性能、并行计算性能等。目前国际上流行的基准程序主要有SPEC、Linpack、Dhrystone、Whetstone、NPB等。</li><li>使用基准程序进行计算机性能评测也存在一些缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或编译器开发者可能针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得不到准确的性能评测结果。</li></ul><p>衡量计算机系统性能是一项比较复杂的任务，很难仅凭借单一指标进行精确衡量。<br>上述一些衡量计算机性能的指标之间也不是完全独立的，改变其中一项指标可能会影响到其他指标。</p><h2 id="第一章错题">第一章错题</h2><ol><li><p>2017年公布的全球超级计算机TOP500排名中，我国“神威·太湖之光”超级计算机蝉联第其浮点运算速度为93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为()<br>A. 9.3x1013次   B.9.3x1015次   c.9.3千万亿次   D.9.3亿亿次<br>d</p></li><li><p>假定基准程序A在某计算机上的运行时间为100s，其中90s为CPU时间，其余为I/O时间。若CPU速度提高50%，I/0速度不变，则运行基准程序A所耗费的时间是()。A.55s   B. 60s   C.65s   D.70s<br>新CPU时间 = 原CPU时间 / 1.5 = 90秒 / 1.5 = 60秒<br>新总时间 = 新CPU时间 + I/O时间 = 60秒 + 10秒 = 70秒</p></li><li><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327163149037.png" alt="image.png"></p></li><li><p>有三种不同的处理器A,B和C执行同样的指令集，A的时钟频率为3GHz，CPI为1.5；B的时钟频率为2.5GHz，CPI为1.0；C的时钟频率为4GHz，CPI为2.2.<br>（1）以每秒钟执行的指令数目为标准，哪个处理器的性能最高？<br>（2）如果每个处理器执行一个程序都需花费10秒的时间，求它们的时钟周期数和指令数。<br>（3）我们试图把执行时间减少30%，但这会引起CPI增加20%。问：时钟频率应该是多少才能达到程序执行时间减少30%的目的？<br>(1)已知时钟频率和CPI，可以求MIPS反映性能，分别是2，2.5，1.82 GIPs。B最高<br>(2)时钟周期数=运行时间×f，时钟周期数分别是3，2.5，4 × 10^10<br>CPI=时钟周期数/指令条数，指令数分别是2，2.5，0.18 × 10^10<br>(3)原执行时间 ($T = \frac{\text{指令数} \times \text{CPI}}{\text{频率}}$)<br>新要求：$0.7T = \frac{\text{指令数} \times 1.2\text{CPI}}{\text{新频率}}$<br>解得：$\text{新频率} = \frac{1.2}{0.7} \times \text{原频率} \approx 1.714 \times \text{原频率}$<br>新频率需为1.71f</p></li><li><p>CPU 不包括()<br>A.地址寄存器   B.地址译码器   C.指令寄存器(IR)   D.通用寄存器<br>CPU 主要包括 运算器（ALU、通用寄存器、状态寄存器） 和 控制器（IR、PC、CU）。地址译码器 属于存储器（如主存）的组成部分，用于将地址总线信号转换为对特定存储单元的访问，不属于 CPU 内部结构。</p></li><li><p>在运算器中，不包含()<br>A.状态寄存器   B.数据总线   C. ALU   D.地址寄存器<br>数据总线在运算器中用于传输操作数，选d</p></li><li><p>若一个8位的计算机系统以 16 位来表示地址，则该计算机系统有( )个地址空间<br>A.256   B.65535   C.65536   D. 131072<br>8 位计算机表明计算机字长为8位，即一次可以处理8位的数据；而 地址空间大小仅由地址位数决定，与数据总线宽度（8位）无关，16 位表示地址码的长度，因此该机器有2^6=65536 个地址空间。</p></li><li><p>()是程序运行时的存储位置，包括所需的数据。<br>A.数据通路   B.主存   C.硬盘   D.操作系统<br>b</p></li><li><p>机器 A 的主频为 800MHz，某程序在 A 上运行需要 12s。现在硬件设计人员想设计机器B,希望该程序在B上的运行时间能缩短为 8s，使用新技术后可使B的主频大幅度提高，但在B上运行该程序所需的时钟周期数为在A上的1.5倍。则机器B的主频至少应为( )。<br>时钟周期数=主频×运行时间<br>时钟周期数A=800M×12s     时钟周期数B=1.5×800M×12s<br>主频B=1.5×800M×12s / 8  = 1.8GHz</p></li><li><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330210323965.png" alt="image.png">CPI1=2.5，CPI2=2，MIPS1=500×10^6 / 2.5×10^6=200，MIPS2=500×10^6 / 2×10^6=250；总周期 = Σ(指令条数 × CPI)，总周期1=15，总周期2=10，所以执行时间1=总时钟周期数×时钟周期=15×2ns=30ns，执行时间2=20ns，d</p></li><li><p>若机器 M的主频为 1.5GHz，在 M 上执行程序P的指令条数为 5x10^5，P的平均 CPI为 1.2，则P在M 上的指令执行速度和用户 CPU 时间分别为( )。<br>A.08GIPS,0.4ms       B.08GIPS,0.4us<br>C.1.25GIPS,0.4ms    D. 1.25GIPS,0.4us<br>IPC指令执行速度=主频/CPI=1.5GHz/1.2=1.25GIPS<br>CPU时间=指令数×CPI/主频=5x10^5×1.2/1.5×10^9=0.4ms</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统组成（硬件/软件） </tag>
            
            <tag> 五大功能部件 </tag>
            
            <tag> 总线系统（地址/数据/控制总线） </tag>
            
            <tag> 指令集体系结构（ISA） </tag>
            
            <tag> 系统层次结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 1 章 操作系统概述：计算机系统基础</title>
      <link href="/post/b328aa63.html"/>
      <url>/post/b328aa63.html</url>
      
        <content type="html"><![CDATA[<h1>1 操作系统的基本概念</h1><h2 id="1-1-概念">1.1 概念</h2><ul><li><strong>操作系统</strong>：指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合<br>管理<strong>软件</strong>【应用程序】和<strong>硬件</strong>【裸机（包含CPU、主板、网卡、内存、磁盘、键盘、鼠标）】资源、为程序提供服务的<strong>程序【软件】</strong><br>软件：<ul><li>系统软件【操作系统、编译器、数据库管理系统】、支撑软件、应用软件</li><li>操作系统是一种<mark>系统软件（</mark><strong><mark>应用</mark></strong><mark>软件安装在</mark><strong><mark>操作系统</mark></strong><mark>里，</mark><strong><mark>系统</mark></strong><mark>软件安装在</mark><strong><mark>硬件</mark></strong><mark>上）</mark></li></ul></li><li>为上层用户，应用程序提供简单易用的服务</li><li>os位于硬件和用户之间</li><li>是计算机系统中<strong>最基本</strong>的系统软件</li><li>操作系统是伴随着计算机的诞生而诞生的</li><li>目标：<mark>有效性</mark>（提高系统资源利用率【批处理】、提高系统的吞吐量）、<mark>方便性</mark>、可扩充性、开放性</li></ul><h2 id="1-2-特征">1.2 特征</h2><ul><li><strong>并发和共享</strong>是最基本的两个特征，两者互为存在条件：<ul><li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题</li><li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法执行</li></ul></li><li>如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性</li><li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性</li></ul><h3 id="1-2-1-并发【时间段】">1.2.1 并发【时间段】</h3><ul><li><strong>并发</strong>：两个或多个事件在<strong>同一时间间隔</strong>内发生</li><li><strong>并行</strong>【时间点】：系统具有同时进行运算或操作的特性，在<strong>同一时刻</strong>能完成两种或两种以上的工作<ul><li>可并行的有【处理机与设备】【处理机与通道】【设备与设备】</li><li><strong>不可并行的有【进程与进程】</strong></li></ul></li><li>引入进程的目的是使程序能够<strong>并发</strong>执行</li><li>并发能力越强，吞吐量越多，并行有很明显的物理极限。并发对于操作系统更重要。</li><li>并发总体上执行时间快</li><li>并发具有<mark>不可再现性</mark></li><li><strong>注意</strong>：<ul><li><strong>单核 CPU</strong> 同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>地执行</li><li><strong>多核 CPU</strong> 同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>地执行</li></ul></li></ul><h3 id="1-2-2-共享">1.2.2 共享</h3><ul><li><strong>共享</strong>：指系统中的资源可供内存中多个并发执行的程序共同使用<ul><li><strong>互斥共享方式</strong>：一个坑的厕所<ul><li>规定一段时间内只允许一个进程访问该资源【称为<strong>临界资源</strong>】</li><li>允许多个程序在同一个共享资源上独立而互不干扰的工作，一种资源在一段时间内只能满足一个请求</li><li>A 访问完并释放该资源后，才允许另一进程访问</li><li>如：计算机系统中的大多数物理设备及某些软件中所有的栈、变量和表格，打印机，磁带机</li></ul></li><li><strong>同时访问方式</strong>：<ul><li>宏观上，一段时间内由多个进程“同时”访问某类资源</li><li>微观上，进程之间可能<strong>交替</strong>对该资源进行访问</li><li>如：磁盘设备，一些可重入代码编写的文件，音频设备，视频设备</li></ul></li><li>生活实例：<br>互斥共享 ： QQ 、微信，同一时间段摄像头只能分配给其中一个进程。<br>同时共享 ： QQ、微信，同时发送文件 ， 宏观上看，两边都在读取并发送文件，微观上看两个进程交替访问硬盘</li></ul></li></ul><h3 id="1-2-3-虚拟">1.2.3 虚拟</h3><ul><li><strong>虚拟</strong>：指将一个物理上的实体变为若干逻辑上的对应物</li><li>用于实现虚拟的技术称为<strong>虚拟技术</strong></li><li><strong>虚拟处理器技术</strong>：多道程序并发执行的方法，来分时使用一个处理器。用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU<ul><li><strong>时分复用技术TDM</strong>（把时间分成小片段，让不同信号在不同时间传输）【一个小时内和三个朋友依次20min通话】eg.CPU（处理器）的分时共享<ul><li>虚拟处理机技术：”四核八线程″</li><li>虚拟设备技术：虚拟打印机</li></ul></li><li><strong>空分复用技术SDM （用于增加通信系统容量的方法）eg.内存空间、虚拟存储器</strong><ul><li>虚拟磁盘技术（允许多个用户或信号在同一时间通过不同的空间通道进行传输）【高速不同车道】：将一块硬盘虚拟出若干个卷</li><li>虚拟存储器技术【使用书架（磁盘）扩展书桌空间（内存）】</li></ul></li></ul></li></ul><h3 id="1-2-4-异步">1.2.4 异步</h3><ul><li>进程的<strong>异步性</strong>：多道程序环境下，允许多个程序<mark>并发执行【走走停停的】</mark>；单处理机环境下，多个程序<mark>分时交替</mark>执行。<ul><li>程序执行的<mark>不可预知性</mark><ul><li>获得运行的时机</li><li>因何暂停</li><li>每道程序需要多少时间</li><li>不同程序的性能，比如计算多少，I/O多少</li></ul></li><li>宏观上“一气呵成”，微观上“走走停停”由于资源有限，进程的执行不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进</li></ul></li></ul><p>关系：</p><ul><li><strong>并发和共享互为存在条件</strong>？<ul><li>共享性要求操作系统中同时运行的多道程序</li><li>若只有单道程序正在运行，则不存在共享的可能</li><li>并发性难以避免的导致多道程序同时访问同一个资源</li><li>如果多到程序无法共享部分资源(比如磁盘)，则无法并发。</li></ul></li><li><strong>异步性的原因（体现方面）</strong><ol><li>进程的异步性，进程以人们不可预知的速度向前推进</li><li>程序的不可再现性，即程序执行的结果有时是不确定的</li><li>程序执行时间的不可预知性，即每个程序何时执行，执行顺序以及完成时间是不确定的</li></ol></li></ul><h2 id="1-3-功能和目标">1.3 功能和目标</h2><h3 id="1-3-1-管理">1.3.1 管理</h3><h4 id="1-3-1-1-处理器管理">1.3.1.1 处理器管理</h4><ul><li>处理机的分配和运行都以进程（或线程）为基本单位</li><li>对处理器的管理可归结为<strong>对进程的管理</strong></li><li>主要功能：进程控制+进程同步+进程通信+死锁处理+处理机调度</li></ul><h4 id="1-3-1-2-存储器管理">1.3.1.2 存储器管理</h4><ul><li>为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率</li><li>主要功能：内存分配与回收+地址映射+内存保护+共享和内存扩充</li></ul><h4 id="1-3-1-3-文件管理">1.3.1.3 文件管理</h4><ul><li>计算机的信息都是以文件的形式存在的</li><li>操作系统重负责文件管理的部分称为<strong>文件系统</strong></li><li>主要功能：文件存储空间的管理+目录管理+文件读写管理和保护</li></ul><h4 id="1-3-1-4-设备管理">1.3.1.4 设备管理</h4><ul><li>主要是完成用户的I/O请求，方便用户使用各种设备，提高设备的利用率</li><li>主要功能：缓冲管理+设备分配+设备处理+虚拟设备</li></ul><h3 id="1-3-2-操作系统给用户的接口">1.3.2 操作系统给用户的接口</h3><h4 id="1-3-2-1-命令接口">1.3.2.1 命令接口</h4><ul><li>用户利用这些操作命令来组织和控制作业的执行</li><li><strong>联机命令接口</strong>【交互式命令接口】：eg.<strong>命令解释器</strong>【一句一句】<ul><li>适用于分时或实时系统的接口</li><li>由一组键盘操作命令组成</li><li>用户发送一个命令，系统就执行一次，主要特点是交互性</li></ul></li><li><strong>脱机命令接口</strong>【批处理命令接口】：eg.编辑器 单道、多道【一堆一堆】<ul><li>适用于批处理系统的接口</li><li>由一组作业控制命令组成</li><li>用户一次性发送命令清单，系统按清单执行，中途不能干预</li></ul></li></ul><h4 id="1-3-2-2-程序接口">1.3.2.2 程序接口</h4><ul><li>可以在程序中进行<strong>系统调用</strong>来使用程序接口，面向<strong>程序员</strong></li><li>普通用户不能直接使用程序接口，只能通过<strong>程序代码间接使用</strong></li><li><mark>是应用程序请求操作系统服务的唯一方式</mark> <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250418200621613.png" alt="image.png"></li></ul><h3 id="1-3-3-实现了对计算机资源的扩充">1.3.3 实现了对计算机资源的扩充</h3><ul><li>裸机：没有任何软件支持的计算机，仅构成计算机系统的物质基础</li><li>在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li><li>扩充机器/虚拟机：覆盖了软件的机器</li></ul><h1>2 操作系统的发展历程</h1><p>设备驱动程序组成的原始操作系统→管理程序→操作系统<br>基本类型：<mark>批处理操作系统、分时、实时</mark></p><h2 id="2-1-手工操作阶段">2.1 手工操作阶段</h2><ul><li>此阶段无操作系统</li><li>所有工作都要人工干预</li><li><strong>缺点</strong>：<ul><li>用户独占全机，资源利用率低</li><li>CPU 等待手工操作，CPU 的利用不充分</li></ul></li></ul><h2 id="2-2-批处理阶段【效率和灵活性】">2.2 批处理阶段【效率和灵活性】</h2><ul><li>为了解决人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾，出现了批处理系统</li><li>单道批处理系统：主要解决CPU、内存和I/O设备利用率不足的问题</li><li>多道批处理系统：主要解决I/O操作时CPU闲置问题</li></ul><h3 id="2-2-1-单道批处理系统【提速，但利用率低】">2.2.1 单道批处理系统【提速，但利用率低】</h3><ul><li>引入<strong>脱机输入/输出技术</strong>（用外围机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出</li><li><strong>特点</strong>：自动性、顺序性、单道性</li><li><strong>优点</strong>：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li><li><strong>缺点</strong>：<ul><li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序</li><li>CPU 有大量的时间是在空闲等待 I/O 完成，资源利用率依然很低</li></ul></li></ul><h3 id="2-2-2-多道批处理系统【并行，但不能人机交互】">2.2.2 多道批处理系统【并行，但不能人机交互】</h3><ul><li>允许多个用户将若干个作业提交给计算机系统集中处理</li><li>当某道程序因请求 I/O 操作而暂停运行时，通过中断机制，CPU 转去运行另一道程序</li><li><strong>特点</strong>：多道、宏观上并行、微观上串行</li><li><strong>优点</strong>：<ul><li>资源利用率高，多道计算机共享计算机资源，从而使各种资源得到充分利用</li><li>系统吞吐量大，CPU 和其他资源保持“忙碌”状态</li></ul></li><li><strong>缺点</strong>：<ul><li>用户的响应时间较长</li><li>不提供人机交互能力</li></ul></li></ul><h2 id="2-3-分时操作系统">2.3 分时操作系统</h2><ul><li>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互</li><li><strong>特点</strong>：<mark>同时性（多路性）、交互性、独立性、及时性</mark></li><li><strong>优点</strong>：<ul><li>用户请求可以被即时响应，<strong>解决了人机交互问题</strong></li><li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互<strong>独立</strong>，感受不到别人的存在</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>作业/用户优先级相同，不能优先处理一些紧急任务</strong></li><li>操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</li></ul></li></ul><h2 id="2-4-实时操作系统">2.4 实时操作系统</h2><ul><li>为了能在某个时间限制内完成某些<strong>紧急任务</strong>而不需要时间片排队</li><li><strong>硬实时系统</strong>：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生【飞机的飞行自动控制系统，导弹控制系统，自动驾驶系统】</li><li><strong>软实时系统</strong>：能够接受偶尔违反时间规定且不会引起任何永久性的损害【飞机订票系统、银行管理系统】</li><li><strong>特点</strong>：<mark>及时性（以用户能接受的等待时间为准）、可靠性（多级容错）</mark></li><li><strong>优点</strong>：能够优先响应一些紧急任务，某些紧急任务不需时间片排队</li></ul><h2 id="2-5-其他几种操作系统">2.5 其他几种操作系统</h2><ul><li><p><strong>网络操作系统</strong>：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）【资源共享，远程通信】</p></li><li><p><strong>分布式操作系统</strong>：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong></p></li><li><p><strong>个人计算机操作系统</strong>：如 Windows XP、MacOS，方便个人使用</p></li></ul><p>unix分时多用户多任务，dos单用户单任务<br>主要由于Linux小部分由汇编，大部分由c语言，使其易移植</p><h1>3 操作系统的运行环境</h1><h2 id="3-1-处理器运行模式">3.1 处理器运行模式</h2><p>程序运行的过程其实就是CPU执行一条一条的机器指令的过程<br>在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型</p><h3 id="3-1-1-两种指令">3.1.1 两种指令</h3><h4 id="3-1-1-1-特权指令">3.1.1.1 特权指令</h4><ul><li>指不允许用户直接使用的指令</li><li>如：<strong>对 I/O 设备操作指令、存取特殊寄存器的指令、有关访问程序状态的指令、置中断指令、关中断指令、清内存指令、置时钟指令</strong></li></ul><h4 id="3-1-1-2-非特权指令">3.1.1.2 非特权指令</h4><ul><li>允许用户直接使用的指令</li><li>不能直接访问系统中的软硬件资源，只限于访问用户的地址空间</li><li>如：访管指令（trap），用户程序通过<strong>系统调用</strong>（如读写文件、申请内存等）主动触发的中断<br>核心目的：让用户程序能够安全地请求操作系统内核的服务</li></ul><h3 id="3-1-2-两种处理器状态">3.1.2 两种处理器状态</h3><h4 id="3-1-2-1-核心态【管态、内核态】">3.1.2.1 核心态【管态、内核态】</h4><ul><li>内核（即os）可以执行CPU能执行除访管指令之外的任何指令，用户程序只能执行特权指令之外的指令</li><li>只能在核心态运行的指令和程序：<ul><li>直接管理系统资源的指令（如<strong>设置时钟</strong>、<strong>启动/关闭硬件设备</strong>、<strong>切换进程</strong>、<strong>进程调度程序</strong>、<strong>设置中断</strong>、<strong>缺页处理</strong>程序、<strong>系统调用命令</strong>）<br>实现程序<strong>并发</strong>就一定离不开时钟管理（因为所有程序的并发执行都依赖精准计时）</li><li>系统状态修改指令（如修改<strong>中断向量表</strong>、<strong>切换 CPU的运行模式</strong>）</li><li>系统控制指令（如<strong>停机</strong>指令、<strong>重启</strong>指令）</li><li><strong>中断机制</strong>相关的指令【<strong>时钟中断</strong>程序】<br>由时钟部件发来的中断信号，比如进程切换</li><li><strong>原语</strong>相关的指令</li><li>陷入指令的调用</li><li>磁盘调度程序，设备驱动程序（用于和硬件设备进行通信）</li></ul></li></ul><h4 id="3-1-2-2-用户态【目态】">3.1.2.2 用户态【目态】</h4><ul><li>此时运行的是用户程序，只能执行非特权指令</li><li>在用户态运行的指令和程序/发生的事件：<ul><li><strong>命令解释程序</strong>【属于命令接口，面向用户】</li><li>普通的<strong>数据处理</strong>指令、<strong>流程控制</strong>指令、<strong>读操作</strong>指令都不会影响系统的安全和整体状态，可以在用户态执行。（<strong>存数</strong>指令、<strong>寄存器清零</strong>指令）</li><li><strong>访管</strong>/Trap 指令，<strong>跳转</strong>指令，<strong>转移</strong>指令，<strong>压栈指令</strong>，设置<strong>断点</strong>指令</li><li>广义指令 (系统调用) 的调用</li><li><strong>执行编译程序</strong></li><li><strong>外部中断</strong>，<strong>缺页</strong>（用户态发生缺页中断，进入内核态执行缺页中断服务程序）</li><li>陷入指令的执行</li><li>库函数</li></ul></li></ul><h4 id="3-1-2-3-如何变态">3.1.2.3 如何变态</h4><ul><li><strong>内核态 —&gt; 用户态</strong>：执行一条<strong>特权指令</strong>——<strong>修改 PSW</strong> 的标志位为“用户态”，这个动作意味着操作系统将主动让出 CPU 使用权</li><li><strong>用户态 —&gt; 内核态</strong>：由“<strong>中断</strong>”引发，<strong>硬件自动完成</strong>变态过程，触发中断信号意味着操作系统将强行夺回 CPU 的使用权</li><li><strong>注意</strong>：<ul><li>CPU 中的程序状态字寄存器（PSW），其中有个二进制位，1 表示“内核态”，0 表示“用户态”</li><li>需要操作系统介入的地方，都会触发中断信号</li></ul></li></ul><h3 id="3-1-3-操作系统的内核">3.1.3 操作系统的内核</h3><ul><li><strong>内核</strong>：是计算机上配置的<strong>底层软件</strong>，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是<strong>内核程序</strong></li></ul><h4 id="3-1-3-1-与硬件关联紧密的模块">3.1.3.1 与硬件关联紧密的模块</h4><ul><li><strong>时钟管理</strong>：实现计时功能</li><li><strong>中断处理</strong>：负责实现中断机制</li><li><strong>原语</strong>：<ul><li>是一种特殊的程序【是一个程序段（由多个指令组成）】</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>用来完成某个特定功能</li><li>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作可以被定义为原语。</li><li>运行在<mark>内核</mark>空间，底层逻辑通常由<mark>关中断</mark>和<mark>开中断</mark>来实现</li><li>该程序运行具有<strong>原子性</strong>（运行只能一气呵成，不可中断）</li><li>运行时间较短，调用频繁</li></ul></li></ul><h4 id="3-1-3-2-对系统资源进行管理的功能">3.1.3.2 对系统资源进行管理的功能</h4><p>一般只涉及到对数据结构的操作，不涉及硬件</p><ul><li><strong>设备管理</strong>：完成设备的请求和释放，以及设备启动等功能【缓冲区、设备控制块】</li><li><strong>进程管理</strong>：完成进程的创建，撤销，阻塞及唤醒等功能【作业控制块、进程控制块】</li><li><strong>存储器管理</strong>：完成内存的分配，回收以及获取作业占用内存区大小及地址等功能【存储器分配与回收】</li></ul><p>操作系统的主要功能：处理机管理、存储器管理、文件管理、设备管理、作业管理</p><h2 id="3-2-中断和异常">3.2 中断和异常</h2><h3 id="3-2-1-基本概念">3.2.1 基本概念</h3><ol><li>中断是os<strong>内核夺回CPU使用权的唯一途径</strong>，没有中断程序会一直在CPU运行，不可能实现程序并发</li><li>中断使CPU从 <strong>用户态→内核态</strong></li><li>中断处理程序一定是<strong>内核</strong>程序，需要运行在内核态</li><li>由硬件生成并被os捕获和处理的一种事件，用于提高多道程序环境下CPU利用率</li><li>类型<ul><li><strong>内中断</strong>（异常、例外）：与当前执行的指令<mark>无关</mark>，中断信号来源于CPU内部<br>异常不能被屏蔽，一旦出现，就应立即处理</li><li>当前执行的指令是<strong>非法</strong>的：地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为0、非法指令、试图在用户态下执行特权指令</li><li>分类：<ul><li><strong>陷入/陷阱</strong>：有应用程序<mark>主动</mark>引发（但不是由应用程序产生的，是由CPU产生的，一般是<strong>系统调用</strong>实现，不是特权指令）eg.<strong>条件陷阱指令、访管中断</strong>【软件中断】</li><li><strong>故障</strong>：由<mark>错误</mark>条件引发，可能会被<mark>内核</mark>程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。eg.<strong>缺页故障</strong>【软件中断】</li><li><strong>终止</strong>：由<mark>致命</mark>错误引发，由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。eg.整数除0、非法使用特权指令、控制器出错、存储器校验错【硬件中断】</li></ul></li><li>故障异常和陷入异常属于软件中断（程序性异常），终止异常和外部中断属于硬件中断</li><li><strong>外中断</strong>（中断）：与当前执行的指令有关，中断信号来源于CPU外部<ul><li>eg.<strong>时钟中断</strong>、<strong>I/O中断</strong></li><li><strong>可屏蔽</strong>：打印机中断</li><li><strong>不可屏蔽</strong>：一旦提出请求，CPU必须无条件响应 eg.电源掉电</li></ul></li></ul></li></ol><ul><li>中断机制的基本实现原理<ul><li>检查中断信号：<ul><li>内中断：CPU在执行指令时，会检查是否有异常发生</li><li>外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理</li></ul></li><li>找到相应的中断处理程序：通过<strong>中断向量表</strong>实现</li></ul></li></ul><h3 id="3-2-2-中断处理-VS-子程序调用">3.2.2 中断处理 VS 子程序调用</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>中断处理</strong></th><th><strong>子程序调用</strong></th></tr></thead><tbody><tr><td><strong>独立性</strong></td><td>中断处理程序与被中断程序<strong>相互独立</strong>（如键盘中断与正在运行的浏览器无关）。</td><td>子程序与主程序是<strong>同一程序</strong>的组成部分（如主函数调用计算函数）。</td></tr><tr><td><strong>触发方式</strong></td><td><strong>随机发生</strong>（如硬件异常、时钟中断），无法预测触发时机。</td><td><strong>由代码预先安排</strong>（通过 <code>CALL</code> 指令显式调用），触发时机由程序员控制。</td></tr><tr><td><strong>硬件/软件依赖</strong></td><td>依赖<strong>硬件中断控制器</strong>检测信号，并自动触发上下文保存（如保存 PC 和 PSW）。</td><td>纯<strong>软件行为</strong>，由编译器生成的指令直接跳转，无硬件参与。</td></tr><tr><td><strong>入口地址获取</strong></td><td>通过<strong>中断向量表</strong>由硬件自动定位（如键盘中断对应固定编号，查表获取处理程序地址）。</td><td>入口地址由 <code>CALL</code> 指令<strong>直接给出</strong>（如 <code>CALL 0x1234</code>）。</td></tr><tr><td><strong>上下文保存</strong></td><td><strong>硬件隐式保存</strong> PC 和 PSW（无需代码显式操作）。</td><td><strong>软件显式保存</strong> PC（通过压栈），<strong>不保存 PSW</strong>（标志位已无意义）。</td></tr><tr><td><strong>多请求处理</strong></td><td>需硬件裁决<strong>多个中断优先级</strong>（如电源故障 &gt; 鼠标点击）。</td><td>无并发调用冲突，按代码顺序执行（如先调用 <code>funcA</code> 再调用 <code>funcB</code>）。</td></tr><tr><td><strong>PSW 保存必要性</strong></td><td><strong>必须保存</strong>：中断可能发生在关键操作中间（如比较指令后），恢复时需保持原标志位状态。</td><td><strong>无需保存</strong>：子程序调用时已通过跳转决策（如 <code>if(a==b)</code> 已执行完），后续流程不依赖原标志位。</td></tr><tr><td><strong>典型场景</strong></td><td>硬件事件（磁盘 I/O 完成）、程序异常（除零错误）、外部输入（鼠标点击）。</td><td>代码逻辑复用（如数学计算、字符串处理）、模块化编程。</td></tr></tbody></table><h2 id="3-3-系统调用">3.3 系统调用</h2><h3 id="3-3-1-基本概念">3.3.1 基本概念</h3><ul><li>操作系统对应用程序和程序员提供的接口，是一套接口（API）的集合，只能通过<mark>用户程序间接使用</mark></li><li>系统调用是<mark>用户</mark>空间和<mark>硬件</mark>设备之间添加的一个中间层</li><li>由操作系统实现，给应用程序调用，应用程序通过系统调用来请求访问操作系统内核服务，在<strong>内核态</strong>处理运行<br><mark>发出系统调用请求</mark>是在<mark>用户态</mark>，而<mark>对系统调用的相应处理</mark>是在<mark>内核态</mark>进行</li><li>系统调用需要触发<strong>陷入</strong>指令（Trap）<br>陷入指令在<mark>用户</mark>空间执行，主动把CPU的控制权还给os，请求os的服务，执行陷入指令后立即引发一个<mark>内中断</mark>，使CPU<mark>进入内核态</mark></li><li>OS 通过提供系统调用<strong>避免用户程序直接访问外设</strong></li><li>在用户程序中，凡是与资源有关的操作（存储分配、I/O 传输及管理文件等）都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成，<strong>保证系统的稳定性和安全性</strong></li><li>每个系统调用都有唯一的系统调用号</li><li>凡是与<mark>共享资源</mark>有关的操作、会直接影响到其他进程的操作，就一定需要操作系统介入，就需要通过<mark>系统调用</mark>来实现</li></ul><h3 id="3-3-2-系统调用-VS-库函数">3.3.2 系统调用 VS 库函数</h3><ul><li><strong>库函数</strong>：<ul><li>是<strong>语言或应用程序的一部分</strong>，可以运行在<strong>用户态</strong>中</li><li>有的库函数是对系统调用的进一步封装，有的库函数没有使用系统调用（取绝对值函数）</li><li>库函数可以很方便地调试，系统调用通常不可替换</li><li>库函数属于过程调用，开销较小；系统调用需要在用户空间和内核空间进行上下文切换，开销较大</li></ul></li><li><strong>系统调用</strong>：<ul><li>是<strong>操作系统的一部分</strong>，是内核为用户提供的程序接口，运行在<strong>内核态</strong></li><li>系统调用要完成上下文的切换和状态的转换，因此未使用系统调用的库函数，执行效率较高</li></ul></li></ul><h3 id="3-3-3-按功能分类">3.3.3 按功能分类</h3><ul><li>设备管理：完成设备的请求或释放+设备启动</li><li>文件管理：完成文件的读+写+创建+删除</li><li>进程控制：完成进程的创建+撤销+阻塞+唤醒</li><li>进程通信：完成进程之间的信息传递或信号传递</li><li>内存管理：完成内存的分配+回收+获取作业占用内存区大小及始址</li></ul><h3 id="3-3-4-系统调用的过程">3.3.4 系统调用的过程</h3><ol><li>传参</li><li>陷入指令/Trap指令/访管【执行系统调用】（用户态）</li><li>由操作系统内核程序处理系统调用请求（内核态）</li><li>返回应用程序<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250419204528208.png" alt="image.png"></li></ol><h3 id="3-3-5-系统调用-VS-一般过程调用">3.3.5 系统调用 VS 一般过程调用</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>一般过程调用</strong></th><th><strong>系统调用</strong></th></tr></thead><tbody><tr><td><strong>运行状态</strong></td><td>调用方与被调用方运行在<strong>同一状态</strong>（均为用户态或均为内核态）。  <br>（如用户程序调用自身函数，都在用户态）</td><td>调用方在<strong>用户态</strong>，被调用方在<strong>内核态</strong>。  <br>（必须通过中断切换至内核态执行特权操作）</td></tr><tr><td><strong>上下文保存</strong></td><td>仅需保存**程序计数器（PC）**的值。</td><td>需保存完整的<strong>程序状态字（PSW）<strong>和</strong>程序计数器（PC）</strong>。</td></tr><tr><td><strong>被调用程序归属</strong></td><td>属于同一程序或库（用户级代码）。</td><td>属于操作系统内核（系统级代码）。</td></tr><tr><td><strong>进入机制</strong></td><td>直接通过 <code>CALL</code> 指令跳转至目标地址。</td><td>通过<strong>软中断指令</strong>（如 <code>int 0x80</code>）触发中断，由内核接管并路由到目标处理程序。</td></tr><tr><td><strong>硬件依赖</strong></td><td>纯<strong>软件</strong>逻辑，无需硬件支持。</td><td>依赖 CPU 的中断处理<strong>硬件</strong>（如自动保存寄存器状态）。</td></tr><tr><td><strong>返回行为</strong></td><td>执行完毕后立即返回调用点继续执行。</td><td>执行完毕后可能触发<strong>进程重新调度</strong>（如时间片耗尽），只有原进程优先级最高时才返回。</td></tr><tr><td><strong>安全性</strong></td><td>无权限切换，调用双方权限相同。</td><td>用户态→内核态切换，通过权限隔离保障系统安全。</td></tr><tr><td><strong>典型场景</strong></td><td>函数调用、算法逻辑处理。</td><td>文件读写、网络通信、进程创建等需内核介入的操作。</td></tr></tbody></table><h1>4 操作系统结构</h1><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250419210618668.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250419210940104.png" alt="image.png"></p><ul><li><strong>大内核</strong><ul><li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li><strong>微内核</strong><ul><li>只把核心功能放入内核，其余功能用用户进程的形式运行在用户态</li><li><strong>微内核优点</strong>：<ul><li>内核足够小，结构清晰，方便维护</li><li>基于C/S模式</li><li>应用机制与策略分离原理</li><li>采用面向对象技术</li></ul></li><li><strong>微内核缺点</strong>：<ul><li>需要频繁的在核心态和用户态之间切换，执行效率不高</li><li>开销较大</li></ul></li><li>典型的大内核/宏内核/单内核操作系统：Linux、UNIX</li><li>典型的微内核操作系统：Windows NT</li></ul></li><li><strong>分层机构</strong>：最底层是<mark>硬件</mark>，最高层是<mark>用户接口</mark>。每层只可调用临近的更低一层<br>效率低，不可跨层调用，系统调用执行时间长</li><li><strong>模块化</strong><br>内核=主模块+可加载内核模块<br>主模块：只负责核心模块，如进程调度、内存管理<br>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核<br>模块化结构和分层结构都是基于“分解”和“模块化”的思想，**分层结构是固定的相邻两层（上层依赖下层）之间调用接口，模块化可以是多个接口互相调用</li><li><strong>外核</strong></li></ul><table><thead><tr><th>类型</th><th>特性、思想</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>分层结构</strong></td><td>内核分多层，每层可单向调用更低一层提供的接口</td><td>1. 便于<strong>调试和验证</strong>，自底向上逐层调试验证  <br>2. <strong>易扩充和易维护</strong>，各层之间调用接口清晰固定</td><td>1. 仅可调用<strong>相邻</strong>低层，难以合理定义各层的边界  <br>2. <strong>效率低，不可跨层调用，系统调用执行时间长</strong></td></tr><tr><td><strong>模块化</strong></td><td>将内核划分为多个模块，各模块之间相互协作  <br><strong>内核 = 主模块 + 可加载内核模块</strong>  <br>主模块：只负责<strong>核心</strong>功能，如<strong>进程调度、内存管理</strong>  <br>可加载内核模块：可以<strong>动态</strong>加载新模块到内核，而无需重新编译整个内核</td><td>1. 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发  <br>2. 支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核 ，增强 OS 适应性  <br>3. 任何模块都可以<strong>直接</strong>调用其他模块，无需采用 “消息传递” 来间接通信</td><td>1. 模块间的接口定义未必合理、实用  <br>2. 模块间相互<strong>依赖</strong>，更<strong>难调试和验证</strong></td></tr><tr><td><strong>宏内核（大内核）</strong></td><td>所有的<strong>系统功能</strong>都放在内核里（大内核结构的 OS 通常也采用了 “模块化” 的设计思想）</td><td>1. 性能高，内核内部各种功能都可<strong>以直</strong>接相互调用</td><td>1. 内核庞大功能复杂，难以维护  <br>2. 大内核中某个功能模块出错，就可能导致整个系统崩溃</td></tr><tr><td><strong>微内核</strong></td><td>只把<strong>中断、原语、进程通信</strong>等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</td><td>1. 内核小功能少、易于维护，内核<strong>可靠性高</strong>  <br>2. 内核外的某个功能模块出错不会导致整个系统崩溃</td><td>1. <strong>性能低</strong>，需要频繁的切换用户态 / 核心态，用户态下的各功能模块不可以直接相互调用，只能通过内核的 “消息传递” 来间接通信  <br>2. 只能通过内核的 “<strong>消息传递</strong>” 来间接通信</td></tr><tr><td><strong>外核（exokernel）</strong></td><td>内核负责进程调度、进程通信等功能，外核负责为用户进程分配<strong>未经抽象的硬件资源</strong>，且由外核负责<strong>保证资源使用安全</strong></td><td>1. 外核直接给用户进程分配 “不虚拟、不抽象” 的硬件资源，使用户进程可以<strong>更灵活</strong>的使用硬件资源  <br>2. 减少了虚拟硬件资源的 “映射层”，<strong>提升效率</strong></td><td>1. 降低了系统的一致性  <br>2. 使系统变得<strong>更复杂</strong></td></tr></tbody></table><p><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240507155838.png" alt="image.png"></p><h1>5 操作系统引导</h1><ul><li><strong>操作系统引导</strong>，即开机的时候，怎么让os运行：指计算机利用 CPU 运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统<br><img src="https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240507165144.png" alt="image.png"><br>常见操作系统的引导过程如下：</li></ul><ol><li><strong>激活 CPU</strong>：激活的 CPU 读取 ROM 中的 boot 程序，将指令寄存器置为 BIOS (基本输入/输出系统) 的第一条指令，即开始执行 BIOS 的指令</li><li><strong>硬件自检</strong>：BIOS 程序在内存最开始的空间构建<strong>中断向量表</strong>，接下来的 POST 过程要用到中断功能，然后通过通电自检，检查硬件是否出现故障</li><li><strong>加载带有操作系统的硬盘</strong>：BIOS 将控制权交给启动顺序排在第一位的存储设备，CPU 将其引导扇区的内容加载到内存中</li><li><strong>加载主引导记录（MBR）</strong>：硬盘以特定的标识符区分引导硬盘和非引导硬盘【MBR 告诉 CPU 去硬盘的哪个主分区去找操作系统】</li><li><strong>扫描硬盘分区表，并加载硬盘活动分区</strong>：MBR 包含硬盘分区表，以特定标识符区别活动分区和非活动分区，MBR 识别含有操作系统的硬盘分区（活动分区）后，加载并将控制权交给活动分区</li><li><strong>加载分区引导记录（PBR）</strong>：读取活动分区的第一个扇区【分区引导记录 PBR】，其作用是寻找并激活分区根目录下用于引导操作系统的程序 (启动管理器)</li><li><strong>加载启动管理器</strong></li><li><strong>加载操作系统</strong><br><strong>注意</strong>：</li></ol><ul><li>自检程序 —&gt; 引导装入程序/自举装入程序 —&gt; 引导程序 —&gt; 操作系统</li><li><strong>操作系统</strong>被装入 <strong>RAM</strong> 中</li><li>自举程序 <strong>BIOS</strong> 装在 <strong>ROM</strong> 中</li><li><strong>引导程序</strong>装在<strong>硬盘</strong>中<br>操作系统的引导程序位于磁盘活动分区的引导扇区中。<br>引导程序分为两种：<ul><li>一种是位于 ROM中的自举程序(BIOS的组成部分)，用于启动具体的设备</li><li>另一种是位于装有操作系统硬盘的活动分区的引导扇区中的引导程序（称为启动管理器），用于引导操作系统。</li></ul></li><li>常驻内存的只是os内核，其他部分仅在需要时才调入</li><li></li></ul><h1>6 机</h1><ul><li><strong>虚拟机</strong>：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（VM），每个虚拟机器都可以独立运行一个操作系统</li></ul><table><thead><tr><th>分类</th><th>第一类 VMM</th><th>第二类 VMM</th></tr></thead><tbody><tr><td>对物理资源的控制权</td><td>直接运行在硬件之上，能直接控制和分配物理资源</td><td>运行在 Host OS 之上，依赖于 Host OS 为其分配物理资源</td></tr><tr><td>资源分配方式</td><td>在安装 Guest OS 时，VMM 要在原本的硬盘上自行分配存储空间，类似于 “外核” 的分配方式，分配未经抽象的物理硬件</td><td>Guest OS 拥有自己的虚拟磁盘，该盘实际上是 Host OS 文件系统中的一个大文件。Guest OS 分配到的内存是虚拟内存</td></tr><tr><td>性能</td><td>性能更好</td><td>性能更差，需要 Host OS 作为 “中介”</td></tr><tr><td>可支持的虚拟机数量</td><td>更多，不需要和 Host OS 竞争资源，相同的硬件资源可以支持更多的虚拟机</td><td>更少，Host OS 本身需要使用物理资源，Host OS 上运行的其他进程也需要物理资源</td></tr><tr><td>虚拟机的可迁移性</td><td>更差</td><td>更好，只需导出虚拟机镜像文件即可迁移到另一台 Host OS 上，商业化应用更广泛</td></tr><tr><td>运行模式</td><td>第一类 VMM 运行在最高特权级（Ring 0），可以执行最高特权的指令</td><td>第二类 VMM 部分运行在用户态、部分运行在内核态。Guest OS 发出的系统调用会被 VMM 截获，并转化为 VMM 对 Host OS 的系统调用</td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250420181854307.png" alt="image.png"></td><td></td><td></td></tr><tr><td>注：</td><td></td><td></td></tr></tbody></table><ol><li>操作系统执行程序时，必须<strong>从</strong><mark><strong>起始地址</strong></mark><strong>开始执行</strong>。</li><li><strong>批处理</strong>的主要缺点是<strong>缺少交互性</strong>；<strong>多道性</strong>是为了<strong>提高系统利用率</strong>和<strong>吞吐量</strong>提出的</li><li>中断程序本身可能是用户程序，但是<strong>进入中断的处理程序一定是OS程序</strong></li><li>操作系统管理内存时，管理的是内存中的数据放在哪里、哪里可以放数据、哪里不可以放数据（内存保护）、哪里空闲等问题， 而内存中的数据是什么、怎么读和怎么写，都不是内核态关心的。</li><li><strong>关中断指令为特权指令</strong>，必须在内核态下才能执行</li><li>VMM 的功能没有操作系统的功能复杂，其代码量少于一个完整的操作系统</li></ol><h1>7 错题</h1><p>实时os：在规定的时间内完成对外部事件的处理<br>分时：交互，多用户，目标：快速响应用户<br>多处理器系统：并行</p><ol><li><strong>分时系统的一个重要性能是系统的响应时间，对操作系统的（）因素进行改进有利于改善系统的响应时间。<br>A.加大时间片   B.采用静态页式管理<br>C.优先级+非抢占式调度算法   D.代码可重入</strong><br>采用优先级+非抢占式调度算法，既可使重要的作业/进程通过高优先级尽快获得系统响应，又可保证次要的作业/进程在非抢占式调度下不会迟迟得不到系统响应,这样有利于改善系统的响应时间。加大时间片会延迟系统响应时间;静态页式管理和代码可重入与系统响应时间无关。</li><li><strong>在分时系统中，为使多个进程能够及时与系统交互，关键的问题是能在短时间内，使所有就绪进程都能运行。当就绪进程数为 100时，为保证响应时间不超过2s，此时的时间片最大应为( )。<br>A. 10ms   B. 20ms   C.50ms   D.100ms</strong><br>响应时间不超过 2s，即在 2s 内必须响应所有进程。所以时间片最大为 2s/100=20ms</li><li><strong>【2018 统考真题】下列关于多任务操作系统的叙述中，正确的是()。<br>I. 具有并发和并行的特点   II. 需要实现对共享资源的保护<br>III. 需要运行在多 CPU 的硬件平台上<br>A. 仅I   B.仅II   C.仅I、II   D.I、II、III</strong><br>现代操作系统都是多任务的，允许用户把程序分为若干个任务，使它们并发执行。在单CPU中，这些任务并发执行，即宏观上并行执行，微观上分时地交替执行;在多 CPU 中，这些任务是真正的并行执行。此外，引入中断之后才出现了多任务操作系统，而中断方式的特点是 CPU 与外设并行工作，因此选项I正确。多个任务必须互斥地访问共享资源，为达到这一目标必须对共享资源进行必要的保护，选项Ⅱ正确。多任务操作系统并不一定需要运行在多 CPU 的硬件上，单个 CPU 通过分时使用也能满足要求，选项III错误。C</li><li><strong>【2022 统考真题】下列关于多道程序系统的叙述中，不正确的是()<br>A.支持进程的并发执行              B.不必支持虚拟存储管理<br>C.需要实现对共享资源的管理   D.进程数越多 CPU 利用率越高。.</strong><br>操作系统的基本特点:并发、共享、虚拟、异步，其中最基本、一定要实现的是并发和共享。早期的多道批处理操作系统会将所有进程的数据全部调入主存，再让多道程序并发执行，即使不支持虚拟存储管理，也能实现多道程序并发。进程多并不意味着CPU 利用率高，进程数量越多，进程之间的资源竞争越激烈，甚至可能因为资源竞争而出现死锁现象，导致 CPU 利用率低。</li><li><strong>下列关于操作系统的说法中，错误的是()<br>I.在通用操作系统管理下的计算机上运行程序，需要向操作系统预订运行时间<br>II.在通用操作系统管理下的计算机上运行程序，需要确定起始地址，并从这个地址开始执行<br>III.操作系统需要提供高级程序设计语言的编译器<br>IV.管理计算机系统资源是操作系统关心的主要问题<br>A.I   B. I、III   C. II、III   D.I、II、III、IV</strong><br>选项1错误：通用操作系统使用时间片轮转调度算法，用户运行程序并不需要预先预订运行时间。<br>选项 Ⅱ正确：操作系统执行程序时，必须从起始地址开始执行。<br>选项III错误：编译器是操作系统的上层软件，不是操作系统需要提供的功能。选项IV正确：操作系统是计算机资源的管理者，管理计算机系统资源是操作系统关心的主要问题。</li><li><strong>下列说法中，正确的是()。<br>I.批处理的主要缺点是需要大量内存<br>II.当计算机提供了内核态和用户态时，输入/输出指令必须在内核态下执行<br>III.操作系统中采用多道程序设计技术的最主要原因是提高 CPU 和外部设备的可靠性<br>IV.操作系统中，通道技术是一种硬件技术<br>A. I、II   B. I、III   C. II、IV   D.II、III、IV</strong><br>选项1错误：批处理的主要缺点是缺少交互性。<br>选项 Ⅱ 正确：输入/输出指令属于特权指令，只能由操作系统使用，因此必须在内核态下执行。<br>选项 III 错误：多道性是为了提高系统利用率和吞吐量而提出的。实时是可靠性<br>选项IV 正确：I/O 通道实际上是一种特殊的处理器，它具有执行 I/O 指令的能力，并通过执行通道程序来控制 I/O 操作。</li><li><strong>CPU 的状态分为用户态和内核态，从用户态转换到内核态的唯一途径是<br>A.修改程序状态字指令   B.中断屏蔽   C.中断   D.中断处理程序</strong><br>CPU 通过程序状态字寄存器中的某个位来标志当前的状态，但是修改程序状态字的指令本身就属于特权指令，不能在用户态下执行。<br>当 CPU执行到一条访管指令或陷阱指令时，会引起访管中断或陷阱中断，CPU 会保存断点和其他上下文环境，然后切换到内核态。也就是说，从用户态转换到内核态，不是通过指令来修改 CPU 的状态标志位的，而是由 CPU 在中断时自动完成的。C<br>中断处理程序一般在内核态执行，因此无法完成“转换成内核态”这一任务。</li><li><strong>【2015 统考真题】处理外部中断时，应该由操作系统保存的是()。<br>A.程序计数器(PC)的内容   B.通用寄存器的内容<br>C.快表(TLB)中的内容         D.Cache 中的内容</strong><br>外部中断处理过程，PC 值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。快表(TLB)和 Cache 中的内容在外部中断处理过程中通常无须保存，直接置有效位为0即可。</li><li><strong>【2015 统考真题】假定下列指令已装入指令寄存器，则执行时不可能导致 CPU 从用户态变为内核态(系统态)的是()。</strong><br><strong>A. DIV R0,R1       ;(R0)/(R1)→R0</strong><br><strong>B. INT n                ;产生软中断</strong><br><strong>C. NOT R0           ;寄存器 R0 的内容取非</strong><br><strong>D. MOV R0,addr  ;把地址 addr 处的内存数据放入寄存器 R0</strong><br>部分指令可能出现异常，从而转到内核态。<br>指令A有除零异常的可能。<br>指令B为软中断指令，用于触发一个中断并跳转到相应的中断处理程序，n表示中断向量号，使用软中断可以在用户态和内核态之间切换，以实现- 系统调用或中断处理。CPU 必须切换到内核态执行中断服务程序。<br>指令D内存访问指令，若地址 <code>addr</code> 对应的页未加载到物理内存（缺页），会触发<strong>缺页异常</strong>。<br>指令C属于纯算术运算，不会发生异常，完全在用户态执行。</li><li><strong>【2016 统考真题】异常是指令执行过程中在处理器内部发生的特殊事件，中断是来自处理器外部的请求事件。下列关于中断或异常情况的叙述中，错误的是()。<br>A.“访存时缺页”属于中断        B.“整数除以 0”属于异常<br>C.“DMA 传送结束”属于中断   D.“存储保护错”属于异常</strong><br>缺页由 CPU 访问内存时触发（内部事件），属于<strong>异常</strong>（内中断），而非外部中断。<br>DMA 控制器完成数据传输后，通过硬件信号通知 CPU（外部中断）。<br>“存储保护错”属于异常，访问内存时违反权限规则（如用户程序访问内核空间），属于指令触发的内部异常。<br>A</li><li><strong>【2020 统考真题】下列与中断相关的操作中，由操作系统完成的是()。<br>I.保存被中断程序的中断点   II.提供中断服务<br>III.初始化中断向量表            IV.保存中断屏蔽字<br>A.仅I、II   B.仅I、II、IV   C.仅III、IV   D.仅II、III、IV</strong><br>I：CPU 检测到中断后，硬件自动保存程序计数器（PC）和程序状态字（PSW），无需操作系统介入。<br>II：中断服务程序（如处理键盘输入、缺页异常）是操作系统内核代码的一部分。<br>III：操作系统在启动时初始化中断向量表，建立中断类型与中断服务程序入口地址的映射。<br>IV：中断服务程序需保存和恢复中断屏蔽状态（如临时屏蔽低优先级中断），由操作系统管理。<br>D</li><li><strong>【2021 统考真题】下列选项中，通过系统调用完成的操作是()<br>A.页置换   B.进程调度   C.创建新进程   D.生成随机整数</strong><br>系统调用是由用户进程发起的，请求操作系统的服务。<br>对于选项A，由操作系统<strong>自动触发</strong>（如缺页异常），用户程序不直接参与，无需显式请求。<br>对于选项B，由操作系统内核<strong>自主决策</strong>（如时间片耗尽、优先级抢占），用户程序无法通过调用干预<br>对于选项C，用户程序需显式调用 <code>fork()</code>、<code>exec()</code> 等系统调用，请求内核分配资源并创建进程。C<br>对于选项 D，生成随机数是普通的函数调用，不涉及请求操作系统的服务，如C语言的random()函数。</li><li><strong>【2022 统考真题】执行系统调用的过程涉及下列操作，其中由操作系统完成的是()。</strong><br><strong>I.保存断点和程序状态字      II.保存通用寄存器的内容</strong><br><strong>III. 执行系统调用服务例程   IV.将 CPU 模式改为内核态</strong><br><strong>A.仅I、III   B.仅II、III   C.仅II、IV   D.仅II、III、IV</strong><br>I（保存断点和PSW）：由CPU硬件在触发软中断时自动保存（类似中断处理）。<br>IV（切换内核态）：通过执行<code>syscall</code>或<code>int</code>指令，硬件自动切换CPU模式。<br>II（保存通用寄存器）：内核在系统调用入口代码中保存用户程序上下文（如eax、ebx等）。<br>III（执行服务例程）：内核根据系统调用号查表（如sys_call_table），执行对应服务（如read()、fork()）。<br>综上，选项I、IV 由硬件完成，选项Ⅱ、III 由操作系统完成。</li><li><strong>【2023 统考真题】在操作系统内核中，中断向量表适合采用的数据结构是</strong><br><strong>A.数组   B.队列   C.单向链表   D.双向链表</strong><br>中断向量表用于存放中断处理程序的入口地址，CPU通过查询得到中断类型号，然后据此计算可以得到对应中断服务程序的入口地址在中断向量表的位置，采用数组作为中断向量表的存储结构，可实现时间复杂度为 O(1)的快速访问，从而提高中断处理的效率。</li><li><strong>【2024 统考真题】下列关于中断、异常和系统调用的叙述中，错误的是</strong><br><strong>A.中断或异常发生时，CPU 处于内核态</strong><br><strong>B.每个系统调用都有对应的内核服务例程</strong><br><strong>C.中断处理程序开始执行时，CPU处于内核态</strong><br><strong>D.系统添加新类型设备时，需要注册相应的中断服务例程</strong><br>当中断或异常发生时，CPU 既可能处于内核态，又可能处于用户态，具体取决于当时CPU正在处理的任务，用户程序触发除零异常（原处于用户态），内核线程处理磁盘中断（原处于内核态），选项A错误。正确说法：中断/异常处理程序<strong>执行时</strong>一定在内核态，但触发时CPU状态不固定。<br>不同的系统调用对应不同的内核服务例程，选项B正确。<br>在中断响应阶段，若 CPU 处于用户态，则需要切换到内核态，因此在中断处理阶段，CPU 一定处于内核态，选项C正确。<br>设备种类繁多，计算机不可能事先准备好所有设备对应的中断服务例程(实际上属于设备驱动程序)，因此当系统添加新类型的设备时，需要注册相应的中断服务例程</li><li><strong>对于以下五种服务，在采用微内核结构的操作系统中，()不宜放在微内核中<br>I.进程间通信机制             II.低级I/O<br>III.低级进程管理和调度   IV.中断和陷入处理     V.文件系统服务<br>A. I、Ⅱ和III   B. II和 V   C.仅V   D.IV和V</strong><br>进程(线程)之间的通信功能是微内核最频繁使用的功能，因此几乎所有微内核 OS都将其放入微内核。<br>低级 I/O 和硬件紧密相关，因此应放入微内核。<br>低级进程管理和调度属于调度功能的机制部分，应将它放入微内核。<br>微内核 OS 将与硬件紧密相关的一小部分放入微内核处理，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行中断响应处理，识别中断或陷入的事件后，再发送给相关的服务器处理，所以中断和陷入处理也应放入微内核。<br>而文件系统服务是放在微内核外的文件服务器中实现的，所以仅选项V不宜放在微内核中。</li><li><strong>下列关于操作系统结构的说法中，正确的是()。<br>I.当前广泛使用的 Windows 操作系统，采用的是分层式 OS 结构<br>II.模块化的 OS 结构设计的基本原则是，每一层都仅使用其底层所提供的功能和服务这样就使系统的调试和验证都变得容易<br>III.因为微内核结构能有效支持多处理机运行，所以非常适合于分布式系统环境<br>IV.采用微内核结构设计和实现操作系统具有诸多好处，如添加系统服务时，不必修改内核、使系统更高效。<br>A.I和 II   B.I和 II   C.III   D.III和IV</strong><br>Windows 是融合了宏内核和微内核的操作系统，选项I错误。<br>选项Ⅱ描述的是层次化构架的原则。<br>微内核架构将操作系统的核心功能和其他服务分离，使不同的服务可在不同的处理器上并行执行，提高了系统的并发性和可扩展性；微内核架构可以方使地实现进程间的通信和同步，支持服务器之间的消息传递和远程过程调用，使得分布式系统的开发和管理更简单和高效，选项III正确。<br>添加系统服务时不必修改内核，这就使得微内核构架的可扩展性和灵活性更强；微内核构架的主要问题是性能问题，“使系统更高效”显然错误。</li><li><strong>下列关于操作系统外核(exokemmel)的说法中，错误的是()。<br>A.外核可以给用户进程分配未经抽象的硬件资源<br>B.用户进程通过调用“库”请求操作系统外核的服务<br>C.外核负责完成进程调度<br>D.外核可以减少虚拟硬件资源的“映射”开销，提升系统效率</strong><br>在拥有外核的操作系统中，外核只负责硬件资源的分配、回收、保护等，进程管理相关的工作仍然由内核负责。</li><li><strong>计算机的启动过程是( )。<br>①CPU 加电，CS:IP 指向 FFFFOH;<br>②进行操作系统引导;<br>③执行 JMP 指令跳转到 BIOS;<br>④登记 BIOS 中断程序入口地址;<br>⑤硬件自检。<br>A.①②③④⑤   B.①③⑤④②<br>C.①③④⑤②   D.①⑤③④②</strong><br>CPU 激活后，从顶端的地址 FFFFOH 获得第一条执行的指令，这个地址仅有 16 字节，放不下一段程序，所以是一条 JMP 指令，以跳到更低地址去执行 BIOS 程序。<br>BIOS 程序在内存最开始的空间构建中断向量表和相应服务程序，在后续 POST 过程中要用到中断调用等功能。<br>然后进行通电自检(Power-on Self Test，POST)以检测硬件是否有故障。<br>完成 POST后，BIOS 需要在硬盘、光驱或软驱等存储设备搜寻操作系统内核的位置以启动操作系统。<br>C</li><li><strong>检查分区表是否正确，确定哪个分区为活动分区，并在程序结束时将该分区的启动程序(操作系统引导扇区)调入内存加以执行，这是（）的任务。<br>A. MBRB   B.引导程序   C.操作系统   D. BIOS</strong><br>BIOS 将控制权交给排在首位的启动设备后，CPU 将该设备主引导扇区的内容【主引导记录(MBR)】加载到内存中，然后由 MBR检查分区表，查找活动分区，并将该分区的引导扇区的内容【分区引导记录(PBR)】加载到内存加以执行。</li><li><strong>下列关于虚拟机的说法中，正确的是<br>I.虚拟机可以用软件实现   II.虚拟机可以用硬件实现<br>III.多台虚拟机可同时运行在同一物理机器上，它实现了真正的并行</strong><br>实现真正并行的是多核处理机，多台虚拟机同时运行在同一物理机器上，类似于多个程序运行在同一个系统中。I，II对</li><li><hr></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统定义 </tag>
            
            <tag> OS 核心特征（并发 / 共享 / 虚拟 / 异步） </tag>
            
            <tag> 处理器运行模式（内核态 / 用户态） </tag>
            
            <tag> 操作系统结构（大内核 / 微内核） </tag>
            
            <tag> OS 引导流程（BIOS/MBR） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道计组pdf</title>
      <link href="/post/77666db.html"/>
      <url>/post/77666db.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/post/bae4ff13.html"/>
      <url>/post/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h1>Redis</h1><p><a href="https://www.notion.so/1-133d2775339a8027b65cf4a2fa4776a6?pvs=21">黑马点评1</a></p><p><a href="https://www.notion.so/2-137d2775339a807eaf12c3684a75bee5?pvs=21">黑马点评2</a></p><p><a href="https://www.notion.so/3-13dd2775339a80db9b7bfe8444b8a975?pvs=21">黑马点评3</a></p><p><a href="https://www.notion.so/4-13dd2775339a80078852e9fb3d26d39a?pvs=21">黑马点评4</a></p><p><a href="https://redis.io/">https://redis.io/</a></p><h1>NoSQL</h1><p>Redis是一种键值型的NoSQL数据库</p><p><code>NoSql</code>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<code>非关系型数据库</code>。</p><ul><li><p><strong>结构化与非结构化</strong></p><p>传统关系型数据库是结构化数据，每张表在创建的时候都有严格的约束信息，如字段名、字段数据类型、字段约束等，插入的数据必须遵循这些约束。而NoSQL则对数据库格式没有约束，可以是键值型，也可以是文档型，甚至是图格式</p></li><li><p><strong>关联与非关联</strong></p><p>传统数据库的表与表之间往往存在关联，例如外键约束</p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合</p><p><img src="images/images/image.png" alt="image.png"></p></li><li><p>事务</p><p>传统关系型数据库能满足事务的ACID原则(原子性、一致性、独立性及持久性)，而非关系型数据库无法全部满足</p></li></ul><p>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</p><h2 id="SQL-VS-NoSQL">SQL VS NoSQL</h2><table><thead><tr><th></th><th>SQL</th><th>NoSQL</th></tr></thead><tbody><tr><td>数据结构</td><td>结构化</td><td>非结构化</td></tr><tr><td>数据关联</td><td>关联的</td><td>无关联的</td></tr><tr><td>查询方式</td><td>SQL查询</td><td>非SQL</td></tr><tr><td>事务特性</td><td>ACID</td><td>BASE</td></tr><tr><td>存储方式</td><td>磁盘</td><td>内存</td></tr><tr><td>扩展性</td><td>垂直</td><td>水平</td></tr><tr><td>使用场景</td><td>1）数据结构固定2）相关业务对数据安全性、一致性要求较高</td><td>1）数据结构不固定2）对一致性、安全性要求不高3）对性能要求高</td></tr></tbody></table><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h1>Redis VS MySQL</h1><p>**Redis：**Remote Dictionary Server远程词典服务器</p><ul><li><strong>内存存储</strong>：Redis 是一个基于<strong>内存</strong>的 <strong>Key-Value</strong> 数据库，主要将数据存储在内存中，读写速度非常快。其性能优势在于数据能够在几微秒内完成读写操作，因此适合对响应时间要求较高的场景。</li><li>单线程，每个命令具有原子性</li><li>低延迟，速度快(基于内存、IO多路复用、良好的编码)</li><li><strong>持久化</strong>：虽然 Redis 是内存数据库，但它支持将数据持久化到磁盘中以避免数据丢失。常见的持久化机制有 RDB 和 AOF。</li><li><strong>数据类型丰富</strong>：除了简单的字符串类型，Redis 还支持哈希、列表、集合、有序集合等数据结构，适合不同业务场景的数据操作。</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li><li><strong>应用场景</strong>：<ul><li><strong>缓存</strong>：用于存储热点数据，如热点商品、新闻、排行榜等，减少对数据库的压力。</li><li><strong>会话管理</strong>：在分布式应用中，Redis 常用来存储用户会话信息。</li><li><strong>计数器和限流器</strong>：由于 Redis 的高性能，常用来实现各类实时计数操作，如商品点击量统计。</li><li><strong>消息队列</strong>：Redis 还可以用于实现简单的消息队列功能。</li></ul></li></ul><p><strong>MySQL：</strong></p><ul><li><strong>磁盘存储</strong>：MySQL 是一个基于<strong>磁盘</strong>的关系型数据库，数据存储在磁盘中，并使用索引等机制来优化查询性能。</li><li><strong>结构化数据</strong>：MySQL 适合处理结构化的<strong>二维表</strong>数据，支持复杂的 SQL 查询，事务处理能力强，保证数据一致性。</li><li><strong>持久化和事务性</strong>：MySQL 的数据持久存储在磁盘上，即使服务器宕机，数据也能安全保存。同时，MySQL 支持 ACID 事务，确保数据操作的原子性和一致性。</li><li><strong>应用场景</strong>：<ul><li><strong>结构化数据存储</strong>：如用户信息、订单数据等需要通过关系表存储和查询的数据。</li><li><strong>事务处理</strong>：MySQL 在复杂的事务处理中表现良好，适合需要高数据一致性的场景，如银行、财务等系统。</li></ul></li></ul><h2 id="结合应用场景">结合应用场景</h2><ul><li><strong>缓存</strong>：Redis 通常作为 MySQL 的缓存层，用于加速查询。MySQL 负责持久存储，而 Redis 则存储热点数据，减轻 MySQL 压力，提升系统的整体性能。</li><li><strong>高并发场景</strong>：对于短时间内大量访问的热点数据（如电商秒杀、新闻排行榜），将其存储在 Redis 中以提供更高效的读写性能。</li><li><strong>企业广泛应用</strong>：Redis 和 MySQL 的结合在现代互联网公司中非常常见，既保障了数据的持久性和一致性（通过 MySQL），又提供了高速缓存和高并发处理能力（通过 Redis）。</li></ul><p>这种组合能够很好地满足企业级应用中对高并发处理和数据持久化的不同需求。</p><p>中文文档：<a href="https://www.redis.net.cn/tutorial/3501.html">Redis 教程_redis教程</a></p><h1>使用</h1><h2 id="windows安装">windows安装</h2><p><img src="images/image%201.png" alt="image.png"></p><p>在redis安装目录下打开cmd</p><p>启动：输入redis-server.exe redis.windows.conf</p><p>停止：Ctrl+C</p><p>客户端连接：再次在redis安装目录下打开cmd，输入redis-cli.exe</p><p>默认连接6379</p><p><img src="images/images/image%202.png" alt="image.png"></p><p>更改连接地址</p><p><img src="images/images/image%203.png" alt="image.png"></p><p>设置密码：删除注释，requirepass顶格，修改foobared为密码</p><p><img src="images/images/image%204.png" alt="image.png"></p><p>redis-cli.exe -h localhost -p 6379 -a 123456</p><p>可视化界面连接</p><p><img src="images/image%205.png" alt="image.png"></p><h2 id="Linux安装">Linux安装</h2><p>sudo apt update<br>sudo apt install -y gcc tcl</p><p>下载redis-6.2.6.tar.gz</p><p><strong><code>cd</code>到<code>/usr/local/src</code>目录执行以下命令进行解压操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p><strong>解压成功后依次执行以下命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.6</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="images/image%206.png" alt="image.png"></p><h3 id="启动redis">启动redis</h3><ul><li><p>前台启动【不推荐】：会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><p><strong>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</strong></p></li><li><p>后台启动【不推荐】：必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下</p><ul><li><p>因为我们要修改配置文件，因此我们需要先将原文件备份一份</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure></li><li><p>然后修改<code>redis.conf</code>文件中的一些配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure></li><li><p>Redis其他常用配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="built_in">dir</span> .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动Redis</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录cd /usr/local/src/redis-6.2.6</span></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>停止Redis服务</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 ps -ef | grep redis查询pid</span><br><span class="line"><span class="comment"># 通过kill命令直接杀死进程kill -9 redis进程ids</span></span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -a 来指定密码</span></span><br><span class="line">redis-cli -a 132537 shutdown</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>开机自启【推荐】</strong></p><p>通过配置来实现开机自启</p><ul><li><p>首先，新建一个系统服务文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure></li><li><p>将以下命令粘贴进去</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">// Type=forking 不知道为什么这行不删掉启动超时</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>然后重载系统服务</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>现在，我们可以用下面这组命令来操作redis了</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li><li><p>执行下面的命令，可以让redis开机自启</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>数据类型</h1><p><strong>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</strong></p><p><img src="images/image-20220524205926164.png" alt="image-20220524205926164.png"></p><p><img src="701cbe108e6e43bebf491be26887bf55.png" alt="701cbe108e6e43bebf491be26887bf55.png"></p><p><img src="images/image%207.png" alt="image.png"></p><ul><li>hash 适合存储对象</li><li>list 按照插入顺序排序，可以有重复元素 eg.朋友圈点赞列表</li><li>set 无序集合，没有重复元素 eg.qq共同好友</li><li>sorted set 有序集合，没有重复元素eg.排行榜</li></ul><h3 id="Key结构"><strong>Key结构</strong></h3><ul><li><p>Redis没有类似MySQL中Table的概念，那么我们该如何区分不同类型的Key呢？</p></li><li><p>例如：需要存储用户、商品信息到Redis，有一个用户的id是1，有一个商品的id恰好也是1，如果此时使用id作为key，那么就回冲突，该怎么办？</p></li><li><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范</p><ul><li>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下<code>项目名:业务名:类型:id</code></li><li>这个格式也并非是固定的，可以根据自己的需求来删除/添加词条，这样我们就可以把不同数据类型的数据区分开了，从而避免了key的冲突问题</li><li>例如我们的项目名叫reggie，有user和dish两种不同类型的数据，我们可以这样定义key<ul><li>user相关的key：<code>reggie:user:1</code></li><li>dish相关的key：<code>reggie:dish:1</code></li></ul></li></ul></li><li><p>如果value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>reggie:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>reggie:dish:1</td><td>{“id”:1, “name”: “鲟鱼火锅”, “price”: 4999}</td></tr></tbody></table></li><li><p>并且在Redis的桌面客户端中，也会以相同前缀作为层次结构，让数据看起来层次分明，关系清晰</p></li></ul><h3 id="1-String（字符串）">1. <strong>String（字符串）</strong></h3><ul><li><p><strong>描述</strong>：Redis 中最基本的数据类型，每个键都对应一个字符串类型的值。可以是文本或二进制数据（如图片、视频等）。</p><p>value是字符串，不过根据字符串的格式不同，又可以分为3类</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同，字符串类型的最大空间不能超过512M</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET</td><td>添加或者修改一个已经存在的String类型的键值对</td></tr><tr><td>GET</td><td>根据key获取String类型的value</td></tr><tr><td>MEST</td><td>批量添加多个String类型的键值对</td></tr><tr><td>MGET</td><td>根据多个key获取多个String类型的value</td></tr><tr><td>INCR</td><td>让一个整型的key自增1，适用于计数器</td></tr><tr><td>INCRBY</td><td>让一个整形的key自增并指定步长值，例如：incrby num 2，让num值自增2</td></tr><tr><td>INCRBYFLOAT</td><td>让一个浮点类型的数字自增并指定步长值</td></tr><tr><td><code>SET key seconds value</code></td><td>设置键 <code>key</code> 对应的值为 <code>value</code> ，并将key的过期时间设为seconds秒。eg.验证码过期</td></tr><tr><td><code>SETNX key value</code></td><td>添加一个String类型的键值对，前提是这个key不存在，否则不执行，可以理解为真正的新增。eg.分布式锁</td></tr><tr><td><code>SETEX key seconds value</code></td><td>添加一个String类型的键值对，并指定有效期（s），一旦时间到了，Redis 会自动删除该键。</td></tr><tr><td>APPEND</td><td>在键 <code>key</code> 的值后追加内容</td></tr></tbody></table></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>缓存对象的简单属性</strong>：如用户的登录状态、验证码、单个配置项。</li><li><strong>计数器</strong>：用户浏览次数、点赞数等。</li></ul></li></ul><p>更多命令：<a href="https://www.redis.net.cn/tutorial/3508.html">Redis 字符串(String)_redis教程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name xiaoming</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="title function_">age</span></span><br><span class="line"><span class="params">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">20</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line"><span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">30</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line"><span class="string">&quot;30&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex city <span class="number">10</span> beijing</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get city</span><br><span class="line"><span class="string">&quot;beijing&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="title function_">city</span></span><br><span class="line"><span class="params">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx k1 <span class="title function_">v1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx k1 <span class="title function_">v2</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure><p>set命令会转成字符串存储</p><h3 id="2-Hash（哈希）">2. <strong>Hash（哈希）</strong></h3><ul><li><p><strong>描述</strong>：也叫散列，其中value是一个无序字典，类似于Java中的HashMap结构。适用于存储对象，类似于一个小型的键值对集合。一个键对应一个哈希表，可以存储多个字段和字段值</p><p><img src="images/image%208.png" alt="image.png"></p><p>String结构是将对象序列化为JSON字符串后存储，当我们要修改对象的某个属性值的时候很不方便</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><p><img src="images/image%209.png" alt="image.png"></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>HSET key field value</td><td>添加或者修改hash类型key的field的值</td></tr><tr><td>HGET key field</td><td>获取一个hash类型key的field的值</td></tr><tr><td>HDEL key field</td><td>删除指定字段</td></tr><tr><td>HMSET</td><td>批量添加多个hash类型key的field的值</td></tr><tr><td>HMGET</td><td>批量获取多个hash类型key的field的值</td></tr><tr><td>HGETALL</td><td>获取一个hash类型的key中的所有的field和value</td></tr><tr><td>HKEYS key</td><td>获取一个hash类型的key中的所有的字段</td></tr><tr><td>HVALS key</td><td>获取一个hash类型的key中的所有的值</td></tr><tr><td>HINCRBY</td><td>让一个hash类型key的字段值自增并指定步长</td></tr><tr><td>HSETNX</td><td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr><tr><td>HGETALL key</td><td>获取一个hash类型的key中的所有的字段和值</td></tr></tbody></table></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>存储用户信息</strong>：如用户的基本资料（姓名、年龄、地址等），将用户的各个属性存储为哈希表的字段。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset <span class="number">001</span> name <span class="title function_">xiaoming</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset <span class="number">001</span> age <span class="number">20</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget <span class="number">001</span> name</span><br><span class="line"><span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget <span class="number">001</span> age</span><br><span class="line"><span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel <span class="number">001</span> age</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget <span class="number">001</span> age</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hkeys <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset <span class="number">001</span> age <span class="number">30</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hkeys <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hvals <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;30&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hgetall <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;30&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-List（列表）">3. <strong>List（列表）</strong></h3><ul><li><p><strong>描述</strong>：列表类型是<strong>有序</strong>的字符串集合，可以包含<strong>重复</strong>元素。列表中的元素按照插入顺序排序。支持从两端插入或删除元素。与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p><img src="images/image%2010.png" alt="image.png"></p><ul><li>特征也与LinkedList类似：<ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul></li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>LPUSH key value1 …</td><td>向列表左侧插入一个或多个元素</td></tr><tr><td>RPUSH key value1 …</td><td>向列表右侧插入一个或多个元素</td></tr><tr><td>LPOP key</td><td>移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td>RPOP key</td><td>移除并返回列表右侧的第一个元素</td></tr><tr><td>LLEN key</td><td>获取列表长度</td></tr><tr><td>LRANGE key star end</td><td>返回一段角标范围内的所有元素。 lrange list 0 -1返回所有元素</td></tr><tr><td>BLPOP和BRPOP</td><td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr><tr><td>BRPOP key1 [key2] timeout</td><td>移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr></tbody></table><p>如何利用List结构模拟一个栈?<br>入口和出口在同一边</p><p>如何利用List结构模拟一个队列?<br>入口和出口在不同边</p><p>如何利用List结构模拟一个阻塞队列?<br>入口和出口在不同边<br>出队时采用BLPOP或BRPOP</p></li><li><p><strong>应用场景</strong>：适合存储按时间顺序排列的数据</p><ul><li><strong>消息队列</strong>：利用 <code>LPUSH</code> 和 <code>RPOP</code> 可以实现先进先出的消息队列。</li><li><strong>朋友圈点赞列表</strong>：按时间顺序存储点赞用户的列表。</li><li><strong>评论区</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list <span class="title function_">zhang</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop list</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; llen <span class="title function_">list</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line">(nil)</span><br><span class="line">(<span class="number">10.</span>04s)</span><br></pre></td></tr></table></figure><p><code>0 -1</code>：这些参数指定了要检索的元素的范围，从索引 0 开始到索引 <code>-1</code> 结束（<code>-1</code> 在 Redis 中表示列表的最后一个元素）</p><p><code>lpush</code> 命令会将元素添加到列表的头部，所以最后插入的元素 <code>c</code> 会成为列表的第一个元素（索引 0），而 <code>a</code> 会成为最后一个元素。</p><p>brpop*移除并获取列表 “list” 的最后一个元素，如果列表为空，则等待 10 秒，*如果操作成功，<code>BRPOP</code> 返回一个包含两个元素的数组：第一个元素是被移除的元素，第二个元素是它所属的列表的键名。</p><h3 id="4-Set（集合）">4. <strong>Set（集合）</strong></h3><ul><li><p><strong>描述</strong>：<strong>无序</strong>集合，集合中的元素是<strong>唯一</strong>的，不能重复。通过<strong>哈希表</strong>实现，所以查找、插入、删除操作的时间复杂度都是 O(1)。</p><p><img src="images/image%2011.png" alt="image.png"></p><p>与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SADD key member …</td><td>向set中添加一个或多个元素</td></tr><tr><td>SREM key member …</td><td>移除set中的指定元素</td></tr><tr><td>SCARD key</td><td>返回set中元素的个数</td></tr><tr><td>SISMEMBER key member</td><td>判断一个元素是否存在于set中</td></tr><tr><td>SMEMBERS key</td><td>获取key中的所有元素</td></tr><tr><td>SINTER key1 key2 …</td><td>求key1与key2的交集</td></tr><tr><td>SUNION key1 key2 …</td><td>求key1与key2的并集</td></tr><tr><td>SDIFF key1 key2 …</td><td>求key1与key2的差集</td></tr></tbody></table></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>共同好友</strong>：存储用户的好友列表，可以很方便地取两个用户的共同好友。</li><li><strong>标签系统</strong>：存储用户的兴趣标签，方便进行交集和并集的操作。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd set a b c <span class="title function_">d</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers set</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd set a <span class="title function_">d</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers set</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard <span class="title function_">set</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s a d s <span class="title function_">o</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sinter set s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sunion set s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sdiff set s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sdiff s set</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s a b c <span class="title function_">d</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;s&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-Sorted-Set（有序集合）">5. <strong>Sorted Set（有序集合）</strong></h3><ul><li><p><strong>描述</strong>：是一个可排序的set集合，与集合类似，元素也是<strong>唯一</strong>的，但每个元素都会关联一个double类型的分数（score），Redis 会根据分数从小到大自动排序。元素不能重复，但分数可以相同。与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p><img src="images/image%2012.png" alt="image.png"></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>ZADD key score member1…</td><td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td>ZREM key member</td><td>删除sorted set中的一个指定元素</td></tr><tr><td>ZSCORE key member</td><td>获取sorted set中的指定元素的score值</td></tr><tr><td>ZRANK key member</td><td>获取sorted set 中的指定元素的排名</td></tr><tr><td>ZCARD key</td><td>获取sorted set中的元素个数</td></tr><tr><td>ZCOUNT key min max</td><td>统计score值在给定范围内的所有元素的个数</td></tr><tr><td>ZINCRBY key increment member</td><td>让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td>ZRANGE key min max</td><td>按照score排序后，获取指定排名范围内的元素</td></tr><tr><td>ZRANGEBYSCORE key min max</td><td>按照score排序后，获取指定score范围内的元素</td></tr><tr><td>ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><code>升序</code>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><code>降序</code>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>排行榜</strong>：如游戏中的积分排行榜，用户的分数决定排名。</li><li><strong>延时队列</strong>：通过分数来表示任务的执行时间，按时间顺序执行任务。</li></ul></li></ul><p>按value排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd sset <span class="number">10.0</span> a <span class="number">9.0</span> b</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd sset <span class="number">9.5</span> c</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;9&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;9.5&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby sset <span class="number">20</span> b</span><br><span class="line"><span class="string">&quot;29&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrem sset <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h3 id="通用命令"><strong>通用命令</strong></h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>KEYS</td><td>查看符合模板的所有key，不建议在生产环境设备上使用，因为Redis是单线程的，执行查询的时候会阻塞其他命令，当数据量很大的时候，使用KEYS进行模糊查询，效率很差</td></tr><tr><td>DEL</td><td>删除一个或多个指定的key</td></tr><tr><td>EXISTS</td><td>判断key是否存在，1在0不在</td></tr><tr><td>EXPIRE</td><td>给一个key设置有效期，有效期到期时该key会被自动删除，s单位</td></tr><tr><td>TTL</td><td>查看一个KEY的剩余有效期，s单位，若未设置有效期返回-1</td></tr><tr><td>TYPE</td><td>返回key所存储的值的类型</td></tr></tbody></table><p>可以通过<code>help [command]</code> 可以查看一个命令的具体用法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;001&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;sset&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;set&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">aaa</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type name</span><br><span class="line">string</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type set</span><br><span class="line">set</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type sset</span><br><span class="line">zset</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> -<span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex test <span class="number">100</span> zhang</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">test</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">97</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del <span class="title function_">test</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Redis-应用广泛的原因：">Redis 应用广泛的原因：</h3><ol><li><strong>高性能</strong>：Redis 基于内存存储，具有极高的读写性能，适合存储和访问热点数据。</li><li><strong>多种数据结构</strong>：支持丰富的数据类型，能够处理多种业务场景。</li><li><strong>简单易用</strong>：Redis 提供的命令十分直观，可以快速上手。</li><li><strong>持久化</strong>：虽然 Redis 是内存数据库，但它提供了多种持久化选项以保证数据的安全性。</li><li><strong>企业应用场景</strong>：<ul><li>高并发情况下的数据缓存（如商品、新闻、排行榜等）。</li><li>实时统计和计数功能。</li><li>用户会话管理和社交功能中的好友关系处理等。</li></ul></li></ol><h1><strong>在 Java 中操作 Redis</strong></h1><p>目前主流的Redis的Java客户端有三种</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即<br>spring-boot-starter-data-redis</p><p>在 Java 中操作 Redis 时，<strong>Jedis</strong> 和 <strong>Spring Data Redis</strong> 是两种常用的库，它们各有优缺点。以下是它们的比较和使用场景：</p><ul><li><strong>选择</strong>：<ul><li>如果你需要一个简单的、直接的 Redis 客户端，Jedis 是一个不错的选择。</li><li>如果你的应用程序已经使用 Spring，或者你需要更多的功能和集成，Spring Data Redis 将是更好的选择。</li></ul></li></ul><h2 id="Jedis"><a href="https://so.csdn.net/so/search?q=Jedis&amp;spm=1001.2101.3001.7020"><strong>Jedis</strong></a></h2><ul><li><strong>概述</strong>：<ul><li>Jedis 是一个简单的、直观的 Redis 客户端库，提供了基本的 Redis 操作API。</li><li>它是一个轻量级的库，适合直接与 Redis 交互。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>简单易用</strong>：Jedis 的 API 设计简单，容易上手。</li><li><strong>直接控制</strong>：开发者可以直接使用 Redis 命令，提供了较高的灵活性。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>管理连接</strong>：需要手动管理 Redis 连接，可能会导致连接池管理和性能问题。</li><li><strong>缺少集成</strong>：与 Spring 的集成不如 Spring Data Redis 方便。</li></ul></li></ul><p>Maven 坐标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jedis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--单元测试--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.7.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意，运行前要先启动 Redis</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1. 建立连接</span></span><br><span class="line">jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.40.128&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 2. 设置密码</span></span><br><span class="line"><span class="comment">// jedis.auth(&quot;123456&quot;);</span></span><br><span class="line"><span class="comment">// 3. 选择库</span></span><br><span class="line">jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lr&quot;</span>);</span><br><span class="line">System.out.println(res);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDowm</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;17&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:2&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Jedis</code>本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p></li><li><p>新建一个<code>util</code>，用于存放我们编写的工具类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 配置连接池</span></span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line"><span class="comment">// 最大连接</span></span><br><span class="line">poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 最大空闲连接</span></span><br><span class="line">poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 最小空闲连接</span></span><br><span class="line">poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置最长等待时间，ms</span></span><br><span class="line">poolConfig.setMaxWaitMillis(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// 创建连接池对象</span></span><br><span class="line">jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.40.128&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>); <span class="comment">// host,port,timeout,[password]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure></li><li><p>但后面我们使用<code>SpringDataRedis</code>的时候，可以直接在<code>yml</code>配置文件里配置这些内容</p></li></ul><h2 id="Spring-Data-Redis"><strong>Spring Data Redis</strong></h2><p><a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><strong>概述</strong>：<ul><li>Spring Data Redis 是一个用于 Spring 应用程序的 Redis 数据访问库，提供了更高级别的抽象和 Spring 生态系统的集成。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>易于集成</strong>：与 Spring 框架无缝集成，支持 Spring 的注解和依赖注入。</li><li><strong>自动化管理</strong>：提供了对连接池的管理，简化了 Redis 连接的创建和管理。</li><li><strong>高级特性</strong>：支持 Redis 的许多高级特性，如事务、发布/订阅、消息队列、哨兵、集群等</li><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><table><thead><tr><th>API</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>redisTemplate.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td>redisTemplate.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td>redisTemplate.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td>redisTemplate.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td>redisTemplate.opsForzSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td>redisTemplate</td><td></td><td>通用的命令</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作步骤：">操作步骤：</h3><ul><li>导入Spring Data Redis 的maven坐标</li><li>配置Redis数据源</li><li>编写配置类，创建RedisTemplate对象</li><li>通过RedisTemplate对象操作Redis</li></ul><h3 id="1-导入依赖"><strong>1. 导入依赖</strong></h3><p>Maven 坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-application-yml"><strong>2. application.yml</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: <span class="number">192.168</span><span class="number">.40</span><span class="number">.128</span></span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      #      password: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      database: <span class="number">1</span></span><br><span class="line">      jedis:</span><br><span class="line">        pool:</span><br><span class="line">          max-active: <span class="number">8</span></span><br><span class="line">          max-idle: <span class="number">8</span></span><br><span class="line">          min-idle: <span class="number">0</span></span><br><span class="line">          max-wait: 100ms</span><br></pre></td></tr></table></figure><h3 id="3-编写配置类，创建RedisTemplate对象">3. 编写配置类，创建RedisTemplate对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.config;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span> <span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;开始创建redis模板对象&quot;</span>);</span><br><span class="line"><span class="comment">// 是 Spring Data Redis 提供的核心类，用于对 Redis 进行各种操作</span></span><br><span class="line"><span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line"><span class="comment">// 设置 Redis 的连接工厂，用来与 Redis 服务器建立连接</span></span><br><span class="line">redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="comment">// 将 Redis 的 key 设置为字符串序列化，这样所有 key 会以可读的字符串形式存储。</span></span><br><span class="line">redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"><span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RedisTemplate-的序列化器设置"><strong>RedisTemplate 的序列化器设置</strong></h3><p>RedisTemplate可以接收任意Object作为值写入Redis</p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果\xAC\xED\x00\x05t\x00\x06\xE5\xBC\xA0\xE4\xB8\x89</p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>在Spring Data Redis中，<code>RedisTemplate</code> 是一个核心组件，用于操作Redis数据库。默认情况下，<code>RedisTemplate</code> 使用 <code>JdkSerializationRedisSerializer</code> 作为其键（Key）的序列化器，这意味着键将使用Java标准序列化机制进行序列化。</p><p>当您执行如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br></pre></td></tr></table></figure><p>键 <code>&quot;city123&quot;</code> 将被序列化为一个二进制形式，如在Redis命令行中通过 <code>keys *</code> 命令看到的那样。</p><p>为了避免使用Java标准序列化，您可以通过自定义 <code>RedisTemplate</code> 的序列化器来更改这一行为。通常，对于值（Value），不需要更改序列化器，因为从Redis中获取时将自动进行反序列化。</p><ol><li><p>默认行为</p><p><code>RedisTemplate</code> 默认使用 <code>JdkSerializationRedisSerializer</code> 来序列化键。这意味着键会被序列化为二进制格式，可能不利于可读性和调试。</p></li><li><p>自定义序列化器</p><p>通过将键序列化器设置为 <code>StringRedisSerializer</code>，你可以确保所有的键都以字符串形式存储和读取。这提高了可读性，并且使得在使用 Redis CLI 或其他工具时，更容易查看和管理数据。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置键的序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值的序列化器</p><p>对于值的序列化，通常你可以保持默认设置，因为当你从 Redis 中获取值时，它会自动反序列化为 Java 对象。你可以根据需求更改值的序列化器，例如使用 <code>Jackson2JsonRedisSerializer</code> 以便将对象序列化为 JSON 格式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键的序列化器</span></span><br><span class="line">redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值的序列化器</span></span><br><span class="line"><span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-通过RedisTemplate对象操作Redis">4. 通过RedisTemplate对象操作Redis</h3><p>Spring Data Redis中提供了一个高度封装的类：RedisTemplate，针对jedis客户端中大量api进行了归类封装，将同一类型操作封装为operation接口，具体分类如下:</p><ul><li><strong>ValueOperations</strong>：用于操作字符串类型的数据。</li><li><strong>HashOperations</strong>：用于操作哈希类型的数据（键值对）。</li><li><strong>ListOperations</strong>：用于操作列表类型的数据。</li><li><strong>SetOperations</strong>：用于操作集合类型的数据。</li><li><strong>ZSetOperations</strong>：用于操作有序集合类型的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.test;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="comment">// 启动整个 Spring 应用上下文，模拟一个真实的 Spring 环境，用于集成测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(redisTemplate); <span class="comment">// 非null证明连接成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作字符串类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">valueOperations.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;lr&quot;</span>);</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">System.out.println(username);</span><br><span class="line"><span class="comment">// del</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="comment">// setex</span></span><br><span class="line">valueOperations.set(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">// setnx</span></span><br><span class="line">valueOperations.setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">valueOperations.setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;2&quot;</span>); <span class="comment">// fale</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作哈希类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"><span class="comment">// hset</span></span><br><span class="line">hashOperations.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lr&quot;</span>);</span><br><span class="line">hashOperations.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="comment">// hget</span></span><br><span class="line"><span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(age); <span class="comment">// lr</span></span><br><span class="line"><span class="comment">// hkeys 用set集合</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">System.out.println(keys); <span class="comment">// [name]</span></span><br><span class="line"><span class="comment">// hvals 用list集合</span></span><br><span class="line"><span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">System.out.println(values); <span class="comment">// [lr]</span></span><br><span class="line"><span class="comment">// hdel</span></span><br><span class="line">hashOperations.delete(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作列表类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"><span class="comment">// lpush</span></span><br><span class="line">listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">// lrange</span></span><br><span class="line"><span class="type">List</span> <span class="variable">mylist</span> <span class="operator">=</span> listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(mylist);</span><br><span class="line"><span class="comment">// rpop</span></span><br><span class="line">listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line"><span class="comment">// llen</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">System.out.println(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作列表类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"><span class="comment">// sadd</span></span><br><span class="line">setOperations.add(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">setOperations.add(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="comment">// smembers</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> setOperations.members(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">System.out.println(set1);</span><br><span class="line"><span class="comment">// scard</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> setOperations.size(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">System.out.println(size);</span><br><span class="line"><span class="comment">// sinter</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">intersect</span> <span class="operator">=</span> setOperations.intersect(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">System.out.println(intersect);</span><br><span class="line"><span class="comment">// sunion</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">union</span> <span class="operator">=</span> setOperations.union(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">System.out.println(union);</span><br><span class="line"><span class="comment">// srem</span></span><br><span class="line">setOperations.remove(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作有序集合类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"><span class="comment">// zadd</span></span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="number">12</span>);</span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// zrange</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">zset</span> <span class="operator">=</span> zSetOperations.range(<span class="string">&quot;zset1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(zset);</span><br><span class="line"><span class="comment">// zincrby</span></span><br><span class="line">zSetOperations.incrementScore(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// zrem</span></span><br><span class="line">zSetOperations.remove(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span> &#123; <span class="comment">// 定义一个User类，name，age</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;user:10&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lr&quot;</span>, <span class="number">45</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:10&quot;</span>);</span><br><span class="line">System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用命令操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// keys</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line"><span class="comment">// exists</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">set1</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line"><span class="type">DataType</span> <span class="variable">type</span> <span class="operator">=</span> redisTemplate.type(key);</span><br><span class="line">System.out.println(type.name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// del</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringRedisTemplate"><strong>StringRedisTemplate</strong></h2><p><img src="images/image%2013.png" alt="image.png"></p><ul><li><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="images/image%2014.png" alt="image.png"></p></li><li><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了</p></li><li><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringRedisTemplate源码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title class_">RedisTemplate</span>&lt;String, String&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">StringRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setKeySerializer(RedisSerializer.string());</span><br><span class="line">      <span class="built_in">this</span>.setValueSerializer(RedisSerializer.string());</span><br><span class="line">      <span class="built_in">this</span>.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">      <span class="built_in">this</span>.setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>不需要自己定义RedisConfiguration，直接使用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 手动序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;userdata&quot;</span>, json);</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userdata</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;userdata&quot;</span>);</span><br><span class="line"><span class="comment">// 手动反序列化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">readValue</span> <span class="operator">=</span> mapper.readValue(userdata, User.class);</span><br><span class="line">System.out.println(readValue);</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.notion.so/147d2775339a80fba43fcec357283b64?pvs=21">高级篇</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/post/79666db.html"/>
      <url>/post/79666db.html</url>
      
        <content type="html"><![CDATA[<p>数据的<mark>逻辑</mark>结构是指<mark>数据元素之间</mark>的逻辑关系，它与所使用的计算机无关。</p><p>数据的<mark>物理</mark>结构，又称<mark>存储结构</mark>，是指数据结构在计算机中的表示，它包括数据元素的表示和元素的表示，其中数据元素之间的关系在计算机中有<strong>顺序</strong>存储结构和<strong>链式</strong>存储结构两种。</p><p><mark>逻辑结构</mark><br>集合，线性，树，图</p><ul><li>线性结构：线性表，栈，队列，串</li><li>非线性结构：树，图</li></ul><p>物理结构(存储结构)</p><ul><li>顺序</li><li>链式</li><li>索引</li><li>散列(Has存储)</li></ul><p>运算的定义针对:逻辑结构<br>运算的实现针对:存储结构</p><p><mark>数据&gt;数据元素&gt;数据项</mark></p><p>算法特性(必须全具备)</p><ul><li>有穷性：算法必须有穷，程序可以无穷</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h1>复杂度</h1><h2 id="1-线性查找时间复杂度"><strong>1. 线性查找时间复杂度</strong></h2><ul><li><strong>最坏情况</strong>：目标元素在最后一个位置，需遍历整个链表，时间复杂度为 <strong>O(n)</strong>。</li><li><strong>平均情况</strong>：假设目标元素在各位置概率相等，平均比较次数为 <strong>(n+1)/2</strong>，时间复杂度 <strong>O(n)</strong></li></ul><h2 id="2-单循环链表的头尾访问"><strong>2. 单循环链表的头尾访问</strong></h2><ul><li><strong>带尾指针的单循环链表</strong>：<ul><li>找表头结点：通过尾指针的 <code>next</code> 直接访问，时间复杂度 <strong>O(1)</strong>。</li><li>找表尾结点：直接访问尾指针，时间复杂度 <strong>O(1)</strong>。</li></ul></li><li><strong>带头结点的单循环链表</strong>：<ul><li>找表头结点：直接访问头结点，时间复杂度 <strong>O(1)</strong>。</li><li>找表尾结点：需从头遍历到尾，时间复杂度 <strong>O(n)</strong>。</li></ul></li></ul><h2 id="3-链表合并的时间复杂度"><strong>3. 链表合并的时间复杂度</strong></h2><ul><li><strong>将长度为 n 的单链表链接到长度为 m 的单链表之后</strong>：<ul><li>需要找到链表 m 的尾节点（耗时 <strong>O(m)</strong>），然后修改其 <code>next</code> 指针指向链表 n 的头节点（耗时 <strong>O(1)</strong>）。</li><li>总时间复杂度为 <strong>O(m)</strong>。</li></ul></li></ul><h2 id="4-插入操作的时间复杂度"><strong>4. 插入操作的时间复杂度</strong></h2><ul><li><strong>数组的插入操作</strong>（假设在位置 i 插入元素）：<ul><li><strong>移动次数</strong>：需将第 i 个位置后的所有元素后移，共移动 <strong>n - i</strong> 次。</li><li><strong>总移动次数</strong>：插入所有可能位置（共 <strong>n+1</strong> 种）的移动次数总和为  <strong>(n+1)/2</strong></li><li><strong>平均移动次数</strong>：n/2，时间复杂度 <strong>O(n)</strong>。</li></ul></li><li><strong>链表的插入操作</strong>（假设已知插入位置的前驱节点）：<ul><li>仅需修改指针，时间复杂度 <strong>O(1)</strong>。</li><li>若需遍历找到插入位置，时间复杂度 <strong>O(n)</strong>。</li></ul></li></ul><h2 id="5-删除操作的时间复杂度"><strong>5. 删除操作的时间复杂度</strong></h2><ul><li><strong>数组的删除操作</strong>（假设删除位置 i 的元素）：<ul><li><strong>移动次数</strong>：需将第 i 个位置后的所有元素前移，共移动 <strong>n - i - 1</strong> 次。</li><li><strong>总移动次数</strong>：删除所有可能位置（共 <strong>n</strong> 种）的移动次数总和为  <strong>n(n-1)/2</strong></li><li><strong>平均移动次数</strong>： <strong>(n-1)/2</strong>，时间复杂度 <strong>O(n)</strong>。</li></ul></li><li><strong>链表的删除操作</strong>（假设已知删除节点的前驱节点）：<ul><li>仅需修改指针，时间复杂度 <strong>O(1)</strong>。</li><li>若需遍历找到删除节点，时间复杂度 <strong>O(n)</strong>。</li></ul></li></ul><ol><li><strong>链表与数组的差异</strong>：<ul><li><strong>链表</strong>的插入和删除操作时间复杂度取决于是否已知操作位置的前驱节点：<ul><li>已知前驱节点：<strong>O(1)</strong>。</li><li>需遍历查找位置：<strong>O(n)</strong>。</li></ul></li><li><strong>数组</strong>的插入和删除操作需移动元素，时间复杂度为 <strong>O(n)</strong>。</li></ul></li></ol><table><thead><tr><th>操作</th><th>数组（平均 / 最坏）</th><th>链表（已知前驱节点）</th><th>链表（需遍历）</th></tr></thead><tbody><tr><td><strong>插入元素</strong></td><td>O(n)</td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>删除元素</strong></td><td>O(n)</td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>查找元素</strong></td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td><strong>访问头节点</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td><strong>访问尾节点</strong></td><td>O(1)（有尾指针）</td><td>O(1)（带尾指针）</td><td>O(n)（无尾指针）</td></tr></tbody></table><h1>线性表</h1><p>顺序存储的物理和逻辑是一一对应的<br>链式存储可用于存储线性和非线性的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10    <span class="comment">// 线性表初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INCREMENT 2     <span class="comment">// 容量不足时的增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;        <span class="comment">// 元素类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;          <span class="comment">// 操作状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType* data;         <span class="comment">// 存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;             <span class="comment">// 当前元素个数</span></span><br><span class="line">    <span class="type">int</span> capacity;           <span class="comment">// 当前分配的存储容量</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.data = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.data) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.capacity = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.data) &#123;</span><br><span class="line">        <span class="built_in">free</span>(L.data);</span><br><span class="line">        L.data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前驱元素</span></span><br><span class="line"><span class="function">Status <span class="title">PriorElem</span><span class="params">(SqList L, ElemType cur_e, ElemType &amp;pre_e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == cur_e) &#123;</span><br><span class="line">            pre_e = L.data[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容处理</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.capacity) &#123;</span><br><span class="line">        ElemType* newbase = (ElemType*)<span class="built_in">realloc</span>(L.data,</span><br><span class="line">            (L.capacity + LIST_INCREMENT) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.data = newbase;</span><br><span class="line">        L.capacity += LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListTraverse</span><span class="params">(SqList L, <span class="type">void</span> (*visit)(ElemType))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">MergeSortedLists</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化结果表</span></span><br><span class="line">    Lc.capacity = La.length + Lb.length;</span><br><span class="line">    Lc.data = (ElemType*)<span class="built_in">malloc</span>(Lc.capacity * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Lc.data) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length &amp;&amp; j &lt; Lb.length) &#123;</span><br><span class="line">        Lc.data[k++] = (La.data[i] &lt;= Lb.data[j]) ? La.data[i++] : Lb.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length) Lc.data[k++] = La.data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; Lb.length) Lc.data[k++] = Lb.data[j++];</span><br><span class="line"></span><br><span class="line">    Lc.length = k;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L, i, i * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入元素后: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(L, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">ListDelete</span>(L, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除第3个元素: %d\n&quot;</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(L, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并测试</span></span><br><span class="line">    SqList La, Lb, Lc;</span><br><span class="line">    <span class="built_in">InitList</span>(La);</span><br><span class="line">    <span class="built_in">InitList</span>(Lb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(La, i, i * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">ListInsert</span>(Lb, i, i * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MergeSortedLists</span>(La, Lb, Lc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;合并后结果: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(Lc, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源清理</span></span><br><span class="line">    <span class="built_in">DestroyList</span>(L);</span><br><span class="line">    <span class="built_in">DestroyList</span>(La);</span><br><span class="line">    <span class="built_in">DestroyList</span>(Lb);</span><br><span class="line">    <span class="built_in">DestroyList</span>(Lc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表的合并">顺序表的合并</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2070.png" alt="Untitled 8 70"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2067.png" alt="Untitled 9 67"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2063.png" alt="Untitled 10 63">时间复杂度Q(ListLength(La)+ListLength(Lb))<br>空间复杂度O(1)</p><h2 id="单链表">单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p>普通变量是LNode.成员名，指针变量是LinkList-&gt;成员名<br>Linklist强调单链表，LNode*强调结点</p><p>定义链表L：LNode * L == LinkList L(更常用)<br>定义结点指针：LNode *p(更常用) == LinkList p<br>L-&gt;next有两层含义，可以表示L的后继节点指针，又可表示L的指针域（单链表的指针域只有后继指针域，双链表的指针域分为前驱指针域和后继指针域））<br>p = L就是p = 头结点，p = L-&gt;next就是让p = 头结点的后一个节点。</p><p>头指针：是指向链表第一个结点的指针<br>首元结点：是指向链表中存储第一个数据元素a1的结点<br>头结点：是在链表的首元结点之前附设的一个结点。链表中的头结点仅起到标识的作用。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/5e68616c9b390b7ef84a08401462f0d.jpg" alt="5e68616c9b390b7ef84a08401462f0d"><br>带<mark>头结点</mark>的好处：</p><ol><li>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。</li><li>便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此统一。</li><li>头结点的指针域可以为空，可以存放长度等，但<mark>不计入链表的长度值</mark>。</li></ol><p>表示空表</p><ul><li>无头结点：头指针为空</li><li>有头结点：头结点的指针域为空</li></ul><p>链表特点：</p><ul><li>结点在存储器中位置任意</li><li>只能通过头指针进入链表，顺序扫描。寻找第一个结点很容易。<mark>顺序表是随机存储法</mark></li><li>结点空间可以动态申请和释放</li><li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li><li>缺点：存储密度小，利用率小，每个结点的指针域额外占用存储空间</li><li>静态链表中的指针表示的是数组下标</li></ul><h2 id="头插（逆序）">头插（逆序）</h2><p>带头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7ae0a7bd64d74b5d9a149f7849e38f93.gif" alt="7ae0a7bd64d74b5d9a149f7849e38f93"><br>不带头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/e062fe1ed673468681ecce4d84a865ae.gif" alt="e062fe1ed673468681ecce4d84a865ae"></p><h2 id="尾插">尾插</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2075.png" alt="Untitled 7 75|Untitled 7 75.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/IMG_20231010_091813.jpg" alt="IMG_20231010_091813"><br>带头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/f47832ac0b274b19b1fb2e5ba8d5fcb9.gif" alt="f47832ac0b274b19b1fb2e5ba8d5fcb9"><br>不带头结点同上</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a9b4f515e81d49d9abbc6456ff2bb60e.jpg" alt="a9b4f515e81d49d9abbc6456ff2bb60e"></p><h2 id="带头结点的单链表">带头结点的单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化带头结点的链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="keyword">return</span> ERROR;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = i*<span class="number">2</span>;  <span class="comment">// 测试数据</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_T</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LNode *tail = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = i*<span class="number">3</span>;  <span class="comment">// 测试数据</span></span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置插入</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;  <span class="comment">// 找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListTraverse</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不带头结点的单链表">不带头结点的单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *NoHeadList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化不带头结点的链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(NoHeadList &amp;L)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i*<span class="number">2</span>;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_T</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Node *tail = <span class="literal">NULL</span>;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i*<span class="number">3</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!L) &#123;</span><br><span class="line">            L = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置插入</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;  <span class="comment">// 特殊处理第一个结点</span></span><br><span class="line">        Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || !L) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;  <span class="comment">// 特殊处理第一个结点</span></span><br><span class="line">        Node *q = L;</span><br><span class="line">        e = q-&gt;data;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node *q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListTraverse</span><span class="params">(NoHeadList L)</span> &#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(NoHeadList &amp;L)</span> &#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么不是 <code>free(*r)</code>？</strong></p><ul><li><code>free()</code> 的参数必须是一个指针，指向动态分配的内存块的起始地址。</li><li>如果 <code>r</code> 是一个指针变量（例如 <code>int* r</code>），则 <code>free(r)</code> 是正确的用法，因为 <code>r</code> 本身就是一个指针。</li><li>如果 <code>r</code> 是一个指向指针的指针（例如 <code>int** r</code>），则 <code>free(*r)</code> 是正确的用法，因为 <code>*r</code> 是一个指针，指向动态分配的内存块</li></ul><h2 id="代码思路整理">代码思路整理</h2><h2 id="1-结构差异对比">1. 结构差异对比</h2><table><thead><tr><th>特性</th><th>带头结点</th><th>不带头结点</th></tr></thead><tbody><tr><td>初始化</td><td>需要创建头结点，头指针指向头结点</td><td>直接置空指针</td></tr><tr><td>首元结点处理</td><td>统一通过头结点的 next 指针访问</td><td>直接通过头指针访问</td></tr><tr><td>空表判断</td><td>L-&gt;next == NULL</td><td>L == NULL</td></tr><tr><td>插入 / 删除首结点</td><td>不需要特殊处理</td><td>需要单独处理头指针变化</td></tr><tr><td>算法复杂度</td><td>各操作时间复杂度 O (n)，但边界处理更简单</td><td>时间复杂度相同，但需要更多条件判断</td></tr></tbody></table><h2 id="2-关键实现要点">2. 关键实现要点</h2><ul><li><strong>头插法</strong>：新结点始终插入到链表头部</li><li><strong>尾插法</strong>：需要维护尾指针以提高效率</li><li><strong>位置索引</strong>：统一采用1-based索引</li><li><strong>内存管理</strong>：每次操作后及时释放内存</li><li><strong>错误处理</strong>：对非法位置进行有效性检查</li></ul><h2 id="3-推荐使用场景">3. 推荐使用场景</h2><ul><li><strong>带头结点</strong>：适合需要频繁进行首结点操作的场景</li><li><strong>不带头结点</strong>：适合内存敏感或需要直接操作首结点的场景</li></ul><h2 id="双链表">双链表</h2><p>在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了由两个方向不同的链，表头结点的prior指向NULL，表尾结点的next指向NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span>    <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span>     <span class="comment">// 后继指针</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br></pre></td></tr></table></figure><h2 id="初始化双链表"><strong>初始化双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作（在节点-p-后插入节点-s）"><strong>插入操作（在节点 p 后插入节点 s）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterDNode</span><span class="params">(DNode *p, DNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;     <span class="comment">// 1. s 的后继指向 p 的后继</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)           <span class="comment">// 如果 p 不是最后一个节点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">// 2. p 的后继的前驱指向 s</span></span><br><span class="line">    s-&gt;prior = p;          <span class="comment">// 3. s 的前驱指向 p</span></span><br><span class="line">    p-&gt;next = s;           <span class="comment">// 4. p 的后继指向 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作（删除节点-p-的后继节点）"><strong>删除操作（删除节点 p 的后继节点）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterDNode</span><span class="params">(DNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;next) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    DNode *q = p-&gt;next;  <span class="comment">// q 指向待删除节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">// 1. p 的后继指向 q 的后继</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next)         <span class="comment">// 如果 q 不是最后一个节点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// 2. q 的后继的前驱指向 p</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">// 3. 释放 q 的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环双链表">循环双链表</h2><p>表头结点的prior指向表尾结点，表尾结点的next指向头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20129.png" alt="Untitled 1 129"><br>对称性：p→prior→next = p = p→next→prior</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">prior</span>;</span>   <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 后继指针</span></span><br><span class="line">&#125; CDNode, *CDLinkList;</span><br></pre></td></tr></table></figure><h2 id="初始化循环双链表"><strong>初始化循环双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCDLinkList</span><span class="params">(CDLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = L;  <span class="comment">// 头结点的前驱指向自己</span></span><br><span class="line">    L-&gt;next = L;   <span class="comment">// 头结点的后继指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作（在节点-p-后插入节点-s）-2"><strong>插入操作（在节点 p 后插入节点 s）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterCDNode</span><span class="params">(CDNode *p, CDNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;     <span class="comment">// 1. s 的后继指向 p 的后继</span></span><br><span class="line">    s-&gt;prior = p;          <span class="comment">// 2. s 的前驱指向 p</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;    <span class="comment">// 3. p 的后继的前驱指向 s</span></span><br><span class="line">    p-&gt;next = s;           <span class="comment">// 4. p 的后继指向 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作（删除节点-p-的后继节点）-2"><strong>删除操作（删除节点 p 的后继节点）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterCDNode</span><span class="params">(CDNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || p-&gt;next == p) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性（空表或只有头结点）</span></span><br><span class="line"></span><br><span class="line">    CDNode *q = p-&gt;next;  <span class="comment">// q 指向待删除节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;    <span class="comment">// 1. p 的后继指向 q 的后继</span></span><br><span class="line">    q-&gt;next-&gt;prior = p;   <span class="comment">// 2. q 的后继的前驱指向 p</span></span><br><span class="line">    <span class="built_in">free</span>(q);              <span class="comment">// 3. 释放 q 的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306144931.jpg" alt="Pasted image 20250306144931"><br>1234——s的前驱和后继-&gt;pnext的前驱-&gt;p的后继<br>s-&gt;prior=p;<br>s-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;perior=s;<br>p-&gt;next=s;<br>3214——pnext的前驱-&gt;s的后继-&gt;s的前驱-&gt;p的后继<br>3241——pnext的前驱-&gt;s的后继-&gt;p的后继-&gt;s的前驱<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2096.png" alt="Untitled 3 96"><br>不用头指针的原因：由表头找到表尾较费时，删表头O(1)，插表尾O(n)<br>让L指向尾指针：都是O(1)<br>终止条件：判断是否等于头指针<br>单链表：<br>p≠NULL;<br>p→next≠NULL;<br>单循环链表：<br>p≠L;<br>p→next≠L;</p><p>带尾指针的循环链表的合并(Tb合并在Ta之后)<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20225.png" alt="Untitled 225|Untitled 225.png"><br>p存表头结点（p = Ta→next）→Tb表头连接Ta表尾（Ta→next = Tb→next→next）→释放Tb表头结点（delete Tb→next）→修改指针（Tb→next = p）</p><h2 id="插入操作（以双链表为例）"><strong>插入操作（以双链表为例）</strong></h2><ol><li><strong><code>s-&gt;next = p-&gt;next;</code></strong>：<ul><li>将新节点 <code>s</code> 的后继指向 <code>p</code> 的后继。</li></ul></li><li><strong><code>if (p-&gt;next) p-&gt;next-&gt;prior = s;</code></strong>：<ul><li>如果 <code>p</code> 不是最后一个节点，将 <code>p</code> 的后继的前驱指向 <code>s</code>。</li></ul></li><li><strong><code>s-&gt;prior = p;</code></strong>：<ul><li>将新节点 <code>s</code> 的前驱指向 <code>p</code>。</li></ul></li><li><strong><code>p-&gt;next = s;</code></strong>：<ul><li>将 <code>p</code> 的后继指向 <code>s</code>。</li></ul></li></ol><h2 id="删除操作（以双链表为例）"><strong>删除操作（以双链表为例）</strong></h2><ol><li><strong><code>p-&gt;next = q-&gt;next;</code></strong>：<ul><li>将 <code>p</code> 的后继指向 <code>q</code> 的后继。</li></ul></li><li><strong><code>if (q-&gt;next) q-&gt;next-&gt;prior = p;</code></strong>：<ul><li>如果 <code>q</code> 不是最后一个节点，将 <code>q</code> 的后继的前驱指向 <code>p</code>。</li></ul></li><li><strong><code>free(q);</code></strong>：<ul><li>释放 <code>q</code> 的内存。</li></ul></li></ol><h2 id="双链表-2"><strong>双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterDNode</span><span class="params">(DNode *p, DNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterDNode</span><span class="params">(DNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next) q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDLinkList</span><span class="params">(DLinkList L)</span> &#123;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line"></span><br><span class="line">    DNode *s1 = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s1-&gt;data = <span class="number">10</span>;</span><br><span class="line">    InsertAfterDNode(L, s1);</span><br><span class="line"></span><br><span class="line">    DNode *s2 = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s2-&gt;data = <span class="number">20</span>;</span><br><span class="line">    InsertAfterDNode(s1, s2);</span><br><span class="line"></span><br><span class="line">    PrintDLinkList(L);  <span class="comment">// 输出：10 20</span></span><br><span class="line"></span><br><span class="line">    DeleteAfterDNode(L);</span><br><span class="line">    PrintDLinkList(L);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环双链表-2"><strong>循环双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CDNode, *CDLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCDLinkList</span><span class="params">(CDLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterCDNode</span><span class="params">(CDNode *p, CDNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterCDNode</span><span class="params">(CDNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || p-&gt;next == p) <span class="keyword">return</span>;</span><br><span class="line">    CDNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintCDLinkList</span><span class="params">(CDLinkList L)</span> &#123;</span><br><span class="line">    CDNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != L) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CDLinkList L;</span><br><span class="line">    InitCDLinkList(L);</span><br><span class="line"></span><br><span class="line">    CDNode *s1 = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    s1-&gt;data = <span class="number">10</span>;</span><br><span class="line">    InsertAfterCDNode(L, s1);</span><br><span class="line"></span><br><span class="line">    CDNode *s2 = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    s2-&gt;data = <span class="number">20</span>;</span><br><span class="line">    InsertAfterCDNode(s1, s2);</span><br><span class="line"></span><br><span class="line">    PrintCDLinkList(L);  <span class="comment">// 输出：10 20</span></span><br><span class="line"></span><br><span class="line">    DeleteAfterCDNode(L);</span><br><span class="line">    PrintCDLinkList(L);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表">静态链表</h2><p>用数组实现的链表结构，它通过数组的下标来模拟链表的指针。静态链表的特点是不需要动态分配内存，而是预先分配一个<strong>固定大小</strong>的数组来存储链表节点。<br>静态链表的结构</p><ul><li><p><strong>数组存储</strong>：</p><ul><li>静态链表使用数组来存储节点，每个节点包含两个部分：<ul><li><strong>数据域</strong>：存储数据。</li><li><strong>游标（或指针域）</strong>：存储下一个节点的数组下标。</li></ul></li><li>数组的每个位置可以看作一个节点，游标指向下一个节点的位置。</li></ul></li><li><p><strong>头结点和空闲链表</strong>：</p><ul><li>静态链表通常有一个头结点，用于指向链表的第一个节点。</li><li>空闲链表用于管理未使用的数组位置，方便插入新节点。</li></ul></li></ul><p>为什么不需要移动元素</p><h2 id="插入操作"><strong>插入操作</strong></h2><ul><li><strong>插入新节点</strong>：<ul><li>从空闲链表中获取一个空闲位置（数组下标）。</li><li>修改游标，将新节点插入到链表中。</li><li><strong>不需要移动其他元素</strong>，只需修改游标。</li></ul></li></ul><h2 id="删除操作"><strong>删除操作</strong></h2><ul><li><strong>删除节点</strong>：<ul><li>将要删除的节点从链表中移除。</li><li>将该节点的位置加入空闲链表。</li><li><strong>不需要移动其他元素</strong>，只需修改游标。</li></ul></li></ul><h2 id="修改游标"><strong>修改游标</strong></h2><ul><li>静态链表通过修改游标（数组下标）来维护链表结构，而不是通过移动数据元素。</li><li>这种方式类似于动态链表，但使用数组下标代替指针。</li></ul><p><strong>与动态链表的对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>动态链表</strong></th><th><strong>静态链表</strong></th></tr></thead><tbody><tr><td><strong>存储结构</strong></td><td>使用指针连接节点</td><td>使用数组下标（游标）连接节点</td></tr><tr><td><strong>内存分配</strong></td><td>动态分配内存</td><td>预先分配固定大小的数组</td></tr><tr><td><strong>插入/删除</strong></td><td>修改指针</td><td>修改游标</td></tr><tr><td><strong>移动元素</strong></td><td>不需要移动元素</td><td>不需要移动元素</td></tr><tr><td><strong>内存管理</strong></td><td>需要动态内存管理</td><td>不需要动态内存管理</td></tr><tr><td><strong>适用场景</strong></td><td>数据量不确定，频繁插入删除</td><td>数据量固定，内存受限的场景</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">// 游标（下一个节点的下标）</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node staticList[MAX_SIZE];  <span class="comment">// 静态链表数组</span></span><br><span class="line"><span class="type">int</span> head;                   <span class="comment">// 头结点下标</span></span><br><span class="line"><span class="type">int</span> freeList;               <span class="comment">// 空闲链表头结点下标</span></span><br></pre></td></tr></table></figure><h2 id="插入操作-2"><strong>插入操作</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (freeList == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;静态链表已满，无法插入新节点！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲链表中获取一个节点</span></span><br><span class="line">    <span class="type">int</span> newNodeIndex = freeList;</span><br><span class="line">    freeList = staticList[freeList].next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    staticList[newNodeIndex].data = data;</span><br><span class="line">    staticList[newNodeIndex].next = staticList[head].next;</span><br><span class="line">    staticList[head].next = newNodeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作-2"><strong>删除操作</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev = head;</span><br><span class="line">    <span class="type">int</span> curr = staticList[head].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticList[curr].data == data) &#123;</span><br><span class="line">            <span class="comment">// 从链表中移除节点</span></span><br><span class="line">            staticList[prev].next = staticList[curr].next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将节点加入空闲链表</span></span><br><span class="line">            staticList[curr].next = freeList;</span><br><span class="line">            freeList = curr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = staticList[curr].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未找到要删除的元素！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态链表不需要移动元素</strong>，因为它通过修改游标（数组下标）来维护链表结构。</li><li>插入和删除操作只需修改游标，而不需要移动数据元素。</li><li>静态链表适用于内存受限的场景，但灵活性不如动态链表。</li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2046.png" alt="Untitled 2 46"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2040.png" alt="Untitled 3 40"><br>顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取<br>在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂<br>双链表中可以快速访问任何一个结点的前驱和后继结点,选项D正确。</p><h2 id="错题">错题</h2><p>^3afb0f</p><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png" alt="Pasted image 20250306152709">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png" alt="Pasted image 20250306152709">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152828.png" alt="Pasted image 20250306152828">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306154314.png" alt="Pasted image 20250306154314">d</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306160930.png" alt="Pasted image 20250306160930">链式存储设计时，各个不同结点的<mark>存储空间</mark>可以不连续，但结点内的<mark>存储单元地址</mark>必须连续</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161045.png" alt="Pasted image 20250306161045"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161310.png" alt="Pasted image 20250306161310"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162035.png" alt="Pasted image 20250306162035"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162229.png" alt="Pasted image 20250306162229"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163931.png" alt="Pasted image 20250306163931">设单链表递增有序，首先要在单链表中找到第一个大于x的结点的直接前驱p，在p之后插入该结点。查找的时间复杂度为 O(n)，插入的时间复杂度为 0(1)，总时间复杂度为 O(n)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162259.png" alt="Pasted image 20250306162259"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162245.png" alt="Pasted image 20250306162245"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162348.png" alt="Pasted image 20250306162348">b有关因为需要遍历链表找到倒数第二个节点。d无关，因为尾指针 r 直接指向最后一个节点，无需遍历</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162745.png" alt="Pasted image 20250306162745">d线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素 a50 不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163806.png" alt="Pasted image 20250306163806">改四个指针域，分别是:新结点的前驱指针域，指向第一个结点:新结点的后继指针域，指向第二个结点;第一个结点的后继指针域，指向新结点;第二个结点的前驱指针域，指向新结点。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306164359.png" alt="Pasted image 20250306164359">带头结点的循环单链表工为空表时，满足L-&gt;next == L，即头结点的指针域与L的值相等,而不是头结点的指针域与工的地址相等。注意，带头结点的循环单链表中不存在空指针。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306165707.png" alt="Pasted image 20250306165707">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170529.png" alt="Pasted image 20250306170529"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170531.png" alt="Pasted image 20250306170531">对于选项 A，删除尾结点* p 时，需要找到* p的前一个结点，时间复杂度为 O(n)。对于选项B，删除首结点* p时，需要找到* p结点,这里没有直接给出头结点指针，而通过尾结点的 prior指针找到* p 结点的时间复杂度为 O(n)。对于选项 D，删除尾结点* p 时，需要找到* p 的前一个结点，时间复杂度为 O(n)。对于C，执行这四种算法的时间复杂度均为 O(1)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171120.png" alt="Pasted image 20250306171120">在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为 O(1)。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在 0(1)的时间找到尾结点:若只有表头指针，则需要遍历整个链表找到尾结点，时间为0(n)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171301.png" alt="Pasted image 20250306171301">对一个空循环单链表，有 head-&gt;next== head，推理 head-&gt;next-&gt;next== head-&gt;next== head。对含有一个元素的循环单链表，头结点(头指针 head 指示)的 next 域指向这个唯一的元素结点，该元素结点的next 域指向头结点，因此也有 head-&gt;next-&gt;next=head。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171913.png" alt="Pasted image 20250306171913">对于两种双链表，删除首结点的时间复杂度都是 0(1)。对于非循环双链表，删除尾结点的时间复杂度是 0(m);对于循环双链表，删除尾结点的时间复杂度是0(1)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172027.png" alt="Pasted image 20250306172027">对于选项 A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为 O(n);而删除第一个元素时，为保持循环单链表的性质(尾结点指向第一个结点)，要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为 O(n)。对于选项 B,双链表的情况与单链表的相同，一个是 O(n),一个是 O(1)。对于选项C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置,时间复杂度为 0(n);删除第一个元素的时间复杂度为 O(1)。对于选项 D，与选项 A 的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为0(1)</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172625.png" alt="Pasted image 20250306172625">静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306173426.png" alt="Pasted image 20250306173426">静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。并非每个空间都存储了元素，因此会造成存储空间的浪费。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174519.png" alt="Pasted image 20250306174519"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174543.png" alt="Pasted image 20250306174543"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306175206.png" alt="Pasted image 20250306175206">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191738.png" alt="Pasted image 20250306191738"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191747.png" alt="Pasted image 20250306191747"></li><li></li></ol><h1>栈LIFO</h1><p>栈和队列都是<strong>操作受限</strong>线性表<br>应用：撤销，递归，进制转换，迷宫求解，表达式求值，括号匹配，处理函数或过程调用时的局部变量、返回地址、参数，深度优先遍历DFS<br>在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。<br>栈只能操作栈顶</p><h2 id="顺序栈">顺序栈</h2><p>在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307111852.png" alt="Pasted image 20250307111852">栈顶指针：S.top，初始时设置S.top=-1<br>栈底 0<br>栈顶元素：S.data[S.top]<br>入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶 S.data[++S.top] = x<br>出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1 x = S.data[S.top–]<br>栈空条件：S.top == -1<br>栈满条件：S.top== MaxSize-1<br>栈长：S.top+1<br>另一种常见的方式是：<br>初始设置栈顶指针 S.top=0<br>入栈时先将值送到栈顶，栈顶指针再加 1<br>出栈时，栈顶指针先减1，再取栈顶元素<br>栈空条件是 S.top== 0<br>栈满条件是S.top== MaxSize.<br>顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">SElemType* base;</span><br><span class="line">SElemType* top;</span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307121133.png" alt="Pasted image 20250307121133|200"><br>top指示真正栈顶元素之上的下标地址<br>stacksize表示栈的最大容量，共stacksize-1个元素<br>空栈：base== top<br>栈满：top-base== stacksize<br>下溢：栈空还要弹出元素，一般当作一种结束条件<br>上溢：是错误</p><p>3+2的前缀表达形式就是+ 3 2<br>3+2的后缀表达形式就是3 2 +<br>后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)</p><h2 id="共享栈">共享栈</h2><p>两个栈共享一个数组空间的好处：存储空间，降低上溢出发生的机率。其存取数据的时间复杂度均为0(1)，所以对存取效率没有什么影响。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112107.png" alt="Pasted image 20250307112107"><br>两个栈的栈顶指针都指向栈顶元素<br>top0=-1时0号栈为空，top1=Maxsize 时1号栈头空<br>仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满<br>当0号栈入栈时 top0 先加再赋值，1号栈入栈时 top1 先减1再赋值，出栈时则刚好相反<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2047.png" alt="Untitled 2 47|500"></p><h2 id="链栈">链栈</h2><p>使用单链表实现，且所有操作都是在表头进行，没有头结点，Lhead指向栈顶元素<br>栈顶-&gt;栈底<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112353.png" alt="Pasted image 20250307112353"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkNode,LiStack;</span><br></pre></td></tr></table></figure><p>采用链式存储，便于结点的插入与删除<br>链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行<br>需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同<br>有多少种不同的出栈序列<br>卡特兰数：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_1203_103148.png" alt="Screenshot_2023_1203_103148|90 "></p><ul><li><strong>时间复杂度</strong><ul><li>链栈和顺序栈的进栈和出栈操作时间复杂度均为 O(1)</li></ul></li><li><strong>空间性能</strong>：<ul><li>链栈不需要预先分配固定空间，但每个节点需要额外的指针域。</li><li>顺序栈需要预先分配固定空间，可能导致内存浪费，但存取方便。</li></ul></li><li><strong>选择建议</strong><ul><li>如果栈的长度变化不可预料，建议使用链栈。</li><li>如果栈的长度变化在可控范围内，建议使用顺序栈。</li></ul></li></ul><h2 id="错题-2">错题</h2><p>1.<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112815.png" alt="Pasted image 20250307112815">栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同<br>2. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112922.png" alt="Pasted image 20250307112922">栈和队列都是限制存取点的线性结构<br>3. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113142.png" alt="Pasted image 20250307113142">顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间<br>4. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113421.png" alt="Pasted image 20250307113421">对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而循环单链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于选项C，插入和删除结点后，找尾结点所需的时间为 O(n)。<br>5. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114112.png" alt="Pasted image 20250307114112">第n个元素第一个出栈，说明前n-1个元素都已经按顺序入栈d<br>6. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114354.png" alt="Pasted image 20250307114354">d<br>7. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114611.png" alt="Pasted image 20250307114611">p3=1第一个出栈，此时栈内有p1,p2;2第二个出栈，所以2只可能是p2或者p4,p5…;因此选C<br>8. 将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-* -g+时,用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空,则转换过程中同时保存在栈中的操作符的最大个数是() A. 5 B. 7 C. 8 D. 11<br>在转换过程中，栈中的操作符最多有5个。这种情况出现在第二个“+”号入栈后，栈中的操作符分别为：“-”，“”，“(”，“(”，“+”。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190631.png" alt="Pasted image 20250307190631"><br>9. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190913.png" alt="Pasted image 20250307190913"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190923.png" alt="Pasted image 20250307190923"><br>10.</p><h1>队列FIFO</h1><p><mark>头删尾插</mark><br>栈和队列是受限的线性表，它们的共同点是只允许在端点处插入和删除元素。<br>栈只允许在一端进行插入、删除操作<br>队列只允许在一端进行插入,在另一端进行删除<br>应用：缓冲区，层次遍历，CPU资源竞争，广度优先搜索BFS，消息队列<br>采用<mark>尾指针</mark>的循环单链表适合作为队列的存储结构<br>队列一般情况下需要修改队尾指针，但是当队列为空时需要同时修改头尾指针<br>最适合用作链式队列的链表是带有队头指针和队尾指针的非循环单链表<br>为了防止队列发生假溢出，应该使用循环队列</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307122136.png" alt="Pasted image 20250307122136|400"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> data[MaxSize];</span><br><span class="line"> <span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>初始时:Q.front=Q.rear=0。<br>入队操作：队不满时，先送值到队尾元素，再将队尾指针加1<br>出队操作：队不空时，先取队首元素值，再将队首指针加1<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123048.png" alt="Pasted image 20250307123048|500"><br>不能用 Q.rear== Maxsize 作为队列满的条件(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出””，但这种溢出并不是真正的溢出，在 data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。</p><h2 id="循环队列">循环队列</h2><p>因为每次入队或者出队都是font或者rear向后移动一位,font指针无法往前移动,此时就会造成删除的空间无法使用，循环队列即可解决问题<br>把存储队列元素的表从逻辑上视为一个环,称为循环队列<br>当队首指针 Q.front=Maxsize-1后，再前进一个位置就自动到0，这可以利用除法取模运算(%)来实现。<br>初始时：Q.front=Q.rear=0。<br>队首指针进1：Q.front=(Q.front+1)%Maxsize。<br>队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。<br>队列长度：(Q.rear+Maxsize-Q.front)%Maxsize。<br>出入队时：指针都按顺时针方向进1<br>循环队列需要几个参数来确定?以及各个参数的含义？<br>需要2个参数,第一个参数是front,第二个参数是rear;<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123713.png" alt="Pasted image 20250307123713|500"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307124944.png" alt="Pasted image 20250307124944"><br>队满条件：（Q.rear+1）%MaxSize== Q.front<br>队空条件：Q.front== Q.rear</p><h2 id="链式队列">链式队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> &#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br></pre></td></tr></table></figure><p>不带头结点时，当Q.front== NULL且Q.rear== NULL 时，链式队列为空<br>插入r→next=s;s-&gt;next=NULL;r=s;<br>用链头作为队头</p><h2 id="静态队列">静态队列</h2><p>基于数组实现的，如果是普通数组，规定front指向第一个元素的位置，rear指向最后一个元素位置的下一个位置<br>如果front指向第一个的前一个元素，rear就指向最后一个元素。<br>初始状态（队空条件）：Q-&gt;front == Q-&gt;rear == 0。<br>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。<br>出队操作：队不空时，先取队头元素值，再将队头指针加1。</p><h2 id="双端队列">双端队列</h2><p>允许两端都可以进行插入和删除操作的线性表<br>输入受限：一端插入删除，另一端删除<br>输出受限：一端插入删除，另一端插入</p><h2 id="错题-3">错题</h2><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307131237.png" alt="Pasted image 20250307131237">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307171220.png" alt="Pasted image 20250307171220">循环队列中，每删除一个元素，队首指针 front=(front+1)%6，每插入一个元素，队尾指针 rear=(rear+1)%6。上述操作后，front=0，rear=3</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307172039.png" alt="Pasted image 20250307172039">虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的入队和出队时间复杂度均为O(1)。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175308.png" alt="Pasted image 20250307175308">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174201.png" alt="Pasted image 20250307174201">因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要 0(n)的时间。选项 B、C和D均可在 0(1)的时间内找到队首和队尾。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174444.png" alt="Pasted image 20250307174444">队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素,则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，修改队尾指针为rear=front。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175540.png" alt="Pasted image 20250307175540"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175551.png" alt="Pasted image 20250307175551"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180416.png" alt="Pasted image 20250307180416"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180430.png" alt="Pasted image 20250307180430"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307181119.png" alt="Pasted image 20250307181119">第一个元素进入队列后存储在A[0]处，此时 front 和 rear 值都为0。入队时因为要执行(rear+1)%n 操作，所以若入队后指针指向 0，则 rear 初值为 n-1，而因为第一个元素在A[0]中，插入操作只改变rear 指针，所以front为0不变</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182400.png" alt="Pasted image 20250307182400">利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得 R1，C入栈，计算得 R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D依次计算得栈深为 4、3、3。因此选择选项 B</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182639.png" alt="Pasted image 20250307182639"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182649.png" alt="Pasted image 20250307182649"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182804.png" alt="Pasted image 20250307182804">b</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182833.png" alt="Pasted image 20250307182833">c</li><li></li></ol><h1>数组</h1><p>线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。<br>特点：结构固定——定义后，维数和维界不再改变。<br>LOC(aij)=基地址+偏移量<br>数组偏移量基址<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20138.png" alt="Untitled 138|Untitled 138.png|300"><br>以行为例，地址=基地址+(i×n+j)×元素大小</p><p>三维数组：a mno<br>三维数组计算a ijk的公式为d=i* n* o+j* o+k，就是d高* 长* 宽+d长* 高+d宽</p><p>typedef elemtype array2【m】【n】;<br>等价<br>typedef elemtype array1[n];<br>typedef array1 array2[m];</p><h2 id="压缩存储">压缩存储</h2><p>为多个值相同的元只分配一个存储空间；对零元不分配空间。<br><strong>特殊矩阵的压缩存储</strong>方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。目的：减少不必要的存储空间</p><p>一维数组a[i]的存放地址=起始地址+i* sizeof(ElemType)<br>存储目的：把一个<strong>n维的数组定义为其数据元素为n-1维数组类型的一维数组</strong>。<br>二维数组的存储结构：<br><mark>行优先存储</mark>：定义二维数组 a：int a【4】【5】。由下图可知，对于行优先，a【2】【3】是第几个元素的求法为：行标2之前的行已填满元素，每行元素有5个，行标2所指的行的元素个数由列标指示出来，因此a【2】【3】是第2x5+3+1=14个元素，a【2】【3】之前有13个元素。<br><mark>列优先存储</mark>：对于列优先，a【2】【3】是第几个元素的求法为：列标3之前的列已填满元素，每列元素有4个，列标3所指的列的元素个数由行标指示出来，因此a【2】【3】是第3x4+2+1=15个元素，a【2】【3】之前有14个元素。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/8ee2d0ea49804b7991042179b2c863fb.jpg" alt="8ee2d0ea49804b7991042179b2c863fb"></p><p>按列<br> LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))* L<br>按行<br>LOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))* L</p><h2 id="特殊矩阵">特殊矩阵</h2><p>矩阵下标默认从1开始<br>数组默认从0开始</p><h2 id="对称矩阵">对称矩阵</h2><p>n阶方阵，aij=aji（1⩽i,j⩽n）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104031.png" alt="Pasted image 20250308104031|200">存储策略：只存储主对角线+上/下三角区<br>元素个数为n(n+1)/2<br>n阶矩阵A可以用一维数组B== [n(n+1)/2]== 以行序为主序存储其下三角（包括对角线）中的元素，那么B[k]与aij之间存在一一对应关系：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104132.png" alt="Pasted image 20250308104132|350"></p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/c694632cf58d4933a61613c570a30ddb.jpg" alt="c694632cf58d4933a61613c570a30ddb"></p><p>一般存下三角+主对角线，用等差数列，上三角i，j互换就可以</p><h2 id="三角阵">三角阵</h2><p>存储方法与对称矩阵类似，使用n(n+1)/2+1个存储空间，其中最后一个空间用来存放常数c，在一维数组中的存储结果如下图：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a588174886ae4654a8ae7fafcb71d526.jpg" alt="a588174886ae4654a8ae7fafcb71d526"><br>下三角：i&lt;j时，有aij=0<br>上三角：i&gt;j时，有aij=0 上三角为0<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20131.png" alt="Untitled 1 131|Untitled 1 131.png|300"><br>上三角矩阵的压缩存储公式<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0815_075029.png" alt="Screenshot_2023_0815_075029|350"></p><h2 id="三对角矩阵">三对角矩阵</h2><p>n(n&gt;=3)阶三对角矩阵中的非零元素都集中在以主对角线为中心的带状区域中，其他区域均为零元，也即当|i-j|&gt;1时，有aij=0。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308120026.png" alt="Pasted image 20250308120026"></p><ul><li>对于 n×nn×n 的三对角矩阵：<ul><li>第 1 行和最后 1 行只有 2 个非零元素。</li><li>中间的行有 3 个非零元素。<br>那么以行序将这些非零元素存储到一维数组B[3n-3]中，那么对应关系是：<br>k=2i+j−3（数组下标从0开始）<br>那么以行序将这些非零元素存储到一维数组B[3n-2]中，那么对应关系是：<br>k=2i+j−2（数组下标从1开始）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/89d0f9130782418894dfe03158fe2059.jpg" alt="89d0f9130782418894dfe03158fe2059"></li></ul></li></ul><h2 id="稀疏矩阵">稀疏矩阵</h2><p>0的个数比非零的多<br>稀疏矩阵进行压缩存储通常有两种方法:顺序存储(三元组)和链式存储(十字链表)<br>稀疏矩阵采用压缩存储后的缺点主要是<mark>丧失随机存取的特性</mark></p><h2 id="错题-4">错题</h2><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308111917.png" alt="Pasted image 20250308111917">A[0][0] 存放在 B[0]<br>对于第 i行，存储的元素为i0 i1 … ii<br>第 i 行的元素个数为 i+1<br>前 i 行的元素总数为：1+2+3+⋯+i=(i+1)i/2</li><li>二维数组 A 按行优先存储，其中每个元素占1个存储单元。若 A11的存储地址为420，A33的存储地址为446，则A55的存储地址为()<br>由行优先存储得到aij的地址地址=基地址+(i×n+j)×元素大小，得出基地址407，12列，故a55=472</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114043.png" alt="Pasted image 20250308114043">k=2i+j- 2，195</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114656.png" alt="Pasted image 20250308114656"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114705.png" alt="Pasted image 20250308114705"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115002.png" alt="Pasted image 20250308115002"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115013.png" alt="Pasted image 20250308115013"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115654.png" alt="Pasted image 20250308115654">总数=2+28×3+1=2+84=87或k=2i+j-3</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122246.png" alt="Pasted image 20250308122246">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122545.png" alt="Pasted image 20250308122545">按上三角存储，m7,2对应的是m2,7，在它之前有： 第1列：1 第2列：2 第6列：6 第7列：1 前面一共1+2+3+4+5+6+1个元素，共22个元素，数组下标从0开始，故下标为m2,7的数组下标为22。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122839.png" alt="Pasted image 20250308122839"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308123055.png" alt="Pasted image 20250308123055"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308124253.png" alt="Pasted image 20250308124253|400">按列优先次序存储，A[6,7]处于第7行第8列，前面有7列，每一列8x5个单元，再加上第8列前面的6个元素6x5，即7x8x5+6x5=310</li><li></li></ol><h1>串</h1><p>定义：是由零个或多个字符组成的有限序列<br>S=’a1a2a3……an’<br>编号默认从1开始<br>串值用单引号括起来<br>子串：串中任意个连续的字符组成的子序列<br>字符串的子串数目为n(n+1)/2 + 1<br>主串：包含子串的串<br>字符在主串中的位置：字符在串中的序号<br>子串在主串中的位置：子串的第一个字符在主串中的位置<br>例如，有串 A=‘china Beijing’，B=‘Beijing’，c=‘china’，则它们的长度分别头13、7 和 5。B 和C是A的子串，B在A中的位置是 7,c 在A中的位置是1。<br>串是一种特殊的线性表，数据元素之间呈线性关系。但线性表以单个元素为操作对象，而串以整体（子串）为操作对象。</p><h2 id="串的存储结构">串的存储结构</h2><h2 id="定长顺序存储">定长顺序存储</h2><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。<br>定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> ch[MaxLen]; <span class="comment">// 每个分量存储一个字符</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h2 id="堆分配存储表示">堆分配存储表示</h2><p>堆分配存储表示仍然以一组地址<mark>连续</mark>的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中<mark>动态</mark>分配得到的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *ch; <span class="comment">// 按串长分配存储区，ch指向串的基地址</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h2 id="块链存储表示">块链存储表示</h2><p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a)是结点大小为4(每个结点存放4个字符)的链表，最后一个结点占不满时通常用“#”补上;图 4.1(b)是结点大小为1的链表。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308125233.png" alt="Pasted image 20250308125233|400"></p><h2 id="字符串的模式匹配">字符串的模式匹配</h2><p>字符串的模式匹配是指在主串中找到与模式串相同的子串，并返回其所在位置。常见的模式匹配算法包括朴素模式匹配算法和KMP算法。</p><h2 id="1-朴素模式匹配算法"><strong>1. 朴素模式匹配算法</strong></h2><p><strong>基本思想</strong></p><ul><li>将主串中所有长度为  m  的子串依次与模式串对比，直到找到一个完全匹配的子串或所有子串都不匹配为止。</li><li>最多需要对比  n - m + 1  个子串。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308131814.png" alt="Pasted image 20250308131814|250"><br><strong>时间复杂度</strong></li><li>最坏情况下，时间复杂度为  O(nm) ，其中  n  是主串长度， m  是模式串长度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(HString S, HString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, i;</span><br><span class="line">    HString sub;</span><br><span class="line">    <span class="built_in">InitString</span>(sub);</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="built_in">StrLength</span>(S);</span><br><span class="line">        m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">        i = pos;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">SubString</span>(sub, S, i, m);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">StrCompare</span>(sub, T) != <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化实现（直接通过数组下标）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index1</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= pos &amp;&amp; pos &lt;= S[<span class="number">0</span>]) &#123;</span><br><span class="line">        i = pos;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">2</span>; <span class="comment">// i 指向下一个子串的第一个位置</span></span><br><span class="line">                j = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) <span class="comment">// S 中存在 T</span></span><br><span class="line">            <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-KMP算法"><strong>2. KMP算法</strong></h2><p><strong>基本思想</strong></p><ul><li>利用已经匹配过的模式串信息，避免主串指针回溯。<ul><li>特点是在模式匹配时，指示主串的指针不会变小</li></ul></li><li>通过预处理模式串，生成 <code>next</code> 数组，记录模式串中每个位置的最长公共前后缀长度。</li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308132051.png" alt="Pasted image 20250308132051"><br><strong>时间复杂度</strong></p><ul><li>预处理 <code>next</code> 数组的时间复杂度为  O(m) 。</li><li>匹配过程的时间复杂度为  O(n) 。</li><li>总时间复杂度为  O(n + m) 。<br><strong>核心思想</strong></li><li>在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位j与主串位 i比较时，两个字符不相等，则i的位移方式是 <code>next[j]</code> ，而不是从头开始匹配。主串位指针i不变</li><li><code>next</code> 数组的定义：<code>next[j]</code> 表示模式串中前  j  个字符的最长公共前后缀长度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(SString T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> next[T[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">getNext</span>(T, next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>next</code> 数组的优化（<code>nextval</code> 数组）</strong></p><ul><li>通过进一步优化 <code>next</code> 数组，减少不必要的比较。</li><li>当 <code>T[i] == T[j]</code> 时，<code>nextval[i] = nextval[j]</code>；否则，<code>nextval[i] = j</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><strong>朴素模式匹配算法</strong></th><th><strong>KMP算法</strong></th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>O(nm)</td><td>O(n + m)</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(1)</td><td>O(m) （<code>next</code> 数组）</td></tr><tr><td><strong>主串指针回溯</strong></td><td>需要回溯</td><td>不需要回溯</td></tr><tr><td><strong>适用场景</strong></td><td>模式串较短，主串较小</td><td>模式串较长，主串较大</td></tr></tbody></table><ul><li><strong>朴素模式匹配算法</strong>：实现简单，但效率较低，适合小规模数据。</li><li><strong>KMP算法</strong>：通过预处理模式串，避免主串指针回溯，适合大规模数据。</li><li><strong><code>nextval</code> 数组</strong>：进一步优化 <code>next</code> 数组，减少不必要的比较。</li></ul><h2 id="模式串示例">模式串示例</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308141430.png" alt="Pasted image 20250308141430"><br>next：</p><ol><li>前两个0,1</li><li>之后在当前索引前找两个正向的最大公共子串，next为第一个子串的下一个索引值，例如索引6，看1—5有aba公共子串，next6为4</li></ol><p>nextval：</p><ol><li>第一个为0</li><li>之后看对应的next值所对应的索引字母，例如索引为3的nextval，对应的next为1，对应的索引字母为a，索引3的字母也为a，nextval为索引为1的nextval；若不是同一个字母，nextval则为对应的next值，例如索引为6的对应next4的字母为b，6为a，不一样，nextval为当前next值4<br>T = “abacab”<br>next = [0, 1, 1, 0, 1, 2]<br>nextval = [0, 1, 0, 1, 0, 1]</li></ol><p>ababaaababaa<br>next=<code>[011234223456]</code></p><p>aaab<br>next=<code>[0123]</code><br>nextval=<code>[0003]</code></p><h2 id="错题-5">错题</h2><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143227.png" alt="Pasted image 20250308143227"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143253.png" alt="Pasted image 20250308143253"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143322.png" alt="Pasted image 20250308143322"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308144541.png" alt="Pasted image 20250308144541"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/66d2e1adc05dd53c7bb762eebfa395b.jpg" alt="66d2e1adc05dd53c7bb762eebfa395b|400"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308145836.png" alt="Pasted image 20250308145836">next<code>[0112342]</code> nextval<code>[0101042]</code> j-nextval<code>[6]</code>=2</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152637.png" alt="Pasted image 20250308152637">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308151042.png" alt="Pasted image 20250308151042">由于i=j=5时失效，故主串和模式串的位序都是从0开始的。此时i=5，next<code>[j]</code>=next<code>[5]</code>=2，c<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152257.png" alt="Pasted image 20250308152257|300"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152151.png" alt="Pasted image 20250308152151">b</li></ol><h1>二叉树</h1><ol><li><strong>树的定义</strong><ul><li><strong>m叉树</strong>：每个结点最多有 <code>m</code> 个子结点，可以为空树。</li><li><strong>树的度</strong>：所有结点的度的最大值。<ul><li><strong>度为m的树</strong>：各结点的度的最大值<br>至少有一个结点度=m<br>至少有m+1个结点</li></ul></li><li><strong>叶子结点</strong>（终端结点）：没有子结点的结点。</li><li><strong>分支结点</strong>（非终端结点）：至少有一个子结点的结点。</li><li><strong>根结点</strong>：唯一没有前驱的结点，既可以是叶子结点（空树），也可以是分支结点。</li></ul></li><li><strong>结点与度的关系</strong><ul><li><strong>结点数 = 总度数 + 1</strong><br>（每个结点被父结点指向一次，根结点无父结点）</li><li><strong>分支数 = 结点数 - 1 = 总度数</strong><br>（每个分支对应一个子结点）</li><li><strong>节点度数关系</strong> n0​=n2​+2n3​+…+(k−1)nk​+1</li><li><h2 id="总节点数与度数关系"><strong>总节点数与度数关系</strong></h2>对于完全二叉树或多叉树：<br>n=1+n1+2n2+3n3（总分支数 + 根节点）<br>n=n0+n1+n2+n3（总节点数）<br>总度数=n-1=n1+2n2+3n3<br>3.<strong>树的路径与高度</strong></li><li><strong>路径长度</strong>：根到每个结点的路径长度之和。</li><li><strong>树的深度/深度</strong>：根结点的层数（通常从 1 开始）。</li></ul></li></ol><h2 id="树的性质">树的性质</h2><ol><li><strong>结点数范围</strong><ul><li><strong>高度为 <code>h</code> 的 m 叉树</strong>：<ul><li><strong>至少</strong>有 <code>h</code> 个结点（每层仅 1 个结点）。</li><li><strong>至多</strong>有 <code>(m^h - 1)/(m - 1)</code> 个结点（满 m 叉树）<br>二叉树2^n-1个</li></ul></li><li><strong>高度为 <code>h</code>、度为 <code>m</code> 的树</strong>：至少 <code>h + m - 1</code> 个结点</li><li>度为 m、具有 n个结点的树的最大高度h为n-m+1</li><li>度为m的树中<strong>第i层</strong>上至多有**m^(i-1)个结点(i≥1)</li></ul></li><li><strong>最小高度公式</strong><ul><li><strong>具有 <code>n</code> 个结点的 m 叉树</strong>的最小高度logm(n(m-1)+1)</li></ul></li><li><strong>树的形态数</strong><ul><li><code>n</code> 个结点的二叉树共有 <code>C(2n, n)/(n+1)</code> 种不同形态（卡塔兰数）。</li><li>例：3 个结点的二叉树有 5 种形态。</li></ul></li></ol><h2 id="二叉树">二叉树</h2><ol><li><strong>定义与性质</strong><ul><li><strong>二叉树</strong>：每个结点最多有 2 个子结点，且左右子树<strong>有序</strong>。</li><li><strong>度为2</strong>的树至少有3个结点，而二叉树可以为空</li><li><strong>非空二叉树</strong>的叶子结点数 <code>n0</code> 与二分支结点数 <code>n2</code> 的关系：n0=n2+1</li><li><strong>高度 H 的二叉树</strong>：</li><li>最多节点数：2k − 1（满二叉树）</li><li>最少节点数：k（退化为链式结构）</li><li>第i层至多有2^(i-1)个结点</li></ul></li><li><strong>特殊二叉树</strong><ul><li><strong>满二叉树</strong>：<ul><li>高度 <code>h</code>，结点数 <code>2^h - 1</code>。</li><li>只有最后一层有叶子结点，不存在度为 1 的结点。</li></ul></li><li><strong>完全二叉树</strong>：<ul><li>由满二叉树删除最底层最右侧连续若干结点形成。</li><li><strong>性质</strong>：<ul><li>叶子结点只出现在<strong>最后两层</strong>。</li><li>最多一个度为 1 的结点（左孩子），为最后一个分支结点，其结点编号为<code>[n/2]</code>，且n为偶数时，若为奇数，每个分支都有左右孩子</li><li>编号为 <code>i</code> 的结点，左孩子为 <code>2i</code>，右孩子为 <code>2i + 1</code>。</li><li>按层次编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点</li><li>i≤<code>[n/2]</code>（向下取整）为<strong>分支结点</strong>，i&gt;<code>[n/2]</code>（向上取整）为<strong>叶子结点</strong></li><li>结点数为 <code>n</code> 时，叶子结点数 <code>n0 = ⌈n/2⌉</code>（向上取整）</li><li>满二叉树一定是完全二叉树</li><li>当结点数目一定时，具有最小深度的二叉树是完全二叉树</li><li>最少节点数：2^(h−1)</li><li>最多节点数：2^h − 1</li><li>深度（高度）公式：  log2(n+1)向上取整 或 (log2n)+1向下取整</li><li>度为0、1、2的节点关系：<br>n0=n2+1n0​=n2​+1，且 n0+n2n0​+n2​ 必为奇数。<ul><li><strong>偶数节点数 2k</strong>：n1=1, n0=k, n2​=k−1</li><li><strong>奇数节点数 2k−1</strong>：n1​=0,n0​=k, n2​=k−1</li></ul></li></ul></li></ul></li><li><strong>偶数节点数</strong>：编号最大的分支节点（编号 n/2）仅有左子女。</li><li><strong>奇数节点数</strong>：所有分支节点均有左右子女。</li></ul></li></ol><h2 id="二叉排序树（BST）">二叉排序树（BST）</h2><ol><li><p><strong>定义</strong></p><ul><li>左子树所有结点值 &lt; 根结点值 &lt; 右子树所有结点值。</li><li><strong>中序</strong>遍历结果为<mark>有序</mark>序列。</li><li>左子树和右子树又各是一颗二叉排序树</li><li>最左结点数值最小</li><li>对于n个结点的二叉排序树，其最大高度值为n</li><li>可用于元素的排序、搜索</li></ul></li><li><p><strong>操作与性质</strong></p><ul><li><strong>插入与查找</strong>：<ul><li>平均时间复杂度 <code>O(log2n)</code>（平衡时）。</li><li>最坏时间复杂度 <code>O(n)</code>（退化为链表）。</li></ul></li><li><strong>删除操作</strong>：<ul><li><strong>叶子结点</strong>：直接删除。</li><li><strong>单子树结点</strong>：用子树替代被删结点。</li><li><strong>双子树结点</strong>：用前驱（左子树最大结点）或后继（右子树最小结点）替代。</li></ul></li></ul></li></ol><h2 id="平衡二叉树（AVL-树）">平衡二叉树（AVL 树）</h2><ul><li>任意结点的左右子树高度差绝对值 ≤ 1【胖、多 搜索效率更高】</li><li>查找时间复杂度稳定为 <code>O(log n)</code>。</li><li><strong>平衡因子</strong> = 左子树深度 - 右子树深度，取值范围为 {-1, 0, 1}。</li><li>若所有结点平衡因子为 0，则为<strong>满二叉树</strong>。</li><li>平均查找长度为O(log2n)</li><li><ul><li>最大深度：O(log⁡2n)O(log2​n)</li></ul></li></ul><p><strong>二叉树的构造</strong></p><p><strong>平衡调整操作</strong></p><ul><li><strong>最小不平衡子树</strong>：只需调整最近失衡的子树，上层结点会自动平衡。<br>当插入或删除导致平衡因子超出范围时，需通过旋转调整树结构。调整分为四种情况：</li></ul><ol><li><p><strong>LL 型（右单旋转）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在左子树的左子树中。</li><li><strong>操作</strong>：以失衡结点为轴，向右旋转。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A (失衡)            B</span><br><span class="line">   /                  /   \</span><br><span class="line">  B        →        C       A</span><br><span class="line"> /</span><br><span class="line">C</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>RR 型（左单旋转）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在右子树的右子树中。</li><li><strong>操作</strong>：以失衡结点为轴，向左旋转。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A (失衡)                B</span><br><span class="line"> \                   /   \</span><br><span class="line">  B        →        A       C</span><br><span class="line">   \</span><br><span class="line">    C</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>LR 型（先左旋后右旋）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在左子树的右子树中。</li><li><strong>操作</strong>：先对左子树左旋（转为 LL 型），再对失衡结点右旋。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A              A            C</span><br><span class="line"> /              /           /   \</span><br><span class="line">B      →       C     →    B       A</span><br><span class="line"> \            /</span><br><span class="line">  C          B</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>RL 型（先右旋后左旋）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在右子树的左子树中。</li><li><strong>操作</strong>：先对右子树右旋（转为 RR 型），再对失衡结点左旋。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A              A                C</span><br><span class="line"> \              \             /   \</span><br><span class="line">  B      →       C     →    A       B</span><br><span class="line"> /                \</span><br><span class="line">C                  B</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311120615.png" alt="Pasted image 20250311120615|400"></p><p>从所插入结点的路径向上查找，找到违反平衡因子的根结点连续的三个结点，min-mid-max，再按二叉排序树的性质插入剩下的结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309124217.png" alt="Pasted image 20250309124217|400"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115540.png" alt="Pasted image 20250311115540|300"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115547.png" alt="Pasted image 20250311115547|250"></p><h2 id="B-树">B 树</h2><ol><li><p><strong>阶数 m</strong>：节点最多有 m 棵子树（m&gt;=3）</p></li><li><p><strong>节点子树数约束</strong>：</p><ul><li>根节点：至少 2 棵子树（除非仅一个节点）。</li><li>非根节点：至少<code>[m/2]</code>棵子树（如 m=5 ，至少 3 棵子树）<br><strong>叶子结点</strong>：均位于同一层，不存储数据（或存储空指针）。<br><strong>关键字与子树关系</strong>：</li><li>关键字数 = 子树数 - 1。</li><li>非叶节点有 j 棵子树时，含 j-1 个关键字。<br><strong>关键字规则</strong>：</li><li>所有关键字按升序排列。</li><li>关键字将子树划分为区间，如结点含关键字  k1, k2 ，则子树范围为 ( -∞, k1), ( k1, k2) , ( k2, ±∞)。</li></ul></li><li><p><strong>2-3树</strong>：3阶B树，非叶节点有2或3棵子树。</p></li><li><p><strong>B+树</strong>：支持顺序查找；B树支持多路查找。</p><ul><li><strong>根结点</strong>：至少 2 棵子树（除非树为空）。<br><strong>B 树的操作</strong></li></ul></li><li><p><strong>插入</strong>：</p><ul><li>若结点关键字数超过上限( m-1 ），需<strong>分裂</strong>：<ul><li>将中间关键字提升到父结点，左右部分形成新结点。</li><li>若父结点也溢出，递归分裂直到根结点。</li></ul></li></ul></li><li><p><strong>删除</strong>：</p><ul><li><strong>非叶子结点删除</strong>：用前驱或后继关键字替代。</li><li><strong>叶子结点删除</strong>：<ul><li>若删除后关键字数 ≥<code>[m/2]</code>-1，直接删除。</li><li>否则需向兄弟结点借关键字或合并结点。</li></ul></li></ul></li></ol><h3 id="B-树与-B-树的区别"><strong>B+ 树与 B 树的区别</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>B 树</strong></th><th><strong>B+ 树</strong></th></tr></thead><tbody><tr><td><strong>关键字存储</strong></td><td>所有结点均存储数据</td><td>仅叶子结点存储数据，非叶结点为索引</td></tr><tr><td><strong>叶子结点链接</strong></td><td>无</td><td>叶子结点通过指针链接，支持顺序遍历</td></tr><tr><td><strong>查询效率</strong></td><td>随机查询效率高</td><td>范围查询和顺序遍历效率高</td></tr><tr><td><strong>结构复杂度</strong></td><td>结点结构简单</td><td>非叶结点仅存索引，结构更紧凑</td></tr></tbody></table><ul><li><strong>AVL 树</strong>：通过平衡因子和旋转操作维持平衡，适用于频繁查找的场景。</li><li><strong>B 树</strong>：多路平衡查找树，减少磁盘 I/O 次数，适合文件系统和数据库索引。</li><li><strong>B+ 树</strong>：在 B 树基础上优化范围查询，广泛应用于数据库和操作系统中。</li></ul><h2 id="二叉树的存储结构">二叉树的存储结构</h2><h2 id="顺序存储">顺序存储</h2><ol><li><strong>适用场景</strong>：完全二叉树。</li><li><strong>原理</strong>：<ul><li>通过数组下标直接计算父子关系（如父结点 <code>i</code> 的左孩子为 <code>2i</code>，右孩子为 <code>2i+1</code>）。</li><li>若树非完全二叉树，需填充空结点以保证结构，导致内存浪费。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：快速定位父子结点，无需额外指针。</li><li><strong>缺点</strong>：<ul><li>单支树（深度为 <code>k</code>）需数组长度为 <code>2^k - 1</code>（指数级内存消耗）。</li><li>非完全二叉树存在大量空位。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="type">bool</span> isEmpty;</span><br><span class="line">&#125; t[MAXSIZE];</span><br></pre></td></tr></table></figure></li></ol><h2 id="链式存储">链式存储</h2><p><strong>空链域数量</strong>：</p><ul><li>在含 <code>n</code> 个结点的二叉链表中，共有 <code>n+1</code> 个空链域。</li><li><strong>推导</strong>：<ul><li>每个结点有 2 个指针（左、右），总指针数为 <code>2n</code>。</li><li>树的边数为 <code>n-1</code>（树的性质），即使用的指针数为 <code>n-1</code>。</li><li>空链域数 = 总指针数 - 使用指针数 = <code>2n - (n-1) = n+1</code>。</li></ul></li><li><strong>用途</strong>：空链域可用于构造线索二叉树（标记前驱/后继）。</li></ul><ol><li><strong>二叉链表</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：无法直接找到父结点，需从根遍历。</li><li><strong>空链域</strong>：<code>n+1</code> 个（同前文推导）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20132.png" alt="Untitled 1 132|Untitled 1 132.png|300"><br><strong>三叉链表</strong>：<br>空链域：n+2个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild, *parent;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：增加父结点指针，方便反向查找  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309152923.png" alt="Pasted image 20250309152923|400"></li></ul></li></ol><h2 id="二叉树的遍历">二叉树的遍历</h2><ol><li><p><strong>遍历顺序</strong>：</p><ul><li><strong>先序遍历</strong>：根 → 左 → 右</li><li><strong>中序遍历</strong>：左 → 根 → 右</li><li><strong>后序遍历</strong>：左 → 右 → 根</li><li><strong>层序遍历</strong>：自上而下、从左到右逐层遍历。</li></ul></li><li><p><strong>递归实现与栈的关系</strong>：</p><ul><li>递归遍历的本质是隐式使用系统调用栈，空间复杂度为树高  O(h) 。</li><li><strong>前序序列与中序序列的关系</strong>：<ul><li>前序序列相当于<strong>入栈顺序</strong>，中序序列相当于<strong>出栈顺序</strong>。</li><li>例如：前序 <code>[A,B,C]</code> 和中序 <code>[B,A,C]</code>，可唯一确定一棵二叉树。</li></ul></li></ul></li><li><p><strong>层序遍历实现</strong>：</p><ul><li><mark>**队列</mark>辅助**：<ol><li>根结点入队。</li><li>循环：出队结点访问，并将其左右孩子入队。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        BiTNode* p;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>特点</strong>：按层输出，适合求树的最小宽度或层次相关操作。</li></ul></li></ol><p><strong>遍历序列的唯一性</strong></p><ol><li><strong>单一遍历序列无法唯一确定二叉树</strong>：<ul><li>例如：前序 <code>[A,B]</code> 可对应两种结构（B为左孩子或右孩子）。</li></ul></li><li><strong>唯一确定条件</strong>：<ul><li><strong>中序 + 前序/后序/层序</strong>：可唯一还原二叉树。</li><li><strong>前序 + 后序</strong>：仅当树是满二叉树时可唯一确定。<br>若只给出一棵二叉树的前/中/后/层 序遍历的一种，不能唯一确定一棵二叉树。<br>一定是由中+前/后/序<br>若有一个<mark>叶结点</mark>是二叉树中某个子树的<mark>中序</mark>遍历结果序列的最后一个结点，则它一定是该子树的<mark>前序</mark>遍历结果序列的最后一个结点<br><strong>前、中、后遍历序列中<mark>叶子结点</mark>的相对位置是不变的</strong><br>若一棵二叉树的中序序列和后序序列相同，则二叉树为空树或二叉树任一结点没有右子树；反之，前序和中序相同，左<br>若先序和后序相反，则高度=结点数<br>已知先/后序与中序：<br>x轴是中序，y轴是 先序 或 倒的后序<br>找最高点M，在M左侧找最高点L，右侧最高点R，连接，递归<br>如果先序遍历序列和层序遍历序列相同，则这个二叉树是一个单支树</li></ul></li></ol><h2 id="线索二叉树">线索二叉树</h2><p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。</strong><br><strong>由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在</strong><mark><strong>遍历</strong></mark><strong>的过程中修改空指针的过程。</strong><br>若无左子树，令lchild指向其前驱结点；<br>若无右子树，令rchild指向其后继结点。<br>左前驱，右后继<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/v2-014d37e12cb6f8fa81143a1ae372f854_b.png" alt="v2-014d37e12cb6f8fa81143a1ae372f854_b|400"><br>还需要增加两个标志语表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。<br>l</p><ol><li>ltag== 0，指向左孩子；ltag== 1，指向前驱结点【指线索/指针/地址】</li><li>rtag== 0，指向右孩子；rtag== 1，指向后继结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag; <span class="comment">// 0:孩子指针；1:线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><ul><li><code>ltag=1</code>：左指针指向前驱；<code>rtag=1</code>：右指针指向后继。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/10ae36162db147adb9e3662d9072f8dd.png" alt="10ae36162db147adb9e3662d9072f8dd"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310102313.png" alt="Pasted image 20250310102313|400"></li></ul></li></ol><p>有了这些前驱后继信息的好处是：在查找某个结点时就可以类似链表那样很方便的从表头遍历到表尾，并且空间复杂度只有 O ( 1 ) 。而前面二叉树的遍历中，无论递归还是非递归，都要用到栈，空间复杂度跟二叉树的具体形态有关。<br>二叉树在线索化后，仍不能有效求解的问题是<mark>后序线索二叉树中求后序后继</mark></p><ul><li><strong>逻辑结构</strong>：描述数据元素之间的抽象关系，如二叉树、链表、图等。<ul><li><strong>二叉树</strong>：一种分层结构，每个结点最多有两个子结点，用于表达数据间的层次关系，属于逻辑结构。</li></ul></li><li><strong>物理结构</strong>：描述数据在计算机内存中的具体存储方式，如顺序存储（数组）、链式存储（指针）等。<ul><li><strong>线索二叉树</strong>：在链式存储的基础上，通过修改空指针为线索（前驱/后继），优化遍历效率，属于物理结构。</li></ul></li></ul><p><strong>后序线索二叉树无法有效求解后序后继的原因</strong><br>后序遍历的顺序为 <strong>左→右→根</strong>，根结点最后被访问。后序线索化的局限性体现在以下场景：<br><strong>场景 1：分支结点的左右子树均为叶结点</strong><br>假设结点 <code>A</code> 是父结点 <code>P</code> 的左孩子，且 <code>A</code> 的左右子树均为叶结点：</p><ul><li><p><strong>后序遍历顺序</strong>：左叶 → 右叶 → <code>A</code> → <code>P</code> 的右子树 → <code>P</code> → …</p></li><li><p><strong>问题</strong>：<code>A</code> 的后继应为 <code>P</code> 的右子树的最左下叶结点，但 <code>A</code> 的右指针可能直接指向 <code>P</code>（作为线索），无法跳转到 <code>P</code> 的右子树，导致无法直接找到正确后继。<br><strong>场景 2：根结点的右子树非空</strong></p></li><li><p><strong>后序遍历顺序</strong>：左子树 → 右子树 → 根结点。</p></li><li><p><strong>问题</strong>：根结点的右指针指向实际右子结点，而非线索化的后继（因为根结点是最后一个被访问的结点，没有后继）。</p></li><li><p><strong>示例</strong>：根结点 <code>R</code> 有右子树，遍历到 <code>R</code> 时，其右指针指向右子结点，而非空，无法通过线索直接确定后继。<br><strong>关键限制</strong></p></li><li><p><strong>无法回溯父结点</strong>：后序线索仅记录直接前驱/后继，但某些后继需要通过父结点的右子树路径确定。</p></li><li><p><strong>依赖栈或父指针</strong>：在非线索化遍历中，栈用于记录路径以回溯父结点；而线索化无法提供此信息，导致必须额外维护栈。</p></li><li><p>先序线索二叉树 ABDGECF<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%206%2080.png" alt="Untitled 6 80|Untitled 6 80.png|400"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2076.png" alt="Untitled 7 76|Untitled 7 76.png|400"></p></li><li><p>中序线索二叉树<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2071.png" alt="Untitled 8 71|Untitled 8 71.png|400"></p></li></ul><ol><li><strong>中序线索树</strong>：<ul><li>某结点有右孩子 → 其后继为右子树的最左下结点。</li><li>某结点有左孩子 → 其前驱为左子树的最右下结点。<br>注意：</li></ul></li><li><strong>限制</strong>：<ul><li><strong>后序线索二叉树</strong>：无法高效求解后序后继（需栈支持）。</li><li><strong>前序/中序线索树</strong>：可无栈遍历，时间复杂度 O(n)，空间复杂度O(1)</li></ul></li><li><strong>线索化目的</strong>：<ul><li>利用空链域（<code>n+1</code>个）记录前驱/后继，加速遍历。</li><li><strong>实质</strong>：遍历时修改空指针为线索。</li></ul></li></ol><p><strong>应用场景</strong></p><ol><li><p><strong>求树深度</strong>：</p><ul><li>递归遍历左右子树深度，取最大值加1。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">Depth</span>(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线索化优势</strong>：</p><ul><li>遍历无需栈，空间复杂度优化为  O(1) 。</li><li>适用于频繁遍历但插入/删除较少的场景。</li></ul></li><li><p><strong>设计选择</strong>：</p><ul><li>频繁查找前驱/后继 → 线索二叉树。</li><li>频繁插入/删除 → 普通链式存储。</li></ul></li></ol><ul><li>线索化本质是空间换时间，适用于遍历密集型操作。</li></ul><h2 id="树的存储结构">树的存储结构</h2><ol><li><strong>双亲表示法</strong>：<ul><li><strong>原理</strong>：每个结点存储数据及其父结点索引（根结点的父结点索引为空）。</li><li><strong>优点</strong>：<ul><li>快速查找父结点（时间复杂度  O(1) ）。</li><li>存储结构简单，仅需一个数组即可表示整棵树。</li></ul></li><li><strong>缺点</strong>：<ul><li>查找子结点需遍历整个表（时间复杂度  O(n) ）。</li><li>插入或删除结点时需维护索引一致性，复杂度较高。</li></ul></li><li><strong>适用场景</strong>：频繁查找父结点且子结点操作较少的场景，如家谱关系管理。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310130809.png" alt="Pasted image 20250310130809|500"></li></ul></li><li><strong>孩子表示法</strong>：<ul><li><strong>原理</strong>：每个结点存储数据及子结点链表的头指针。</li><li><strong>优点</strong>：<ul><li>快速查找子结点（直接通过链表访问，时间复杂度  O(k) ， k  为子结点数）。</li><li>适合动态增删子结点的场景。</li></ul></li><li><strong>缺点</strong>：<ul><li>查找父结点需从根结点遍历，效率低（时间复杂度  O(n) ）。</li><li>存储空间较大（每个结点需额外维护链表指针）。</li></ul></li><li><strong>适用场景</strong>：需要频繁操作子结点（如文件系统目录树）。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310131023.png" alt="Pasted image 20250310131023"></li></ul></li><li><strong>二叉树表示法（孩子兄弟表示法）</strong>：<ul><li><strong>原理</strong>：将普通树转换为二叉树，规则如下：<ul><li><strong>左指针</strong>指向第一个孩子结点（最左子结点）。</li><li><strong>右指针</strong>指向当前结点的下一个兄弟结点。</li></ul></li><li><strong>特点</strong>：<ul><li>一个普通树转化成的二叉树一定没有右子树。</li><li><strong>森林转换</strong>：先把森林转化为二叉树，再存储二叉树（如森林 {T1, T2}转换为 T1-&gt;T2）。</li></ul></li><li><strong>优点</strong>：<ul><li>统一使用二叉树结构，可复用二叉树的遍历、插入、删除等算法。</li><li>节省存储空间（仅需两个指针）。</li></ul></li><li><strong>缺点</strong>：<ul><li>逻辑结构需通过指针关系间接理解，初次接触可能较难适应。</li><li>遍历时需区分“孩子”与“兄弟”指针，逻辑稍复杂。</li></ul></li><li><strong>适用场景</strong>：需要利用二叉树算法处理一般树或森林的场景（如编译器语法树）。<br>双亲表示法是顺序存储结构，孩子表示法和孩子兄弟表示法是链式存储结构</li></ul></li></ol><ul><li><p><strong>存储效率</strong>：</p><ul><li>双亲表示法最节省空间，但功能单一；</li><li>孩子兄弟表示法在空间和功能间取得平衡，适合通用场景。</li></ul></li><li><p><strong>操作效率</strong>：</p><ul><li>若需频繁查找父结点，双亲表示法最优；</li><li>若需频繁操作子结点，孩子表示法或双亲孩子表示法更优。</li></ul></li><li><p>**转换：</p><ul><li><strong>树 → 二叉树</strong>：  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310160725.png" alt="Pasted image 20250310160725|300"></li><li><strong>森林 &lt;-&gt; 二叉树</strong>：  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310161030.png" alt="Pasted image 20250310161030|400"><br>森林-&gt;二叉树，右子树非空（因为各树根节点通过右指针链接）<br>二叉树-&gt;森林，若根节点有右子树，则右子树拆分成独立的树<br><strong>森林与二叉树的转换</strong>是唯一的，且右指针为空的数量与非终端结点数相关<br>森林树的数量=森林结点数-边数<br><strong>森林的非终端结点数 n → 二叉树右指针为空的结点数 n+1</strong>：<br>非终端节点指有子结点的节点（包括跟根节点）<br>每个非终端结点对应一个右指针，最后一个兄弟右指针为空。<br><strong>森林的叶结点数 = 二叉树左指针为空的结点数</strong><br>原森林的叶结点在二叉树中无左孩子<br>高度为h的满二叉树对应森林所含树的个数为h</li></ul></li><li><p><strong>树转二叉树</strong>：无右子树。</p></li><li><p><strong>森林转二叉树</strong>：右子树存在（各树根通过右指针链接）。</p></li></ul><h2 id="树的遍历方式">树的遍历方式</h2><h2 id="树的先根遍历（深度优先遍历）">树的先根遍历（深度优先遍历）</h2><p>先访问树的根节点，然后依次先根遍历根的每棵子树。这种遍历方式和二叉树的先序遍历（先访问根节点，再访问左子树，最后访问右子树）类似。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20234.png" alt="Untitled 234|Untitled 234.png"></p><h2 id="树的后根遍历（深度优先遍历）">树的后根遍历（深度优先遍历）</h2><p>先依次后根遍历根的每棵子树，然后再访问根节点。这种遍历方式类似于二叉树的中序遍历（先访问左子树，再访问根节点，最后访问右子树） 。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20135.png" alt="Untitled 1 135|Untitled 1 135.png"></p><h2 id="树的层次遍历（广度优先遍历）">树的层次遍历（广度优先遍历）</h2><p>按照层次，从根节点开始，一层一层地访问节点，同一层的节点按照从左到右的顺序进行访问。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%20119.png" alt="Untitled 2 119|Untitled 2 119.png"></p><h2 id="森林的遍历方式">森林的遍历方式</h2><p>森林是由 m（m≥0）棵互不相交的树组成的集合。</p><h2 id="森林的先序遍历">森林的先序遍历</h2><p>依次对森林中的各个树进行先根遍历，这等同于依次对与森林对应的二叉树进行先序遍历。具体过程是：先访问森林中第一棵树的根节点，然后先序遍历第一棵树的子树森林，接着先序遍历除去第一棵树之后剩余的树组成的森林。</p><h2 id="森林的中序遍历">森林的中序遍历</h2><p>依次对森林中的各个树进行后根遍历，也就相当于依次对与森林对应的二叉树进行中序遍历。具体过程为：先中序遍历森林中第一棵树的子树森林，然后访问第一棵树的根节点，接着中序遍历除去第一棵树之后剩余的树组成的森林。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310163959.png" alt="Pasted image 20250310163959"><br>关键结论 ：</p><ul><li><strong>顺序存储</strong>适合完全二叉树，否则内存浪费严重。</li><li><strong>线索二叉树</strong>通过利用空链域优化遍历，但后序线索化无法完全消除栈依赖。</li><li><strong>普通树转二叉树</strong>后右子树为空（根无兄弟），森林转换则通过右指针链接各树根。</li><li><strong>三叉链表</strong>以空间换时间，支持父结点快速访问。</li></ul><h2 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h2><p>是对数据压缩和编码长度的优化</p><ol><li><strong>带权路径长度（WPL）</strong><ul><li><strong>定义</strong>：树中所有叶结点的带权路径长度之和。</li><li><strong>公式</strong>：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310172719.png" alt="Pasted image 20250310172719|400"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173324.png" alt="Pasted image 20250310173324|450"><br>加权平均长度=带权路径长度/所有结点频次之和_</li></ul></li><li><strong>哈夫曼树（最优二叉树）</strong><ul><li><strong>目标</strong>：构造 WPL 最小的二叉树。</li><li><strong>特点</strong>：<ul><li>权值越小的叶结点离根越远，路径长度越大。</li><li>构造过程中新建  n-1  个内部结点，总结点数为  2n-1 。</li><li>不存在度为 1 的结点（n0=n2+1，已知n0叶结点可求n2双分支节点）</li><li>n个初始节点构造哈夫曼树共新建n-1个双分支结点，因此哈夫曼树的节点总数是2n-1，是奇数</li><li>权值最小的两个结点互为兄弟。</li><li>用一组权值构造出的哈夫曼树可能不唯一（左右子树不同），但带权路径长度唯一<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173511.png" alt="Pasted image 20250310173511|500"></li></ul></li></ul></li><li><strong>前缀编码</strong><ul><li><strong>定义</strong>：没有一个编码是另一个编码的前缀，保证解码唯一性【检查所有编码是否互不为前缀】</li><li><strong>实现方式</strong>：通过哈夫曼树生成可变长度编码，左分支标记为 <code>0</code>，右分支标记为 <code>1</code>。</li></ul></li></ol><h2 id="哈夫曼树构造步骤">哈夫曼树构造步骤</h2><ol><li><strong>初始化</strong>：将  n  个权值作为独立的单结点树。</li><li><strong>合并子树</strong>：<ul><li>每次选择权值最小的两棵树合并，生成新结点作为其父结点，权值为子树权值之和。</li><li>重复此过程直至只剩一棵树。</li></ul></li><li><strong>贪心算法依据</strong>：局部最优选择（合并最小权值树）保证全局最优（WPL 最小）。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173701.png" alt="Pasted image 20250310173701|500"></li></ol><h2 id="应用场景与优势">应用场景与优势</h2><ol><li><p><strong>数据压缩</strong>：</p><ul><li>对高频字符分配短编码，低频字符分配长编码，显著减少总编码长度。</li></ul></li><li><p><strong>文件传输</strong>：</p><ul><li>结合前缀编码，实现高效无损压缩（如 ZIP、JPEG 中的哈夫曼编码）。</li></ul></li><li><p><strong>唯一性与最优性</strong>：</p><ul><li>哈夫曼树不唯一（左右分支标记可互换），但所有哈夫曼树的 WPL 相同且最小。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li>构造哈夫曼树： O(n \log n) （使用优先队列优化选择最小权值）。</li><li>生成编码： O(n) 。</li></ul></li></ol><h2 id="并查集">并查集</h2><p><strong>并查集</strong>是一种用于管理<strong>不相交集合</strong>的数据结构，支持以下两种核心操作：</p><ol><li><strong>查询（Find）</strong>：确定元素属于哪个集合（通常通过根节点标识）<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311104951.png" alt="Pasted image 20250311104951|400"></li><li><strong>合并（Union）</strong>：将两个集合合并为一个集合。<br>并查集的结构是一种<mark>双亲表示法</mark>存储的树</li></ol><p><strong>应用场景</strong>：</p><ul><li>判断图的连通分支数（如判断森林中有几棵树）。</li><li>动态连通性问题（如网络节点是否可达）。</li><li>Kruskal 算法中判断边是否会形成环。</li></ul><p><strong>核心构成</strong></p><ol><li><strong>数组 <code>parent[]</code></strong>：<ul><li>记录每个节点的父节点。</li><li>根节点的父节点指向自身（即 <code>parent[root] = root</code>）。</li></ul></li><li><strong>函数 <code>find(x)</code></strong>：<ul><li>查找节点 <code>x</code> 所属集合的根节点。</li></ul></li><li><strong>函数 <code>union(x, y)</code></strong>：<ul><li>合并 <code>x</code> 和 <code>y</code> 所属的集合。</li></ul></li></ol><p><strong>基本实现与时间复杂度</strong></p><ol><li><p><strong>未优化版本</strong>：</p><ul><li><strong><code>find(x)</code></strong>：逐层向上查找根节点，最坏时间复杂度为  O(n) 。</li><li><strong><code>union(x, y)</code></strong>：需要先调用 <code>find(x)</code> 和 <code>find(y)</code>，时间复杂度  O(n) 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化：每个节点的父节点指向自己</span></span><br><span class="line">parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">while</span> parent[x] != x:</span><br><span class="line">        x = parent[x]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">    root_x = find(x)</span><br><span class="line">    root_y = find(y)</span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        parent[root_y] = root_x</span><br></pre></td></tr></table></figure></li><li><p><strong>优化目标</strong>：</p><ul><li>通过<strong>路径压缩</strong>和<strong>按秩合并</strong>，将操作的时间复杂度优化至  O(\alpha(n)) ，其中α(n) 是阿克曼函数的反函数（实际应用中接近常数）。</li></ul></li></ol><p><strong>优化方法</strong></p><ol><li><strong>按秩合并（Union by Rank）</strong>：<ul><li><strong>原理</strong>：将小树合并到大树中，避免树高度过高。</li><li><strong>实现</strong>：<ul><li>用 <code>rank[]</code> 数组记录每个根节点的树高（或节点数）。</li><li>合并时，将小树的根节点指向大树的根节点。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rank = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">    root_x = find(x)</span><br><span class="line">    root_y = find(y)</span><br><span class="line">    <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 小树合并到大树</span></span><br><span class="line">    <span class="keyword">if</span> rank[root_x] &gt; rank[root_y]:</span><br><span class="line">        parent[root_y] = root_x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[root_x] = root_y</span><br><span class="line">        <span class="keyword">if</span> rank[root_x] == rank[root_y]:</span><br><span class="line">            rank[root_y] += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><strong>路径压缩（Path Compression）</strong>：<ul><li><strong>原理</strong>：在 <code>find(x)</code> 过程中，将路径上的所有节点直接指向根节点，缩短后续查找路径。</li><li><strong>实现</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">        parent[x] = find(parent[x])  <span class="comment"># 递归压缩路径</span></span><br><span class="line">    <span class="keyword">return</span> parent[x]</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>操作</th><th>未优化</th><th>按秩合并</th><th>按秩合并 + 路径压缩</th></tr></thead><tbody><tr><td><code>find(x)</code></td><td>O(n)</td><td>O(log n)</td><td>O(α(n)）</td></tr><tr><td><code>union(x, y)</code></td><td>O(n)</td><td>O(log n)</td><td>O(α(n)）</td></tr></tbody></table><ul><li>**阿克曼函数 α(n) ：增长极慢，对任何实际输入的n（如n &lt;= 10^80），α(n) &lt;= 5。</li></ul><p><strong>应用示例</strong></p><ol><li><p><strong>连通分支数统计</strong>：</p><ul><li>初始化每个节点为独立集合。</li><li>遍历所有边，执行 <code>union(u, v)</code>。</li><li>最终统计根节点数量即为连通分支数。</li></ul></li><li><p><strong>Kruskal 算法</strong>：</p><ul><li>按边权重排序后，依次选择边并检查是否连通（<code>find(u) == find(v)</code>）。</li><li>若未连通，执行 <code>union(u, v)</code> 并加入生成树。</li></ul></li></ol><p><strong>常见问题</strong></p><ol><li><p><strong>如何判断编码是否合法？</strong></p><ul><li><strong>前缀编码冲突</strong>：若某编码是另一编码的前缀，则无法唯一解码。</li><li><strong>哈夫曼编码性质</strong>：通过构造哈夫曼树生成的编码天然为前缀编码，保证唯一性。</li></ul></li><li><p><strong>为什么并查集适合动态连通性问题？</strong></p><ul><li>并查集支持高效的动态合并与查询操作，时间复杂度接近常数，适合处理大规模数据。</li></ul></li></ol><ul><li><strong>并查集的核心优化</strong>：路径压缩 + 按秩合并，时间复杂度接近  O(1) 。</li><li><strong>应用场景</strong>：连通性问题、图论算法、动态等价类划分。</li></ul><p>并查集：路径压缩 + 按秩合并 → 时间复杂度O(α(n))<br>应用：连通分支数统计、Kruskal 算法、动态连通性检测。</p><h2 id="错题-6">错题</h2><ol><li><strong>完全二叉树结点数计算</strong><ul><li>例：第 6 层有 8 个叶子结点，总结点数最多为 111，最少为 39。</li><li><strong>最多</strong>：第6层有8个叶结点，说明第7层不存在。前5层满（25−1=31），第6层最多有2^5=32个节点，其中8个为叶结点，非叶节点为24个。总节点数：31+24×2+8=111。</li><li><strong>最少</strong>：第6层的8个叶结点集中在左侧，第6层有8个节点（均为叶结点）。总节点数：前5层满（31） + 第6层8个 = 39。</li></ul></li><li><strong>完全二叉树叶结点数</strong><ul><li>例：768 个结点的完全二叉树，叶结点数为 <code>384</code>（<code>n0 = ⌈768/2⌉</code>）。</li></ul></li><li><strong>B 树关键字数范围</strong>：<ul><li>对于 5 阶 B 树（ m=5 ）：<ul><li>非根结点关键字数： 2 \leq \text{关键字数} \leq 4 。</li><li>根结点关键字数： 1 \leq \text{关键字数} \leq 4 。</li></ul></li></ul></li><li><strong>B 树高度与结点数关系</strong>：<ul><li>含  n  个关键字的  m  阶 B 树，最小高度  h  满足：<br>n &lt;= (m-1)(1 + m + m^2 + … + m^(h-1)) = m^h - 1</li><li>最大高度  h  满足：<br>n &gt;= 2(<code>[m/2]</code>^(h-1) - 1)</li></ul></li><li>设有一棵度为3的树，其中度为3的结点数n3=2，度为2的结点数n2=1，叶结点数n0=6，则该树的结点总数为() A. 12  B.9 C.10 D.&gt;=9 的任意整数<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311124831.png" alt="Pasted image 20250311124831"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134338.png" alt="Pasted image 20250309134338"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134401.png" alt="Pasted image 20250309134401"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134836.png" alt="Pasted image 20250309134836">若森林F有 15 条边、25 个结点，则下包含树的个数是( )。8/9/10/11<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134844.png" alt="Pasted image 20250309134844"></li><li>二叉树为空意味着二叉树（）<br>A.根结点没有子树 B.不存在 C.没有结点 D.由一些没有赋值的空结点构成<br>二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图(图中不能没有结点)</li><li>设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为( )。 A. h B. 2h-1 C. 2h+1 D. h+1<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309142623.png" alt="Pasted image 20250309142623"></li><li>具有n个结点且高度为n的二叉树的数目为()。A. log2n B. n/2 C. n D. 2^n-1<br>d</li><li>设二叉树有 2n个结点，且m&lt;n，则不可能存在()的结点<br>A. n 个度为 0  B. 2m 个度为 0  C.2m 个度为1  D.2m 个度为2<br>叶子结点数 n0=n2+1，总结点数：n0+n1+n2=2n。带入A对；B是n0=2m，得4m-1+n1=2n，当m=1,n=2,n1=1符合；C是n1=2m，得n2=(2n-2m-1)/2，矛盾不存在；D是n2=2m，得4m+1+n1=2n，当m=1,n=3，符合</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309150857.png" alt="Pasted image 20250309150857">若一棵二叉树有 126 个结点，在第7层(根结点在第1层)至多有( )个结点。<br>A. 32 B.64 C.63 D.不存在第7层<br>要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有 127 个结点，126 仅比 127 少1个结点，只能少在第7层，所以第7层最多有 2^6-1=63 个结点。</li><li>一棵有 124 个叶结点的完全二叉树，最多有()个结点。<br>A. 247 B. 248 C.249 D.250<br>124&lt;2^7=128，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120 个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1 个左孩子(不改变叶结点数)，因此结点总数=2^7-1+120+1=248。<br>也可以用总结点数为偶数2k，n1=1, n0=k, n2​=k−1，k=124，求出</li><li>某完全二叉树T中，结点个数最大的层有8个结点，则T中至多有()个结点。<br>A. 8  B.15  C.23  D. 31<br>在完全二叉树中，第4层刚好最多有8个结点(前4层对应高度为4的满二叉树)，若第5层也有8个结点，则对应于结点个数最多的情况，此时树高为5，总结点数为15+8=23。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153206.png" alt="Pasted image 20250309153206">I正确；II若该结点非根结点，其双亲指针还会指向父结点，共 三个指针。但根结点度为 2 时，无双亲指针，仅被两个孩子指向，只有两个指针；IIIn=1（无双亲根节点） 时，唯一结点是叶结点且无指针指向</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153328.png" alt="Pasted image 20250309153328"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153335.png" alt="Pasted image 20250309153335"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309154115.png" alt="Pasted image 20250309154115"><strong>奇数节点数 2k−1</strong>：n1​=0,n0​=k, n2​=k−1</li><li>对于任意一棵高度为5且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元(仅存放结点的数据信息)，则存放该二叉树需要的存储单元数量至少是()。A.31 B. 16 C.15 D.10<br>即使实际只有10个结点，存储时仍需覆盖所有可能的位置，以确保父结点与子结点的位置关系可通过下标直接计算。因此，存储单元数量至少为2^5-1=31</li><li>设n,m 为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D.n是m子孙<br>c</li><li>设n,m 为一棵二叉树上的两个结点，在后序遍历时，n在m前的充分条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D. n是m 子孙<br>d</li><li>对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用( )次序的遍历实现编号 A.先序 B.中序 C.后序 D.层次<br>c</li><li>一棵二叉树的先序遍历序列为 1234567，它的中序遍历序列可能是()。<br>A. 3124567 B. 1234567 C.4135627 D.1463572<br>b</li><li>某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用()遍历方法最合适。A. 中序 B.层次 C.后序 D.先序<br>删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。</li><li>某二叉树T采用二叉链表存储结构，T的中序遍历序列为一个升序序列，要求采用某种方法对 T进行某种操作之后得到一棵新的二叉树T,要求 T&quot;的中序遍历序列为一个降序序列，则下列关于该算法的叙述中，正确的是()<br>A. 采用中序遍历的方法最合适 B. 采用后序遍历的方法最合透<br>C.T中的根结点还是原T中的根结点 D. T中的叶结点不一定是原T中的叶结点<br>选项 B（采用后序遍历的方法最合适）<ul><li>后序遍历（左→右→根）允许先递归处理左右子树，再交换当前结点的左右子树。这种顺序确保子树已完全处理后再调整父结点的结构，避免逻辑混乱。通过后序遍历交换所有分支结点的左右子树，最终中序遍历序列自然逆序为降序。因此，后序遍历是最合适的方法。<br>选项 C（T’中的根结点还是原T中的根结点）</li><li>镜像翻转操作仅交换分支结点的左右子树，不会改变根结点的位置或值。因此，根结点保持不变，选项 C 正确。<br>选项 D（T’中的叶结点不一定是原T中的叶结点）</li><li>叶结点没有左右子树，交换操作对其无影响，原叶结点在 T’ 中仍为叶结点（仅位置可能变化）。因此，选项 D 错误</li></ul></li><li>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是()。<br>A. 不确定  B.0个  C.1个 D.2 个<br>根结点的左指针：1 个空链域，最右侧叶结点的右指针：1 个空链域，所以线索化后，树中空链域有2个。</li><li>某二叉树的先序序列和后序序列正好相反，则该二叉树一定是()。<br>A.空或只有一个结点           B.高度等于其结点数<br>C.任意一个结点无左孩子   D.任意一个结点无右孩子<br>最多只有一个子结点，即树退化为单链结构（如所有结点只有右孩子或只有左孩子）此时，树的高度等于结点数 h=n，b。C或D属于选项 B 的子集</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310122100.png" alt="Pasted image 20250310122100">d</li><li>若一棵二叉树的前序遍历序列为 a,e,b,d,c，后序遍历序列为 b,c,d,e,a，则根结点的孩子结点()。A.只有e  B.有e、b  C.有e、c  D.无法确定<br>根 <code>a</code> 的唯一孩子是左孩子 <code>e</code></li><li>先序序列为 a,b,c,d的不同二叉树的个数是( )。13/14/15/16<br>(C4 8)/ 5 = 14</li><li>利用二叉链表存储森林时，根结点的右指针是()。<br>A. 指向最左兄弟 B.指向最右兄弟 C.一定为空 D.不一定为空<br>森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。</li><li>设森林F中有3棵树，第 1、2、3 棵树的结点个数分别为 M1,M2和M3，与森林F对应的二叉树根结点的右子树上的结点个数是()<br>A. M1 B.M1+M2 C.M3 D.M2+M3<br>d</li><li>设森林 F中有 4棵树，第 1、2、3、4 棵树的结点数分别为 a、b、c和 d，与森林F对应的二叉树的根结点的左子树上的结点数是()<br>A. a  B. b+c+d  C.a-1  D. a+b+c<br>c</li><li>设森林F对应的二叉树是一棵具有 16 个结点的完全二叉树，则森林F中树的数目和结点最多的树的结点数分别是() A. 2和8  B.2和9  C.4和8  D. 4和9<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310165243.png" alt="Pasted image 20250310165243|250"></li><li>设X是树T中的一个非根结点，B是T所对应的二叉树。在B中，X是其双亲结点的右孩子，下列结论中正确的是()。<br>A.在树T中，X是其双亲结点的第一个孩子<br>B.在树T中，X一定无右边兄弟<br>C.在树T中，X一定是叶结点<br>D.在树T中，X一定有左边兄弟在二叉树<br>B中，X是其双亲的右孩子，因此在树T中，X必是其双亲结点的右兄弟，换句话说，X在树中必有左兄弟。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310170049.png" alt="Pasted image 20250310170049">A. 双亲表示法中，每个非根结点有一个指向双亲的指针。若树有 n个结点，则双亲指针数为 n−1，正确；B对；C. O(n)；D对</li><li>已知一棵有 2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点个数是()。 A. 115  B. 116  C. 1895 D.1896</li><li>下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是<br>A. 24,10,5 和 24,10,7      B. 24,10,5 和 24,12,7<br>C. 24,10,10 和 24,14,11  D. 24,10,5 和 24,14,6</li><li>根据使用频率为5个字符设计的哈夫曼编码不可能是()<br>A. 000,001,010,011,1   B.0000,0001,001,01,1<br>C. 000,001,01,10,11     D. 00,100,101,110,111<br>D构造出来有度为1的结点，不对</li><li>设哈夫曼编码的长度不超过 4，若已对两个字符编码为1和 01，则还最多可对( )个字符编码。<br>根据前缀编码规则，得到新编码必须以00开头，且总长度&lt;=4，0000，0001，0010，0011，共四个</li><li>一棵哈夫曼树共有 215 个结点，对其进行哈夫曼编码，共能得到( )个不同的码字。A. 107   B. 108  C.214   D. 215<br>树有 <code>n</code> 个叶子结点，则总结点数为 <code>2n - 1</code>，得到n=108</li><li>并查集中最核心的两个操作是:查找，查找两个元素是否属于同一个集合;合并，若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为 10(0~9)的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9 的顺序进行查找和合并操作，最终并查集共有( )个集合。A. 1 B.2 C.3D.4<br>初始时，0~9各自成一个集合。查找 1-2 时，合并{1}和{2};查找 3-4 时，合并{3}和{4};查找 5-6 时，合并(5}和(6};査找 7-8时，合并{7}和{8}:查找 8-9 时，合并{7,8,和{9};查找1-8 时，合并(1,2和{7,8,9}:查找 0-5 时，合并(0}和{5,6}:查找 1-9 时，它们属于同一个集合。最终的集合为10,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项 C。</li><li>下列关于大根堆(至少含2个元素)的叙述中正确的是<br>I. 可以将堆看成一棵完全二叉树      II. 可采用顺序存储方式保存堆<br>III. 可以将堆看成一棵二叉排序树    IV. 堆中的次大值一定在根的下一层<br>A. 仅1、II      B. 仅1、III       C. 仅I、II、IV        D. 仅I、II、IV<br>c</li><li>已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二又树中无右孩子的结点的个数是() A. 115    B. 116    C. 1895    D. 1896<br>非叶子结点=1895，数转换成的二叉树没有右孩子，原树中每个非叶结点对应一个无右孩子的结点，无右孩子结点数为1895，根节点也无右孩子+1，1896</li><li>有n(n&gt;0)个分支结点的满二叉树的深度是<br>A. n^2-1    B. log2(n+1)+1    C. log2(n+1)     D. log2(n-1)<br>满二叉树的结点总数 N 与深度 h的关系为:N=2^h -1<br>分支结点数 n 与叶子结点数L的关系为:n=L-1<br>对于满二叉树，叶子结点数  L=2^(h-1)，因此:n=2^(h-1)-1<br>可得:h=log2(n+1)+1</li><li>若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的分支结点的个数是()<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115823.png" alt="Pasted image 20250311115823|400">3</li><li>一个关键字序列为{50，20，60，30，35}，依次构造平衡二叉树，当插入25后引起不平衡，则应进行的平衡旋转是()型旋转 LL?<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123317.png" alt="Pasted image 20250311123317"></li><li>对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是<br>A. 92，20，91，34，88，35              B. 95，22，91，24，94，71<br>C. 21，89，77，29，36，38              D. 12，25，71，68，33，34<br>由二叉排序树的性质可知，一个数后面的数字都要全部大于或全部小于它 b选项的91后面既有小于它的数，也有大于它的数</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123606.png" alt="Pasted image 20250311123606"></li><li>设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平3.在平衡二叉树中插入一个结点后造成了不平衡，因子为1，则应作()型调整以使其平衡。 A.LL B. LR C.RL D.RR<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311130434.png" alt="Pasted image 20250311130434">c</li><li></li></ol><h1>图</h1><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311143034.png" alt="Pasted image 20250311143034|450">由顶点集  V （非空）和边集  E  组成，记为G = (V, E)</p><ul><li><strong>注意</strong>：线性表、树可以为空，但图不能为空（V ≠ ∅）</li></ul><h2 id="无向图与有向图">无向图与有向图</h2><ol><li><p><strong>无向图</strong>：</p><ul><li><strong>边（Edge）</strong>：无序对 (v, w) = (w, v)</li><li><strong>度数性质</strong>：所有顶点的度数之和= 2 × |E|（必为偶数）</li></ul></li><li><p><strong>有向图</strong>：</p><ul><li><strong>弧（Arc）</strong>：有序对  &lt;v, w&gt;≠ &lt;w, v&gt; 。</li><li><strong>度数性质</strong>：<ul><li>入度：指向该顶点的边数。</li><li>出度：从该顶点出发的边数。</li></ul></li></ul></li></ol><ul><li>稀疏图：顶点很多而边很少的图</li><li>稠密图：顶点多边也多的图</li></ul><h2 id="图的分类">图的分类</h2><ol><li><strong>简单图</strong>：<ul><li>无重复边，无自环（顶点到自身的边）。</li></ul></li><li><strong>多重图</strong>：<ul><li>允许两点间有多条边（适用于交通网络等场景）。</li></ul></li><li><strong>完全图</strong>（也称简单完全图）： 对于给定的一组顶点，顶点间都存在边<ul><li><strong>无向完全图</strong>：任意两顶点间均有边，边数=n(n-1)/2</li><li><strong>有向完全图</strong>：任意两顶点间有两条方向相反的弧，弧数= n(n-1)</li></ul></li><li>生成子图：点都有</li><li><strong>极大连通分量</strong>：子图连通，且包含尽可能多的顶点和边<br><strong>极大连通子图</strong>：要求子图必须连通，而且包含尽可能多的顶点和边<br><strong>极小连通子图</strong>：既要保持子图连通又要使得边数最少的子图<br><strong>连通分量</strong>：<mark>无向</mark>图中的<strong>极大连通子图</strong><br><strong>强连通分量</strong>：<mark>有向</mark>图中的极大连通分量（在有向图中考虑强连通性）</li><li>无向<mark>连通图</mark>的<mark>生成树</mark>：是包含<strong>全部顶点</strong>的一个<strong>极小连通子图</strong> n-1条边<br><mark>非连通</mark>的<mark>生成森林</mark>：非连通图分解的多个连通分量，多个连通分量对应的多棵生成树</li><li>有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。</li><li><mark>完全图一定是连通图，但连通图不一定是完全图</mark></li></ol><h2 id="连通性与路径">连通性与路径</h2><ol><li><p><strong>无向图的连通性</strong>：</p><ul><li><strong>连通图</strong>：任意两顶点间存在路径，最少边数 = n-1（树结构）。</li><li><strong>非连通图</strong>：最多边数=(n-1)(n-2)/2（一个孤立顶点，其余构成完全图）。</li></ul></li><li><p><strong>有向图的连通性</strong>：</p><ul><li><strong>强连通图</strong>：任意两顶点间双向可达，最少弧数=n（环形结构）。</li><li><strong>弱连通图</strong>：忽略方向后为连通无向图。</li></ul></li><li><p><strong>路径与环</strong>：</p><ul><li><strong>简单路径</strong>：顶点不重复出现，最多 n 个顶点，n-1 条边。</li><li><strong>回路（环）</strong>：起点与终点相同的路径。</li><li>若一个图有n个顶点，且有大于n-1条边，此图一定有<strong>环</strong></li></ul></li></ol><h2 id="生成树与生成森林">生成树与生成森林</h2><ol><li><strong>生成树</strong>：<ul><li><strong>定义</strong>：无向连通图的极小<mark>连通</mark>子图，包含所有顶点和n-1条边。</li><li><strong>性质</strong>：<ul><li>删除任意一条边会破坏连通性。</li><li>添加任意一条边会形成回路。<br><strong>生成树 G′</strong> 是图 G 的一个子图，满足以下条件：</li></ul></li></ul></li><li><strong>连通性</strong>：G′ 是连通的。</li><li><strong>无环性</strong>：G′ 是无环的。</li><li><strong>极小性</strong>：G′ 是 GG 的极小连通子图（删除任意一条边会破坏连通性）。</li><li><strong>顶点集</strong>：G′ 包含 GG 的所有顶点（V′=V）。</li><li><strong>生成森林</strong>：<ul><li><strong>定义</strong>：非连通图的多个连通分量对应的生成树的集合。</li></ul></li></ol><h3 id="关键公式与结论">关键公式与结论</h3><ul><li>对于n个顶点的<strong>无向图G</strong><ul><li>若G是<mark>连通</mark>图，&gt;= <mark>n-1</mark>条边（树），若|E|&gt;n-1，则一定有<strong>回路</strong>。</li><li>保证G在<strong>任何</strong>情况下均连通的最少边数:(n-1)(n-2)/2+1</li><li>若G是<mark>非连通</mark>图，&lt;= <mark>C2 n − 1</mark>条边【即(n-1)(n-2)/2】，若超过此值，图必<strong>连通</strong></li><li>无向完全图共有C2 n条边【即n(n-1)/2】</li></ul></li><li>对于n个顶点的<strong>有向图G</strong><ul><li>若G是<mark>强连通</mark>图，&gt;= <mark>n</mark>条边（形成简单回路）</li><li><mark>有向完全</mark>图共有<mark>2C2 n</mark> 条边【即n(n-1)】</li></ul></li><li>求有向图的强连通分量<ul><li>找入度或出度为0的顶点</li><li>依次删掉这些顶点以及相连的弧，直到没有存在入度或出度为0的顶点、</li><li>删掉的顶点以及剩下的有向图，就是强连通分量<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311164300.png" alt="Pasted image 20250311164300|400"></li></ul></li><li><strong>顶点度数</strong>：<ul><li>无向图顶点最大度数 = n-1</li><li>有向图顶点最大度（入度 + 出度） = 2(n-1)</li></ul></li></ul><h3 id="算法与应用">算法与应用</h3><ol><li><p><strong>判断回路</strong>：</p><ul><li><strong>有向图</strong>：拓扑排序、深度优先遍历（DFS）检测环。</li><li><strong>无向图</strong>：并查集或DFS检测环。</li></ul></li><li><p><strong>连通分量</strong>：</p><ul><li><strong>无向图</strong>：广度优先遍历（BFS）或DFS求所有连通分量。</li><li><strong>有向图</strong>：Kosaraju算法求强连通分量。</li></ul></li><li><p><strong>最小生成树</strong>：</p><ul><li><strong>Kruskal算法</strong>：按边权升序选择，避免成环。</li><li><strong>Prim算法</strong>：从顶点出发逐步扩展最小边。</li></ul></li></ol><ul><li><strong>完全图边数</strong>：<ul><li>无向完全图边数  n(n-1)/2，有向完全图弧数n(n-1)</li></ul></li><li><strong>邻接表结点数</strong>：<ul><li>无向图邻接表结点总数  2|E| ，有向图邻接表结点总数  |E| 。</li></ul></li></ul><h2 id="图的存储结构">图的存储结构</h2><h3 id="邻接矩阵（数组、顺序存储）">邻接矩阵（数组、顺序存储）</h3><ul><li>用 n×n 矩阵表示顶点间关系，适用于稠密图。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311142927.jpg" alt="Pasted image 20250311142927|500"><br>无向图邻接矩阵：</li></ul><ol><li>无向图的邻接矩阵一定是一个<strong>对称矩阵</strong>。 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。</li><li>对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个顶点的度</li><li>求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍， <code>A[i][j]</code>为 1就是邻接点。</li><li>无向图非零元素至少有2 * 边数个</li><li>在含有 n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为n^2 - 2e</li><li></li></ol><p>有向图邻接矩阵：</p><ol><li>主对角线上数值依然为0，但矩阵并不对称。</li><li>有向图入度是一列和，出度是一行和==（出行入列）==</li><li>与无向图同样的办法，判断顶点vi​到vj​是否存在弧，只需要查找矩阵中<code>A[i][j]</code>是否为1即可。</li></ol><p>邻接矩阵的 存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">VertexType Vex[MaxVertexNum];<span class="comment">//顶点表</span></span><br><span class="line">EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵，边表</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧树</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><ul><li>在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。</li><li>当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。</li><li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。</li><li>邻接矩阵表示法的空间复杂度为O(n^2)， 其中n为图的顶点数|V|</li><li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li><li><mark>稠密图</mark>适合使用邻接矩阵的存储表示。</li><li><code>A^n[i][j]</code>表示从顶点 i 到 j 的长度为 n 的路径数目<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312110923.png" alt="Pasted image 20250312110923|400"></li></ul><h3 id="邻接表（顺序-链式）">邻接表（顺序+链式）</h3><p>结合顺序+链序存储，不唯一<br>对于<mark>稀疏图</mark>，采用邻接表表示将极大地节省存储空间<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311145242.png" alt="Pasted image 20250311145242|400"></p><ul><li><strong>无向图</strong>：每个顶点的邻接表存储其邻接顶点，总边结点数为 2|E|，所需的存储空间为<mark>O(|V|+2|E|)</mark></li><li><strong>有向图</strong>：邻接表存储出边，逆邻接表存储入边，总边结点数为 |E|，所需的存储空间为 <mark>O(|V|+|E|)</mark><br>有向图邻接表的总结点个数 = 表头结点数（顶点数 ∣V∣） + 表结点数（边数 ∣E∣）</li></ul><table><thead><tr><th>操作</th><th>邻接表</th><th>邻接矩阵</th></tr></thead><tbody><tr><td><strong>查找邻边</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>判断边是否存在</strong></td><td>O(d)</td><td>O(1)</td></tr><tr><td><strong>计算出度（有向图）</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>计算入度（有向图）</strong></td><td>O(n+e)</td><td>O(n)</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(n+e)</td><td>O(n2)</td></tr></tbody></table><ul><li><strong>邻接表</strong>：<ul><li>适合稀疏图（边数远小于 n^2）。</li><li>需要频繁查找邻边的场景（如DFS/BFS遍历）。</li></ul></li><li><strong>邻接矩阵</strong>：<ul><li>适合稠密图（边数接近 n^2）。</li><li>需要频繁判断边是否存在的场景（如最短路径算法）</li></ul></li></ul><h3 id="十字链表（有向图）">十字链表（有向图）</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2069.png" alt="Untitled 9 69|Untitled 9 69.png"></p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0824_165443.png" alt="Screenshot_2023_0824_165443"></p><p>顶点节点表三个格子，边节点表四个格子<br>弧节点表：<br>第一个格子是当前节点的索引<br>第二个格子是箭头所指节点的索引<br>第三个格子先空着，前两个格子全部写完，再由节点表的第二个格子指向与弧节点表的第二个格子索引值一样的弧节点的第三个格子，弧节点表的第三个格子依次指向下一个索引值一样的边节点，后面没有了写”空“<br>第四个格子是当前行的最后一个弧界点就写“空”<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312111806.png" alt="Pasted image 20250312111806|400"><br>在十字链表中，既容易找到Vi为尾的弧，也容易找到Vi为头的弧，因而容易求得顶点的出度和入度<br>图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。</p><h3 id="邻接多重表（无向图）">邻接多重表（无向图）</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2065.png" alt="Untitled 10 65|Untitled 10 65.png"><br>顶点节点两个格子，弧节点四个格子<br>弧节点：<br>第一个格子是当前节点的索引<br>第三个格子是箭头所指节点的索引（连完之后把线叉掉）<br>两两节点一起，顶点节点空格指向所有弧节点中一/三节点索引一样的二/四空格，直到没有写“空 ”<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312113325.png" alt="Pasted image 20250312113325|400"></p><p>空间复杂度O(|V|+|E|)<br>删除边、结点方便</p><table><thead><tr><th>特性</th><th>邻接矩阵</th><th>邻接表</th><th>十字链表</th><th>邻接多重表</th></tr></thead><tbody><tr><td>空间复杂度</td><td>O(|V|^2)</td><td>无向图：O(|V| + 2|E|) 有向图：O(|V| + |E|)</td><td>O(|V| + |E|)</td><td>O(|V| + |E|)</td></tr><tr><td>找相邻边</td><td>遍历对应行或列，时间复杂度O(|V|)</td><td>找有向图的入边需遍历整个邻接表</td><td>很方便</td><td>很方便</td></tr><tr><td>删除边或顶点</td><td>删边方便，删顶点需大量移动数据</td><td>无向图中删边或顶点都不方便</td><td>很方便</td><td>很方便</td></tr><tr><td>适用于</td><td>稠密图</td><td>稀疏图和其他</td><td>只能存有向图</td><td>只能存无向图</td></tr><tr><td>表示方式</td><td>唯一</td><td>不唯一</td><td>不唯一</td><td>不唯一</td></tr></tbody></table><table><thead><tr><th>图类型</th><th>存储结构</th><th>操作类型</th><th>时间复杂度说明</th></tr></thead><tbody><tr><td><strong>无向图</strong></td><td>邻接矩阵</td><td>查找相邻边</td><td>遍历对应行 / 列，时间复杂度 O(|V|)（|V|为顶点数）</td></tr><tr><td></td><td></td><td>删除边</td><td>直接修改矩阵元素，时间复杂度 O(1)</td></tr><tr><td></td><td></td><td>计算顶点的度</td><td>统计对应行 / 列非零元素个数，时间复杂度 O(|V|)</td></tr><tr><td></td><td>邻接表</td><td>查找相邻边</td><td>遍历顶点对应链表，时间复杂度 O(d)（d为顶点度）</td></tr><tr><td></td><td></td><td>删除边</td><td>需遍历链表找到对应边结点，时间复杂度 O(d)</td></tr><tr><td></td><td></td><td>计算顶点的度</td><td>统计顶点对应链表的结点数，时间复杂度 O(d)</td></tr><tr><td></td><td>邻接多重表</td><td>查找相邻边</td><td>通过指针直接定位关联边，时间复杂度 O(1)（理想情况，实际与存储组织相关）</td></tr><tr><td></td><td></td><td>删除边</td><td>标记或移除边结点，时间复杂度 O(1)（需提前定位边，定位时间另计）</td></tr><tr><td></td><td></td><td>计算顶点的度</td><td>统计顶点关联的边结点数，时间复杂度 O(d)</td></tr><tr><td><strong>有向图</strong></td><td>邻接矩阵</td><td>查找出边</td><td>遍历对应行，时间复杂度 O(|V|)</td></tr><tr><td></td><td></td><td>查找入边</td><td>遍历对应列，时间复杂度 O(|V|)</td></tr><tr><td></td><td></td><td>删除边（出边 / 入边）</td><td>直接修改矩阵元素，时间复杂度 O(1)</td></tr><tr><td></td><td></td><td>计算出度</td><td>统计对应行非零元素个数，时间复杂度 O(|V|)</td></tr><tr><td></td><td></td><td>计算入度</td><td>统计对应列非零元素个数，时间复杂度 O(|V|)</td></tr><tr><td></td><td>邻接表</td><td>查找出边</td><td>遍历顶点对应链表，时间复杂度 O(d出)（d出为出度）</td></tr><tr><td></td><td></td><td>查找入边</td><td>需遍历全表，时间复杂度 O(|V| + |E|)（|E|为边数）</td></tr><tr><td></td><td></td><td>删除出边</td><td>遍历链表找到对应边结点，时间复杂度 O(d出)</td></tr><tr><td></td><td></td><td>计算出度</td><td>统计顶点对应链表的结点数，时间复杂度 O(d出)</td></tr><tr><td></td><td></td><td>计算入度</td><td>需遍历全表统计，时间复杂度 O(|V| + |E|)</td></tr><tr><td></td><td>十字链表</td><td>查找出边 / 入边</td><td>通过结点指针直接定位，时间复杂度 O(1)（理想情况，实际与存储组织相关）</td></tr><tr><td></td><td></td><td>删除边（出边 / 入边）</td><td>调整指针关系，时间复杂度 O(1)（需提前定位边，定位时间另计）</td></tr><tr><td></td><td></td><td>计算出度 / 入度</td><td>直接读取结点记录的出度 / 入度值（十字链表可存储度数信息），时间复杂度 O(1)</td></tr></tbody></table><p>稀疏矩阵用三元组：(x,y,z):(行，列，非零值）的顺序表；十字链表（有向图）存储</p><h2 id="图的遍历">图的遍历</h2><h3 id="深度优先遍历（DFS）">深度优先遍历（DFS）</h3><ol><li><p><strong>核心思想</strong>：</p><ul><li>类似树的<strong>先序遍历</strong>，沿着一条路径尽可能深入探索，直到无法继续时回溯。</li><li><mark>递归</mark>或显式使用<mark>栈</mark>实现。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>树高较大</strong>：DFS 的递归深度或栈深度可能接近图的顶点数（如单链结构）。</li><li><strong>空间复杂度</strong>：最坏情况下为O(|V|) ，由递归栈深度或显式栈大小决定。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li><strong>邻接矩阵</strong>： O(|V|^2) 。<ul><li>每个顶点需遍历所有其他顶点以查找邻接点。</li></ul></li><li><strong>邻接表</strong>： O(|V| + |E|) 。<ul><li>仅遍历实际存在的边。</li></ul></li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>稠密图</strong>（邻接矩阵效率更高）。</li><li><strong>拓扑排序</strong>、<strong>强连通分量</strong>（如 Tarjan 算法）。</li></ul></li></ol><h3 id="广度优先遍历（BFS）">广度优先遍历（BFS）</h3><ol><li><p><strong>核心思想</strong>：</p><ul><li>类似树的<strong>层序遍历</strong>，逐层访问顶点。</li><li>使用<mark>队列</mark>作为辅助数据结构，<strong>每个顶点仅入队一次</strong>。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>最短路径</strong>：BFS 天然适合求解无权图的最短路径问题。</li><li><strong>连通分量</strong>：通过 BFS 可遍历一个连通分量中的所有顶点。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li><strong>邻接矩阵</strong>： O(|V|^2) 。</li><li><strong>邻接表</strong>： O(|V| + |E|) 。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>稀疏图</strong>（邻接表更高效）。</li><li><strong>社交网络分析</strong>（如六度分隔理论）。</li></ul></li></ol><h4 id="生成树与生成森林-2"><strong>生成树与生成森林</strong></h4><ol><li><p><strong>广度优先生成树</strong>：</p><ul><li><strong>邻接表不唯一性</strong>：邻接表中顶点的邻接顺序不固定，导致生成树结构可能不同。</li><li><strong>邻接矩阵唯一性</strong>：邻接矩阵的邻接顺序固定（按顶点编号），生成树唯一。</li></ul></li><li><p><strong>广度优先生成森林</strong>：</p><ul><li>针对非连通图，每个连通分量生成一棵广度优先生成树。</li></ul></li></ol><table><thead><tr><th>特性</th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>遍历方式</td><td>深度优先（单路径深入）</td><td>广度优先（逐层扩展）</td></tr><tr><td>数据结构</td><td>栈（递归或显式栈）</td><td>队列</td></tr><tr><td>空间复杂度</td><td>O(∣V∣)（最坏情况）</td><td>O(∣V∣)（队列存储顶点）</td></tr><tr><td>时间复杂度</td><td>邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣)</td><td>邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣)</td></tr><tr><td>应用场景</td><td>拓扑排序、路径存在性检测</td><td>最短路径、连通分量统计</td></tr></tbody></table><h4 id="关键结论"><strong>关键结论</strong></h4><ul><li><strong>时间复杂度与存储结构的关系</strong>：<ul><li>邻接矩阵需遍历所有顶点，时间复杂度较高；邻接表仅遍历实际边，效率更高。</li></ul></li><li><strong>生成树的唯一性</strong>：<ul><li>邻接表因邻接顺序不固定，生成树可能不唯一；邻接矩阵生成树唯一。</li></ul></li><li><strong>空间复杂度</strong>：<ul><li>DFS 和 BFS 的最坏空间复杂度均为O(|V|) ，与搜索路径无关。</li></ul></li></ul><h2 id="错题-7">错题</h2><ol><li>一个有 28 条边的非连通无向图至少有()个顶点。7/8/9/10<br>为了使顶点数最小，应使其中一个连通分量为孤立顶点（无边），另一个连通分量为完全图（边数最多），完全图边数n(n-1)/2，可得n=8，总顶点数=n+1=9</li><li>在有n个顶点的有向图中，顶点的度最大可达() A. n B. n-1 C.2n D.2n-2<br>在有向图中，顶点的度等于入度与出度之和。n个顶点的有向图中，任意一个顶点最多还可以与其他n-1个顶点有一对指向相反的边相连。注意，数据结构中仅讨论简单图。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311161002.png" alt="Pasted image 20250311161002">一个连通图的生成树是一个极小连通子图，显然它是无环的，因此选项 Ⅱ、 正确。极大连通子图称为连通分量，G’连通但非连通分量。这里再补充一下“极大连通子图”:若图本来就是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。</li><li>具有51个顶点和21条边的无向图的连通分量最多为 A. 33 B.34 C. 45 D.32<br>要想连通分量最多，就要使图中孤立的点数量最多（每一个孤立的点都是一个连通分量）  问题转为最少用多少点可连21条边，设用x个点.则有x(x-1)/2≥21，得xmin=7  ，这7个点作为1个连通分量，剩余51-7=44个孤立的点，每一个点作为一个连通分量，故连通分量最多为1+(51-7)=45个</li><li>在如下图所示的有向图中，共有()个强连通分量。1/2/3/4<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311162046.png" alt="Pasted image 20250311162046|150">2个，b和其他</li><li>若具有 n个顶点的图是一个环，则它有()棵生成树 A. n B. n C. n-1 D.1<br>环图删除任意一条边可形成生成树，共有 nn 种选择</li><li>若一个具有 n个顶点、e条边的无向图是一个森林，则该森林中必有()棵树。<br>A.n  B.e  C.n-e  D.1<br>n个结点的树有n—1条边，假设有x棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是n+1，边数是e+x，从而可知x=n—e，也就是n—e棵树了</li><li>下列关于无向连通图特性的叙述中，正确的是()<br>I.所有顶点的度之和为偶数<br>II.边数大于顶点个数减1<br>III.至少有一个顶点的度为1<br>A. 只有I    B.只有II    C.I和II    D.I和III<ul><li>I正确（度数之和为边数两倍，必为偶数）。</li><li>II错误（树结构边数 n−1，不大于顶点数减1）。</li><li>III错误（环图所有顶点度为2）。</li></ul></li><li>若无向图 G=(V,E)中含有6个顶点，要保证图 G在任何情况下都是连通的，则需要的边数最少是() 8/9/10/11<br>特定情况下6条，就连通；任意情况下，<mark>n-1个点的完全图+单独出去的一条边连剩下一个点</mark>，答案是11。如果题目求的是有向图，<mark>n-1个点的有向完全图+单独出去的一条边连剩下一个点</mark>，答案是21<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165458.png" alt="Pasted image 20250311165458|300"></li><li>对于无向图G=(V,E)，下列选项中，正确的是()。<br>A.|V|&gt;|E|时，G 一定是连通的<br>B.当|V|&lt;|E|时，G一定是连通的<br>C.当|V|=|E|-1时，G一定是不连通的<br>D.当|V|=|E|+1时，G一定是不连通的<br>d<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311171144.png" alt="Pasted image 20250311171144"></li><li>用有向无环图描述表达式(x+y)((x+y)/x)，需要的顶点个数至少是5/6/8/9<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165839.png" alt="Pasted image 20250311165839|300">5</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312122108.png" alt="Pasted image 20250312122108">bd</li><li>假设有 n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)<br><strong>删出边</strong>：遍历v的顶点表结点及其边表，删除出边，最多n-1条，时间复杂度O(n)。<br><strong>删入边</strong>：扫描整个边表（含剩余顶点表结点及边表），删除v的入边，时间复杂度O(n+e)。</li><li>假设有 n个顶点、e条边的有向图用邻接表表示，则某个顶点v的入度时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)<br>为了求顶点v的入度，只需要遍历邻接表中的所有边表，检查每条边是否指向顶点&quot;，这相当于遍历整个邻接表，因此算法的时间复杂度为 O(n+e)。</li><li>无向图邻接多重表求顶点b，d的度<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312125659.png" alt="Pasted image 20250312125659|400"><br>b的入度1，出度2；d的入度1，出度3</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/post/b8b0eacd.html"/>
      <url>/post/b8b0eacd.html</url>
      
        <content type="html"><![CDATA[<h1>基础概念和常识</h1><h2 id="Java-SE-vs-Java-EE">Java SE vs Java EE</h2><ul><li>Java SE（Java Platform，Standard Edition）: Java 平台<mark>标准版</mark>，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。</li><li>Java EE（Java Platform, Enterprise Edition ）：Java 平台<mark>企业版</mark>，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。</li></ul><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><h2 id="JVM-vs-JDK-vs-JRE">JVM vs JDK vs JRE</h2><h3 id="JVM">JVM</h3><p>Java 虚拟机（Java Virtual Machine, JVM）是运行 <mark>Java 字节码</mark>的虚拟机。JVM 有针对<strong>不同系统</strong>的特定实现（Windows，Linux，macOS），目的是<strong>使用相同的字节码，它们都会给出相同的结果</strong>。<em>字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在</em>。</p><p>如下图所示，不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure …）通过各自的编译器编译成 <code>.class</code> 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309183756.png" alt="Pasted image 20250309183756"></p><h3 id="JDK和JRE">JDK和JRE</h3><p>JDK是一个功能齐全的java开发工具包，供开发者使用，用于<strong>创建和编译</strong>java程序。它包含了<strong>JRE以及编译器javac和其他工具</strong>（eg.javadoc文档生成器、jdb调试器、jconsole监控工具、javap反编辑工具）<br>JRE是<mark>运行已编译java程序所需要的环境</mark>，主要包括：</p><ul><li>JVM：java虚拟机</li><li>Java基础类库（<strong>Class Library</strong>）：一组标准的类库，提供常用的功能和API（eg.IO操作、网络通信、数据结构等）<br>即：JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309184829.png" alt="Pasted image 20250309184829|400"><br><strong>从JDK9开始</strong>：用模块系统（94个模块）+ jlink工具取代传统JRE，<strong>JDK11起不再单独提供JRE</strong>。开发者可<strong>用jlink打包应用仅依赖的模块</strong>，生成<strong>轻量级定制运行时镜像</strong>（例如仅保留20个必要模块），使运行环境体积减少80%+，同时提升部署效率、降低内存占用、增强安全性，<strong>完美适配容器化/微服务等云原生场景</strong><br><strong>核心逻辑</strong>：模块化 = 按需裁剪 + 轻量部署</li></ul><h2 id="字节码">字节码</h2><p>Java字节码（<code>.class</code>文件）是<strong>JVM</strong>的通用指令，<strong>独立于硬件平台</strong>（不面向任何特定的处理器，只面向JVM虚拟机），由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。平衡了执行效率与跨移植性（虽效率仍低于C/C++等编译型语言）。<br><strong>Java 程序从源代码到运行的过程</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190054.png" alt="Pasted image 20250309190054|500"><br>程序运行时，JVM通过<strong>解释器逐行翻译字节码为机器码</strong> <code>.class-&gt;机器码</code>（初始速度较慢），而对高频调用的<strong>热点代码</strong>，<strong>JIT编译器</strong>（属于<mark>运行</mark>时编译）会动态编译并缓存对应机器码，后续直接执行加速。<br>机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。<br>Java高效跨平台 = <strong>字节码中间层</strong> + <strong>解释与JIT编译协同</strong>（冷代码解释执行，热代码编译缓存）<br>热代码：方法和代码块是经常需要被调用的<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190159.png" alt="Pasted image 20250309190159|500"><br>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190229.png" alt="Pasted image 20250309190229|200"></p><h2 id="为什么说java语言”编译与解释并存“">为什么说java语言”编译与解释并存“</h2><p>Java 的执行过程结合了<strong>编译型语言</strong>和<strong>解释型语言</strong>的特性，具体体现为以下两个阶段：</p><ul><li><strong>编译型</strong>：源码需预先编译为字节码（静态编译）</li><li><strong>解释型</strong>：字节码由解释器逐行翻译执行（动态解释）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309191659.png" alt="Pasted image 20250309191659|300"><br>改善：</li><li><strong>混合模式</strong>：先将源码编译成字节码，到执行期间，再将字节码直译，之后执行。java和LLVM是这种技术的代表产物<br><strong>为什么说 Java 语言“编译与解释并存”？</strong><br>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。<br>Java程序需<strong>先编译为字节码</strong>（平台无关的中间代码），再通过JVM的<strong>解释器逐行翻译为机器码执行</strong>，这一过程体现了解释型语言的特性；而针对高频执行的<strong>热点代码</strong>，JVM的<strong>JIT编译器</strong>会在运行时将其<strong>动态编译为本地机器码并缓存</strong>（类似编译型语言的特性），后续直接调用以大幅提升效率。这种“冷代码解释+热代码编译”的混合模式，既保留了跨平台灵活性，又通过运行时优化逼近了编译型语言的性能。</li></ul><h2 id="AOT">AOT</h2><p><strong>JDK9引入的AOT（预编译）直接在运行前将字节码<mark>静态</mark>编译为机器码</strong>（C、 C++，Rust，Go 等语言就是静态编译），消除JIT预热开销，显著提升启动速度并降低内存消耗，尤其适配云原生场景对快速扩容的需求。相较于JIT的运行时动态优化，AOT牺牲了部分极限性能（如高并发吞吐量），但通过<strong>预编译加固代码安全性</strong>（防反编译和修改），在微服务等轻量级应用中优势明显。<br><strong>JIT 与 AOT 两者的关键指标对比</strong>:<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309192909.jpg" alt="Pasted image 20250309192909|400"><br>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p><strong>GraalVM作为技术桥梁</strong>：不仅支持Java/JVM生态的AOT编译，还能运行JS/Python等非JVM语言，实现多语言混合编程（GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译）。<br><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong><br>AOT虽在<strong>启动速度和资源占用</strong>上优势显著，但其<strong>静态编译特性</strong>与Java生态广泛依赖的<strong>动态能力</strong>存在根本冲突：</p><ol><li><strong>动态特性失效</strong><br>如反射（运行时获取/修改类信息）、动态代理（如Spring AOP）、字节码生成（如CGLIB基于ASM实时创建<code>.class</code>）等操作，均需<strong>运行时动态修改或加载类</strong>。而AOT要求所有代码<strong>预先编译为机器码</strong>，导致这些灵活机制无法实时生效，直接破坏Spring等框架的核心功能。</li><li><strong>技术生态兼容性</strong><br>Java主流框架（Spring/Hibernate）大量通过注解、反射注入依赖关系，若强制AOT需<strong>代码全量静态可分析</strong>，开发者需大幅改写业务代码或框架适配（如Spring Native项目），显著增加复杂度。</li><li><strong>性能取舍</strong><br>AOT的静态优化无法像JIT基于<strong>运行时热点分析</strong>做深度优化（如方法内联、逃逸分析），对长期运行的高并发服务，JIT的渐进式优化更能释放极限性能。<br><strong>实例</strong>：CGLIB动态代理通过ASM在内存中即时生成代理类的字节码，若用AOT提前编译，则代理逻辑无法动态插入，导致@Transactional等依赖代理的注解失效。</li></ol><p><strong>结论</strong>：AOT与JIT是<strong>场景互补</strong>而非替代</p><ul><li><strong>短时任务/云函数</strong>：AOT优先（秒级启动）</li><li><strong>复杂业务/传统应用</strong>：JIT维持动态灵活性</li><li><strong>混合方案</strong>：GraalVM等工具允许部分AOT+JIT（如预编译基础库，核心业务保持动态）</li></ul><h2 id="Oracle-JDK-VS-OpenJDK">Oracle JDK VS OpenJDK</h2><p><strong>开源与商业化的博弈</strong><br>OpenJDK作为<strong>开源参考实现</strong>，遵循GPL协议允许自由修改与分发（如阿里基于其定制Dragonwell），而Oracle JDK虽衍生自OpenJDK，但<strong>部分高级功能闭源</strong>（如早期Java Flight Recorder），且受BCL/OTN协议约束——JDK 17后免费商用仅限3年，长期需付费许可。</p><p><strong>功能与生态平衡</strong></p><ul><li><strong>特性差异</strong>：Oracle JDK曾独占JFR性能监控等工具，但<strong>Java 11后两者核心功能趋同</strong>，Oracle将多数组件开源捐赠，削弱了独家优势。</li><li><strong>更新策略</strong>：OpenJDK以<strong>3个月为周期快速迭代</strong>（试水新特性），Oracle JDK则以6个月为周期整合稳定版本，实际通过第三方（如Amazon Corretto）提供OpenJDK的LTS支持，弥补了官方长期支持的缺失。</li></ul><p><strong>为何OpenJDK不可替代？</strong></p><ol><li><strong>开源自由</strong>：企业可深度定制（如适配云环境、优化GC算法），避免受限于Oracle的商业策略；</li><li><strong>零成本商用</strong>：无版本时间锁，尤其适合需长期维护的遗留系统（如JDK 8无限期免费）；</li><li><strong>云原生适配</strong>：主流云厂商（AWS/Azure/AliCloud）均基于OpenJDK发行优化版，天然适配容器化、Serverless等场景。</li></ol><p><strong>协议风险警示</strong><br>Oracle JDK的OTN协议要求<strong>Java 17+商用付费</strong>，且禁止修改二进制代码；而OpenJDK的GPLv2允许自由使用与二次开发，这对企业构建自主技术栈至关重要。</p><p><strong>选型结论</strong></p><ul><li><strong>常规场景</strong>：优先选择<strong>OpenJDK发行版</strong>（如Corretto/Dragonwell），兼顾免费、稳定与生态兼容；</li><li><strong>特殊需求</strong>：若依赖Oracle独家工具（如JMC深度诊断），可短期使用Oracle JDK，但需评估后续版本付费风险。</li></ul><h2 id="Java-VS-C">Java VS C++</h2><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h1>基本语法</h1><p>注释：单行、多行、文档</p><h2 id="移位运算符">移位运算符</h2><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为<mark>二进制数</mark>，移位就是将其向左或向右移动若干位的运算。<br><strong>一、三种移位运算符本质</strong></p><ol><li><p><strong><code>&lt;&lt;</code> 左移</strong><br>二进制整体向左移动，<strong>低位补0，高位丢弃</strong></p><ul><li>示例：<code>5 &lt;&lt; 2</code> → <code>0000 0101</code> → <code>0001 0100</code> = 20</li><li><strong>等效计算</strong>：<code>x * 2ⁿ</code>（适用于非溢出场景）</li></ul></li><li><p><strong><code>&gt;&gt;</code> 带符号右移</strong><br>二进制向右移动，<strong>高位补符号位（正补0，负补1），低位丢弃</strong></p><ul><li>示例：<code>-8 &gt;&gt; 1</code> → <code>1111 1000</code> → <code>1111 1100</code> = -4</li><li><strong>等效计算</strong>：<code>x / 2ⁿ</code>（向下取整）</li></ul></li><li><p><strong><code>&gt;&gt;&gt;</code> 无符号右移</strong><br>二进制向右移动，<strong>高位强制补0，低位丢弃</strong></p><ul><li>示例：<code>-8 &gt;&gt;&gt; 1</code> → <code>1111 1000</code> → <code>0111 1100</code> = 124（int类型）</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">midPoint</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心公式：中间值 = low + ((high - low) &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">return</span> low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、关键特性与使用场景</strong></p><ol><li><p><strong>高效计算</strong></p><ul><li>直接映射CPU指令（如SHL/SHR），比乘除法快10倍以上（实测示例）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能对比：移位 vs 乘法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1024</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 等效 1024*8</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;移位耗时：&quot;</span> + (end - start) + <span class="string">&quot;ns&quot;</span>); <span class="comment">// 约5ns</span></span><br><span class="line"></span><br><span class="line">start = System.nanoTime();</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">8</span>;</span><br><span class="line">end = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;乘法耗时：&quot;</span> + (end - start) + <span class="string">&quot;ns&quot;</span>); <span class="comment">// 约20ns</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内存优化</strong></p><ul><li>用int/long存储多个布尔标志（每个位表示一个状态）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限管理示例：读(1&lt;&lt;0)、写(1&lt;&lt;1)、执行(1&lt;&lt;2)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;   <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXECUTE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;<span class="comment">// 0100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">userA</span> <span class="operator">=</span> READ | WRITE; <span class="comment">// 0011（有读写权限）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>哈希算法应用</strong></p><ul><li><strong>HashMap中的扰动函数</strong>：通过无符号右移增强散列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将高16位特征混合到低16位，减少哈希碰撞</li></ul></li></ol><p><strong>三、注意</strong></p><ol><li><p><strong>移位位数超限</strong></p><ul><li>移位位数超过类型位数时，实际移位数为 <code>位数 % 类型长度</code></li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span> &lt;&lt; <span class="number">34</span>;  <span class="comment">// 等效 3 &lt;&lt; (34%32)=2 → 3*4=12</span></span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5L</span> &lt;&lt; <span class="number">66</span>;<span class="comment">// 等效 5L &lt;&lt; (66%64)=2 → 5*4=20</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>类型隐式转换</strong></p><ul><li>对<code>byte/short/char</code>移位时，自动转为int操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0b1000_0000</span>; <span class="comment">// -128</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> b &lt;&lt; <span class="number">2</span>;  <span class="comment">// 转换为int操作：-128 &lt;&lt; 2 = -512</span></span><br></pre></td></tr></table></figure></li><li><p><strong>符号位陷阱</strong></p><ul><li>带符号右移保留符号位，无符号右移强制补零</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">negative</span> <span class="operator">=</span> -<span class="number">8</span>;          <span class="comment">// 1111...1000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">signedShift</span> <span class="operator">=</span> negative &gt;&gt; <span class="number">1</span>;  <span class="comment">// 1111...1100 (-4)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">unsignedShift</span> <span class="operator">=</span> negative &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 0111...1100 (2147483644)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="continue-VS-break-VS-return">continue VS break VS return</h2><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。<br><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</li><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line">xixi</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">xixi</span><br><span class="line"><span class="number">3</span></span><br><span class="line">haha</span><br></pre></td></tr></table></figure><h2 id="基本类型">基本类型</h2><p>Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一</p><table><thead><tr><th>类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768（-(2^{15})） ~ 32767（(2^{15}) - 1）</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808（-(2^{63})） ~ 9223372036854775807（(2^{63}) -1）</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘\u0000’</td><td>0 ~ 65535（(2^{16}) - 1）</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0.0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0.0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1（逻辑上）</td><td>-</td><td>false</td><td>true、false</td></tr><tr><td><strong>补充说明</strong>：</td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><p><strong><code>boolean</code>类型</strong>：</p><ul><li>逻辑上为1位，但实际存储依赖JVM实现（通常用1字节或4字节存储）。</li><li>默认值为<code>false</code>，取值范围仅为<code>true</code>和<code>false</code>。</li></ul></li><li><p><strong>浮点数精度</strong>：</p><ul><li><code>float</code>为单精度浮点数，精度约6-7位小数。</li><li><code>double</code>为双精度浮点数，精度约15位小数。</li></ul></li><li><p><strong>字符类型</strong>：</p><ul><li><code>char</code>为16位无符号整数，表示Unicode字符，范围为<code>0</code>到<code>65535</code>。</li></ul></li><li><p><strong>默认值规则</strong>：</p><ul><li>类成员变量（字段）有默认值，局部变量必须显式初始化，否则编译报错。</li></ul></li></ol><h3 id="基本类-VS-包装类">基本类 VS 包装类</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>基本类型</strong></th><th><strong>包装类</strong></th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>- 局部变量：栈中<br>- 成员变量：堆中（未static修饰）</td><td>堆中（对象实例）</td></tr><tr><td><strong>占用空间</strong></td><td>极小（如<code>int</code>：4字节，<code>boolean</code>：1位逻辑值）</td><td>较大（对象头+实例数据，通常16字节以上）</td></tr><tr><td><strong>默认值</strong></td><td>有默认值（如<code>int</code>：0，<code>boolean</code>：false）</td><td><code>null</code>（未赋值时）</td></tr><tr><td><strong>比较方式</strong></td><td>== 比较值</td><td>equals()比较值，== 比较对象的内存地址</td></tr><tr><td><strong>泛型支持</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>逃逸分析</strong></td><td>无（直接存储值）</td><td>可能通过逃逸分析优化为栈上分配（如局部对象未逃逸出方法）</td></tr></tbody></table><ol><li><p><strong>局部变量</strong></p><ul><li>基本类型：栈中（如方法内的<code>int a = 10;</code>）</li><li>包装类：堆中（如<code>Integer b = 20;</code>）</li></ul></li><li><p><strong>成员变量</strong></p><ul><li>基本类型：堆中（如<code>int a = 10;</code>）</li><li>包装类：堆中（如<code>Integer b = 20;</code>）</li></ul></li><li><p><strong>静态变量</strong></p><ul><li>基本类型：方法区（JDK 1.7及之前）或元空间（JDK 1.8+）</li><li>包装类：方法区（JDK 1.7及之前）或元空间（JDK 1.8+）</li></ul></li></ol><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量（堆中）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量（方法区/元空间）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量（栈中）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逃逸分析优化：局部对象可能分配在栈中</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">70</span>); <span class="comment">// 可能栈上分配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<br><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><ol><li><p><strong>栈与堆的误区</strong></p><ul><li>基本类型的存储位置取决于作用域：局部变量在栈中，成员变量在堆中。</li><li>包装类始终是对象，通常分配在堆中，但可能通过逃逸分析优化为栈上分配。</li></ul></li><li><p><strong>性能权衡</strong></p><ul><li><strong>基本类型</strong>：性能高，内存占用小，但功能受限（如不支持泛型）。</li><li><strong>包装类</strong>：功能强大（如支持泛型、集合操作），但内存开销大。</li></ul></li><li><p><strong>默认值与空指针</strong></p><ul><li>基本类型有默认值，包装类未赋值时为<code>null</code>，使用时需注意空指针异常。</li></ul></li><li><p><strong>比较方式</strong></p><ul><li>对于基本数据类型用== 比较值。包装类用equals()比较值，== 比较对象的内存地址</li></ul></li></ol><h3 id="适用场景"><strong>适用场景</strong></h3><ul><li><strong>基本类型</strong>：性能敏感场景（如循环计算、数组存储）。</li><li><strong>包装类</strong>：泛型集合、数据库映射（如<code>List&lt;Integer&gt;</code>）、API设计（如方法参数可为<code>null</code>）。</li><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li></ul><h2 id="包装类型的缓存机制">包装类型的缓存机制</h2><table><thead><tr><th><strong>包装类</strong></th><th><strong>缓存范围</strong></th><th><strong>缓存实现方式</strong></th></tr></thead><tbody><tr><td><code>Byte</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Short</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Integer</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Long</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Character</code></td><td>0 ~ 127</td><td>全部缓存（128个对象）</td></tr><tr><td><code>Boolean</code></td><td><code>true</code> / <code>false</code></td><td>全部缓存（2个对象）</td></tr><tr><td><code>Float</code></td><td>无缓存</td><td>每次创建新对象</td></tr><tr><td><code>Double</code></td><td>无缓存</td><td>每次创建新对象</td></tr></tbody></table><p><strong>缓存机制的作用</strong></p><ol><li><p><strong>性能优化</strong></p><ul><li>频繁使用的小范围数值直接复用缓存对象，避免重复创建。</li><li>示例：<code>Integer i1 = 40;</code> 直接从缓存中获取对象，无需<code>new</code>。</li></ul></li><li><p><strong>内存节省</strong></p><ul><li>缓存常用对象，减少堆内存占用。</li><li>示例：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code>的缓存对象总数仅约1000个。</li></ul></li><li><p><strong>代码简洁</strong></p><ul><li>自动装箱（如<code>Integer i = 10;</code>）隐式调用<code>valueOf()</code>，利用缓存机制。</li></ul></li></ol><p><strong>缓存机制的实现</strong></p><ol><li><p><strong><code>Integer</code>缓存源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i); <span class="comment">// 超出缓存范围，创建新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(low + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Character</code>缓存源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) <span class="comment">// 仅缓存0~127</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c); <span class="comment">// 超出缓存范围，创建新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Boolean</code>缓存源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE); <span class="comment">// 直接返回缓存对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。<br>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。<br>4. <strong>比较方式</strong></p><ul><li>== 比较:仅适用于缓存范围内的对象（如Integeri1=40;Integer i2= 40;）</li><li><strong><code>equals()</code>比较</strong>：适用于所有场景，推荐使用。</li></ul><ol start="2"><li><p><strong>缓存范围外的对象</strong></p><ul><li>超出缓存范围（如Integeri1=200;Integeri2=200;）会创建新对象，== 比较结果为 false</li></ul></li><li><p><strong>浮点数无缓存</strong></p><ul><li>Float 和 Double 每次装箱都会创建新对象，== 比较结果始终为 false</li></ul></li></ol><p><strong>经典面试题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;           <span class="comment">// 使用缓存</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>); <span class="comment">// 创建新对象</span></span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>发生装箱，<code>i1</code>通过<code>valueOf()</code>从<mark>缓存</mark>中获取对象，等价于 <code>Integer i1=Integer.valueOf(40)</code>，<code>i1</code> 直接使用的是缓存中的对象</li><li><code>i2</code>通过<code>new</code>创建新对象。</li><li>== 比较内存地址，结果为 false</li></ul><h3 id="最佳实践"><strong>最佳实践</strong></h3><ol><li><p><strong>比较包装类对象</strong></p><ul><li>始终使用<code>equals()</code>方法，避免== 的潜在问题。</li></ul></li><li><p><strong>自动装箱与缓存</strong></p><ul><li>理解自动装箱（如<code>Integer i = 10;</code>）隐式调用<code>valueOf()</code>，利用缓存机制。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li>在频繁使用小范围数值时，优先使用基本类型（如<code>int</code>），避免包装类的内存开销。</li></ul></li></ol><h2 id="自动装箱和拆箱">自动装箱和拆箱</h2><ol><li><p><strong>装箱</strong></p><ul><li>将基本类型转换为对应的包装类对象。</li><li>示例：<code>Integer i = 10;</code></li><li>实际调用：<code>Integer.valueOf(10)</code></li></ul></li><li><p><strong>拆箱</strong></p><ul><li>将包装类对象转换为基本类型。</li><li>示例：<code>int n = i;</code></li><li>实际调用：<code>i.intValue()</code></li></ul></li></ol><p><strong>性能问题</strong></p><ul><li><strong>频繁拆装箱</strong>会显著影响性能（如循环中大量使用包装类）。</li><li><strong>优化建议</strong>：在性能敏感场景优先使用基本类型。</li></ul><p><strong>反例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 每次循环都会装箱</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i; <span class="comment">// 拆箱后再装箱</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化后</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 使用基本类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i; <span class="comment">// 无拆装箱开销</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么浮点数运算会有精度丢失的风险">为什么浮点数运算会有精度丢失的风险</h2><ul><li>计算机以二进制存储浮点数，部分十进制小数无法精确表示（如0.2）。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>; <span class="comment">// 0.100000024</span></span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>; <span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="解决方案：BigDecimal"><strong>解决方案：<code>BigDecimal</code></strong></h3><ol><li><p><strong>精确计算</strong></p><ul><li>使用<code>BigDecimal</code>避免精度丢失。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> a.subtract(b); <span class="comment">// 0.2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>比较方式</strong></p><ul><li><strong><code>equals()</code></strong>：比较值和精度（<code>1.0</code> ≠ <code>1.00</code>）。</li><li><strong><code>compareTo()</code></strong>：仅比较值（<code>1.0</code> = <code>1.00</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.20&quot;</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.compareTo(y) == <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="大整数处理">大整数处理</h2><h3 id="BigInteger">BigInteger</h3><ul><li>用于处理超出<code>long</code>范围的整数。</li><li>内部通过<code>int[]</code>数组存储数据。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789012345678901234567890&quot;</span>);</span><br><span class="line">System.out.println(bigInt.add(BigInteger.ONE)); <span class="comment">// +1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值溢出问题">数值溢出问题</h3><ul><li>基本类型有固定范围，超出后会发生溢出。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808（溢出）</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="变量">变量</h2><h3 id="成员变量-VS-局部变量">成员变量 VS 局部变量</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>成员变量</strong></th><th><strong>局部变量</strong></th></tr></thead><tbody><tr><td><strong>语法形式</strong></td><td>属于类，可被<code>public</code>/<code>private</code>/<code>static</code>等修饰</td><td>定义在方法/代码块中或作为参数，仅能被<code>final</code>修饰</td></tr><tr><td><strong>存储位置</strong></td><td><code>static</code>修饰：方法区/元空间<br>非<code>static</code>修饰：堆内存</td><td>栈内存</td></tr><tr><td><strong>生存时间</strong></td><td>随对象创建而存在，随对象销毁而消亡</td><td>随方法调用生成，随方法结束消亡</td></tr><tr><td><strong>默认值</strong></td><td>自动赋默认值（如<code>int</code>→0，<code>boolean</code>→false）</td><td>必须显式初始化，否则编译报错</td></tr><tr><td><strong>作用域</strong></td><td>类内全局可见（受访问修饰符限制）</td><td>仅在定义的方法/代码块内有效</td></tr><tr><td><font color="#0070c0">成堆</font></td><td></td><td></td></tr></tbody></table><p><strong>为什么成员变量有默认值？</strong></p><ol><li>先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</li><li>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。<strong>成员变量在运行时可借助反射等方法手动赋值，而局部变量不行</strong></li><li>对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量（堆内存）</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 默认值 null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">// 默认值 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量（栈内存）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;      <span class="comment">// 必须显式初始化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(num1 + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;   <span class="comment">// 成员变量手动赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>;      <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量有什么作用？"><a href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">静态变量有什么作用？</a></h3><ol><li><p><strong>共享性</strong></p><ul><li>被<code>static</code>修饰，属于类而非实例，所有对象共享同一份内存。</li><li>示例：计数器统计对象创建次数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123; count++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存效率</strong></p><ul><li>仅分配一次内存，节省资源。</li><li>示例：全局配置常量。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_USERS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问方式</strong></p><ul><li>通过类名直接访问（如<code>Config.MAX_USERS</code>）。</li><li>若被<code>private</code>修饰，需通过类方法访问。</li></ul></li></ol><table><thead><tr><th><strong>场景</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>全局常量</td><td><code>public static final double PI = 3.14159;</code></td></tr><tr><td>资源共享</td><td>数据库连接池的配置参数</td></tr><tr><td>工具类方法</td><td><code>Math</code>类中的<code>sqrt()</code>方法</td></tr><tr><td>单例模式</td><td>通过静态变量持有唯一实例</td></tr></tbody></table><h3 id="字符型常量-VS-字符串常量">字符型常量 VS 字符串常量</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>字符常量</strong></th><th><strong>字符串常量</strong></th></tr></thead><tbody><tr><td><strong>定义形式</strong></td><td>单引号包裹单个字符：<code>'A'</code></td><td>双引号包裹0-N个字符：<code>&quot;Hello&quot;</code></td></tr><tr><td><strong>本质</strong></td><td><code>char</code>类型（2字节），可参与算术运算</td><td><code>String</code>对象（堆内存），存储地址值</td></tr><tr><td><strong>内存占用</strong></td><td>固定2字节</td><td>可变长度（UTF-8编码英文1字节/字符，中文3字节）</td></tr><tr><td><strong>比较方式</strong></td><td>== 比较值</td><td><code>equals()</code>比较内容，== 比较地址</td></tr><tr><td>⚠️ 注意 <code>char</code> 在 Java 中占两个字节。</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantExample</span> &#123;</span><br><span class="line">    <span class="comment">// 字符常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">LETTER_A</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 2字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREETING</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 内存占用：英文5字符→5字节（UTF-8）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>; <span class="comment">// 2字节存储Unicode</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; <span class="comment">// 6字节（UTF-8）</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Character.BYTES); <span class="comment">// 输出2</span></span><br><span class="line">        System.out.println(str.getBytes().length); <span class="comment">// 输出6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>字符常量</strong></p><ul><li>用于单个字符处理（如ASCII运算）。</li><li>示例：<code>char c = 'A' + 1;</code> → <code>'B'</code>。</li></ul></li><li><p><strong>字符串常量</strong></p><ul><li>用于文本处理，注意不可变性（每次修改生成新对象）。</li><li>示例：<code>String s = &quot;Hi&quot;; s += &quot;!&quot;;</code> → 新建对象<code>&quot;Hi!&quot;</code>。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li>高频操作字符串时用<code>StringBuilder</code>减少内存开销。</li></ul></li></ol><h2 id="方法">方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态方法为什么不能调用非静态成员?</a></h3><p>根本原因：<mark>生命周期与内存分配</mark><br>静态方法与非静态成员的<strong>加载时机</strong>和<strong>内存归属</strong>存在本质差异：</p><table><thead><tr><th><strong>特性</strong></th><th><strong>静态方法</strong></th><th><strong>非静态成员</strong></th></tr></thead><tbody><tr><td><strong>内存分配时机</strong></td><td>类加载阶段分配内存（JVM加载类时）</td><td>对象实例化时分配内存（<code>new</code>关键字创建对象时）</td></tr><tr><td><strong>内存归属</strong></td><td>类级别（方法区/元空间）</td><td>对象级别（堆内存）</td></tr><tr><td><strong>访问依赖</strong></td><td>不依赖对象实例</td><td>必须通过对象实例访问</td></tr></tbody></table><ol><li><strong>时序矛盾</strong><br>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li><li><strong>内存安全</strong><br>非静态成员属于对象实例，不同实例的成员变量值可能不同。静态方法无对象上下文（无<code>this</code>指针），无法确定访问哪个实例的成员。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 非静态成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法尝试访问非静态成员 → 编译错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(instanceVar); // 错误：无法访问非静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法可自由访问非静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(instanceVar); <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法-VS-实例方法">静态方法 VS 实例方法</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>静态方法</strong></th><th><strong>实例方法</strong></th></tr></thead><tbody><tr><td><strong>调用方式</strong></td><td><code>类名.方法名()</code></td><td><code>对象.方法名()</code></td></tr><tr><td><strong>内存归属</strong></td><td>类级别（方法区/元空间）</td><td>对象级别（堆内存）</td></tr><tr><td><strong><code>this</code>引用</strong></td><td>不可用（无对象上下文）</td><td>可用（指向当前对象）</td></tr><tr><td><strong>访问成员权限</strong></td><td>仅能直接访问静态成员</td><td>可访问所有成员（静态+实例）</td></tr><tr><td><strong>多态支持</strong></td><td>不支持重写（隐藏而非覆盖）</td><td>支持重写（动态绑定）</td></tr><tr><td><strong>静态方法</strong>：仅能直接访问静态成员，需通过对象间接访问实例成员</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">population</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        population++; <span class="comment">// 允许访问静态变量</span></span><br><span class="line">        <span class="comment">// name = &quot;Alice&quot;; // 编译错误：无法直接访问实例变量</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 通过对象间接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载-VS-重写">重载 VS 重写</h2><blockquote><p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</p><p>重写发生在运行期，就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p></blockquote><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr><tr><td>重写补充：</td><td></td><td></td></tr></tbody></table><ol><li>方法名、参数列表必须相同，子类方法返回值类型应&lt;=父类方法返回值类型，抛出的异常范围&lt;=父类，访问修饰符范围&gt;=父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h2 id="可变长参数">可变长参数</h2><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method1(String... args) &#123;</span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method2(String arg1, String... args) &#123;</span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><ul><li><strong>固定参数优先</strong>：当重载方法中存在固定参数和可变参数版本时，编译器优先匹配固定参数方法。</li><li><strong>可变参数本质</strong>：可变参数在编译后会被转换为数组（如<code>String... args</code> → <code>String[] args</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定参数方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String arg1, String arg2)</span> &#123;</span><br><span class="line">        System.out.println(arg1 + arg2); <span class="comment">// 优先匹配</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);      <span class="comment">// 调用固定参数方法 → 输出 ab</span></span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 调用可变参数方法 → 输出 a b c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译后的字节码分析</strong>：<br>可变参数方法<code>printVariable(String... args)</code>会被编译为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环遍历数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载冲突场景"><strong>重载冲突场景</strong></h3><ul><li><strong>避免歧义</strong>：若同时存在<code>method(String[])</code>和<code>method(String...)</code>，编译器会报错，因两者本质相同。</li><li><strong>类型明确性</strong>：调用时传入明确数组会优先匹配数组参数方法。</li></ul><h1>面向对象基础</h1><h2 id="面向对象-OOP-VS-面向过程-POP">面向对象 (OOP) VS 面向过程 (POP)</h2><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><table><thead><tr><th><strong>维度</strong></th><th><strong>面向过程 (POP)</strong></th><th><strong>面向对象 (OOP)</strong></th></tr></thead><tbody><tr><td><strong>核心思想</strong></td><td>以<strong>过程</strong>为中心，将问题拆解为一系列步骤（方法/函数）</td><td>以<strong>对象</strong>为中心，通过对象交互解决问题</td></tr><tr><td><strong>代码组织方式</strong></td><td>按<strong>执行流程</strong>组织代码</td><td>按<strong>对象职责</strong>组织代码（类、属性、方法）</td></tr><tr><td><strong>数据与行为</strong></td><td>数据与操作分离（函数操作外部数据）</td><td>数据与行为封装在对象内部（对象管理自身状态）</td></tr><tr><td><strong>典型语言</strong></td><td>C、Pascal、Fortran</td><td>Java、C++、Python</td></tr></tbody></table><h3 id="OOP-的核心优势"><strong>OOP 的核心优势</strong></h3><ol><li><strong>易维护</strong><ul><li>封装性：隐藏对象内部状态，通过方法暴露安全操作。</li><li>示例：<code>Circle</code>类封装半径，外部无法直接修改非法值。</li></ul></li><li><strong>易复用</strong><ul><li>继承与多态：复用父类逻辑，扩展子类行为。</li><li>示例：<code>Animal</code>类派生出<code>Dog</code>和<code>Cat</code>，复用<code>eat()</code>方法。</li></ul></li><li><strong>易扩展</strong><ul><li>模块化设计：新增功能只需扩展类或接口，无需修改全局逻辑。</li><li>示例：新增<code>Square</code>类实现<code>Shape</code>接口，系统无需重构。<br>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</li></ul></li></ol><p>面向过程：<strong>面向过程性能比面向对象高</strong>。因为对象调用需要实例化，开销比较大，较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等，一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</p><p>面向对象：<strong>面向对象易维护、易复用、易扩展</strong>。因为面向对象有封装、继承、多态性的特性，所以可设计出低耦合的系统，使得系统更加灵活、更加易于维护。</p><p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。</p><p><strong>面向过程性能比面向对象高的背后原因？</strong></p><blockquote><p>面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是因为 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机器码。</p><p>而面向过程语言大多都是直接编译成机器码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p></blockquote><p><strong>代码示例对比</strong></p><h4 id="面向对象实现"><strong>面向对象实现</strong></h4><p>定义一个 <code>Circle</code> 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius; <span class="comment">// 封装半径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (radius &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;半径必须为正数&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius; <span class="comment">// 行为与数据绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;面积: &quot;</span> + circle.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面向过程实现"><strong>面向过程实现</strong></h4><p>直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">3.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> calculateArea(radius); <span class="comment">// 数据与逻辑分离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;面积: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">(<span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><strong>面向对象实现</strong></th><th><strong>面向过程实现</strong></th></tr></thead><tbody><tr><td><strong>封装性</strong></td><td>数据与操作封装在类中，避免非法修改</td><td>数据暴露在外，需外部校验合法性</td></tr><tr><td><strong>复用性</strong></td><td>可通过继承/组合复用<code>Circle</code>类逻辑</td><td>函数可复用，但数据传递需重复管理</td></tr><tr><td><strong>扩展性</strong></td><td>新增功能（如颜色属性）只需扩展类</td><td>需修改全局函数或添加新函数，易破坏现有逻辑</td></tr><tr><td><strong>性能开销</strong></td><td>轻微对象创建开销（JVM优化后几乎可忽略）</td><td>无对象开销，直接计算</td></tr></tbody></table><p><strong>如何选择编程范式？</strong></p><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐范式</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td>复杂业务系统（如电商平台）</td><td>OOP</td><td>模块化设计、易维护、团队协作高效</td></tr><tr><td>底层驱动开发（如嵌入式）</td><td>POP</td><td>资源受限、需直接操作硬件，逻辑简单直接</td></tr><tr><td>脚本工具（如数据处理脚本）</td><td>POP</td><td>快速开发、无需复杂架构</td></tr><tr><td>框架/库开发</td><td>OOP</td><td>提供高扩展性API，支持多态和接口隔离</td></tr></tbody></table><ol><li><strong>OOP核心价值</strong>：提升代码可维护性、复用性和扩展性，适合中大型项目。</li><li><strong>POP适用场景</strong>：简单任务、资源敏感型开发，或与硬件直接交互的底层逻辑。</li><li><strong>性能误区</strong>：语言实现（如编译方式）对性能影响远大于编程范式本身。</li><li><strong>现代语言趋势</strong>：多数语言支持多范式（如Python、C++），开发者需灵活选择。</li></ol><p><strong>最终建议</strong>：</p><ul><li>优先考虑代码结构和长期维护成本，而非单纯追求性能。</li><li>在性能关键路径（如高频循环）中，可局部使用POP优化，但整体架构仍保持OOP优势。</li></ul><h2 id="创建对象的运算符：对象实体-vs-对象引用">创建对象的运算符：对象实体 vs 对象引用</h2><ul><li><strong><code>new</code> 运算符</strong>：用于在堆内存中创建对象实例。</li><li><strong>对象引用</strong>：指向堆内存中对象实例的变量，存储在栈内存中。</li></ul><table><thead><tr><th><strong>比喻</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>对象实例（气球）</strong></td><td>存在于堆内存中的实际数据。</td></tr><tr><td><strong>对象引用（绳子）</strong></td><td>指向对象的变量，可以指向0个或1个对象（绳子不系或系一个气球）。</td></tr><tr><td><strong>多引用共享</strong></td><td>多个引用可指向同一对象（多条绳子系同一个气球）。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象引用未指向任何对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象引用指向一个新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个引用指向同一对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2;</span><br></pre></td></tr></table></figure><h2 id="对象相等-vs-引用相等">对象相等 vs 引用相等</h2><table><thead><tr><th><strong>对比维度</strong></th><th><strong>引用相等（==）</strong></th><th><strong>对象相等（equals()）</strong></th></tr></thead><tbody><tr><td><strong>比较内容</strong></td><td>内存地址是否相同</td><td>对象内部数据是否相同</td></tr><tr><td><strong>适用场景</strong></td><td>判断两个引用是否指向同一对象</td><td>判断两个对象逻辑上是否相等（如字符串内容）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;          <span class="comment">// 字符串常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 堆中新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;          <span class="comment">// 指向常量池中的同一对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用相等比较（内存地址）</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false（不同对象）</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">// true（同一对象）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象相等比较（内容）</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true（内容相同）</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">// true（内容相同）</span></span><br></pre></td></tr></table></figure><h2 id="如果一个类没有声明构造方法，程序能正确执行吗？"><a href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97">如果一个类没有声明构造方法，程序能正确执行吗？</a></h2><p><strong>默认构造方法</strong>：</p><ul><li>若类未显式定义任何构造方法，Java会自动生成一个<strong>无参默认构造方法</strong>。</li><li>若类显式定义了构造方法（无论是否有参数），Java不再生成默认构造方法。</li></ul><h2 id="构造方法的特点与重写问题"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9-%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">构造方法的特点与重写问题</a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>名称与类名相同</strong></td><td>构造方法必须与类名完全一致（区分大小写）。</td></tr><tr><td><strong>无返回值声明</strong></td><td>无返回类型（包括<code>void</code>）。</td></tr><tr><td><strong>自动执行</strong></td><td>创建对象时自动调用，无法手动调用。</td></tr></tbody></table><table><thead><tr><th><strong>操作</strong></th><th><strong>是否支持</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>重载</strong></td><td>✅ 支持</td><td>同一类中定义多个参数列表不同的构造方法。</td></tr><tr><td><strong>重写</strong></td><td>❌ 不支持</td><td>构造方法不能被继承，因此子类无法重写父类构造方法。子类需通过super调用父类构造方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 无参构造方法（可被重载）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法（参数不同）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物名称：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 子类构造方法默认调用父类无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 隐式调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式调用父类有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 必须通过super调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三大特征">三大特征</h2><h4 id="封装"><a href="#%E5%B0%81%E8%A3%85">封装</a></h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int id;//id属性私有化</span><br><span class="line">    private String name;//name属性私有化</span><br><span class="line"></span><br><span class="line">    //获取id的方法</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置id的方法</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取name的方法</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置name的方法</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#%E7%BB%A7%E6%89%BF">继承</a></h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="多态"><a href="#%E5%A4%9A%E6%80%81">多态</a></h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="接口和抽象类有什么共同点和区别？"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">接口和抽象类有什么共同点和区别？</a></h3><h4 id="接口和抽象类的共同点"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">接口和抽象类的共同点</a></h4><ul><li><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</li><li><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li></ul><h4 id="接口和抽象类的区别"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB">接口和抽象类的区别</a></h4><ul><li><strong>设计目的</strong>：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li><strong>继承和实现</strong>：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。</li><li><strong>成员变量</strong>：接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（<code>private</code>, <code>protected</code>, <code>public</code>），可以在子类中被重新定义或赋值。</li><li><strong>方法</strong>：<ul><li>Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 <code>default</code>（默认） 方法和 <code>static</code> （静态）方法。 自 Java 9 起，接口可以包含 <code>private</code> 方法。</li><li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li></ul></li></ul><p>在 Java 8 及以上版本中，接口引入了新的方法类型：<code>default</code> 方法、<code>static</code> 方法和 <code>private</code> 方法。这些方法让接口的使用更加灵活。</p><p>Java 8 引入的<code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    default void defaultMethod() &#123;</span><br><span class="line">        System.out.println(&quot;This is a default method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 引入的<code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code> 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    static void staticMethod() &#123;</span><br><span class="line">        System.out.println(&quot;This is a static method in the interface.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 9 允许在接口中使用 <code>private</code> 方法。<code>private</code>方法可以用于在接口内部共享代码，不对外暴露。<br>public interface MyInterface {<br>// default 方法<br>default void defaultMethod() {<br>commonMethod();<br>}</p><pre><code>// static 方法static void staticMethod() &#123;    commonMethod();&#125;// 私有静态方法，可以被 static 和 default 方法调用private static void commonMethod() &#123;    System.out.println(&quot;This is a private method used internally.&quot;);&#125;  // 实例私有方法，只能被 default 方法调用。private void instanceCommonMethod() &#123;    System.out.println(&quot;This is a private instance method used internally.&quot;);&#125;</code></pre><p>}</p><h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><h4 id="浅拷贝"><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D">浅拷贝</a></h4><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。<br>public class Address implements Cloneable{<br>private String name;<br>// 省略构造函数、Getter&amp;Setter方法<br>@Override<br>public Address clone() {<br>try {<br>return (Address) super.clone();<br>} catch (CloneNotSupportedException e) {<br>throw new AssertionError();<br>}<br>}<br>}</p><p>public class Person implements Cloneable {<br>private Address address;<br>// 省略构造函数、Getter&amp;Setter方法<br>@Override<br>public Person clone() {<br>try {<br>Person person = (Person) super.clone();<br>return person;<br>} catch (CloneNotSupportedException e) {<br>throw new AssertionError();<br>}<br>}<br>}<br>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">// true</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><h4 id="深拷贝"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D">深拷贝</a></h4><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Person clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Person person = (Person) super.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        return person;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">// false</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><h2 id="我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：Pasted-image-20250310210416">我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310210416.png" alt="Pasted image 20250310210416"></h2><h2 id="Object">Object</h2><h3 id="Object-类的常见方法有哪些？"><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Object 类的常见方法有哪些？</a></h3><p>Object 类是一个特殊的类，是所有类的父类，主要提供了以下 11 个方法：<br>/**</p><ul><li>native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。<br><em>/<br>public final native Class&lt; ?&gt; getClass()<br>/</em>*</li><li>native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。<br><em>/<br>public native int hashCode()<br>/</em>*</li><li>用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。<br><em>/<br>public boolean equals(Object obj)<br>/</em>*</li><li>native 方法，用于创建并返回当前对象的一份拷贝。<br><em>/<br>protected native Object clone() throws CloneNotSupportedException<br>/</em>*</li><li>返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。<br><em>/<br>public String toString()<br>/</em>*</li><li>native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。<br><em>/<br>public final native void notify()<br>/</em>*</li><li>native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。<br><em>/<br>public final native void notifyAll()<br>/</em>*</li><li>native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。<br><em>/<br>public final native void wait(long timeout) throws InterruptedException<br>/</em>*</li><li>多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。<br><em>/<br>public final void wait(long timeout, int nanos) throws InterruptedException<br>/</em>*</li><li>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念<br><em>/<br>public final void wait() throws InterruptedException<br>/</em>*</li><li>实例被垃圾回收器回收的时候触发的操作<br>*/<br>protected void finalize() throws Throwable { }</li></ul><h3 id="和-equals-的区别"><a href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">== 和 equals() 的区别</a></h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">     return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">System.out.println(aa == bb);// true</span><br><span class="line">System.out.println(a == b);// false</span><br><span class="line">System.out.println(a.equals(b));// true</span><br><span class="line">System.out.println(42 == 42.0);// true</span><br></pre></td></tr></table></figure><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><p><code>String</code>类<code>equals()</code>方法：<br>public boolean equals(Object anObject) {<br>if (this == anObject) {<br>return true;<br>}<br>if (anObject instanceof String) {<br>String anotherString = (String)anObject;<br>int n = value.length;<br>if (n == anotherString.value.length) {<br>char v1[] = value;<br>char v2[] = anotherString.value;<br>int i = 0;<br>while (n-- != 0) {<br>if (v1[i] != v2[i])<br>return false;<br>i++;<br>}<br>return true;<br>}<br>}<br>return false;<br>}</p><h3 id="hashCode-有什么用？"><a href="#hashcode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">hashCode() 有什么用？</a></h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png" alt="hashCode() 方法"></p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><blockquote><p>⚠️ 注意：该方法在 <strong>Oracle OpenJDK8</strong> 中默认是 “使用线程局部状态来实现 Marsaglia’s xor-shift 随机数生成”, 并不是 “地址” 或者 “地址转换而来”, 不同 JDK/VM 可能不同。在 <strong>Oracle OpenJDK8</strong> 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。参考源码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line"></span><br><span class="line">散列表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）**</span><br><span class="line"></span><br><span class="line">### [为什么要有 hashCode？](#为什么要有-hashcode)</span><br><span class="line"></span><br><span class="line">我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 `hashCode`？</span><br><span class="line">当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。</span><br><span class="line"></span><br><span class="line">其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。</span><br><span class="line"></span><br><span class="line">**那为什么 JDK 还要同时提供这两个方法呢？**</span><br><span class="line">这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！</span><br><span class="line"></span><br><span class="line">我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。</span><br><span class="line"></span><br><span class="line">**那为什么不只提供 `hashCode()` 方法呢？**</span><br><span class="line"></span><br><span class="line">这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。</span><br><span class="line"></span><br><span class="line">**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**</span><br><span class="line"></span><br><span class="line">因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。</span><br><span class="line"></span><br><span class="line">---总结下来就是：</span><br><span class="line"></span><br><span class="line">- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。</span><br><span class="line">- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。</span><br><span class="line">- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。</span><br><span class="line"></span><br><span class="line">相信大家看了我前面对 `hashCode()` 和 `equals()` 的介绍之后，下面这个问题已经难不倒你们了。</span><br><span class="line"></span><br><span class="line">### [为什么重写 equals() 时必须重写 hashCode() 方法？](#为什么重写-equals-时必须重写-hashcode-方法)</span><br><span class="line">因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。</span><br><span class="line"></span><br><span class="line">如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。</span><br><span class="line"></span><br><span class="line">**思考**：重写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现什么问题。</span><br><span class="line"></span><br><span class="line">**总结**：</span><br><span class="line"></span><br><span class="line">- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。</span><br><span class="line">- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。</span><br><span class="line">## [String](#string)</span><br><span class="line"></span><br><span class="line">### [String、StringBuffer、StringBuilder 的区别？](#string、stringbuffer、stringbuilder-的区别)</span><br><span class="line"></span><br><span class="line">**可变性**</span><br><span class="line"></span><br><span class="line">`String` 是不可变的（后面会详细分析原因）。</span><br><span class="line"></span><br><span class="line">`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">   char[] value;</span><br><span class="line">   public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">       if (str == null)</span><br><span class="line">           return appendNull();</span><br><span class="line">       int len = str.length();</span><br><span class="line">       ensureCapacityInternal(count + len);</span><br><span class="line">       str.getChars(0, len, value, count);</span><br><span class="line">       count += len;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br><span class="line">**线程安全性**</span><br><span class="line"></span><br><span class="line">`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。</span><br><span class="line"></span><br><span class="line">**性能**</span><br><span class="line"></span><br><span class="line">每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</span><br><span class="line"></span><br><span class="line">**对于三者使用的总结：**</span><br><span class="line"></span><br><span class="line">- 操作少量的数据: 适用 `String`</span><br><span class="line">- 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`</span><br><span class="line">- 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`</span><br><span class="line"></span><br><span class="line">### [String 为什么是不可变的?](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84)</span><br><span class="line">`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，~~所以`String` 对象是不可变的。~~</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>public final class String implements java.io.Serializable, Comparable<String>, CharSequence {<br>private final char value[];<br>//…<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 🐛 修正：我们知道被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，`final` 关键字修饰的数组保存字符串并不是 `String` 不可变的根本原因，因为这个数组保存的字符串是可变的（`final` 修饰引用类型变量的情况）。</span><br><span class="line">&gt;</span><br><span class="line">&gt; `String` 真正不可变有下面几点原因：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。</span><br><span class="line">&gt; 2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 相关阅读：[如何理解 String 类型值的不可变？ - 知乎提问](https://www.zhihu.com/question/20618891/answer/114125846)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>public final class String implements java.io.Serializable,Comparable<String>, CharSequence {<br>// @Stable 注解表示变量最多被修改一次，称为“稳定的”。<br>@Stable<br>private final byte[] value;<br>}</p><p>abstract class AbstractStringBuilder implements Appendable, CharSequence {<br>byte[] value;</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Java 9 为何要将 `String` 的底层实现由 `char[]` 改成了 `byte[]` ?**</span><br><span class="line"></span><br><span class="line">新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。</span><br><span class="line"></span><br><span class="line">JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/jdk9-string-latin1.png)</span><br><span class="line"></span><br><span class="line">如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，`byte` 和 `char` 所占用的空间是一样的。</span><br><span class="line"></span><br><span class="line">这是官方的介绍：[https://openjdk.java.net/jeps/254](https://openjdk.java.net/jeps/254) 。</span><br><span class="line"></span><br><span class="line">### [字符串拼接用“+” 还是 StringBuilder?](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder)</span><br><span class="line"></span><br><span class="line">Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>String str1 = “he”;<br>String str2 = “llo”;<br>String str3 = “world”;<br>String str4 = str1 + str2 + str3;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的代码对应的字节码如下：</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png)</span><br><span class="line"></span><br><span class="line">可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。</span><br><span class="line"></span><br><span class="line">不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String[] arr = {“he”, “llo”, “world”};<br>String s = “”;<br>for (int i = 0; i &lt; arr.length; i++) {<br>s += arr[i];<br>}<br>System.out.println(s);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`StringBuilder` 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 `StringBuilder` 对象。</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/java/image-20220422161320823.png)</span><br><span class="line"></span><br><span class="line">如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String[] arr = {“he”, “llo”, “world”};<br>StringBuilder s = new StringBuilder();<br>for (String value : arr) {<br>s.append(value);<br>}<br>System.out.println(s);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/java/image-20220422162327415.png)</span><br><span class="line"></span><br><span class="line">如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。</span><br><span class="line"></span><br><span class="line">在 JDK 9 中，字符串相加“+”改为用动态方法 `makeConcatWithConstants()` 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： `a+b+c` 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。这个改进是 JDK9 的 [JEP 280](https://openjdk.org/jeps/280) 提出的，关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 [StringBuilder？来重温一下字符串拼接吧](https://juejin.cn/post/7182872058743750715) 以及参考 [issue#2442](https://github.com/Snailclimb/JavaGuide/issues/2442)。</span><br><span class="line"></span><br><span class="line">### [String#equals() 和 Object#equals() 有何区别？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-equals-%E5%92%8C-object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB)</span><br><span class="line"></span><br><span class="line">`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。</span><br><span class="line"></span><br><span class="line">### [字符串常量池的作用了解吗？](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97)</span><br><span class="line"></span><br><span class="line">**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 在字符串常量池中创建字符串对象 ”ab“<br>// 将字符串对象 ”ab“ 的引用赋值给 aa<br>String aa = “ab”;<br>// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb<br>String bb = “ab”;<br>System.out.println(aa==bb); // true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">更多关于字符串常量池的介绍可以看一下 [Java 内存区域详解](https://javaguide.cn/java/jvm/memory-area.html) 这篇文章。</span><br><span class="line"></span><br><span class="line">### [String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-s1-new-string-abc-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1)</span><br><span class="line"></span><br><span class="line">先说答案：会创建 1 或 2 个字符串对象。</span><br><span class="line"></span><br><span class="line">1. 字符串常量池中不存在 &quot;abc&quot;：会创建 2 个 字符串对象。一个在字符串常量池中，由 `ldc` 指令触发创建。一个在堆中，由 `new String()` 创建，并使用常量池中的 &quot;abc&quot; 进行初始化。</span><br><span class="line">2. 字符串常量池中已存在 &quot;abc&quot;：会创建 1 个 字符串对象。该对象在堆中，由 `new String()` 创建，并使用常量池中的 &quot;abc&quot; 进行初始化。</span><br><span class="line"></span><br><span class="line">下面开始详细分析。</span><br><span class="line"></span><br><span class="line">1、如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 &quot;abc&quot;，然后在堆内存中再创建其中一个字符串对象 &quot;abc&quot;。</span><br><span class="line"></span><br><span class="line">示例代码（JDK 1.8）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String s1 = new String(“abc”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的字节码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 在堆内存中分配一个尚未初始化的 String 对象。<br>// #2 是常量池中的一个符号引用，指向 java/lang/String 类。<br>// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。<br>0 new #2 &lt;java/lang/String&gt;<br>// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。<br>// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。<br>3 dup<br>// JVM 先检查字符串常量池中是否存在 “abc”。<br>// 如果常量池中已存在 “abc”，则直接返回该字符串的引用；<br>// 如果常量池中不存在 “abc”，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。<br>// 这个引用被压入操作数栈，用作构造函数的参数。<br>4 ldc #3 <abc><br>// 调用构造方法，使用从常量池中加载的 “abc” 初始化堆中的 String 对象<br>// 新的 String 对象将包含与常量池中的 “abc” 相同的内容，但它是一个独立的对象，存储于堆中。<br>6 invokespecial #4 &lt;java/lang/String.<init> : (Ljava/lang/String;)V&gt;<br>// 将堆中的 String 对象引用存储到局部变量表<br>9 astore_1<br>// 返回，结束方法<br>10 return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`ldc (load constant)` 指令的确是从常量池中加载各种类型的常量，包括字符串常量、整数常量、浮点数常量，甚至类引用等。对于字符串常量，`ldc` 指令的行为如下：</span><br><span class="line"></span><br><span class="line">1. **从常量池加载字符串**：`ldc` 首先检查字符串常量池中是否已经有内容相同的字符串对象。</span><br><span class="line">2. **复用已有字符串对象**：如果字符串常量池中已经存在内容相同的字符串对象，`ldc` 会将该对象的引用加载到操作数栈上。</span><br><span class="line">3. **没有则创建新对象并加入常量池**：如果字符串常量池中没有相同内容的字符串对象，JVM 会在常量池中创建一个新的字符串对象，并将其引用加载到操作数栈中。</span><br><span class="line"></span><br><span class="line">2、如果字符串常量池中已存在字符串对象“abc”，则只会在堆中创建 1 个字符串对象“abc”。</span><br><span class="line"></span><br><span class="line">示例代码（JDK 1.8）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 字符串常量池中已存在字符串对象“abc”<br>String s1 = “abc”;<br>// 下面这段代码只会在堆中创建 1 个字符串对象“abc”<br>String s2 = new String(“abc”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的字节码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0 ldc #2 <abc><br>2 astore_1<br>3 new #3 &lt;java/lang/String&gt;<br>6 dup<br>7 ldc #2 <abc><br>9 invokespecial #4 &lt;java/lang/String.<init> : (Ljava/lang/String;)V&gt;<br>12 astore_2<br>13 return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里就不对上面的字节码进行详细注释了，7 这个位置的 `ldc` 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 `ldc` 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 `ldc` 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</span><br><span class="line"></span><br><span class="line">### [String#intern 方法有什么作用?](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8)</span><br><span class="line"></span><br><span class="line">`String.intern()` 是一个 `native` (本地) 方法，用来处理字符串常量池中的字符串对象引用。它的工作流程可以概括为以下两种情况：</span><br><span class="line"></span><br><span class="line">1. **常量池中已有相同内容的字符串对象**：如果字符串常量池中已经有一个与调用 `intern()` 方法的字符串内容相同的 `String` 对象，`intern()` 方法会直接返回常量池中该对象的引用。</span><br><span class="line">2. **常量池中没有相同内容的字符串对象**：如果字符串常量池中还没有一个与调用 `intern()` 方法的字符串内容相同的对象，`intern()` 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">- `intern()` 方法的主要作用是确保字符串引用在常量池中的唯一性。</span><br><span class="line">- 当调用 `intern()` 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</span><br><span class="line"></span><br><span class="line">示例代码（JDK 1.8） :</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// s1 指向字符串常量池中的 “Java” 对象<br>String s1 = “Java”;<br>// s2 也指向字符串常量池中的 “Java” 对象，和 s1 是同一个对象<br>String s2 = s1.intern();<br>// 在堆中创建一个新的 “Java” 对象，s3 指向它<br>String s3 = new String(“Java”);<br>// s4 指向字符串常量池中的 “Java” 对象，和 s1 是同一个对象<br>String s4 = s3.intern();<br>// s1 和 s2 指向的是同一个常量池中的对象<br>System.out.println(s1 == s2); // true<br>// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同<br>System.out.println(s3 == s4); // false<br>// s1 和 s4 都指向常量池中的同一个对象<br>System.out.println(s1 == s4); // true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [String 类型的变量和常量做“+”运算时发生了什么？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A-%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)</span><br><span class="line"></span><br><span class="line">先来看字符串不加 `final` 关键字拼接的情况（JDK1.8）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String str1 = “str”;<br>String str2 = “ing”;<br>String str3 = “str” + “ing”;<br>String str4 = str1 + str2;<br>String str5 = “string”;<br>System.out.println(str3 == str4);//false<br>System.out.println(str3 == str5);//true<br>System.out.println(str4 == str5);//false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; **注意**：比较 String 字符串的值是否相等，可以使用 `equals()` 方法。 `String` 中的 `equals` 方法是被重写过的。 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是字符串的值是否相等。如果你使用 `==` 比较两个字符串是否相等的话，IDEA 还是提示你使用 `equals()` 方法替换。</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/java-guide-blog/image-20210817123252441.png)</span><br><span class="line"></span><br><span class="line">**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**</span><br><span class="line"></span><br><span class="line">在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/javaguide/image-20210817142715396.png)</span><br><span class="line"></span><br><span class="line">常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</span><br><span class="line"></span><br><span class="line">对于 `String str3 = &quot;str&quot; + &quot;ing&quot;;` 编译器会给你优化成 `String str3 = &quot;string&quot;;` 。</span><br><span class="line"></span><br><span class="line">并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</span><br><span class="line"></span><br><span class="line">- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。</span><br><span class="line">- `final` 修饰的基本数据类型和字符串变量</span><br><span class="line">- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</span><br><span class="line"></span><br><span class="line">**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**</span><br><span class="line"></span><br><span class="line">对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String str4 = new StringBuilder().append(str1).append(str2).toString();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。</span><br><span class="line"></span><br><span class="line">不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>final String str1 = “str”;<br>final String str2 = “ing”;<br>// 下面两个表达式其实是等价的<br>String c = “str” + “ing”;// 常量池中的对象<br>String d = str1 + str2; // 常量池中的对象<br>System.out.println(c == d);// true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</span><br><span class="line"></span><br><span class="line">如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</span><br><span class="line"></span><br><span class="line">示例代码（`str2` 在运行时才能确定其值）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>final String str1 = “str”;<br>final String str2 = getStr();<br>String c = “str” + “ing”;// 常量池中的对象<br>String d = str1 + str2; // 在堆上创建的新的对象<br>System.out.println(c == d);// false<br>public static String getStr() {<br>return “ing”;<br>}</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识总结</title>
      <link href="/post/188a7023.html"/>
      <url>/post/188a7023.html</url>
      
        <content type="html"><![CDATA[<h1>基础</h1><p>Python解释器：即python.exe<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%2041.png" alt="image 41|image 41.png"><br>作用：<br>将Python代码翻译成计算机认识的0和1并提交计算机执行<br>在解释器环境内可以一行行的执行我们输入的代码<br>也可以使用解释器程序，去执行&quot;.py&quot;代码文件</p><p>关于注释的面试题：</p><ol><li><strong>单行注释中能否使用多行注释？</strong></li><li><strong>多行注释中能否使用单行注释？</strong><ul><li>多行注释中可以包含单行注释，但单行注释符号 <code>#</code> 在多行注释中不起作用。</li></ul></li><li><strong>多行注释中能否使用多行注释？</strong><ul><li>多行注释不能嵌套多行注释。Python不支持嵌套的多行注释。</li></ul></li></ol><h2 id="python内存管理">python内存管理</h2><p><strong>Python采用基于值的自动内存管理模式，变量并不直接存储值，而是存储值的引用或内存地址</strong></p><ul><li>基于值的模式：<br>小整数、短字符串等会驻留内存，<mark>同值变量指向同一地址</mark>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">a = 5</span><br><span class="line">b = 5</span><br><span class="line">print(a is b)  # True（小整数驻留）</span><br></pre></td></tr></table></figure><ul><li>变量赋值：<br>变量存储值的内存地址（引用），赋值改变指向。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> y)  <span class="comment"># False（不同对象）</span></span><br><span class="line">x = y</span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> y)  <span class="comment"># True（指向同一对象）</span></span><br></pre></td></tr></table></figure><ul><li>与 Java 对比：<br>Java 对象变量也是<mark>引用传递</mark>，类似 Python。</li></ul><h1>关键字</h1><table><thead><tr><th>关键字</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>assert</code></td><td>断言条件为真，否则抛出异常</td><td><code>assert x &gt; 0, &quot;x 必须为正数&quot;</code></td></tr><tr><td><code>pass</code></td><td>空语句，占位符</td><td><code>if x &gt; 0: pass</code></td></tr><tr><td><code>raise</code></td><td>手动抛出异常</td><td><code>raise ValueError(&quot;错误&quot;)</code></td></tr><tr><td><code>yield</code></td><td>生成器函数返回值</td><td><code>def gen(): yield 1</code></td></tr></tbody></table><h1>函数</h1><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>all(iterable)</code></td><td>所有元素为真时返回 <code>True</code></td><td><code>all([1, 2, 3]) → True</code></td></tr><tr><td><code>any(iterable)</code></td><td>任一元素为真时返回 <code>True</code></td><td><code>any([0, &quot;&quot;, 3]) → True</code></td></tr><tr><td><code>callable(obj)</code></td><td>检查对象是否可调用</td><td><code>callable(print) → True</code></td></tr><tr><td><code>chr(ascii)</code></td><td>返回 ASCII 字符</td><td><code>chr(65) → 'A'</code></td></tr><tr><td><code>dir(obj)</code></td><td>返回对象的属性列表</td><td><code>dir([])</code></td></tr><tr><td><code>divmod(a, b)</code></td><td>返回商和余数</td><td><code>divmod(10, 3) → (3, 1)</code></td></tr><tr><td><code>enumerate(seq)</code></td><td>返回索引-元素对</td><td><code>list(enumerate([&quot;a&quot;, &quot;b&quot;])) → [(0, 'a'), (1, 'b')]</code></td></tr><tr><td><code>eval(expr)</code></td><td>执行字符串表达式</td><td><code>eval(&quot;2+3&quot;) → 5</code></td></tr><tr><td><code>exec(code)</code></td><td>执行字符串代码</td><td><code>exec(&quot;print('Hello')&quot;)</code></td></tr><tr><td><code>filter(func, seq)</code></td><td>过滤序列中符合条件的元素</td><td><code>list(filter(lambda x: x&gt;0, [-1, 2])) → [2]</code></td></tr><tr><td><code>frozenset(seq)</code></td><td>创建不可变集合</td><td><code>frozenset([1,2])</code></td></tr><tr><td><code>globals()</code></td><td>返回全局变量字典</td><td><code>globals()</code></td></tr><tr><td><code>hex(x)</code></td><td>转十六进制字符串</td><td><code>hex(255) → '0xff'</code></td></tr><tr><td><code>id(obj)</code></td><td>返回对象内存地址</td><td><code>id(5) → 140736...</code></td></tr><tr><td><code>locals()</code></td><td>返回局部变量字典</td><td><code>locals()</code></td></tr><tr><td><code>map(func, seq)</code></td><td>对序列元素应用函数</td><td><code>list(map(str, [1,2])) → ['1', '2']</code></td></tr><tr><td><code>oct(x)</code></td><td>转八进制字符串</td><td><code>oct(8) → '0o10'</code></td></tr><tr><td><code>open(file)</code></td><td>打开文件</td><td><code>with open(&quot;file.txt&quot;) as f:</code></td></tr><tr><td><code>ord(char)</code></td><td>返回字符的 Unicode 码</td><td><code>ord('A') → 65</code></td></tr><tr><td><code>quit()</code></td><td>退出 Python 解释器</td><td><code>quit()</code></td></tr><tr><td><code>reduce(func, seq)</code></td><td>累积运算（需导入 <code>functools</code>）</td><td><code>from functools import reduce; reduce(lambda x,y: x+y, [1,2,3]) → 6</code></td></tr><tr><td><code>reversed(seq)</code></td><td>返回反转的迭代器</td><td><code>list(reversed([1,2])) → [2,1]</code></td></tr><tr><td><code>zip(seq1, seq2)</code></td><td>组合多个序列为元组迭代器</td><td><code>list(zip([1,2], ['a','b'])) → [(1, 'a'), (2, 'b')]</code></td></tr></tbody></table><h2 id="输入输出">输入输出</h2><p>print换行输出<br>在print语句中加上end=’’，即可不换行（使用的方法传参功能）<br>\t可以让多行字符串对齐<br>键盘输入<code>input()</code> 是一个内置函数，会将用户输入的内容作为<mark>字符串</mark>返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字：&quot;</span>)</span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>)</span><br><span class="line"><span class="comment"># 打印输入的内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;你好，<span class="subst">&#123;name&#125;</span>！你今年 <span class="subst">&#123;age&#125;</span> 岁。&quot;</span>)</span><br><span class="line"><span class="comment"># 将输入的年龄转换为整数并进行计算</span></span><br><span class="line">age = <span class="built_in">int</span>(age)  <span class="comment"># 将字符串转换为整数</span></span><br><span class="line">birth_year = <span class="number">2023</span> - age</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;你出生的年份大约是：<span class="subst">&#123;birth_year&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><strong>输入内容始终是字符串</strong>：无论用户输入什么，<code>input()</code> 都会将其作为字符串返回。如果需要数字，必须使用 <code>int()</code> 或 <code>float()</code> 进行转换。</li><li><strong>处理异常输入</strong>：如果用户输入的内容无法转换为数字（例如输入了字母），直接使用 <code>int()</code> 或 <code>float()</code> 会引发 <code>ValueError</code>。可以使用 <code>try-except</code> 来处理异常。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你输入的年龄是：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入无效，请输入一个数字！&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="值类型">值类型</h3><ol><li><strong>数字（Number）</strong>：<ul><li><strong>整数（int）</strong>：如 <code>10</code>, <code>10</code></li><li><strong>浮点数（float）</strong>：如 <code>13.14</code>, <code>13.14</code></li><li><strong>复数（complex）</strong>：如 <code>4+3j</code>，以 <code>j</code> 结尾表示复数</li><li><strong>布尔（bool）</strong>：表示逻辑值，<code>True</code> 为真，<code>False</code> 为假。<code>True</code> 本质上是 <code>1</code>，<code>False</code> 是 <code>0</code>，可以 参与数值运算，java不可以</li></ul></li><li><strong>字符串（String）</strong>：用于描述文本，由任意数量的字符组成。</li><li><strong>列表（List）</strong>：<mark>有序</mark>的<mark>可变</mark>序列，常用于存储一系列数据。</li><li><strong>元组（Tuple）</strong>：<mark>有序</mark>的<mark>不可变</mark>序列，适用于存储不可变的数据集合。<br>注：若只有一个元素，逗号不可以省略 eg.（3,）</li><li><strong>集合（Set）</strong>：<mark>无序</mark>且<mark>不重复</mark>的集合，适用于<mark>去重和集合</mark>运算。</li><li><strong>字典（Dictionary）</strong>：<mark>无序</mark>的<mark>键值对</mark>集合，适用于<mark>存储和快速查找键值对</mark>数据。</li></ol><table><thead><tr><th>Python 类型</th><th>Java 对应类型</th><th>特点</th></tr></thead><tbody><tr><td>列表 (List)</td><td><code>ArrayList</code></td><td>有序，可变</td></tr><tr><td>元组 (Tuple)</td><td>不可变 <code>List</code>/数组</td><td>有序，不可变</td></tr><tr><td>集合 (Set)</td><td><code>HashSet</code></td><td>无序，元素唯一</td></tr><tr><td>字典 (Dict)</td><td><code>HashMap</code></td><td>键值对，键唯一</td></tr><tr><td><code>+</code>和<code>*</code>支持列表和元组</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2] + [3] = [1,2,3]</span><br><span class="line">(1,2) * 2 = (1,2,1,2)</span><br></pre></td></tr></table></figure><p>通过type()得到数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字类型示例</span></span><br><span class="line">integer_example = <span class="number">10</span></span><br><span class="line">float_example = <span class="number">13.14</span></span><br><span class="line">complex_example = <span class="number">4</span> + <span class="number">3j</span></span><br><span class="line">bool_example = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 字符串类型示例</span></span><br><span class="line">string_example = <span class="string">&quot;Hello, Python!&quot;</span></span><br><span class="line"><span class="comment"># 列表类型示例</span></span><br><span class="line">list_example = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 元组类型示例</span></span><br><span class="line">tuple_example = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 集合类型示例</span></span><br><span class="line">set_example = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 字典类型示例</span></span><br><span class="line">dict_example = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="comment"># 打印示例</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;整数:&quot;</span>, integer_example) <span class="comment"># 整数: 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;浮点数:&quot;</span>, float_example) <span class="comment"># 浮点数: 13.14</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;复数:&quot;</span>, complex_example) <span class="comment"># 复数: (4+3j)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;布尔值:&quot;</span>, bool_example) <span class="comment"># 布尔值: True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串:&quot;</span>, string_example) <span class="comment"># 字符串: Hello, Python!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表:&quot;</span>, list_example) <span class="comment"># 列表: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;元组:&quot;</span>, tuple_example) <span class="comment"># 元组: (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;集合:&quot;</span>, set_example) <span class="comment"># 集合: &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字典:&quot;</span>, dict_example) <span class="comment"># 字典: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(integer_example)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set_example)) <span class="comment"># &lt;class &#x27;set&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(dict_example)) <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line">bool_type = <span class="built_in">type</span>(bool_example)</span><br><span class="line"><span class="built_in">print</span>(bool_type) <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>注：<br>通过type(变量)输出的类型是查看变量的类型还是数据的类型<br>答：变量存储的<mark>数据的类型</mark>。因为，变量无类型，但是它存储的数据有</p><ul><li>数据类型转换<br>类型转换函数：</li></ul><table><thead><tr><th>函数</th><th>功能说明</th><th>典型用例与示例</th><th>注意事项</th></tr></thead><tbody><tr><td><code>int(x)</code></td><td>将 <code>x</code> 转换为整数（截断小数 / 按基数解析字符串）</td><td><code>int(3.9)</code> → <code>3</code>  <br><code>int(&quot;123&quot;)</code> → <code>123</code>  <br><code>int(&quot;11&quot;, 2)</code> → <code>3</code>（二进制转十进制）</td><td>① 字符串必须是纯数字（或带基数前缀）  <br>② 非数值类型（如<code>&quot;abc&quot;</code>）报错 <code>ValueError</code></td></tr><tr><td><code>float(x)</code></td><td>将 <code>x</code> 转换为浮点数（支持整数 / 字符串 / 布尔值）</td><td><code>float(5)</code> → <code>5.0</code>  <br><code>float(&quot;3.14&quot;)</code> → <code>3.14</code>  <br><code>float(True)</code> → <code>1.0</code></td><td>① 字符串需符合浮点数格式（如<code>&quot;12&quot;</code>→<code>12.0</code>，<code>&quot;1a&quot;</code>报错）  <br>② 精度限制（如<code>float(&quot;0.1234567890123456789&quot;)</code>会舍入）</td></tr><tr><td><code>str(x)</code></td><td>将对象 <code>x</code> 转换为字符串（调用 <code>__str__</code> 或 <code>__repr__</code> 方法）</td><td><code>str(123)</code> → <code>&quot;123&quot;</code>  <br><code>str([1, 2])</code> → <code>&quot;[1, 2]&quot;</code>  <br><code>str(Exception(&quot;error&quot;))</code> → <code>&quot;error&quot;</code></td><td>① 几乎支持所有对象（包括自定义类）  <br>② 与 <code>repr(x)</code> 区别：<code>str</code> 更注重可读性，<code>repr</code> 更注重准确性（如<code>str(0.1)</code>→<code>&quot;0.1&quot;</code>，<code>repr(0.1)</code>→<code>&quot;0.10000000000000001&quot;</code>）</td></tr><tr><td>``</td><td></td><td></td><td></td></tr></tbody></table><pre><code>这些函数都有返回值，可以直接用 `print` 输出或用变量存储结果1. **任何类型都可以通过** `str()`转换为字符串。2. **字符串必须包含有效的数字才能转换为数字类型**。</code></pre><ul><li>标识符命名规则<br>标识符命名中只允许出现以下四类元素：<ul><li>英文</li><li>中文</li><li>数字</li><li>下划线（<code>_</code>）<br><strong>注意事项</strong>：</li><li>不推荐使用中文。</li><li>数字不能开头。</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a_b = <span class="number">2</span></span><br><span class="line">_a = <span class="number">3</span></span><br><span class="line">a_b_1 = <span class="number">4</span></span><br></pre></td></tr></table></figure>Python有一些保留关键字，不能用作标识符。常见的关键字包括：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">False    True    None    and    as    assert    break    class</span><br><span class="line">continue    def    del    elif    else    except    finally    for</span><br><span class="line">from    global    if    import    in    is    lambda    nonlocal</span><br><span class="line">not    or    pass    raise    return    try    while    with    yield</span><br></pre></td></tr></table></figure>变量的命名规范<ul><li><strong>见名知意</strong>：变量名应清晰表达其用途。</li><li><strong>下划线命名法</strong>：使用小写字母和下划线组合，如 <code>my_variable</code>。</li><li><strong>英文字母全小写</strong>：通常变量名使用小写字母。</li></ul></li></ul><h3 id="字符串">字符串</h3><ul><li>字符串的三种定义方式<ol><li><strong>双引号定义法</strong>：<code>&quot;字符串&quot;</code></li><li><strong>单引号定义法</strong>：<code>'字符串'</code></li><li><strong>三引号定义法</strong>：<code>&quot;&quot;&quot;字符串&quot;&quot;&quot;</code> 或 <code>'''字符串'''</code><br>三引号定义法通常用于多行字符串或文档字符串（docstring）。</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text1 = <span class="string">&quot;我是字符串（文本）数据&quot;</span></span><br><span class="line">text2 = <span class="string">&#x27;我也是字符串（文本）数据哦&#x27;</span></span><br><span class="line">text3 = <span class="string">&quot;&quot;&quot;使用变量接收就是字符串，反之是块注释&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li>字符串的引号嵌套<br>在Python中，如果字符串本身包含单引号或双引号，可以通过以下方式处理：<ol><li><strong>单引号定义法</strong>：可以内含双引号。</li><li><strong>双引号定义法</strong>：可以内含单引号。</li><li><strong>转义字符</strong>：使用反斜杠（<code>\</code>）来转义引号。</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text1 = <span class="string">&#x27;他说：&quot;你好！&quot;&#x27;</span></span><br><span class="line">text2 = <span class="string">&quot;这是一个单引号：&#x27;&quot;</span></span><br><span class="line">text3 = <span class="string">&quot;这是一个双引号：\&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li>字符串前的 <code>r</code> 或 <code>R</code><br><strong>作用</strong>：表示原始字符串，转义字符无效。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">r&quot;C:\Users\name&quot;</span>  <span class="comment"># 无需转义反斜杠</span></span><br></pre></td></tr></table></figure><ul><li>字符串拼接<br>字符串可以通过 <code>+</code> 号进行拼接。通常用于拼接字符串字面量和变量。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字是：&quot;</span> + name + <span class="string">&quot;, 我可以教大家IT技能&quot;</span>)<span class="number">5</span></span><br></pre></td></tr></table></figure>不加<code>+</code>仅适用于字符串常量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span> <span class="string">&quot; World&quot;</span>    <span class="comment"># 自动拼接，输出 &quot;Hello World&quot;</span></span><br><span class="line">x = <span class="string">&quot;hello&quot;</span></span><br><span class="line">y = x<span class="string">&quot; world&quot;</span> <span class="comment"># 不可以</span></span><br></pre></td></tr></table></figure><ul><li>字符串与数字拼接<br>字符串不能直接与数字类型拼接，需要先将数字转换为字符串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;传智播客&quot;</span></span><br><span class="line">set_up_year = <span class="number">2006</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是：&quot;</span> + name + <span class="string">&quot;, 我成立于：&quot;</span> + <span class="built_in">str</span>(set_up_year))</span><br></pre></td></tr></table></figure></li><li>字符串格式化<br>使用 <code>%</code> 进行字符串格式化，可以快速拼接字符串和变量。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line">message = <span class="string">&quot;学IT就来 %s&quot;</span> % name</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>数字类型的占位<br>数字类型也可以使用 <code>%d</code> 和 <code>%f</code> 进行占位。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class_num = <span class="number">57</span></span><br><span class="line">avg_salary = <span class="number">16781</span></span><br><span class="line">message = <span class="string">&quot;Python大数据学科：北京%d期、毕业平均工资：%s&quot;</span> % (class_num, avg_salary)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></li><li>字符串格式化 - 数字精度控制<br>在Python中，可以使用辅助符号 <code>m.n</code> 来控制数字的宽度和精度：<ul><li><strong>m</strong>：控制宽度，要求是数字。如果设置的宽度小于数字自身，不生效。</li><li><strong>.n</strong>：控制小数点精度，要求是数字，会进行小数的四舍五入。</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">11</span></span><br><span class="line">num2 = <span class="number">11.345</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%5d&quot;</span> % num1)  <span class="comment"># 输出: [空格][空格][空格]11</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%7.2f&quot;</span> % num2)  <span class="comment"># 输出: [空格][空格]11.35</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.2f&quot;</span> % num2)  <span class="comment"># 输出: 11.35</span></span><br></pre></td></tr></table></figure></li><li>字符串格式化 - 快速写法<br>Python 提供了更简洁的字符串格式化方式，使用 <code>f-string</code>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;作者推荐&quot;</span></span><br><span class="line">set_up_year = <span class="number">2086</span></span><br><span class="line">stock_price = <span class="number">19.99</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;name&#125;</span>，我成立于：<span class="subst">&#123;set_up_year&#125;</span>，我今天创建我的作品：<span class="subst">&#123;stock_price&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>这种写法不做精度控制，也不理会类型，适用于快速格式化字符串。</li><li>字符串格式化 - 表达式的格式化<br>可以直接格式化表达式，简化代码：<br>表达式是具有明确结果的代码语句，如 <code>1 + 1</code>、<code>type(&quot;字符串&quot;)</code>、<code>3 * 5</code> 等。在变量定义时，等号右侧的就是表达式。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 * 1的结果是：%d&quot;</span> % (<span class="number">1</span> * <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;1 * 1的结果是：<span class="subst">&#123;<span class="number">1</span> * <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在Python中的类型是：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&#x27;字符串&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul><p>字节串 VS 字符串</p><table><thead><tr><th>类型</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td>字符串</td><td>文本数据</td><td><code>s = &quot;Hello&quot;</code></td></tr><tr><td>字节串</td><td>二进制数据</td><td><code>b = b&quot;Hello&quot;</code></td></tr></tbody></table><h3 id="算术运算符">算术运算符</h3><p>Python支持多种算术运算符：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>运算符</td><td>描述</td><td>示例</td></tr><tr><td><code>+</code></td><td>加法</td><td><code>3 + 2</code> 结果为 <code>5</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>3 - 2</code> 结果为 <code>1</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>3 * 2</code> 结果为 <code>6</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>3 / 2</code> 结果为 <code>1.5</code></td></tr><tr><td><code>%</code></td><td>取模</td><td><code>3 % 2</code> 结果为 <code>1</code></td></tr><tr><td><code>**</code></td><td>幂运算</td><td><code>3 ** 2</code> 结果为 <code>9</code></td></tr><tr><td><code>//</code></td><td>整除</td><td><code>3 // 2</code> 结果为 <code>1</code></td></tr><tr><td>注：python中的/是真除，可以有小数，java中的/是整除</td><td></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a + b  <span class="comment"># 13</span></span><br><span class="line">a - b  <span class="comment"># 7</span></span><br><span class="line">a * b  <span class="comment"># 30</span></span><br><span class="line">a / b  <span class="comment"># 3.333...</span></span><br><span class="line">a % b  <span class="comment"># 1</span></span><br><span class="line">a ** b  <span class="comment"># 1000</span></span><br><span class="line"><span class="built_in">pow</span>(a,b) <span class="comment"># 1000</span></span><br><span class="line"><span class="built_in">pow</span>(a,b,<span class="number">5</span>) <span class="comment"># 10^3%5=0</span></span><br><span class="line">a // b  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>复合赋值运算符结合了算术运算符和赋值运算符。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>运算符</td><td>描述</td><td>示例</td></tr><tr><td><code>+=</code></td><td>加法赋值</td><td><code>a += b</code> 等价于 <code>a = a + b</code></td></tr><tr><td><code>-=</code></td><td>减法赋值</td><td><code>a -= b</code> 等价于 <code>a = a - b</code></td></tr><tr><td><code>*=</code></td><td>乘法赋值</td><td><code>a *= b</code> 等价于 <code>a = a * b</code></td></tr><tr><td><code>/=</code></td><td>除法赋值</td><td><code>a /= b</code> 等价于 <code>a = a / b</code></td></tr><tr><td><code>%=</code></td><td>取模赋值</td><td><code>a %= b</code> 等价于 <code>a = a % b</code></td></tr><tr><td><code>**=</code></td><td>幂赋值</td><td><code>a **= b</code> 等价于 <code>a = a ** b</code></td></tr><tr><td><code>//=</code></td><td>整除赋值</td><td><code>a //= b</code> 等价于 <code>a = a // b</code></td></tr><tr><td><strong>负数取模</strong></td><td></td><td></td></tr><tr><td><strong>公式</strong>：<code>a % b = a - b * floor(a / b)</code></td><td></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a += b  <span class="comment"># a = 13</span></span><br><span class="line">a -= b  <span class="comment"># a = 10</span></span><br><span class="line">a *= b  <span class="comment"># a = 30</span></span><br><span class="line">a /= b  <span class="comment"># a = 10.0</span></span><br><span class="line">a %= b  <span class="comment"># a = 1.0</span></span><br><span class="line">a **= b  <span class="comment"># a = 1.0</span></span><br><span class="line">a //= b  <span class="comment"># a = 0.0</span></span><br><span class="line">-<span class="number">17</span> % <span class="number">4</span> <span class="comment"># -17-4*(-5) = 3</span></span><br></pre></td></tr></table></figure><p>注：python可以多个变量连等赋值，java不可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=b=1 # python</span><br><span class="line">int a = 1,b = 1; # java</span><br></pre></td></tr></table></figure><p><strong>海象运算符:=</strong><br>用于表达式内部赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算">逻辑运算</h2><ul><li>&amp;<br>Python：返回最后一个为真的值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>)  <span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure><p>Java：&amp;&amp; 返回布尔值，非真值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">3</span> &amp;&amp; <span class="number">5</span>);  <span class="comment">// 编译错误（需布尔表达式）</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>运算符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>`|·</td><td>并集</td><td><code>&#123;1,2&#125;|&#123;2,3&#125; → &#123;1,2,3&#125;</code></td></tr><tr><td><code>&amp;</code></td><td>交集</td><td><code>&#123;1,2&#125; &amp; &#123;2,3&#125; → &#123;2&#125;</code></td></tr><tr><td><code>^</code></td><td>对称差集</td><td><code>&#123;1,2&#125; ^ &#123;2,3&#125; → &#123;1,3&#125;</code></td></tr><tr><td><code>-</code></td><td>差集</td><td><code>&#123;1,2&#125; - &#123;2,3&#125; → &#123;1&#125;</code></td></tr></tbody></table><h3 id="判断">判断</h3><p>比较运算符<br>比较运算符用于比较两个值，并返回一个布尔值（<code>True</code> 或 <code>False</code>）。以下是常用的比较运算符：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>运算符</td><td>描述</td><td>示例</td></tr><tr><td>==</td><td>判断内容是否相等，满足为 <code>True</code>，不满足为 <code>False</code></td><td>如 <code>a=3, b=3</code>，则 <code>(a==b)</code> 为 <code>True</code></td></tr><tr><td><code>!=</code></td><td>判断内容是否不相等，满足为 <code>True</code>，不满足为 <code>False</code></td><td>如 <code>a=1, b=3</code>，则 <code>(a!=b)</code> 为 <code>True</code></td></tr><tr><td><code>&gt;</code></td><td>判断运算符左侧内容是否大于右侧</td><td>如 <code>a=7, b=3</code>，则 <code>(a&gt;b)</code> 为 <code>True</code></td></tr><tr><td><code>&lt;</code></td><td>判断运算符左侧内容是否小于右侧</td><td>如 <code>a=3, b=7</code>，则 <code>(a&lt;b)</code> 为 <code>True</code></td></tr><tr><td><code>&gt;=</code></td><td>判断运算符左侧内容是否大于等于右侧</td><td>如 <code>a=3, b=3</code>，则 <code>(a&gt;=b)</code> 为 <code>True</code></td></tr><tr><td><code>&lt;=</code></td><td>判断运算符左侧内容是否小于等于右侧</td><td>如 <code>a=3, b=3</code>，则 <code>(a&lt;=b)</code> 为 <code>True</code></td></tr><tr><td>条件语句（<code>if</code> 语句）</td><td></td><td></td></tr><tr><td><code>if</code> 语句用于根据条件执行代码块。如果条件为 <code>True</code>，则执行相应的代码块。</td><td></td><td></td></tr></tbody></table><ul><li><strong>缩进</strong>：归属于 <code>if</code> 判断的代码语句块，需在前方填充 4 个空格缩进。Python 通过缩进判断代码块的归属关系。</li><li><strong>冒号</strong>：<code>if</code> 语句后需要加冒号 <code>:</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;今年我已经<span class="subst">&#123;age&#125;</span>岁了&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已经成年了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;即将步入大学生活&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;时间过的真快&quot;</span>)</span><br></pre></td></tr></table></figure><p>多条件判断（<code>if-elif-else</code> 语句）<br>在某些场景下，判断条件不止一个，可能有多个。可以使用 <code>if-elif-else</code> 语句来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;欢迎来到黑马动物园。&quot;</span>)</span><br><span class="line">height = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))</span><br><span class="line">vip_level = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的vip级别(1~5)：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> height &lt; <span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的身高小于120CM，可以免费游玩。&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> vip_level &gt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的vip级别大于3，可以免费游玩。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不好意思，所有条件都不满足，需要购票10元。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;祝您游玩愉快。&quot;</span>)</span><br></pre></td></tr></table></figure><p>为了节省代码量，可以在条件判断中直接写 <code>input</code> 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>)) &lt; <span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的身高小于120CM，可以免费游玩。&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的vip级别(1~5)：&quot;</span>)) &gt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的vip级别大于3，可以免费游玩。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不好意思，所有条件都不满足，需要购票10元。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;祝您游玩愉快。&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="循环">循环</h3><ol><li><code>while</code> 循环 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件：</span><br><span class="line">    条件满足时，做的事情<span class="number">1</span></span><br><span class="line">    条件满足时，做的事情<span class="number">2</span></span><br><span class="line">    条件满足时，做的事情<span class="number">3</span></span><br><span class="line">    ...（省略）...</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>注意事项</strong>：<ul><li>条件需提供布尔类型结果，<code>True</code> 继续，<code>False</code> 停止。</li><li>空格缩进不能忘。</li><li>规划好循环终止条件，否则将无限循环。</li></ul></li></ul><ol><li><code>for</code> 循环 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集：</span><br><span class="line">    循环满足条件时执行的代码</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>注意点</strong>：<ul><li>无法定义循环条件，只能被动取出数据处理。</li><li>循环内的语句需要有空格缩进。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历字典</span></span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Wonderland&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> person.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li><code>range</code> 语句<ul><li><strong>语法格式</strong>：<ul><li><code>range(num)</code>：从 <code>0</code> 开始，到 <code>num</code> 结束（不含 <code>num</code> 本身）。</li><li><code>range(num1, num2)</code>：从 <code>num1</code> 开始，到 <code>num2</code> 结束（不含 <code>num2</code> 本身）。</li><li><code>range(num1, num2, step)</code>：从 <code>num1</code> 开始，到 <code>num2</code> 结束（不含 <code>num2</code> 本身），步长为 <code>step</code>。</li></ul></li><li><strong>用途</strong>：多数用在 <code>for</code> 循环场景。</li></ul></li><li><code>for</code> 循环的变量作用域<ul><li><strong>临时变量</strong>：在编程规范上，作用范围（作用域）只限定在 <code>for</code> 循环内部。</li><li><strong>外部访问</strong>：实际上可以访问到，但在编程规范上是不允许、不建议的。</li></ul></li><li><code>continue</code> 和 <code>break</code><ul><li><strong>continue</strong>：中断所在循环的当次执行，直接进入下一次。</li><li><strong>break</strong>：直接结束所在的循环。</li><li><strong>注意事项</strong>：<ul><li><code>continue</code> 和 <code>break</code> 在 <code>for</code> 和 <code>while</code> 循环中使用一致。</li><li>在嵌套循   环中，只能作用在所在的循环上，无法对上层循环起作用。<br><code>_</code> 是一个变量名，通常用于表示循环中不需要使用的变量。</li></ul></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>猜数字案例实现</p><ol><li>使用 <code>if</code> 实现 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">target_number = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个 1 到 10 之间的数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> guess == target_number:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你，猜对了！&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> guess &lt; target_number:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你猜的数字太小了！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你猜的数字太大了！&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>使用 <code>while</code> 实现 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">target_number = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">attempts = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> attempts &gt; <span class="number">0</span>:</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;你还有 <span class="subst">&#123;attempts&#125;</span> 次机会，请输入一个 1 到 10 之间的数字：&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess == target_number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;恭喜你，猜对了！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> guess &lt; target_number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你猜的数字太小了！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你猜的数字太大了！&quot;</span>)</span><br><span class="line">    attempts -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;很遗憾，你没有猜中。正确的数字是 <span class="subst">&#123;target_number&#125;</span>。&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>使用 <code>for</code> 实现 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">target_number = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;第 <span class="subst">&#123;attempt + <span class="number">1</span>&#125;</span> 次猜测，请输入一个 1 到 10 之间的数字：&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess == target_number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;恭喜你，猜对了！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> guess &lt; target_number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你猜的数字太小了！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你猜的数字太大了！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;很遗憾，你没有猜中。正确的数字是 <span class="subst">&#123;target_number&#125;</span>。&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="while-VS-for">while VS for</h2><p><code>while</code> 需要手动控制循环变量的变化（比如<code>index += 1</code>），否则可能会导致无限循环。<br><code>for</code>不需要显式地管理循环变量，因为它会自动遍历可迭代对象。</p><ul><li>在循环控制上：<ul><li><strong>while循环可以自定循环条件，并自行控制</strong></li><li><strong>for循环不可以自定循环条件，只可以一个个从容器内取出数据</strong></li></ul></li><li>在无限循环上：<ul><li><strong>while循环可以通过条件控制做到无限循环</strong></li><li><strong>for循环理论上不可以，因为被遍历的容器容量不是无限的</strong></li></ul></li><li>在使用场景上：<ul><li><strong>while循环适用于任何想要循环的场景</strong></li><li><strong>for循环适用于，遍历数据容器的场景或简单的固定次数循环场景</strong></li></ul></li></ul><h3 id="函数">函数</h3><p>函数通过 <code>def</code> 关键字定义，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数列表</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值  <span class="comment"># 可选</span></span><br></pre></td></tr></table></figure><p>函数调用：函数名(参数)</p><ol><li><strong>传入参数</strong><br>函数可以接收不同类型的参数：<ul><li><strong>位置参数</strong>：按顺序传递参数。</li><li><strong>默认参数</strong>：为参数提供默认值。</li><li><strong>关键字参数</strong>：通过参数名指定值。</li><li><strong>可变参数</strong>：接收任意数量的参数（<code>args</code> 和 <code>*kwargs</code>）。：</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, greeting=<span class="string">&quot;Hello&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;向某人打招呼&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)                 <span class="comment"># 输出: Hello, Alice!</span></span><br><span class="line">greet(<span class="string">&quot;Bob&quot;</span>, greeting=<span class="string">&quot;Hi&quot;</span>)    <span class="comment"># 输出: Hi, Bob!</span></span><br></pre></td></tr></table></figure></li><li><strong>返回值</strong><br>使用 <code>return</code> 语句返回结果。若无 <code>return</code>，默认返回 <code>None</code>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回两个数的和&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment"># result = 8</span></span><br></pre></td></tr></table></figure>None：<ul><li><strong>类型</strong>：<code>None</code> 属于 <code>NoneType</code> 类，是 Python 中的一个特殊字面量。</li><li><strong>含义</strong>：表示“空”或“无意义”，常用于占位或标记无值状态。</li><li><strong>唯一性</strong>：<code>None</code> 是单例对象，所有 <code>None</code> 实例在内存中指向同一地址。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">None</span>))  <span class="comment"># 输出: &lt;class &#x27;NoneType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="literal">None</span>))    <span class="comment"># 输出: 固定地址（如 140735806203296）</span></span><br></pre></td></tr></table></figure></li></ul><code>None</code> <strong>的常见应用场景</strong><ol><li><strong>函数无返回值</strong><br>函数默认返回 <code>None</code>，显式返回 <code>None</code> 与省略 <code>return</code> 效果相同： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_no_return</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数无 return 语句&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_return_none</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数显式返回 None&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">result1 = func_no_return()    <span class="comment"># 输出: 函数无 return 语句</span></span><br><span class="line">result2 = func_return_none()  <span class="comment"># 输出: 函数显式返回 None</span></span><br><span class="line"><span class="built_in">print</span>(result1, result2)       <span class="comment"># 输出: None None</span></span><br></pre></td></tr></table></figure></li><li><code>if</code> <strong>判断</strong><ul><li><code>None</code> 在条件判断中视为 <code>False</code>，但 <code>None</code> 与 <code>False</code> 本身不相等。</li><li>常用于函数返回值的逻辑处理：</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># None 在条件判断中的行为</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不会执行&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;None 被视为 False&quot;</span>)  <span class="comment"># 输出: None 被视为 False</span></span><br><span class="line"><span class="comment"># 函数返回 None 配合 if 判断</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 等价于不返回</span></span><br><span class="line">result = check_even(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入是奇数&quot;</span>)  <span class="comment"># 输出: 输入是奇数</span></span><br></pre></td></tr></table></figure></li><li><strong>声明无内容的变量</strong><br>初始化变量时，用 <code>None</code> 表示暂时无具体值： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_data = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 后续逻辑中赋值</span></span><br><span class="line">user_data = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">if</span> user_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;用户数据: <span class="subst">&#123;user_data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><code>None</code> <strong>与</strong> <code>False</code> <strong>的区别</strong><ul><li><strong>类型不同</strong>：<code>None</code> 是 <code>NoneType</code>，<code>False</code> 是 <code>bool</code>。</li><li><strong>值不同</strong>：<code>None</code> 不表示布尔假，但条件判断中视为假：</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">None</span> == <span class="literal">False</span>)  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">None</span>))     <span class="comment"># 输出: False</span></span><br></pre></td></tr></table></figure></li></ol><strong>注：</strong><ul><li><strong>身份判断</strong>：使用 <code>is</code> 或 <code>is not</code> 判断 <code>None</code>，而非 == ：</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> <span class="literal">None</span>)    <span class="comment"># 输出: True</span></span><br><span class="line"><span class="built_in">print</span>(x == <span class="literal">None</span>)    <span class="comment"># 不推荐，但输出: True（因 None 是单例）</span></span><br></pre></td></tr></table></figure><ul><li><strong>不可参与运算</strong>：<code>None</code> 与数值类型操作会引发错误：</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print(None + 5)  # 报错: TypeError</span></span><br></pre></td></tr></table></figure></li><li><strong>说明文档（Docstring）</strong><br>通过多行注释的形式，对函数进行说明解释<br>在函数定义后添加文档字符串，说明函数功能、参数和返回值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个数的乘积。</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        a (int/float): 第一个数</span></span><br><span class="line"><span class="string">        b (int/float): 第二个数</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        int/float: a 和 b 的乘积</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"><span class="comment"># 查看文档</span></span><br><span class="line"><span class="built_in">help</span>(multiply)</span><br></pre></td></tr></table></figure>在PyCharm编写代码时，可以通过鼠标悬停，查看调用函数的说明文档</li><li><strong>嵌套调用</strong><br>函数内部可以调用其他函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两数之和的两倍&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> add(a, b) * <span class="number">2</span></span><br><span class="line">result = calculate(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment"># result = 16</span></span><br></pre></td></tr></table></figure></li><li><strong>变量作用域</strong><ul><li><strong>局部变量</strong>：函数内部定义的变量，仅在函数内有效。</li><li><strong>全局变量</strong>：函数外部定义的变量，需用 <code>global</code> 声明<strong>修改</strong>。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>  <span class="comment"># 全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_global</span>():</span><br><span class="line"><span class="comment"># globa] 关键字声明x是全局变量</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = <span class="number">20</span>  <span class="comment"># 修改全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">local_scope</span>():</span><br><span class="line">    y = <span class="number">5</span>  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(y)  <span class="comment"># 输出: 5</span></span><br><span class="line">update_global()</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出: 20</span></span><br><span class="line">local_scope()</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 报错: NameError（y 未定义）</span></span><br></pre></td></tr></table></figure></li></ol><p>使用函数优化猜数字案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_number</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成一个 1 到 10 的随机数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_guess</span>(<span class="params">guess, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查猜测结果&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> guess &lt; target:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;太小了！&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> guess &gt; target:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;太大了！&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;猜对了！&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_game</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;猜数字游戏主逻辑&quot;&quot;&quot;</span></span><br><span class="line">    target = generate_number()</span><br><span class="line">    attempts = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(attempts):</span><br><span class="line">        guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">f&quot;第 <span class="subst">&#123;attempt + <span class="number">1</span>&#125;</span> 次猜测，请输入 1-10 的数字：&quot;</span>))</span><br><span class="line">        result = check_guess(guess, target)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">        <span class="keyword">if</span> result == <span class="string">&quot;猜对了！&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;游戏结束，正确数字是 <span class="subst">&#123;target&#125;</span>。&quot;</span>)</span><br><span class="line"><span class="comment"># 启动游戏</span></span><br><span class="line">play_game()</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%201%203.png" alt="image 1 3|image 1 3.png"></p><h2 id="数据容器">数据容器</h2><p>一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素，即一种可以存储多个元素的Python数据类型<br>每一个元素，可以是任意类型的数据，如字符串、数字、布尔等。<br>数据容器根据特点的不同，如：</p><ul><li>是否支持重复元素</li><li>是否可以修改</li><li>是否有序</li></ul><p>分为5类，分别是：<br>列表（list|类型|可变性|特点|<br>|—|—|—|<br>|列表|可变|支持增删改|<br>|元组|不可变|创建后不能修改|<br>|字典|可变|键值对，键唯一|<br>|集合|可变|元素唯一，无序|<br>|字符串|不可变|创建后不能修改|）、元组（tuple）、字符串（str）、集合（set）、字典（dict）</p><table><thead><tr><th>类型</th><th>可嵌套类型</th><th>示例</th></tr></thead><tbody><tr><td>列表</td><td>任意类型</td><td><code>[[1,2], &#123;&quot;key&quot;: 3&#125;]</code></td></tr><tr><td>元组</td><td>任意类型</td><td><code>( (1,2), [3,4] )</code></td></tr><tr><td>集合</td><td>仅不可变类型（如元组）</td><td><code>&#123; (1,2), 3 &#125;</code></td></tr><tr><td>字典</td><td>键必须不可变</td><td><code>&#123; &quot;key&quot;: [1,2] &#125;</code></td></tr></tbody></table><table><thead><tr><th>类型</th><th>比较规则</th><th>示例</th></tr></thead><tbody><tr><td>列表</td><td>按元素逐个比较</td><td><code>[1,2,3] &lt; [1,2,4]</code> → <code>True</code></td></tr><tr><td>元组</td><td>同列表</td><td><code>(1,2) &lt; (1,3)</code> → <code>True</code></td></tr><tr><td>集合</td><td>不支持 <code>&lt;</code>，但支持 ==</td><td><code>&#123;1,2&#125; == &#123;2,1&#125;</code> → <code>True</code></td></tr></tbody></table><table><thead><tr><th>类型</th><th>可变性</th><th>特点</th></tr></thead><tbody><tr><td>列表</td><td>可变</td><td>支持增删改</td></tr><tr><td>元组</td><td>不可变</td><td>创建后不能修改</td></tr><tr><td>字典</td><td>可变</td><td>键值对，键唯一</td></tr><tr><td>集合</td><td>可变</td><td>元素唯一，无序</td></tr><tr><td>字符串</td><td>不可变</td><td>创建后不能修改</td></tr></tbody></table><h3 id="列表（List）"><strong>列表（List）[]</strong></h3><ul><li><strong>特点</strong>：<ul><li><strong>可变</strong>：支持增删改操作。</li><li><strong>有序</strong>：元素按插入顺序排列。</li><li><strong>允许重复</strong>：同一元素可多次出现。</li><li><strong>支持嵌套</strong></li></ul></li><li><strong>适用场景</strong>：需要动态修改的数据集合，如日志记录、用户输入管理等。</li><li>当列表增加或删除元素时，列表对象自动进行<mark>内存的扩展或收缩</mark>，从而保证相邻元素之间没缝隙， 应尽量从列表尾部进行元素的追加和删除</li><li>索引从0开始。反向索引从-1开始</li><li><strong>基本操作</strong>：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%202%203.png" alt="image 2 3|image 2 3.png">  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个示例列表</span></span><br><span class="line">my_list = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"><span class="comment"># 也可以使用list()函数把元组、range对象、字符串、字典、集合或其他可迭代对象转换为列表</span></span><br><span class="line"><span class="built_in">list</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment"># [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27; &#x27;,&#x27;w&#x27;…&#x27;d&#x27;]</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)) <span class="comment"># [1,3,5,7,9]</span></span><br><span class="line"><span class="comment"># 字典转换为列表时默认将“键”转换为列表</span></span><br><span class="line"><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">9</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">78</span>&#125;) <span class="comment"># [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br><span class="line"><span class="comment"># 若想将“值”转换成列表，需要使用字典对象的items()方法明确说明，也可以用value()来明确说明</span></span><br><span class="line"><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">9</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">78</span>&#125;.items()) <span class="comment"># [(&#x27;a&#x27;:3),(&#x27;b&#x27;:9),(&#x27;c&#x27;:78)]</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 1. 插入元素</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 末尾追加元素</span></span><br><span class="line">my_list.append(<span class="number">60</span>) <span class="comment"># [10, 20, 30, 40, 50, 60]</span></span><br><span class="line"><span class="comment"># 列表.extend(其它数据容器)，将其它数据容器的内容取出，依次追加到列表尾部</span></span><br><span class="line"><span class="number">1</span>ist=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line"><span class="built_in">list</span>.extend([<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>) <span class="comment"># [1，2，3，4，5，6]</span></span><br><span class="line"><span class="comment"># 在索引2处插入元素</span></span><br><span class="line">my_list.insert(<span class="number">2</span>, <span class="number">15</span>) <span class="comment"># [10, 20, 15, 30, 40, 50, 60]</span></span><br><span class="line"><span class="comment"># 查找某元素下标</span></span><br><span class="line">my_list.index(<span class="number">50</span>) <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 2. 删除元素</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 根据值删除元素（删除第一个匹配项）</span></span><br><span class="line">my_list.remove(<span class="number">15</span>) <span class="comment"># [10, 20, 30, 40, 50, 60]</span></span><br><span class="line"><span class="comment"># 根据索引弹出元素（删除索引2的元素）</span></span><br><span class="line">     语法<span class="number">1</span>： <span class="keyword">del</span> 列表[下标]</span><br><span class="line">     语法<span class="number">2</span>：列表.pop(下标)</span><br><span class="line">popped = my_list.pop(<span class="number">2</span>) <span class="comment"># [10, 20, 40, 50, 60]</span></span><br><span class="line"><span class="comment"># 根据索引直接删除元素</span></span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>] <span class="comment"># [10, 40, 50, 60]</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 3. 清空列表</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line">my_list.clear() <span class="comment"># []</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 4. 修改元素</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 重新初始化列表</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 修改索引2的元素</span></span><br><span class="line">my_list[<span class="number">2</span>] = <span class="number">99</span> <span class="comment"># [1, 2, 99, 4, 5]</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 5. 统计元素</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"><span class="comment"># 统计元素出现次数</span></span><br><span class="line">count = my_list.count(<span class="number">2</span>) <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 统计列表长度</span></span><br><span class="line">length = <span class="built_in">len</span>(my_list) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>注：<ol><li>append(),insert(),extend()都属于<mark>原地操作</mark>，不影响列表对象在内存中的起始地址<br>对于长列表，insert()在头/中间插入效率低，若需要在首部按序插入多个元素，可以现在尾部追加，然后使用reverse()方法进行反转，或者使用collections的双端队列deque对象的appendleft()</li><li>pop()删除并返回指定位置（默认是最后一个）</li></ol></li><li>列表的遍历<ul><li>while循环：<br>定义一个变量表示下标，从0开始<br>循环条件为 下标值 &lt; 列表的元素数量  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(列表):</span><br><span class="line">元素 = 列表[index]</span><br><span class="line">对元素进行处理</span><br><span class="line">index += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li>取出列表内的偶数  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">new_list = []</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for i in range(len(list)):</span></span><br><span class="line"><span class="string">    if list[i] % 2 == 0:</span></span><br><span class="line"><span class="string">        new_list.append(list[i])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">list</span>[index] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        new_list.append(<span class="built_in">list</span>[index])</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br></pre></td></tr></table></figure></li></ul></li><li>列表的排序<ul><li>sort()默认升序</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line">random.shuffle(x) <span class="comment"># shuffle随即乱序，x=[6,0,1,7,4,3,2,8,5,10,9]</span></span><br><span class="line">x.short(key=<span class="keyword">lambda</span> item:<span class="built_in">len</span>(<span class="built_in">str</span>(item)),reverse=<span class="literal">True</span>) <span class="comment"># 转换成字符串以后按长度降序排列，长度一样的保持相对顺序 x=[10,6,0,1,7,4,3,2,8,5,9]</span></span><br></pre></td></tr></table></figure><ul><li>reverse()<br>sort()和reverse()<mark>原地排序</mark>，没有返回值<br>sorted()和reversed()返回排列后的新列表</li><li>3 in [1][2][3]</li><li>内置函数对列表的操作<ul><li>random.shuffle(lst) # 打乱列表中元素的顺序</li><li>all(x) # 测试是否所有元素都等价于True</li><li>any(x) # 测试是否存在元素等价于True</li><li>x = [1, 2, 3, 4, 5]  list(zip(x, [1] * 11)) # [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]</li><li>list(zip(range(1, 4))) # [(1,), (2,), (3,)]</li><li>names = [“Alice”, “Bob”, “Charlie”]   ages = [25, 30]<br>result = list(zip(names, ages)) # [(‘Alice’, 25), (‘Bob’, 30)]</li><li>list(zip(range(1,4)))</li><li>enumerate(iterable, start=0)<br>返回一个枚举对象，每个元素是一个元组 <code>(index, value)</code>，其中 <code>index</code> 是索引，<code>value</code> 是原可迭代对象的元素。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 不指定起始索引</span><br><span class="line">x = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line">result = <span class="built_in">list</span>(<span class="built_in">enumerate</span>(x)) <span class="comment"># [(0, &#x27;apple&#x27;), (1, &#x27;banana&#x27;), (2, &#x27;cherry&#x27;)]</span></span><br><span class="line"><span class="number">2.</span> 指定起始索引</span><br><span class="line">result = <span class="built_in">list</span>(<span class="built_in">enumerate</span>(x, start=<span class="number">1</span>)) <span class="comment"># [(1, &#x27;apple&#x27;), (2, &#x27;banana&#x27;), (3, &#x27;cherry&#x27;)]</span></span><br><span class="line"><span class="number">3.</span> 遍历枚举对象</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;index&#125;</span>, Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">Index: <span class="number">0</span>, Value: apple</span><br><span class="line">Index: <span class="number">1</span>, Value: banana</span><br><span class="line">Index: <span class="number">2</span>, Value: cherry</span><br><span class="line"><span class="number">4.</span> 结合列表推导式</span><br><span class="line">   result = [<span class="string">f&quot;<span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span> <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(x)] <span class="comment"># [&#x27;0: apple&#x27;, &#x27;1: banana&#x27;, &#x27;2: cherry&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li>列表→字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="string">&quot;分隔符&quot;</span>.join(列表)</span><br><span class="line">   lst = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Python&quot;</span>]</span><br><span class="line">   result = <span class="string">&quot; &quot;</span>.join(lst) <span class="comment"># &quot;Hello World Python&quot;</span></span><br><span class="line"><span class="number">2.</span> `<span class="built_in">str</span>()` 和 `<span class="built_in">map</span>()`</span><br><span class="line">   lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">   result = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, lst)) <span class="comment"># &quot;1234&quot;</span></span><br><span class="line"><span class="number">3.</span> 使用<span class="string">&quot;+&quot;</span>逐个拼接列表中的元素</span><br><span class="line">   lst = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">   result = <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">      result += item <span class="comment"># &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><ul><li>字符串→列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 字符串.split(分隔符)</span><br><span class="line">   s = <span class="string">&quot;Hello World Python&quot;</span></span><br><span class="line">   lst = s.split(<span class="string">&quot; &quot;</span>) <span class="comment"># [&#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;Python&#x27;]</span></span><br><span class="line"><span class="number">2.</span> <span class="comment">#使用 `list()`</span></span><br><span class="line">   s = <span class="string">&quot;Python&quot;</span></span><br><span class="line">   lst = <span class="built_in">list</span>(s) <span class="comment"># [&#x27;P&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;n&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li>列表推导式：<code>[表达式 for 变量 in 可迭代对象 if 条件]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">evens = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>] <span class="comment"># 过滤偶数</span></span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 生成平方数列表</span></span><br></pre></td></tr></table></figure><ul><li>切片：{start,stop,step}<br>start默认0，stop默认列表长度，step默认1<br>省略步长的同时还可以省略’:'，步长为负数时反向切片，这是start在stop右侧<br>切片返回部分元素的新列表，不会因下标越界抛出异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取整个列表</span></span><br><span class="line"><span class="built_in">print</span>(alist[::])  <span class="comment"># 输出 [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]，相当于就alist[0:len(alist)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序列表</span></span><br><span class="line"><span class="built_in">print</span>(alist[::-<span class="number">1</span>])  <span class="comment"># 输出 [17, 15, 13, 11, 9, 7, 6, 5, 4, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偶数位置元素（隔一个取一个）</span></span><br><span class="line"><span class="built_in">print</span>(alist[::<span class="number">2</span>])  <span class="comment"># 输出 [3, 5, 7, 11, 15]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 奇数位置元素（隔一个取一个）</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">1</span>::<span class="number">2</span>])  <span class="comment"># 输出 [4, 6, 9, 13, 17]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从下标 3 开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">3</span>::])  <span class="comment"># 输出 [6, 7, 9, 11, 13, 15, 17]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下标在 [3, 6] 之间的元素</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">3</span>:<span class="number">6</span>])  <span class="comment"># 输出 [6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后 3 个元素</span></span><br><span class="line"><span class="built_in">print</span>(alist[-<span class="number">3</span>:])  <span class="comment"># 输出 [13, 15, 17]，倒数第三个元素到末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒数第 6 个（不包含）之前的元素</span></span><br><span class="line"><span class="built_in">print</span>(alist[:-<span class="number">6</span>])  <span class="comment"># 输出 [3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前 100 个元素（自动截断）</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">0</span>:<span class="number">100</span>:<span class="number">1</span>])  <span class="comment"># 输出 [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下标 100 之后的元素（自动截断）</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">100</span>:])  <span class="comment"># 输出 []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用下标访问（越界报错）</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">100</span>])  <span class="comment"># 报错：IndexError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除前 3 个元素</span></span><br><span class="line">alist[:<span class="number">3</span>] = [] <span class="comment"># 输出 [12, 7, 9, 11, 13, 15, 17]</span></span><br><span class="line"><span class="keyword">del</span> alist[:<span class="number">3</span>] <span class="comment"># 输出 [11, 13, 15, 17]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尾部添加元素</span></span><br><span class="line">alist[<span class="built_in">len</span>(alist):] = [<span class="number">9</span>] <span class="comment"># 输出 [11, 13, 15, 17, 9]</span></span><br><span class="line"><span class="comment"># 在头部添加元素</span></span><br><span class="line">alist[:<span class="number">0</span>]=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 在中间插入元素</span></span><br><span class="line">alist[<span class="number">3</span>:<span class="number">3</span>]=[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="元组（Tuple）"><strong>元组（Tuple）()</strong></h3><p>元组使用小括号 <code>()</code> 定义，元素之间用逗号分隔，支持任意数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义元组字面量</span></span><br><span class="line">t1 = (<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>, <span class="literal">True</span>)</span><br><span class="line">t2 = (<span class="string">&quot;单元素元组必须有逗号&quot;</span>,)  <span class="comment"># 必须加逗号，否则类型为 str</span></span><br><span class="line">t3 = ()                     <span class="comment"># 空元组</span></span><br><span class="line">t4 = <span class="built_in">tuple</span>()                <span class="comment"># 空元组的另一种定义方式</span></span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：<ul><li><strong>不可变</strong>：创建后不能修改。</li><li><strong>有序</strong>：元素顺序固定。</li><li><strong>允许重复</strong>。</li><li><strong>支持嵌套</strong>：可包含其他元组或列表。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nested_tuple = ((<span class="number">1</span>, <span class="number">2</span>), [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], (<span class="literal">True</span>, <span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(nested_tuple[<span class="number">0</span>][<span class="number">1</span>])  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>特性</strong></td><td><strong>元组（Tuple）</strong></td><td><strong>列表（List）</strong></td></tr><tr><td>可变性</td><td>不可变</td><td>可变</td></tr><tr><td>定义符号</td><td><code>()</code></td><td><code>[]</code></td></tr><tr><td>性能</td><td>内存占用更小，访问更快</td><td>内存占用较大，动态操作灵活</td></tr><tr><td>适用场景</td><td>存储常量或配置项</td><td>存储需频繁修改的数据</td></tr></tbody></table><ul><li><strong>适用场景</strong>：存储常量数据（如配置项）、函数返回多个值。</li></ul><ol><li><strong>基础操作</strong><ul><li><strong>索引访问</strong>：通过下标获取元素。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>])  <span class="comment"># 输出: 20</span></span><br></pre></td></tr></table></figure></li><li><strong>切片操作</strong>：提取子元组。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出: (2, 3, 4)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>元组方法</strong></li></ol><table><thead><tr><th><strong>方法（语法）</strong></th><th><strong>作用</strong></th><th><strong>示例（结果）</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>tuple.index(x)</code></td><td>返回元素 <code>x</code> 的第一个匹配项的<strong>索引</strong></td><td><code>t = (10, 20, 30); t.index(20) → 1</code></td><td>若元素不存在则报错 <code>ValueError</code></td></tr><tr><td><code>tuple.count(x)</code></td><td>统计元素 <code>x</code> 在元组中的<strong>出现次数</strong></td><td><code>t = (1, 2, 2, 3); t.count(2) → 2</code></td><td>无元素时返回 <code>0</code></td></tr><tr><td><code>len(tuple)</code>（内置函数）</td><td>获取元组的<strong>长度</strong>（元素个数）</td><td><code>len((1, 2, 3)) → 3</code></td><td>非元组专属，适用于所有序列</td></tr></tbody></table><ol start="3"><li><strong>不可变性的特殊说明</strong><ul><li><strong>元组内列表可修改</strong>：元组本身不可变，但若元素是列表，列表内容可修改。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">t[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">99</span>  <span class="comment"># 合法操作，修改列表元素</span></span><br><span class="line"><span class="built_in">print</span>(t)       <span class="comment"># 输出: (1, 2, [99, 4])</span></span><br></pre></td></tr></table></figure></li><li><strong>不可直接替换元素</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">t[<span class="number">2</span>] = [<span class="number">5</span>, <span class="number">6</span>]  <span class="comment"># 报错: TypeError</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>元组的遍历</strong><br>所有可迭代对象（如列表、元组、字典、集合、字符串）均支持 <code>for</code> 循环，<code>while</code> 循环需手动控制索引。<br>4. <code>for</code> <strong>循环遍历</strong>（推荐）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_tuple:</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 依次输出: 10, 20, 30</span></span><br></pre></td></tr></table></figure><br>5. <code>while</code> <strong>循环遍历</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(my_tuple):</span><br><span class="line">    <span class="built_in">print</span>(my_tuple[index])  <span class="comment"># 依次输出: a, b, c</span></span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure><br><strong>元组的应用场景</strong><br>6. <strong>函数返回多个值</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_info</span>():</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>, <span class="string">&quot;alice@example.com&quot;</span>)</span><br><span class="line">name, age, email = get_user_info()  <span class="comment"># 元组解包</span></span><br></pre></td></tr></table></figure><br>7. <strong>常量配置</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_CONFIG = (<span class="string">&quot;localhost&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure><br>8. <strong>字典的键</strong>：元组可作为字典的键（因其不可变性），列表则不能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coordinates = &#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="string">&quot;A&quot;</span>, (<span class="number">3</span>, <span class="number">4</span>): <span class="string">&quot;B&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符串（str）"><strong>字符串（str）</strong></h3><p>字符串可以看做是字符的容器，支持下标索引等特性</p><ul><li><strong>只可以存储字符串</strong></li><li>长度任意(取决于内存大小)</li><li>支持下标索引<br>从前到后0，从后到前-1</li><li>允许重复字符串存在</li><li><strong>不可以修改</strong>(增加或删除元素等)<br>不可以：<ul><li>修改指定下标的字符 （如：字符串[0] = “a”）</li><li>移除特定下标的字符 （如：del 字符串[0]、字符串.remove()、字符串.pop()等）</li><li>追加字符等 （如：字符串.append()）</li></ul></li><li>支持for循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># s[0] = &quot;H&quot;  # 会抛出 TypeError: &#x27;str&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>使用单引号、双引号或三引号表示字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">string2 = <span class="string">&quot;World&quot;</span></span><br><span class="line">string3 = <span class="string">&#x27;&#x27;&#x27;This is a multiline string.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>基本和列表、元组相同<br>不同与列表和元组的在于：字符串容器可以容纳的类型是单一的，只能是字符串类型。<br>不同于列表，相同于元组的在于：字符串不可修改<br><strong>字符串的常用操作</strong></p><ol><li><strong>连接与重复</strong><ul><li><strong>连接</strong>：用 <code>+</code> 操作符连接两个或多个字符串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;World&#x27;</span></span><br><span class="line">result = str1 + <span class="string">&#x27; &#x27;</span> + str2  <span class="comment"># &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>重复</strong>：用 <code>*</code>操作符重复字符串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;Hello &#x27;</span></span><br><span class="line">result = str1 * <span class="number">3</span>  <span class="comment"># &quot;Hello Hello Hello &quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>切片</strong><ul><li><strong>基本语法</strong>：<code>str[start:end:step]</code>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">3</span>])  <span class="comment"># &quot;Pyt&quot;  -&gt; 从索引0到3（不包括3）</span></span><br><span class="line"><span class="built_in">print</span>(s[::<span class="number">2</span>])  <span class="comment"># &quot;Pto&quot; -&gt; 每隔一个字符取一个</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>])   <span class="comment"># &quot;n&quot; -&gt; 取最后一个字符</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>成员运算符</strong><ul><li><code>in</code>：检查子串是否在字符串中。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;World&quot;</span> <span class="keyword">in</span> s)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span> <span class="keyword">in</span> s)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>字符串的大小写</strong></li></ol><ul><li><code>upper()</code>：将所有字符转为大写。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.upper())  <span class="comment"># &quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure></li><li><code>lower()</code>：将所有字符转为小写。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;HELLO&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.lower())  <span class="comment"># &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><code>title()</code>：将字符串中每个单词的首字母转为大写。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.title())  <span class="comment"># &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>去除空格</strong><ul><li><code>strip()</code>：去除两侧的空格或指定字符。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;  hello world  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())  <span class="comment"># &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></li><li><code>lstrip()</code> 和 <code>rstrip()</code>：分别去除左侧和右侧的空格或指定字符。</li></ul></li><li><strong>字符串替换</strong><ul><li><code>replace(old, new)</code>：替换指定子字符串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">new_s = s.replace(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Python&quot;</span>)  <span class="comment"># &quot;hello Python&quot;</span></span><br></pre></td></tr></table></figure>注意：不是修改字符串本身，而是得到了一个新字符串</li></ul></li><li><strong>字符串分割</strong><ul><li><code>split()</code>：将字符串分割为<mark>列表</mark>，默认按空格分割。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())  <span class="comment"># [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><code>split(delimiter)</code>：按指定分隔符分割（去前后指定字符串）  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&#x27;,&#x27;</span>))  <span class="comment"># [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul>注意：<strong>字符串本身不变，而是得到了一个列表对象</strong><br><strong>字符串方法</strong></li></ol><ul><li><code>find(sub)</code>：返回子串第一次出现的索引，如果没有则返回 -1。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&quot;world&quot;</span>))  <span class="comment"># 6</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&quot;Python&quot;</span>))  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure></li><li><code>count(sub)</code>：返回子串出现的次数。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello hello hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;hello&quot;</span>))  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li><li><code>startswith(prefix)</code>：检查字符串是否以指定前缀开头。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.startswith(<span class="string">&quot;hello&quot;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><code>endswith(suffix)</code>：检查字符串是否以指定后缀结尾。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.endswith(<span class="string">&quot;world&quot;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字符串的编码与解码</strong></p><ul><li><code>encode()</code>：将字符串编码为字节串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">byte_s = s.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte_s)  <span class="comment"># b&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li><li><code>decode()</code>：将字节串解码为字符串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte_s = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line">s = byte_s.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字符串与其他数据类型转换</strong></p><ul><li><code>**str()**</code>：将其他类型转换为字符串。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">s = <span class="built_in">str</span>(x)  <span class="comment"># &#x27;10&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字符串遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;lr牛逼哈哈哈哈&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">index = 0</span></span><br><span class="line"><span class="string">while index &lt; len(str):</span></span><br><span class="line"><span class="string">    print(str[index], end=&#x27;&#x27;)</span></span><br><span class="line"><span class="string">    index += 1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="built_in">print</span>(s, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="数据容器的切片">数据容器的切片</h3><p>序列是指内容<strong>连续、有序</strong>、可以使用<strong>下标索引</strong>访问的容器。常见的序列类型包括：<strong>列表</strong>、<strong>元组</strong>、<strong>字符串</strong>，它们都可以视作序列。<br>对于一个序列，其元素可以通过<strong>下标</strong>来访问：</p><ul><li><strong>正索引</strong>：从左到右，索引从 <code>0</code> 开始，依次递增，直到 <code>n-1</code>。</li><li><strong>负索引</strong>：从右到左，索引从 <code>-1</code> 开始，依次递减，直到 <code>n</code>。<br>例如，给定一个字符串 <code>&quot;abcdef&quot;</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正向索引：a  b  c  d  e  f</span><br><span class="line">           0  1  2  3  4  5</span><br><span class="line">反向索引：a  b  c  d  e  f</span><br><span class="line">          -6 -5 -4 -3 -2 -1</span><br></pre></td></tr></table></figure><p><strong>序列的切片操作</strong><br>切片是指从一个序列中获取一个子序列的操作，序列支持切片，允许通过指定<strong>起始位置</strong>、<strong>结束位置</strong>和<strong>步长</strong>来截取部分元素。<br><strong>语法</strong>：<code>序列[起始下标:结束下标:步长]</code></p><ul><li><strong>起始下标</strong>：表示从何处开始截取，若省略，则默认为从序列的头部开始（索引 <code>0</code>）。</li><li><strong>结束下标</strong>：表示在哪个位置结束截取，但不包括结束位置本身，若省略，则默认为序列的结尾。</li><li><strong>步长</strong>：表示每次截取元素的间隔，默认为 <code>1</code>。可以为正数，也可以为负数（用于倒序截取）。</li></ul><ol><li><strong>基本示例</strong>：从序列中取出部分元素。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># &quot;bcd&quot;  从索引1开始，到索引4（不包括4）</span></span><br></pre></td></tr></table></figure></li><li><strong>省略起始和结束下标</strong>：<ul><li>省略<strong>起始</strong>下标：默认从序列的开始位置截取。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">3</span>])  <span class="comment"># &quot;abc&quot;  从索引0开始，到索引3（不包括3）</span></span><br></pre></td></tr></table></figure></li><li>省略<strong>结束</strong>下标：默认截取到序列的结尾。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>:])  <span class="comment"># &quot;cdef&quot;  从索引2开始，直到序列末尾</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>使用步长</strong>：<ul><li>步长 <code>1</code>：每次取一个元素（默认步长）。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">1</span>])  <span class="comment"># &quot;bcde&quot;</span></span><br></pre></td></tr></table></figure></li><li>步长 <code>2</code>：每次跳过一个元素，取间隔为2的元素。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[::<span class="number">2</span>])  <span class="comment"># &quot;ace&quot;  从头到尾每隔1个字符取一个</span></span><br></pre></td></tr></table></figure></li><li>步长为负数：表示倒序取元素，起始和结束下标也会反向。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])  <span class="comment"># &quot;fedcba&quot;  字符串反转</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>])  <span class="comment"># &quot;fedc&quot;  从索引5到索引2（不包括2），步长为负数</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>注：</p><ul><li>切片操作不会改变原序列，返回的是一个<mark>新的</mark>序列（列表、元组、字符串）。</li><li>切片时，<strong>结束下标不包含</strong>，即切片包含起始下标位置的元素，但不包含结束下标位置的元素。</li></ul><h3 id="集合（Set）">集合（Set）{}</h3><ul><li><strong>无序</strong>：集合的元素没有固定的顺序，不支持下标索引。</li><li><strong>去重</strong>：集合内的元素唯一，不能有重复。</li><li><strong>可修改</strong>：可以通过 <code>add()</code>、<code>remove()</code> 等方法修改集合的内容。</li><li><strong>支持不同数据类型</strong>：集合可以容纳不同类型的数据，支持混合类型元素。</li><li><strong>支持遍历</strong>：集合支持使用 <code>for</code> 循环进行遍历，但不支持 <code>while</code> 循环，因为集合不支持索引。</li><li><strong>定义集合字面量</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></li><li><strong>定义空集合</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_set = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>添加元素</strong>：<code>集合.add(元素)</code><ul><li>向集合中添加新元素。</li><li>注意：集合不允许重复元素，如果添加已存在的元素，不会报错，只是不进行任何操作。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">my_set.add(<span class="number">4</span>)  <span class="comment"># 添加4</span></span><br><span class="line"><span class="built_in">print</span>(my_set)  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>移除元素</strong>：<code>集合.remove(元素)</code><ul><li>从集合中移除指定的元素。</li><li>如果元素不存在，会抛出 <code>KeyError</code>。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">my_set.remove(<span class="number">2</span>)  <span class="comment"># 移除元素2</span></span><br><span class="line"><span class="built_in">print</span>(my_set)  <span class="comment"># &#123;1, 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>从集合中随机取出元素</strong>：<code>集合.pop()</code><ul><li>从集合中随机移除一个元素，并返回该元素。</li><li>注意：集合是无序的，<code>pop()</code>方法返回的元素不一定是你期望的。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">element = my_set.pop()</span><br><span class="line"><span class="built_in">print</span>(element)  <span class="comment"># 随机输出：1, 2 或 3</span></span><br><span class="line"><span class="built_in">print</span>(my_set)   <span class="comment"># 输出剩余元素</span></span><br></pre></td></tr></table></figure></li><li><strong>清空集合</strong>：<code>集合.clear()</code><ul><li>清空集合中的所有元素。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">my_set.clear()</span><br><span class="line"><span class="built_in">print</span>(my_set)  <span class="comment"># set()  空集合</span></span><br></pre></td></tr></table></figure></li><li><strong>差集</strong>：<code>集合1.difference(集合2)</code><ul><li>返回一个新的集合，包含集合1中有但集合2中没有的元素。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">result = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>差集更新</strong>：<code>集合1.difference_update(集合2)</code><ul><li>删除集合1中与集合2相同的元素。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">set1.difference_update(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)  <span class="comment"># &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>集合并集</strong>：<code>集合1.union(集合2)</code><ul><li>返回一个新的集合，包含集合1和集合2的所有元素（去重）。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">result = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>集合的常用操作</p><ul><li><strong>去重</strong>：集合的去重特性非常适合用于从其他数据容器（如列表、元组）中去重。</li><li><strong>无序性</strong>：如果你不关心元素的顺序，集合是一个很好的选择。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定列表</span></span><br><span class="line">my_list = [<span class="string">&#x27;黑马程序员&#x27;</span>, <span class="string">&#x27;传智播客&#x27;</span>, <span class="string">&#x27;黑马程序员&#x27;</span>, <span class="string">&#x27;传智播客&#x27;</span>, <span class="string">&#x27;itheima&#x27;</span>, <span class="string">&#x27;itcast&#x27;</span>, <span class="string">&#x27;itheima&#x27;</span>, <span class="string">&#x27;itcast&#x27;</span>, <span class="string">&#x27;best&#x27;</span>]</span><br><span class="line"><span class="comment"># 定义一个空集合</span></span><br><span class="line">my_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># 使用for循环遍历列表，将元素添加至集合</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    my_set.add(item)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有列表：&quot;</span>, my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;存入集合后结果：&quot;</span>, my_set)</span><br><span class="line">有列表： [<span class="string">&#x27;黑马程序员&#x27;</span>, <span class="string">&#x27;传智播客&#x27;</span>, <span class="string">&#x27;黑马程序员&#x27;</span>, <span class="string">&#x27;传智播客&#x27;</span>, <span class="string">&#x27;itheima&#x27;</span>, <span class="string">&#x27;itcast&#x27;</span>, <span class="string">&#x27;itheima&#x27;</span>, <span class="string">&#x27;itcast&#x27;</span>, <span class="string">&#x27;best&#x27;</span>]</span><br><span class="line">存入集合后结果： &#123;<span class="string">&#x27;itheima&#x27;</span>, <span class="string">&#x27;best&#x27;</span>, <span class="string">&#x27;itcast&#x27;</span>, <span class="string">&#x27;传智播客&#x27;</span>, <span class="string">&#x27;黑马程序员&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="字典（Dictionary）-key-value"><strong>字典（Dictionary）{key:value}</strong></h3><ul><li><strong>特点</strong>：<ul><li><strong>键值对（Key-Value）</strong>：通过键快速查找值。</li><li><strong>无序</strong>（Python 3.7+ 后按插入顺序保留）。</li><li><strong>键唯一</strong>，值可重复。</li><li><strong>可修改</strong>：可以增、删、改字典中的元素。</li><li><strong>支持</strong><code>for</code><strong>循环</strong>：可以使用<code>for</code>循环遍历字典的Key，也可以通过Key访问Value。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接创建</span></span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 使用 dict() 函数</span></span><br><span class="line">my_dict = <span class="built_in">dict</span>(name=<span class="string">&quot;Alice&quot;</span>, age=<span class="number">25</span>, city=<span class="string">&quot;New York&quot;</span>)</span><br><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><ul><li><strong>适用场景</strong>：需要高效查找的数据，如用户信息、配置参数。</li></ul><ol><li><strong>访问字典元素</strong><ul><li>通过键访问值。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(my_dict[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 输出: Alice</span></span><br></pre></td></tr></table></figure></li><li>使用 <code>get()</code> 方法避免键不存在时报错：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(my_dict.get(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;未知&quot;</span>))  <span class="comment"># 输出: 未知</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>新增元素</strong>：<ul><li>语法：<code>字典[Key] = Value</code></li><li>如果Key不存在，则新增键值对。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;王力鸿&quot;</span>: <span class="number">77</span>, <span class="string">&quot;周杰轮&quot;</span>: <span class="number">88</span>&#125;</span><br><span class="line">stu_score[<span class="string">&quot;张学油&quot;</span>] = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(stu_score)  <span class="comment"># 结果：&#123;&#x27;王力鸿&#x27;: 77, &#x27;周杰轮&#x27;: 88, &#x27;张学油&#x27;: 66&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>更新元素</strong>：<ul><li>语法：<code>字典[Key] = Value</code></li><li>如果Key已经存在，则更新对应的Value。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu_score[<span class="string">&quot;王力鸿&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(stu_score)  <span class="comment"># 结果：&#123;&#x27;王力鸿&#x27;: 100, &#x27;周杰轮&#x27;: 88, &#x27;张学油&#x27;: 66&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>删除元素</strong>：<ul><li>语法：<code>字典.pop(Key)</code></li><li>删除指定的Key及其对应的Value，返回删除的Value。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = stu_score.pop(<span class="string">&quot;王力鸿&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># 结果：100</span></span><br><span class="line"><span class="built_in">print</span>(stu_score)  <span class="comment"># 结果：&#123;&#x27;周杰轮&#x27;: 88, &#x27;张学油&#x27;: 66&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>删除键值对</strong><ul><li><code>**del**</code> <strong>语句</strong>：删除指定键值对。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> my_dict[<span class="string">&quot;city&quot;</span>]  <span class="comment"># 删除键 &quot;city&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>清空字典</strong>：<ul><li>语法：<code>字典.clear()</code></li><li>删除字典中的所有键值对。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu_score.clear()</span><br><span class="line"><span class="built_in">print</span>(stu_score)  <span class="comment"># 结果：&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>遍历字典：</strong><ul><li><strong>遍历键</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure></li><li><strong>遍历值</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_dict.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure></li><li><strong>遍历键值对</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>获取全部的Key</strong>：<ul><li>语法：<code>字典.keys()</code></li><li>获取字典中的所有Key。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = stu_score.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># 结果：dict_keys([&#x27;王力鸿&#x27;, &#x27;周杰轮&#x27;, &#x27;张学油&#x27;])</span></span><br></pre></td></tr></table></figure></li><li><strong>获取字典的长度</strong>：<ul><li>语法：<code>len(字典)</code></li><li>获取字典中键值对的数量。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(stu_score)  <span class="comment"># 结果：3</span></span><br></pre></td></tr></table></figure></li><li><strong>检查键是否存在</strong></li></ol><ul><li>使用 <code>in</code> 关键字。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if &quot;name&quot; in my_dict:</span><br><span class="line">    print(&quot;键 &#x27;name&#x27; 存在&quot;)</span><br></pre></td></tr></table></figure></li></ul><p>假设有如下员工信息，要求根据员工级别进行升职和加薪操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">employees = &#123;</span><br><span class="line">    <span class="string">&quot;王力鸿&quot;</span>: &#123;<span class="string">&quot;部门&quot;</span>: <span class="string">&quot;科技部&quot;</span>, <span class="string">&quot;工资&quot;</span>: <span class="number">3000</span>, <span class="string">&quot;级别&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&quot;周杰轮&quot;</span>: &#123;<span class="string">&quot;部门&quot;</span>: <span class="string">&quot;市场部&quot;</span>, <span class="string">&quot;工资&quot;</span>: <span class="number">5000</span>, <span class="string">&quot;级别&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;林俊节&quot;</span>: &#123;<span class="string">&quot;部门&quot;</span>: <span class="string">&quot;市场部&quot;</span>, <span class="string">&quot;工资&quot;</span>: <span class="number">7000</span>, <span class="string">&quot;级别&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&quot;张学油&quot;</span>: &#123;<span class="string">&quot;部门&quot;</span>: <span class="string">&quot;科技部&quot;</span>, <span class="string">&quot;工资&quot;</span>: <span class="number">4000</span>, <span class="string">&quot;级别&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&quot;刘德滑&quot;</span>: &#123;<span class="string">&quot;部门&quot;</span>: <span class="string">&quot;市场部&quot;</span>, <span class="string">&quot;工资&quot;</span>: <span class="number">6000</span>, <span class="string">&quot;级别&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 输出原始信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全体员工当前信息如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(employees)</span><br><span class="line"><span class="comment"># 对级别为1的员工升职加薪</span></span><br><span class="line"><span class="keyword">for</span> emp, info <span class="keyword">in</span> employees.items():</span><br><span class="line">    <span class="keyword">if</span> info[<span class="string">&quot;级别&quot;</span>] == <span class="number">1</span>:</span><br><span class="line">        info[<span class="string">&quot;级别&quot;</span>] += <span class="number">1</span></span><br><span class="line">        info[<span class="string">&quot;工资&quot;</span>] += <span class="number">1000</span></span><br><span class="line"><span class="comment"># 输出升职加薪后的信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全体员工级别为1的员工完成升职加薪操作，操作后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(employees)</span><br></pre></td></tr></table></figure><p>嵌套字典：</p><ol><li><strong>创建嵌套字典</strong><ul><li>直接定义嵌套字典：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nested_dict = &#123;</span><br><span class="line">    <span class="string">&quot;user1&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;user2&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>动态构建嵌套字典：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nested_dict = &#123;&#125;</span><br><span class="line">nested_dict[<span class="string">&quot;user1&quot;</span>] = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line">nested_dict[<span class="string">&quot;user2&quot;</span>] = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>访问嵌套字典的值</strong><ul><li>通过多层键访问嵌套值：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(nested_dict[<span class="string">&quot;user1&quot;</span>][<span class="string">&quot;name&quot;</span>])  <span class="comment"># 输出: Alice</span></span><br></pre></td></tr></table></figure></li><li>使用 <code>get()</code> 方法避免键不存在时报错：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(nested_dict.get(<span class="string">&quot;user3&quot;</span>, &#123;&#125;).get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;未知&quot;</span>))  <span class="comment"># 输出: 未知</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>修改嵌套字典</strong><ul><li>修改嵌套字典的值：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nested_dict[<span class="string">&quot;user1&quot;</span>][<span class="string">&quot;age&quot;</span>] = <span class="number">26</span></span><br><span class="line"><span class="built_in">print</span>(nested_dict[<span class="string">&quot;user1&quot;</span>])  <span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 26, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li>添加新的嵌套键值对：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nested_dict[<span class="string">&quot;user1&quot;</span>][<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;Female&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nested_dict[<span class="string">&quot;user1&quot;</span>])  <span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 26, &#x27;city&#x27;: &#x27;New York&#x27;, &#x27;gender&#x27;: &#x27;Female&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>删除嵌套字典的键值对</strong><ul><li>删除嵌套字典的键值对：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> nested_dict[<span class="string">&quot;user1&quot;</span>][<span class="string">&quot;city&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(nested_dict[<span class="string">&quot;user1&quot;</span>])  <span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 26, &#x27;gender&#x27;: &#x27;Female&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li>删除整个嵌套字典：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> nested_dict[<span class="string">&quot;user2&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(nested_dict)  <span class="comment"># 输出: &#123;&#x27;user1&#x27;: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 26, &#x27;gender&#x27;: &#x27;Female&#x27;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>遍历嵌套字典</strong><ul><li>遍历外层字典的键值对：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> user, info <span class="keyword">in</span> nested_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;用户: <span class="subst">&#123;user&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> info.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>输出：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户: user1</span><br><span class="line">  name: Alice</span><br><span class="line">  age: 26</span><br><span class="line">  gender: Female</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="数据容器总结">数据容器总结</h3><p><strong>数据容器分类</strong><br>数据容器的分类可以根据是否支持下标索引、是否支持重复元素以及是否可修改来区分：</p><ul><li><strong>支持下标索引</strong>：<ul><li>序列类型：列表、元组、字符串</li><li>非序列类型：集合、字典（不支持下标索引）</li></ul></li><li><strong>支持重复元素</strong>：<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li><strong>是否可修改</strong>：<ul><li>可修改：列表、集合、字典</li><li>不可修改：元组、字符串</li></ul></li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>特点</strong></td><td><strong>列表</strong></td><td><strong>元组</strong></td><td><strong>字符串</strong></td><td><strong>集合</strong></td><td><strong>字典</strong></td></tr><tr><td><strong>元素数量</strong></td><td>支持多个</td><td>支持多个</td><td>支持多个</td><td>支持多个</td><td>支持多个</td></tr><tr><td><strong>元素类型</strong></td><td>任意</td><td>任意</td><td>仅字符</td><td>任意</td><td>Key:Value（Key可为任意类型，Value为任意类型）</td></tr><tr><td><strong>下标索引</strong></td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td><strong>重复元素</strong></td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td><strong>可修改性</strong></td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td><strong>数据有序</strong></td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td><strong>各类数据容器应用场景</strong></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><strong>列表（List）</strong>：适合用于存储可修改、可重复的数据，常用于需要改变数据内容的场景。</li><li><strong>元组（Tuple）</strong>：适合存储不可修改、可重复的数据，常用于存储固定不变的数据。</li><li><strong>字符串（String）</strong>：用于存储字符序列的数据，支持不可变操作。</li><li><strong>集合（Set）</strong>：适合存储去重数据，集合中元素不可重复，且无序。</li><li><strong>字典（Dict）</strong>：适合存储键值对数据，通过Key快速查找Value的场景。<br><strong>数据容器的通用操作</strong></li></ul><ol><li>遍历操作：<ul><li><strong>支持</strong><code>for</code><strong>循环遍历</strong>：列表、元组、字符串、集合、字典都支持<code>for</code>循环。</li><li><strong>支持</strong><code>while</code><strong>循环</strong>：列表、元组、字符串支持；<mark>集合和字典</mark>不支持，因为它们没有下标索引。</li></ul></li><li>通用统计功能：<ol><li><code>len()</code>：统计容器的元素个数。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))  <span class="comment"># 结果：3</span></span><br></pre></td></tr></table></figure></li><li><code>max()</code>：获取容器中的最大元素（适用于可比较类型的容器）。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(my_list))  <span class="comment"># 结果：3</span></span><br></pre></td></tr></table></figure></li><li><code>min()</code>：获取容器中的最小元素（适用于可比较类型的容器）。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(my_list))  <span class="comment"># 结果：1</span></span><br></pre></td></tr></table></figure></li></ol></li><li>类型转换功能：<ul><li><code>list()</code>：将容器转换为列表。</li><li><code>tuple()</code>：将容器转换为元组。</li><li><code>str()</code>：将容器转换为字符串。</li><li><code>set()</code>：将容器转换为集合。</li></ul></li><li>排序功能：<ul><li><code>sorted()</code>：对容器进行排序，可以指定<code>reverse=True</code>进行<mark>降序</mark>排序。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(my_list))  <span class="comment"># 结果：[1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(my_list, reverse=<span class="literal">True</span>))  <span class="comment"># 结果：[3, 2, 1]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>功能</strong></td><td><strong>描述</strong></td></tr><tr><td>for循环</td><td>遍历容器（字典是遍历Key）</td></tr><tr><td>max()</td><td>获取容器内的最大元素</td></tr><tr><td>min()</td><td>获取容器内的最小元素</td></tr><tr><td>len()</td><td>获取容器内的元素个数</td></tr><tr><td>list()</td><td>转换为列表</td></tr><tr><td>tuple()</td><td>转换为元组</td></tr><tr><td>str()</td><td>转换为字符串</td></tr><tr><td>set()</td><td>转换为集合</td></tr><tr><td>sorted()</td><td>对容器进行排序，<code>reverse=True</code>为降序</td></tr><tr><td><strong>字符串大小比较</strong></td><td></td></tr></tbody></table><ul><li><strong>ASCII码表</strong>：在Python中，字符串的比较基于字符的ASCII值进行逐位比较。每个字符都有对应的数字值，根据字符的ASCII码大小进行比较，若某一位字符更大，则整个字符串更大。</li><li><strong>字符串比较</strong>：字符串按字符逐位比较，若前面字符相同，比较下一个字符，直到有较大的字符为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串比较示例</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span> &gt; <span class="string">&quot;abd&quot;</span>)  <span class="comment"># 结果：False，因为c &lt; d</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> &gt; <span class="string">&quot;b&quot;</span>)       <span class="comment"># 结果：False，因为a &lt; b</span></span><br></pre></td></tr></table></figure><p><strong>选择容器的基本原则</strong></p><ol><li><strong>是否需要修改数据</strong>：<ul><li>可变 → 列表、字典、集合。</li><li>不可变 → 元组。</li></ul></li><li><strong>是否需要快速查找</strong>：<ul><li>键值对 → 字典。</li><li>唯一性 → 集合。</li></ul></li><li><strong>是否需要保持顺序</strong>：<ul><li>列表、元组。</li></ul></li></ol><h2 id="Python函数进阶">Python函数进阶</h2><ol><li>函数的多返回值<ul><li><strong>思考：</strong> 如果一个函数有多个 <code>return</code>，程序如何执行？  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">return_num</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">result = return_num()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：1</span></span><br></pre></td></tr></table></figure>只执行了第一个 <code>return</code>，因为 <code>return</code> 会立即退出函数，导致后续的代码不再执行。</li><li><strong>多个返回值：</strong><br>如果一个函数要有多个返回值，可以用逗号分隔多个值：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">x, y = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 结果 1</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 结果 2</span></span><br></pre></td></tr></table></figure><ul><li>可以返回不同类型的数据：</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">True</span></span><br><span class="line">x, y, z = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出：hello</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># 输出：True</span></span><br></pre></td></tr></table></figure></li></ul></li><li>函数的多种传参方式<br>函数的常见参数类型有：位置参数、关键字参数、缺省参数、不定长参数。<ul><li><strong>位置参数</strong><br>根据函数定义的顺序传递参数：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的姓名是：<span class="subst">&#123;name&#125;</span>, 年龄是：<span class="subst">&#123;age&#125;</span>, 性别是：<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><strong>关键字参数</strong><br>通过“键=值”方式传递参数，不需要按照顺序：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的姓名是：<span class="subst">&#123;name&#125;</span>, 年龄是：<span class="subst">&#123;age&#125;</span>, 性别是：<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line">user_info(name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">20</span>, gender=<span class="string">&quot;男&quot;</span>)</span><br><span class="line">user_info(age=<span class="number">10</span>, gender=<span class="string">&#x27;女&#x27;</span>, name=<span class="string">&#x27;潇潇&#x27;</span>)  <span class="comment"># 顺序可以不一致</span></span><br></pre></td></tr></table></figure><ul><li>位置参数要放在关键字参数之前：</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_info(<span class="string">&#x27;甜甜&#x27;</span>, gender=<span class="string">&#x27;女&#x27;</span>, age=<span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><strong>缺省参数</strong><br>为函数参数提供默认值，调用时可以不传递：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender=<span class="string">&#x27;男&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的姓名是：<span class="subst">&#123;name&#125;</span>, 年龄是：<span class="subst">&#123;age&#125;</span>, 性别是：<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;小天&#x27;</span>, <span class="number">13</span>)  <span class="comment"># 使用默认值 &#x27;男&#x27;</span></span><br><span class="line">user_info(<span class="string">&#x27;小美&#x27;</span>, <span class="number">13</span>, <span class="string">&#x27;女&#x27;</span>)  <span class="comment"># 修改默认值为 &#x27;女&#x27;</span></span><br></pre></td></tr></table></figure></li><li><strong>不定长参数（可变参数）</strong><br>用于传递不定数量的参数：<ol><li><strong>位置不定长参数 (</strong><code>**args**</code><strong>)</strong><br>用 <code>*args</code> 接收多个位置参数，参数会以<mark>元组</mark>（tuple）形式传入： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>)  <span class="comment"># (&#x27;TOM&#x27;,)</span></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">18</span>)  <span class="comment"># (&#x27;TOM&#x27;, 18)</span></span><br></pre></td></tr></table></figure></li><li><strong>关键字不定长参数 (</strong><code>***kwargs**</code><strong>)</strong><br>用 <code>**kwargs</code> 接收多个关键字参数，参数会以<mark>字典</mark>形式传入： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">user_info(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><strong>Lambda匿名函数：</strong><br>匿名函数可以通过 <code>lambda</code> 关键字创建，无需命名，通常用于简单的函数。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数: 表达式</span><br></pre></td></tr></table></figure>示例：计算两个数之和 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure><ul><li><strong>应用：</strong><br>通过匿名函数将函数作为参数传递给另一个函数：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">test_func(<span class="keyword">lambda</span> x, y: x + y)  <span class="comment"># 结果：3</span></span><br></pre></td></tr></table></figure></li></ul></li><li>函数作为参数传递<br>函数不仅可以接收数据作为参数，也可以接收其他函数作为参数。比如，下面的例子中，<code>test_func</code> 接收一个计算函数 <code>compute</code>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"><span class="comment"># 传递不同的函数</span></span><br><span class="line">test_func(add)       <span class="comment"># 输出: 计算结果：15</span></span><br><span class="line">test_func(subtract)  <span class="comment"># 输出: 计算结果：5</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用：</strong><br>传递的是计算的<mark>逻辑</mark>，而不是数据。可以用不同的函数来替代 <code>compute</code>，从而灵活改变计算逻辑。</li></ul></li></ol><h2 id="Python文件操作">Python文件操作</h2><ol><li>文件编码<ul><li><strong>编码的定义：</strong><br>编码是将文本内容转换为计算机可以理解的二进制格式的规则集。常见的编码方式有UTF-8、GBK、Big5等。每种编码使用不同的方式将字符映射到二进制。</li><li><strong>为什么需要编码？</strong><br>计算机只理解0和1（即二进制），为了存储文本数据，我们需要将字符映射为二进制存储在硬盘上，同时，当读取文件时，我们需要将二进制数据转换回可以理解的文本。</li><li><strong>查看文件编码：</strong><br>使用Windows记事本可以查看文件的编码格式。通常，UTF-8是全球通用的编码格式，除非有特殊需求，推荐使用UTF-8编码。</li></ul></li><li>文件读取操作<ul><li><strong>文件的定义：</strong><br>文件是计算机中用于存储数据的一种管理单位。文件存储在硬盘、U盘等存储设备上，常见的文件类型包括文本文件、音频文件、视频文件等。</li><li><strong>文件操作的步骤：</strong><ol><li>打开文件</li><li>读写文件</li><li>关闭文件</li></ol></li><li><strong>Python中的文件打开：</strong><br>使用<br><code>open()</code> 函数来打开文件，常见的参数有：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(name, mode, encoding)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure>注：要正确指定文件编码，必须使用关键字参数 <code>encoding</code><ul><li><code>name</code>: 文件名或路径</li><li><code>mode</code>: 文件访问模式（如 <code>r</code> 只读、<code>w</code> 写入、<code>a</code> 追加）</li><li><code>encoding</code>: 编码格式（通常使用UTF-8）</li></ul></li><li><strong>常见的访问模式：</strong><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>模式</td><td>描述</td></tr><tr><td><code>r</code></td><td>只读模式，文件指针放在文件开头</td></tr><tr><td><code>w</code></td><td>写入模式，文件不存在时创建文件，存在时<mark>清空</mark>文件</td></tr><tr><td><code>a</code></td><td>追加模式，文件不存在时创建文件，存在时追加内容</td></tr></tbody></table></li><li><strong>读取文件的几种方法：</strong><ul><li><code>read(num)</code>：按字节读取文件内容，返回==<strong>字符串</strong>==，不写nunm就表示读取所有  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br></pre></td></tr></table></figure></li><li><code>readline()</code>：<mark>逐行</mark>读取文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line = f.readline()</span><br></pre></td></tr></table></figure></li><li><code>readlines()</code>：<mark>按行</mark>读取文件，返回==<strong>列表list</strong>==：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">[<span class="string">&#x27;hello world\n&#x27;</span>, <span class="string">&#x27;abcdefg\n&#x27;</span>, <span class="string">&#x27;aaa\n&#x27;</span>, <span class="string">&#x27;bbb\n&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>逐行遍历文件：</strong><br>使用<br><code>for</code> 循环逐行读取文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line.strip())</span><br></pre></td></tr></table></figure></li><li><strong>自动关闭文件：</strong><br>使用<br><code>with open()</code> 语法可以自动关闭文件，无需手动调用 <code>close()</code>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br></pre></td></tr></table></figure></li><li><strong>文件关闭：</strong><br>使用<br><code>close()</code> 方法关闭文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 读写操作...</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>如果不调用close,同时程序没有停止运行，那么这个文件将一直被Python程序占用。<br>注：文件读取时会续接上一次</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;E:\\Python_code\\课件\\text.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">法一：读取全部内容，通过字符串count方法统计指定单词数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span>(f.read().count(<span class="string">&quot;itheima&quot;</span>))</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">法二：逐行读取，分割单词</span></span><br><span class="line">count = 0</span><br><span class="line">for line in f:</span><br><span class="line">    line = line.strip(&quot;\n&quot;)</span><br><span class="line">    words = line.split(&quot; &quot;)</span><br><span class="line">    for word in words:</span><br><span class="line">        if word == &quot;itheima&quot;:</span><br><span class="line">            count += 1</span><br><span class="line">print(count)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></li><li>文件写入操作<ul><li><strong>写入文件：</strong><br>使用<br><code>open()</code> 函数以 <code>w</code> 模式打开文件进行写入。注意，如果文件存在，原有内容会被覆盖：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><strong>刷新缓冲区：</strong><br>写入内容时，数据会先存入缓冲区，使用<br><code>flush()</code> 方法可以将缓冲区的内容写入文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    f.flush()  <span class="comment"># 将内容写入文件</span></span><br></pre></td></tr></table></figure>直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区<br>当调用flush的时候，内容会真正写入文件<br>这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）</li><li><strong>追加写入：</strong><br>使用<br><code>a</code> 模式可以将数据追加到文件末尾：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>a模式，文件不存在，会创建新文件</li><li>a模式，文件存在，会在原有内容后面继续写入</li><li>可以使用”\n”来写出换行符</li></ul></li></ul></li><li>文件的实际案例<ul><li><strong>文件备份并丢弃特定数据行：</strong><br>假设我们有一个账单文件<br><code>bill.txt</code>，需要读取文件并将标记为 “测试” 的数据行丢弃，最后将内容保存到一个新文件 <code>bill.txt.bak</code>。  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name,date,money,type,remarks</span><br><span class="line">周杰轮,2022-01-01,100000,消费,正式</span><br><span class="line">周杰轮,2022-01-02,300000,收入,正式</span><br><span class="line">周杰轮,2022-01-03,100000,消费,测试</span><br><span class="line">林俊节,2022-01-01,300000,收入,正式</span><br><span class="line">林俊节,2022-01-02,100000,消费,测试</span><br><span class="line">林俊节,2022-01-03,100000,消费,正式</span><br><span class="line">林俊节,2022-01-04,100000,消费,测试</span><br><span class="line">林俊节,2022-01-05,500000,收入,正式</span><br><span class="line">张学油,2022-01-01,100000,消费,正式</span><br><span class="line">张学油,2022-01-02,500000,收入,正式</span><br></pre></td></tr></table></figure><strong>实现步骤：</strong><ol><li>打开原文件和备份文件</li><li>读取每一行，如果是测试数据行，跳过</li><li>否则写入到备份文件</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;bill.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f_in, <span class="built_in">open</span>(<span class="string">&#x27;bill.txt.bak&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f_in:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;测试&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        f_out.write(line)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Python-异常">Python 异常</h2><ul><li><strong>异常演示：</strong><br>当尝试以只读模式 (<code>r</code>) 打开一个不存在的文件时，程序会抛出异常：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/python-learn/test.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;D:/abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;D:/abc.txt&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p>异常的捕获与处理</p><ul><li><strong>基本语法：</strong>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能发生错误的代码</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 如果发生异常，执行的代码</span></span><br></pre></td></tr></table></figure></li><li><strong>捕获指定异常：</strong><br>你可以捕获特定类型的异常，并且给出相应的错误提示：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></li><li><strong>捕获多个异常：</strong><br>如果需要捕获多种异常，可以使用元组形式将异常类型列出：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 1 / 0</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义 或者 除以0的异常&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><code>**else**</code> <strong>语句：</strong><br><code>else</code> 语句会在没有异常发生时执行：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现异常了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好高兴，没有出现异常。&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><code>**finally**</code> <strong>语句：</strong><br>无论是否发生异常，<code>finally</code> 中的代码都会执行，通常用于资源清理，如关闭文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;D:/123.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现异常了&quot;</span>)</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;D:/123.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好高兴，没有出现异常。&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是finally，有没有异常我都要执行&quot;</span>)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></li><li><strong>捕获所有异常：</strong><br>可以使用以下两种方式捕获所有异常：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br></pre></td></tr></table></figure></li><li><strong>异常的传递性：</strong><br>异常是具有传递性的。如果一个函数没有捕获到异常，异常会传递到调用该函数的地方，直到异常被捕获或程序崩溃为止。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1 开始执行&quot;</span>)</span><br><span class="line">    num = <span class="number">1</span> / <span class="number">0</span>  <span class="comment"># 除零异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1 结束执行&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2 开始执行&quot;</span>)</span><br><span class="line">    func1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2 结束执行&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        func2()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;出现异常了，异常的信息是：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">main()</span><br><span class="line">func2 开始执行</span><br><span class="line">func1 开始执行</span><br><span class="line">出现异常了，异常的信息是：division by zero</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块与包">模块与包</h2><ul><li><strong>模块（Module）：</strong><br>模块是一个 Python 文件，通常以 <code>.py</code> 结尾，包含类、函数、变量等内容。模块是为了复用代码而设计的，可以将不同的功能组织到不同的模块中，通过导入模块来使用其中的内容。<br><strong>模块的作用：</strong><br>模块可以帮助我们实现特定的功能，例如：时间相关功能可以使用 <code>time</code> 模块。我们可以将模块看作是一个工具包，提供不同的工具供我们使用。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名</span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类、函数、变量</span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *  <span class="comment"># 导入模块中所有功能</span></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 别名  <span class="comment"># 为模块起别名</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能 <span class="keyword">as</span> 别名  <span class="comment"># 为功能起别名</span></span><br></pre></td></tr></table></figure><strong>导入模块：</strong>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">16</span>))  <span class="comment"># 输出: 4.0</span></span><br></pre></td></tr></table></figure><strong>从模块中导入特定内容：</strong>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="built_in">print</span>(sqrt(<span class="number">16</span>))  <span class="comment"># 输出: 4.0</span></span><br></pre></td></tr></table></figure><strong>模块的别名：</strong>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line"><span class="built_in">print</span>(m.sqrt(<span class="number">16</span>))  <span class="comment"># 输出: 4.0</span></span><br></pre></td></tr></table></figure></li><li><strong>制作自定义模块：</strong><br>可以通过创建<br><code>.py</code> 文件来制作自己的模块，例如：<br><code>module1.py</code> 文件：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>然后你可以通过 <code>import</code> 导入并使用它：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1</span><br><span class="line">module1.test(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure></li><li><strong>模块的命名：</strong><br>每个 Python 文件都可以作为模块，模块的名字就是文件的名字。模块名必须符合标识符命名规则。</li><li><strong>多个模块同名问题：</strong><br>如果导入了多个模块，并且它们有同名函数，后导入的模块会覆盖前导入模块的同名函数。</li><li><strong>测试模块：</strong><br>用于区分模块是被直接运行还是被导入到其他文件中。<ul><li><strong>作用</strong>：<br><strong>name</strong> 是当前模块名，当模块被直接<mark>运行</mark>时模块名为 <strong>main</strong> 。这句话的意思就是，当模块被直接运行时，if 以下代码块将被运行，当模块是<mark>被导入</mark>时，代码块不被运行。</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test (<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>这样，只有直接执行该文件时，<code>test</code> 函数才会被调用；如果该文件作为模块导入到其他文件中，<code>test</code> 函数的调用不会执行。</li><li><code>**__all__**</code> <strong>变量：</strong><br>在模块中定义<br><code>__all__</code> 变量可以控制使用 <code>from 模块名 import *</code> 时能导入哪些内容。<ul><li><strong>作用</strong>：<ul><li>如果定义了 <code>__all__</code>，则 <code>from 模块名 import *</code> 只会导入 <code>__all__</code> 中列出的内容。</li><li>如果未定义 <code>__all__</code>，则 <code>from 模块名 import *</code> 会导入模块中所有不以 <code>_</code> 开头的名称。<br>注：对<code>improt xxx</code>无效</li></ul></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;test_a&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_a</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_b</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a - b)</span><br></pre></td></tr></table></figure></li><li><strong>包（Package）：</strong><br>包是包含多个模块的目录，目录下必须有一个 <code>__init__.py</code> 文件，表示该目录是一个包，而不是普通的文件夹。包的作用是帮助我们管理多个模块，使得模块结构更加清晰。包本质还是模块</li><li><strong>创建自定义包：</strong><br>创建一个名为<br><code>my_package</code> 的包，里面包含两个模块 <code>module1.py</code> 和 <code>my_module2.py</code>。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mypackage/</span><br><span class="line">    __init__.py</span><br><span class="line">    module1.py</span><br><span class="line">    module2.py</span><br></pre></td></tr></table></figure><code>my_package/module1.py</code>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info_print1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是模块1的功能函数代码&quot;</span>)</span><br></pre></td></tr></table></figure><code>my_package/my_module2.py</code>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info_print2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是模块2的功能函数代码&quot;</span>)</span><br></pre></td></tr></table></figure>包内的 <code>__init__.py</code> 文件可以用于控制包的导入行为。</li><li><strong>导入包：</strong><ol><li><strong>方式一：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package.module1</span><br><span class="line">my_package.module1.info_print1()</span><br><span class="line"><span class="keyword">import</span> my_package.my_module2</span><br><span class="line">my_package.my_module2.info_print2()</span><br></pre></td></tr></table></figure></li><li><strong>方式二：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module1</span><br><span class="line">module1.info_print1()</span><br><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> my_module2</span><br><span class="line">my_module2.info_print2()</span><br></pre></td></tr></table></figure></li><li><strong>方式三：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> info_print1</span><br><span class="line">info_print1()</span><br><span class="line"><span class="keyword">from</span> my_package.my_module2 <span class="keyword">import</span> info_print2</span><br><span class="line">info_print2()</span><br></pre></td></tr></table></figure></li></ol></li><li><code>**__init__.py**</code> <strong>文件的作用：</strong><code>__init__.py</code> 文件的主要作用是标识该目录是一个 Python 包，并且可以在该文件中定义 <code>__all__</code> 变量来控制哪些模块或功能可以被导入。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;my_module2&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><p><strong>安装第三方包</strong></p><ul><li><strong>什么是第三方包：</strong><br>第三方包是指 Python 官方以外的包，通常由社区或其他开发者提供，能够极大地扩展 Python 的功能。例如，数据分析常用的 <code>pandas</code>，科学计算常用的 <code>numpy</code>，机器学习常用的 <code>tensorflow</code> 等。</li><li><strong>安装第三方包：</strong><br>使用 <code>pip</code> 工具来安装第三方包。在命令行中执行：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名</span><br></pre></td></tr></table></figure><strong>国内镜像：</strong><br>可以使用清华大学等提供的镜像来加速包的下载：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名</span><br></pre></td></tr></table></figure><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%203%203.png" alt="image 3 3|image 3 3.png"><br><strong>总结</strong></li></ul><ol><li><strong>模块：</strong><ul><li>模块是包含函数、类、变量的 Python 文件。</li><li>可以通过 <code>import</code> 或 <code>from ... import ...</code> 导入模块来使用其中的功能。</li></ul></li><li><strong>包：</strong><ul><li>包是包含多个模块的文件夹，目录下需要有 <code>__init__.py</code> 文件，表示该目录是一个包。</li><li>可以通过包来管理和组织多个模块。</li></ul></li><li><strong>自定义模块与包：</strong><ul><li>自定义模块通过创建 <code>.py</code> 文件，包通过包含多个模块的文件夹来创建。</li><li><code>__main__</code> 用于控制模块是否在当前文件中执行测试代码。</li><li><code>__all__</code> 控制 <code>from ... import *</code> 导入时，哪些功能可以被导入。</li></ul></li><li><strong>安装第三方包：</strong><ul><li>使用 <code>pip</code> 安装第三方包，国内可以使用镜像加速下载。<br>示例：<br>创建一个自定义包，名称为：my_utils  (我的工具）<br>在包内提供2个模块</li></ul></li></ol><ul><li>str_util.py （字符串相关工具，内含：）</li><li><strong>函数：str_reverse(s)，接受传入字符串，将字符串反转返回</strong></li><li><strong>函数：substr(s, x, y)，按照下标x和y，对字符串进行切片</strong></li><li>file_util.py（文件处理相关工具，内含：）</li><li><strong>函数：print_file_info(file_name)，接收传入文件的路径，打印文件的全部内容，如文件不存在则捕获异常，输出提示信息，通过finally关闭文件对象</strong></li><li><strong>函数：append_to_file(file_name, data)，接收文件路径以及传入数据，将数据追加写入到文件中</strong><br><strong>str_util.py</strong>*（字符串工具模块）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串反转函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_reverse</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接受传入字符串，将字符串反转返回</span></span><br><span class="line"><span class="string">    :param s: 输入的字符串</span></span><br><span class="line"><span class="string">    :return: 反转后的字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 字符串切片函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">substr</span>(<span class="params">s, x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    按照下标x和y，对字符串进行切片</span></span><br><span class="line"><span class="string">    :param s: 输入的字符串</span></span><br><span class="line"><span class="string">    :param x: 起始下标</span></span><br><span class="line"><span class="string">    :param y: 结束下标</span></span><br><span class="line"><span class="string">    :return: 切片后的字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s[x:y]</span><br></pre></td></tr></table></figure><p><strong>file_util.py</strong>（文件处理工具模块）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印文件内容函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_file_info</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收传入文件的路径，打印文件的全部内容</span></span><br><span class="line"><span class="string">    如文件不存在则捕获异常，输出提示信息，通过finally关闭文件对象</span></span><br><span class="line"><span class="string">    :param file_name: 文件路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(file_name, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        content = f.read()</span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;文件 <span class="subst">&#123;file_name&#125;</span> 不存在&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;f&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():  <span class="comment"># 检查文件对象是否存在</span></span><br><span class="line">            f.close()</span><br><span class="line"><span class="comment"># 追加写入文件函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">append_to_file</span>(<span class="params">file_name, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收文件路径以及传入数据，将数据追加写入到文件中</span></span><br><span class="line"><span class="string">    :param file_name: 文件路径</span></span><br><span class="line"><span class="string">    :param data: 要追加的数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;数据已追加到文件 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>if ‘f’ in locals()</strong>：</p><ol><li>调用 <code>locals()</code> 函数，获取当前局部命名空间的字典。</li><li>检查该字典的键中是否包含字符串 <code>'f'</code>，也就是检查当前局部命名空间中是否定义了名为 <code>f</code> 的变量。</li><li>如果存在名为 <code>f</code> 的变量，表达式返回 <code>True</code>，<code>if</code> 语句块中的代码会被执行；如果不存在，表达式返回 <code>False</code>，<code>if</code> 语句块中的代码会被跳过。<br><code>**__init__.py**</code> <strong>文件</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 __all__ 变量，控制 from my_utils import * 的行为</span></span><br><span class="line">__all__ = [<span class="string">&#x27;str_util&#x27;</span>, <span class="string">&#x27;file_util&#x27;</span>]</span><br><span class="line"><span class="comment"># 导入子模块</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> str_util</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> file_util</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_utils <span class="keyword">import</span> str_util, file_util</span><br><span class="line"><span class="comment"># 测试字符串工具模块</span></span><br><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;反转字符串:&quot;</span>, str_util.str_reverse(s))  <span class="comment"># 输出: !dlroW ,olleH</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串切片:&quot;</span>, str_util.substr(s, <span class="number">0</span>, <span class="number">5</span>))  <span class="comment"># 输出: Hello</span></span><br><span class="line"><span class="comment"># 测试文件工具模块</span></span><br><span class="line">file_name = <span class="string">&quot;test.txt&quot;</span></span><br><span class="line"><span class="comment"># 打印文件内容</span></span><br><span class="line">file_util.print_file_info(file_name)  <span class="comment"># 如果文件不存在，输出提示信息</span></span><br><span class="line"><span class="comment"># 追加数据到文件</span></span><br><span class="line">file_util.append_to_file(file_name, <span class="string">&quot;\n这是追加的内容&quot;</span>)</span><br><span class="line"><span class="comment"># 再次打印文件内容</span></span><br><span class="line">file_util.print_file_info(file_name)</span><br></pre></td></tr></table></figure><ul><li><strong>date_formatter.py</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_date</span>(<span class="params">date, format_str=<span class="string">&quot;%Y-%m-%d&quot;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> date.strftime(format_str)</span><br></pre></td></tr></table></figure></li><li><strong>date_calculator.py</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_days</span>(<span class="params">date, days</span>):</span><br><span class="line">    <span class="keyword">return</span> date + timedelta(days=days)</span><br></pre></td></tr></table></figure></li><li><strong>使用示例</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> date_utils <span class="keyword">import</span> date_formatter, date_calculator</span><br><span class="line">today = datetime.now()</span><br><span class="line"><span class="built_in">print</span>(date_formatter.format_date(today))  <span class="comment"># 输出: 2023-10-05</span></span><br><span class="line"><span class="built_in">print</span>(date_calculator.add_days(today, <span class="number">7</span>))  <span class="comment"># 输出: 2023-10-12</span></span><br></pre></td></tr></table></figure></li></ul><h1>数据可视化</h1><p>数据可视化是将数据转化为直观图形的过程，帮助快速理解数据趋势、分布和关联。<br><strong>核心工具</strong>：<code>PyEcharts</code>（基于百度Echarts的Python库），支持动态交互式图表，适用于Web和本地展示。<br><strong>适用场景</strong>：疫情趋势分析、地理分布统计、经济数据对比等。<br><strong>JSON</strong></p><ul><li><strong>特点</strong>：<ul><li>跨语言通用（Python、Java、C等均可解析）。</li><li>支持嵌套结构（字典、列表组合）。</li></ul></li><li><strong>常见结构</strong>：  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单对象</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// 多对象列表</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li></ul><p>Python语言使用JSON有很大优势，因为：JSON无非就是一个单独的字典或一个内部元素都是字典的列表<br>所以JSON可以直接和Python的<mark>字典或列表</mark>进行无缝转换。<br><strong>Python与JSON互转</strong></p><ul><li><strong>核心函数</strong>：<ul><li><code>json.dumps()</code>：Python对象 → JSON字符串。<br>如果有中文可以带上：ensure_ascii=False参数来确保中文正常转换</li><li><code>json.loads()</code>：JSON字符串 → Python对象（字典/列表）。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># Python列表转JSON</span></span><br><span class="line">data = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;]</span><br><span class="line">json_str = json.dumps(data, ensure_ascii=<span class="literal">False</span>)  <span class="comment"># 禁用ASCII转码，支持中文</span></span><br><span class="line"><span class="built_in">print</span>(json_str)  <span class="comment"># 输出: [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 25&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 30&#125;]</span></span><br><span class="line"><span class="comment"># JSON转Python字典</span></span><br><span class="line">json_data = <span class="string">&#x27;&#123;&quot;city&quot;: &quot;北京&quot;, &quot;population&quot;: 2154&#125;&#x27;</span></span><br><span class="line">py_dict = json.loads(json_data)</span><br><span class="line"><span class="built_in">print</span>(py_dict[<span class="string">&quot;city&quot;</span>])  <span class="comment"># 输出: 北京</span></span><br></pre></td></tr></table></figure><h2 id="折线图可视化">折线图可视化</h2><p>安装PyEcharts模块<code>pip install pyecharts</code><br>官方画廊<br><a href="https://gallery.pyecharts.org/#/README">https://gallery.pyecharts.org/#/README</a></p><ol><li><strong>基础折线图示例</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line">line = Line()</span><br><span class="line">line.add_xaxis([<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;英国&quot;</span>])</span><br><span class="line">line.add_yaxis(<span class="string">&quot;GDP&quot;</span>, [<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>])</span><br><span class="line">line.render()  <span class="comment"># 生成并展示图表</span></span><br></pre></td></tr></table></figure>网页打开文件render.html<br>Pyecharts提供了多种配置选项，, 常用到2个类别的选项:<br><strong>全局配置（</strong><code>**set_global_opts**</code><strong>）</strong><br>控制图表的整体外观和交互功能，通过 <code>set_global_opts()</code> 方法设置。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%204%203.png" alt="image 4 3|image 4 3.png"><br>|   |   |   |<br>|—|—|—|<br>|配置项|作用|示例代码|<br>|<code>**TitleOpts**</code>|设置标题和副标题|<code>title_opts=opts.TitleOpts(title=&quot;疫情趋势&quot;, subtitle=&quot;2020年数据&quot;)</code>|<br>|<code>**LegendOpts**</code>|控制图例显示位置和样式|<code>legend_opts=opts.LegendOpts(pos_left=&quot;right&quot;, item_width=20)</code>|<br>|<code>**TooltipOpts**</code>|自定义悬停提示框内容/触发方式|<code>tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;, axis_pointer_type=&quot;cross&quot;)</code>|<br>|<code>**VisualMapOpts**</code>|视觉映射（颜色渐变、范围筛选）|<code>visualmap_opts=opts.VisualMapOpts(min=0, max=100, is_show=True)</code>|<br>|<code>**ToolboxOpts**</code>|显示工具箱（保存图片、数据视图）|<code>toolbox_opts=opts.ToolboxOpts(is_show=True, feature=&#123;&quot;saveAsImage&quot;: &#123;&#125;&#125;)</code>|</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line">line = Line()</span><br><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=opts.TitleOpts(title=<span class="string">&quot;疫情趋势&quot;</span>, subtitle=<span class="string">&quot;2020年数据&quot;</span>, pos_left=<span class="string">&quot;center&quot;</span>),</span><br><span class="line">    legend_opts=opts.LegendOpts(pos_right=<span class="string">&quot;20%&quot;</span>),</span><br><span class="line">    toolbox_opts=opts.ToolboxOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    tooltip_opts=opts.TooltipOpts(trigger=<span class="string">&quot;axis&quot;</span>),</span><br><span class="line">    visualmap_opts=opts.VisualMapOpts(<span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">1000</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>系列配置（</strong><code>**add_yaxis**</code><strong>）</strong><br>针对具体数据系列的样式设置，通过 <code>add_yaxis()</code> 方法配置。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置项</td><td>作用</td><td>示例代码</td></tr><tr><td><code>**series_name**</code></td><td>设置图例名称</td><td><code>series_name=&quot;美国确诊人数&quot;</code></td></tr><tr><td><code>**label_opts**</code></td><td>显示/隐藏数值标签</td><td><code>label_opts=opts.LabelOpts(is_show=True, color=&quot;red&quot;)</code></td></tr><tr><td><code>**linestyle_opts**</code></td><td>设置线条颜色、宽度</td><td><code>linestyle_opts=opts.LineStyleOpts(color=&quot;#FF0000&quot;, width=2, type=&quot;dashed&quot;)</code></td></tr><tr><td><code>**areastyle_opts**</code></td><td>区域填充颜色和透明度</td><td><code>areastyle_opts=opts.AreaStyleOpts(opacity=0.3, color=&quot;blue&quot;)</code></td></tr><tr><td><code>**symbol_size**</code></td><td>数据点的大小</td><td><code>symbol_size=10</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">line.add_yaxis(</span><br><span class="line">    series_name=<span class="string">&quot;美国确诊人数&quot;</span>,</span><br><span class="line">    y_axis=[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>],</span><br><span class="line">    label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">    linestyle_opts=opts.LineStyleOpts(width=<span class="number">2</span>),</span><br><span class="line">    symbol_size=<span class="number">8</span>,</span><br><span class="line">    areastyle_opts=opts.AreaStyleOpts(opacity=<span class="number">0.1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>折线图专属配置</strong><br>初始化图表时使用的配置项。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置项</td><td>作用</td><td>示例代码</td></tr><tr><td><code>**init_opts**</code></td><td>设置图表容器的宽高</td><td><code>Line(init_opts=opts.InitOpts(width=&quot;1600px&quot;, height=&quot;800px&quot;))</code></td></tr><tr><td><code>**add_xaxis**</code></td><td>添加X轴数据</td><td><code>.add_xaxis([&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;])</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="comment"># 1. 初始化折线图</span></span><br><span class="line">line = Line(init_opts=opts.InitOpts(width=<span class="string">&quot;1200px&quot;</span>, height=<span class="string">&quot;600px&quot;</span>))</span><br><span class="line"><span class="comment"># 2. 添加数据系列</span></span><br><span class="line">line.add_xaxis([<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>])</span><br><span class="line">line.add_yaxis(</span><br><span class="line">    series_name=<span class="string">&quot;A地区&quot;</span>,</span><br><span class="line">    y_axis=[<span class="number">30</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">80</span>],</span><br><span class="line">    symbol_size=<span class="number">10</span>,</span><br><span class="line">    label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    linestyle_opts=opts.LineStyleOpts(color=<span class="string">&quot;red&quot;</span>, width=<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 3. 设置全局配置</span></span><br><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=opts.TitleOpts(title=<span class="string">&quot;月度数据趋势&quot;</span>, pos_left=<span class="string">&quot;center&quot;</span>),</span><br><span class="line">    legend_opts=opts.LegendOpts(pos_top=<span class="string">&quot;10%&quot;</span>),</span><br><span class="line">    tooltip_opts=opts.TooltipOpts(trigger=<span class="string">&quot;axis&quot;</span>),</span><br><span class="line">    toolbox_opts=opts.ToolboxOpts(is_show=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 4. 生成HTML文件</span></span><br><span class="line">line.render(<span class="string">&quot;line_chart.html&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>全局配置</strong>：通过 <code>set_global_opts()</code> 控制标题、图例、工具箱等。</li><li><strong>系列配置</strong>：通过 <code>add_yaxis()</code> 定制数据系列的线条、标签、颜色等。</li><li><strong>初始化配置</strong>：通过 <code>init_opts</code> 设置图表容器的基础属性。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%205%203.png" alt="image 5 3|image 5 3.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%206%202.png" alt="image 6 2|image 6 2.png"><br>以下是根据美国、印度和日本的疫情数据生成折线图的代码示例：<br>原始数据：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%207%202.png" alt="image 7 2|image 7 2.png"><br><strong>数据清洗</strong></li><li><strong>问题</strong>：原始数据可能包含非JSON规范内容（如函数调用包裹）。</li><li><strong>处理步骤</strong>：<ol><li>去除非法前缀（如 <code>jsonp_1629344292311_69436(</code>）。</li><li>去除非法后缀（如末尾的 <code>);</code>）。</li><li>转换为Python数据结构。</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：处理美国疫情数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:/美国.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    raw_data = f.read()</span><br><span class="line"><span class="comment"># 清洗数据</span></span><br><span class="line">cleaned_data = raw_data.replace(<span class="string">&quot;jsonp_1629344292311_69436(&quot;</span>, <span class="string">&quot;&quot;</span>).strip(<span class="string">&quot;);&quot;</span>)</span><br><span class="line">us_dict = json.loads(cleaned_data)  <span class="comment"># 转换为字典</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%208%202.png" alt="image 8 2|image 8 2.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts, LabelOpts</span><br><span class="line"><span class="comment"># 读取各国疫情数据文件</span></span><br><span class="line">f_us = <span class="built_in">open</span>(<span class="string">&quot;D:/美国.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">us_data = f_us.read().replace(<span class="string">&quot;jsonp_1629344292311_69436(&quot;</span>, <span class="string">&quot;&quot;</span>)[:-<span class="number">2</span>]</span><br><span class="line">f_jp = <span class="built_in">open</span>(<span class="string">&quot;D:/日本.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">jp_data = f_jp.read().replace(<span class="string">&quot;jsonp_1629350871167_29498(&quot;</span>, <span class="string">&quot;&quot;</span>)[:-<span class="number">2</span>]</span><br><span class="line">f_in = <span class="built_in">open</span>(<span class="string">&quot;D:/印度.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">in_data = f_in.read().replace(<span class="string">&quot;jsonp_1629350745930_63180(&quot;</span>, <span class="string">&quot;&quot;</span>)[:-<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 转换为Python字典</span></span><br><span class="line">us_dict = json.loads(us_data)</span><br><span class="line">jp_dict = json.loads(jp_data)</span><br><span class="line">in_dict = json.loads(in_data)</span><br><span class="line"><span class="comment"># 获取疫情数据</span></span><br><span class="line">us_trend_data = us_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;trend&#x27;</span>]</span><br><span class="line">jp_trend_data = jp_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;trend&#x27;</span>]</span><br><span class="line">in_trend_data = in_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;trend&#x27;</span>]</span><br><span class="line"><span class="comment"># x_data存放日期数据，获取2020年的数据（取到314下标结束）</span></span><br><span class="line">us_x_data = us_trend_data[<span class="string">&#x27;updateDate&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">jp_x_data = jp_trend_data[<span class="string">&#x27;updateDate&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">in_x_data = in_trend_data[<span class="string">&#x27;updateDate&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line"><span class="comment"># y_data存放确诊人数数据，获取2020年的数据</span></span><br><span class="line">us_y_data = us_trend_data[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">jp_y_data = jp_trend_data[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">in_y_data = in_trend_data[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line"><span class="comment"># 构建折线图</span></span><br><span class="line">line = Line()</span><br><span class="line">line.add_xaxis(us_x_data)</span><br><span class="line">line.add_yaxis(<span class="string">&quot;美国确诊人数&quot;</span>, us_y_data, label_opts=LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line">line.add_yaxis(<span class="string">&quot;日本确诊人数&quot;</span>, jp_y_data, label_opts=LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line">line.add_yaxis(<span class="string">&quot;印度确诊人数&quot;</span>, in_y_data, label_opts=LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;2020年美日印三国新冠确诊人数趋势&quot;</span>, pos_left=<span class="string">&quot;center&quot;</span>),</span><br><span class="line">    tooltip_opts=TooltipOpts(trigger=<span class="string">&quot;axis&quot;</span>),  <span class="comment"># 鼠标悬停显示数据</span></span><br><span class="line">    visualmap_opts=VisualMapOpts(is_show=<span class="literal">False</span>)  <span class="comment"># 可选：颜色映射</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 5. 生成HTML文件</span></span><br><span class="line">line.render(<span class="string">&quot;global_covid_cases.html&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="地图可视化">地图可视化</h2><ol><li><strong>创建地图</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="comment"># 创建地图对象</span></span><br><span class="line">map_chart = Map()</span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">data = [(<span class="string">&quot;北京&quot;</span>, <span class="number">99</span>), (<span class="string">&quot;上海&quot;</span>, <span class="number">199</span>), (<span class="string">&quot;广东&quot;</span>, <span class="number">299</span>)]</span><br><span class="line">map_chart.add(<span class="string">&quot;测试地图&quot;</span>, data, <span class="string">&quot;china&quot;</span>)</span><br><span class="line"><span class="comment"># 生成HTML文件</span></span><br><span class="line">map_chart.render(<span class="string">&quot;map.html&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><strong>常用参数</strong><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>参数</strong></td><td><strong>说明</strong></td></tr><tr><td><code>series_name</code></td><td>系列名称（显示在图例中）。</td></tr><tr><td><code>data_pair</code></td><td>数据对，格式为 <code>[(区域名称, 数值), ...]</code>。</td></tr><tr><td><code>maptype</code></td><td>地图类型，如 <code>&quot;china&quot;</code>（中国地图）、<code>&quot;world&quot;</code>（世界地图）。</td></tr><tr><td><code>is_roam</code></td><td>是否开启鼠标缩放和平移漫游（<code>True</code> 或 <code>False</code>）。</td></tr></tbody></table></li></ol><p><strong>全局配置（</strong><code>**set_global_opts**</code><strong>）</strong><br>3. <strong>标题配置（</strong><code>**TitleOpts**</code><strong>）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts</span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(</span><br><span class="line">        title=<span class="string">&quot;全国疫情地图&quot;</span>,  <span class="comment"># 主标题</span></span><br><span class="line">        subtitle=<span class="string">&quot;2023年数据&quot;</span>,  <span class="comment"># 副标题</span></span><br><span class="line">        pos_left=<span class="string">&quot;center&quot;</span>,  <span class="comment"># 标题位置（居中）</span></span><br><span class="line">        pos_top=<span class="string">&quot;top&quot;</span>  <span class="comment"># 标题位置（顶部）</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4. <strong>视觉映射配置（</strong><code>**VisualMapOpts**</code><strong>）</strong><br>视觉映射用于根据数值大小设置颜色渐变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> VisualMapOpts</span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    visualmap_opts=VisualMapOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,  <span class="comment"># 是否显示视觉映射</span></span><br><span class="line">        is_piecewise=<span class="literal">True</span>,  <span class="comment"># 是否分段显示</span></span><br><span class="line">        pieces=[</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1-99人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#CCFFFF&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100</span>, <span class="string">&quot;max&quot;</span>: <span class="number">999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;100-999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FF6666&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1000</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1000+人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#990033&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>5. <strong>工具箱配置（</strong><code>**ToolboxOpts**</code><strong>）</strong><br>工具箱提供了一些实用工具，如保存图片、数据视图等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> ToolboxOpts</span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    toolbox_opts=ToolboxOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,  <span class="comment"># 是否显示工具箱</span></span><br><span class="line">        feature=&#123;</span><br><span class="line">            <span class="string">&quot;saveAsImage&quot;</span>: &#123;&#125;,  <span class="comment"># 保存为图片</span></span><br><span class="line">            <span class="string">&quot;restore&quot;</span>: &#123;&#125;,  <span class="comment"># 还原</span></span><br><span class="line">            <span class="string">&quot;dataView&quot;</span>: &#123;&#125;  <span class="comment"># 数据视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>6. <strong>提示框配置（</strong><code>**TooltipOpts**</code><strong>）</strong><br>提示框用于显示鼠标悬停时的详细信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TooltipOpts</span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    tooltip_opts=TooltipOpts(</span><br><span class="line">        trigger=<span class="string">&quot;item&quot;</span>,  <span class="comment"># 触发方式（item：数据项）</span></span><br><span class="line">        formatter=<span class="string">&quot;&#123;b&#125;: &#123;c&#125;&quot;</span>  <span class="comment"># 显示格式（&#123;b&#125;：区域名称，&#123;c&#125;：数值）</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><strong>系列配置（</strong><code>**add**</code> <strong>方法）</strong><br>系列配置用于设置地图中数据系列的样式。<br>7. <strong>区域颜色配置</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map_chart.add(</span><br><span class="line">    series_name=<span class="string">&quot;测试地图&quot;</span>,</span><br><span class="line">    data_pair=data,</span><br><span class="line">    maptype=<span class="string">&quot;china&quot;</span>,</span><br><span class="line">    is_roam=<span class="literal">True</span>,</span><br><span class="line">    itemstyle_opts=&#123;</span><br><span class="line">        <span class="string">&quot;normal&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;areaColor&quot;</span>: <span class="string">&quot;\#EEEEEE&quot;</span>,  <span class="comment"># 区域默认颜色</span></span><br><span class="line">            <span class="string">&quot;borderColor&quot;</span>: <span class="string">&quot;\#FFFFFF&quot;</span>  <span class="comment"># 边界颜色</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;emphasis&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;areaColor&quot;</span>: <span class="string">&quot;\#FFCC00&quot;</span>  <span class="comment"># 鼠标悬停时的区域颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>8. <strong>标签配置</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map_chart.add(</span><br><span class="line">    series_name=<span class="string">&quot;测试地图&quot;</span>,</span><br><span class="line">    data_pair=data,</span><br><span class="line">    maptype=<span class="string">&quot;china&quot;</span>,</span><br><span class="line">    label_opts=&#123;</span><br><span class="line">        <span class="string">&quot;show&quot;</span>: <span class="literal">True</span>,  <span class="comment"># 是否显示标签</span></span><br><span class="line">        <span class="string">&quot;formatter&quot;</span>: <span class="string">&quot;&#123;b&#125;: &#123;c&#125;&quot;</span>,  <span class="comment"># 标签显示格式</span></span><br><span class="line">        <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#000000&quot;</span>  <span class="comment"># 标签颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts, VisualMapOpts, ToolboxOpts, TooltipOpts</span><br><span class="line"><span class="comment"># 创建地图对象</span></span><br><span class="line">map_chart = Map()</span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">data = [(<span class="string">&quot;北京&quot;</span>, <span class="number">99</span>), (<span class="string">&quot;上海&quot;</span>, <span class="number">199</span>), (<span class="string">&quot;广东&quot;</span>, <span class="number">299</span>), (<span class="string">&quot;湖北&quot;</span>, <span class="number">399</span>), (<span class="string">&quot;四川&quot;</span>, <span class="number">499</span>)]</span><br><span class="line">map_chart.add(</span><br><span class="line">    series_name=<span class="string">&quot;测试地图&quot;</span>,</span><br><span class="line">    data_pair=data,</span><br><span class="line">    maptype=<span class="string">&quot;china&quot;</span>,</span><br><span class="line">    is_roam=<span class="literal">True</span>,</span><br><span class="line">    label_opts=&#123;</span><br><span class="line">        <span class="string">&quot;show&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;formatter&quot;</span>: <span class="string">&quot;&#123;b&#125;: &#123;c&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#000000&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    itemstyle_opts=&#123;</span><br><span class="line">        <span class="string">&quot;normal&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;areaColor&quot;</span>: <span class="string">&quot;\#EEEEEE&quot;</span>,</span><br><span class="line">            <span class="string">&quot;borderColor&quot;</span>: <span class="string">&quot;\#FFFFFF&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;emphasis&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;areaColor&quot;</span>: <span class="string">&quot;\#FFCC00&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(</span><br><span class="line">        title=<span class="string">&quot;全国疫情地图&quot;</span>,</span><br><span class="line">        subtitle=<span class="string">&quot;2023年数据&quot;</span>,</span><br><span class="line">        pos_left=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">        pos_top=<span class="string">&quot;top&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    visualmap_opts=VisualMapOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,</span><br><span class="line">        is_piecewise=<span class="literal">True</span>,</span><br><span class="line">        pieces=[</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1-99人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#CCFFFF&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100</span>, <span class="string">&quot;max&quot;</span>: <span class="number">999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;100-999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FF6666&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1000</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1000+人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#990033&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">    toolbox_opts=ToolboxOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,</span><br><span class="line">        feature=&#123;</span><br><span class="line">            <span class="string">&quot;saveAsImage&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;restore&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;dataView&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ),</span><br><span class="line">    tooltip_opts=TooltipOpts(</span><br><span class="line">        trigger=<span class="string">&quot;item&quot;</span>,</span><br><span class="line">        formatter=<span class="string">&quot;&#123;b&#125;: &#123;c&#125;&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 生成HTML文件</span></span><br><span class="line">map_chart.render(<span class="string">&quot;map.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>数据整体结构（全国）</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%209%202.png" alt="image 9 2|image 9 2.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 读取数据文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;E:\\Python_code\\可视化案例数据\\地图数据\\疫情.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">data = f.read()  <span class="comment"># 全部数据</span></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 取到各省数据</span></span><br><span class="line"><span class="comment"># 将字符串json转换为python的字典</span></span><br><span class="line">data_dict = json.loads(data)  <span class="comment"># 基础数据字典</span></span><br><span class="line"><span class="comment"># 从字典中取出省份的数据</span></span><br><span class="line">province_data_list = data_dict[<span class="string">&quot;areaTree&quot;</span>][<span class="number">0</span>][<span class="string">&quot;children&quot;</span>]</span><br><span class="line"><span class="comment"># 组装每个省份和确诊人数为元组，并将各个省的数据都封装入列表内</span></span><br><span class="line">data_list = []  <span class="comment"># 绘图需要的元组列表</span></span><br><span class="line"><span class="keyword">for</span> province_data <span class="keyword">in</span> province_data_list:</span><br><span class="line">    province_name = province_data[<span class="string">&quot;name&quot;</span>] <span class="comment"># 省份名称</span></span><br><span class="line">    province_confirm = province_data[<span class="string">&quot;total&quot;</span>][<span class="string">&quot;confirm&quot;</span>]  <span class="comment"># 确诊人数</span></span><br><span class="line">    data_list.append((province_name, province_confirm))</span><br><span class="line"><span class="comment"># 创建地图对象</span></span><br><span class="line"><span class="built_in">map</span> = Map()</span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line"><span class="built_in">map</span>.add(<span class="string">&quot;各省份确诊人数&quot;</span>, data_list, <span class="string">&quot;china&quot;</span>)</span><br><span class="line"><span class="comment"># 设置全局配置，定制分段的视觉映射</span></span><br><span class="line"><span class="built_in">map</span>.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;全国疫情地图&quot;</span>),</span><br><span class="line">    visualmap_opts=VisualMapOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,  <span class="comment"># 是否显示</span></span><br><span class="line">        is_piecewise=<span class="literal">True</span>,  <span class="comment"># 是否分段</span></span><br><span class="line">        pieces=[</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;1~99人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#CCFFFF&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100</span>, <span class="string">&quot;max&quot;</span>: <span class="number">999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;100~999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FFFF99&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">4999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;1000~4999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FF9966&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">5000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">9999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;5000~9999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FF6666&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">10000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;10000~99999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#CC3333&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100000</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;100000+&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#990033&quot;</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line"><span class="built_in">map</span>.render(<span class="string">&quot;全国疫情地图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>省数据结构</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%2010%202.png" alt="image 10 2|image 10 2.png"><br><strong>疫情数据实战（省级地图）</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%2011%202.png" alt="image 11 2|image 11 2.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 读取数据文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;E:\\Python_code\\可视化案例数据\\地图数据\\疫情.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">data = f.read()  <span class="comment"># 全部数据</span></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 将字符串json转换为python的字典</span></span><br><span class="line">data_dict = json.loads(data)  <span class="comment"># 基础数据字典</span></span><br><span class="line"><span class="comment"># 从字典中取出省份的数据</span></span><br><span class="line">province_data_list = data_dict[<span class="string">&quot;areaTree&quot;</span>][<span class="number">0</span>][<span class="string">&quot;children&quot;</span>]</span><br><span class="line"><span class="comment"># 对数据过滤，只留下河南省的各市区的确诊数据</span></span><br><span class="line"><span class="keyword">for</span> province_data <span class="keyword">in</span> province_data_list:</span><br><span class="line">    <span class="keyword">if</span> province_data[<span class="string">&quot;name&quot;</span>] == <span class="string">&#x27;河南&#x27;</span>:</span><br><span class="line">        cities_data = province_data[<span class="string">&quot;children&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(cities_data)</span><br><span class="line"><span class="comment"># 准备数据为元组并放入list</span></span><br><span class="line">data_list = []</span><br><span class="line"><span class="keyword">for</span> city_data <span class="keyword">in</span> cities_data:</span><br><span class="line">    city_name = city_data[<span class="string">&quot;name&quot;</span>] + <span class="string">&quot;市&quot;</span></span><br><span class="line">    city_confirm = city_data[<span class="string">&quot;total&quot;</span>][<span class="string">&quot;confirm&quot;</span>]</span><br><span class="line">    data_list.append((city_name, city_confirm))</span><br><span class="line"><span class="comment"># 创建地图对象</span></span><br><span class="line"><span class="built_in">map</span> = Map()</span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line"><span class="built_in">map</span>.add(<span class="string">&quot;河南省确诊人数&quot;</span>, data_list, <span class="string">&quot;河南&quot;</span>)</span><br><span class="line"><span class="comment"># 设置全局配置，定制分段的视觉映射</span></span><br><span class="line"><span class="built_in">map</span>.set_global_opts(</span><br><span class="line">    visualmap_opts=VisualMapOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,  <span class="comment"># 是否显示</span></span><br><span class="line">        is_piecewise=<span class="literal">True</span>,  <span class="comment"># 是否分段</span></span><br><span class="line">        pieces=[</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;1~99人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#CCFFFF&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100</span>, <span class="string">&quot;max&quot;</span>: <span class="number">999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;100~999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FFFF99&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">4999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;1000~4999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FF9966&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">5000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">9999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;5000~9999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#FF6666&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">10000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99999</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;10000~99999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;\#CC3333&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100000</span>, <span class="string">&quot;lable&quot;</span>: <span class="string">&quot;100000+&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#990033&quot;</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line"><span class="built_in">map</span>.render(<span class="string">&quot;河南疫情地图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p>注：<br>china小写<br>要加省/市</p><h2 id="动态柱状图">动态柱状图</h2><ol><li><strong>基础柱状图</strong><ol><li><strong>导入模块</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> LabelOpts</span><br></pre></td></tr></table></figure></li><li><strong>创建柱状图对象</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure></li><li><strong>添加数据</strong>：<ul><li><code>add_xaxis()</code>：添加 x 轴数据（分类数据，如国家名称）。</li><li><code>add_yaxis()</code>：添加 y 轴数据（数值数据，如 GDP）。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar.add_xaxis([<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;英国&quot;</span>])</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;GDP&quot;</span>, [<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>], label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br></pre></td></tr></table></figure>label_opts=LabelOpts(position=“right”)设置数值标签在右侧显示，方便反转xy轴数值显示</li><li><strong>反转 x 轴和 y 轴</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.reversal_axis()</span><br></pre></td></tr></table></figure></li><li><strong>生成图表</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.render(<span class="string">&quot;基础柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>基础时间线柱状图</strong><br><strong>Timeline()-时间线</strong><br>柱状图描述的是分类数据，回答的是每一个分类中『有多少？』这个问题。这是柱状图的主要特点,同时柱状图很难<mark>动态</mark>的描述一个趋势性的数据。这里pyecharts为我们提供了一种解决方案-<strong>时间线</strong><br>如果说一个Bar、Line对象是一张图表的话，时间线就是创建一个<strong>一维的x轴，轴上每一个点就是一个图表对象</strong><br>6. <strong>导入模块</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar, Timeline</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> LabelOpts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br></pre></td></tr></table></figure><br>7. <strong>创建多个柱状图对象</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bar1 = Bar()</span><br><span class="line">bar1.add_xaxis([<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;英国&quot;</span>])</span><br><span class="line">bar1.add_yaxis(<span class="string">&quot;GDP&quot;</span>, [<span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>], label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">bar1.reversal_axis()</span><br><span class="line">bar2 = Bar()</span><br><span class="line">bar2.add_xaxis([<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;英国&quot;</span>])</span><br><span class="line">bar2.add_yaxis(<span class="string">&quot;GDP&quot;</span>, [<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>], label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">bar2.reversal_axis()</span><br></pre></td></tr></table></figure><br>8. <strong>创建时间线对象</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeline = Timeline(&#123;<span class="string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;)</span><br></pre></td></tr></table></figure><br>9. <strong>将柱状图添加到时间线</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeline.add(bar1, <span class="string">&quot;点1&quot;</span>)</span><br><span class="line">timeline.add(bar2, <span class="string">&quot;点2&quot;</span>)</span><br></pre></td></tr></table></figure><br>10. <strong>设置时间线自动播放</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeline.add_schema(</span><br><span class="line">    play_interval=<span class="number">1000</span>,  <span class="comment"># 自动播放的时间间隔，单位毫秒</span></span><br><span class="line">    is_timeline_show=<span class="literal">True</span>,  <span class="comment"># 是否显示时间线</span></span><br><span class="line">    is_auto_play=<span class="literal">True</span>,  <span class="comment"># 是否自动播放</span></span><br><span class="line">    is_loop_play=<span class="literal">True</span>  <span class="comment"># 是否循环播放</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>11. <strong>生成图表</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeline.render(<span class="string">&quot;基础时间线柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><strong>GDP动态柱状图绘制</strong><ol><li><strong>需求分析</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/image%2012%202.png" alt="image 12 2|image 12 2.png"><br>部分数据<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250322181823983.png" alt="image.png|300"><ul><li><strong>数据格式</strong>：年份 → 国家 → GDP。</li><li><strong>数据处理</strong>：<ul><li>GDP 数据转换为亿级。</li><li>按年份排序，每年取前 8 名国家。</li></ul></li><li><strong>图表要求</strong>：<ul><li>反转 x 轴和 y 轴，标签在右</li><li>动态标题显示年份。</li><li>设置主题为 <code>LIGHT</code>。</li></ul></li></ul></li><li><strong>核心步骤</strong><ol><li><strong>读取数据</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/1960-2019全球GDP数据.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;GB2312&quot;</span>)</span><br><span class="line">data_lines = f.readlines()</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 删除第一条据，表头</span></span><br><span class="line">data_lines.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><strong>数据清洗与存储</strong>：<ul><li>将数据转换为字典格式：<code>&#123;年份: [[国家, GDP], ...]&#125;</code>。</li><li>使用 <code>try-except</code> 处理字典键不存在的情况。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data_lines:</span><br><span class="line">    year = <span class="built_in">int</span>(line.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">    country = line.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    gdp = <span class="built_in">float</span>(line.split(<span class="string">&quot;,&quot;</span>)[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data_dict[year].append([country, gdp])</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        data_dict[year] = [] <span class="comment"># 该year还没有存入key</span></span><br><span class="line">        data_dict[year].append([country, gdp])</span><br></pre></td></tr></table></figure></li><li><strong>排序与筛选</strong>：<ul><li>按年份排序。</li><li>每年取前 8 名国家。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sorted_year_list = <span class="built_in">sorted</span>(data_dict.keys())</span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> sorted_year_list:</span><br><span class="line">    data_dict[year].sort(key=<span class="keyword">lambda</span> element: element[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    year_data = data_dict[year][<span class="number">0</span>:<span class="number">8</span>]</span><br></pre></td></tr></table></figure></li><li><strong>构建柱状图并添加到时间线</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timeline = Timeline(&#123;<span class="string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;)</span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> sorted_year_list:</span><br><span class="line">    x_data = [country_gdp[<span class="number">0</span>] <span class="keyword">for</span> country_gdp <span class="keyword">in</span> year_data]</span><br><span class="line">    y_data = [country_gdp[<span class="number">1</span>] / <span class="number">100000000</span> <span class="keyword">for</span> country_gdp <span class="keyword">in</span> year_data]</span><br><span class="line">    bar = Bar()</span><br><span class="line">    bar.add_xaxis(x_data[::-<span class="number">1</span>])  <span class="comment"># 反转 x 轴数据</span></span><br><span class="line">    bar.add_yaxis(<span class="string">&quot;GDP(亿)&quot;</span>, y_data[::-<span class="number">1</span>], label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">    bar.reversal_axis()</span><br><span class="line">    bar.set_global_opts(title_opts=TitleOpts(title=<span class="string">f&quot;<span class="subst">&#123;year&#125;</span>年全球前8GDP数据&quot;</span>))</span><br><span class="line">    timeline.add(bar, <span class="built_in">str</span>(year))</span><br></pre></td></tr></table></figure></li><li><strong>设置时间线自动播放</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeline.add_schema(</span><br><span class="line">    play_interval=<span class="number">500</span>,</span><br><span class="line">    is_timeline_show=<span class="literal">True</span>,</span><br><span class="line">    is_auto_play=<span class="literal">True</span>,</span><br><span class="line">    is_loop_play=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><strong>生成图表</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeline.render(<span class="string">&quot;1960-2019全球GDP前8国家.html&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar,Timeline</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> LabelOpts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;E:\\Python_code\\可视化案例数据\\动态柱状图数据\\1960-2019全球GDP数据.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;GB2312&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">lines.pop(<span class="number">0</span>) <span class="comment"># 移除第一条数据（表头）</span></span><br><span class="line"><span class="comment"># 将数据转换为字段格式：&#123;年份：[[国家，GDP],...]&#125;</span></span><br><span class="line">data_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="comment"># 分割每行数据</span></span><br><span class="line">    parts = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    year = <span class="built_in">int</span>(parts[<span class="number">0</span>])  <span class="comment"># 年份</span></span><br><span class="line">    country = parts[<span class="number">1</span>]  <span class="comment"># 国家</span></span><br><span class="line">    gdp = <span class="built_in">float</span>(parts[<span class="number">2</span>])  <span class="comment"># GDP 数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data_dict[year].append((country, gdp))</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        data_dict[year] = [] <span class="comment"># 表明还未存入该key</span></span><br><span class="line">        data_dict[year].append((country, gdp))</span><br><span class="line"><span class="comment"># 绘制动态柱状图</span></span><br><span class="line">timeline = Timeline(&#123;<span class="string">&quot;theme&quot;</span>:ThemeType.LIGHT&#125;)</span><br><span class="line"><span class="comment"># 按年份排序</span></span><br><span class="line">sorted_year_list = <span class="built_in">sorted</span>(data_dict.keys())</span><br><span class="line"><span class="comment"># 遍历每一年数据</span></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> sorted_year_list:</span><br><span class="line">    <span class="comment"># 对当前年份的数据按GDP降序排序</span></span><br><span class="line">    data_dict[year].sort(key=<span class="keyword">lambda</span> element:element[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 取出当前年份前8名的国家</span></span><br><span class="line">    year_data = data_dict[year][<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">    <span class="comment"># 准备x轴和y轴数据</span></span><br><span class="line">    x_data = []</span><br><span class="line">    y_data = []</span><br><span class="line">    <span class="keyword">for</span> country_gdp <span class="keyword">in</span> year_data:</span><br><span class="line">        x_data.append(country_gdp[<span class="number">0</span>]) <span class="comment"># 国家</span></span><br><span class="line">        y_data.append(country_gdp[<span class="number">1</span>] / <span class="number">100000000</span>) <span class="comment"># GDP以亿为单位</span></span><br><span class="line">    bar = Bar()</span><br><span class="line">    bar.add_xaxis(x_data)</span><br><span class="line">    bar.add_yaxis(<span class="string">&quot;GDP(亿)&quot;</span>,y_data,label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">    bar.reversal_axis()</span><br><span class="line">    timeline.add(bar,<span class="built_in">str</span>(year))</span><br><span class="line"><span class="comment"># 设置时间线自动播放</span></span><br><span class="line">timeline.add_schema(</span><br><span class="line">    play_interval=<span class="number">500</span>,  <span class="comment"># 自动播放间隔（毫秒）</span></span><br><span class="line">    is_timeline_show=<span class="literal">True</span>,  <span class="comment"># 显示时间线</span></span><br><span class="line">    is_auto_play=<span class="literal">True</span>,  <span class="comment"># 自动播放</span></span><br><span class="line">    is_loop_play=<span class="literal">False</span>  <span class="comment"># 不循环播放</span></span><br><span class="line">)</span><br><span class="line">timeline.render(<span class="string">&quot;基础时间线柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>时间线设置主题</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>主题</strong></td><td><strong>颜色风格</strong></td><td><strong>备注</strong></td></tr><tr><td><code>ThemeType.WHITE</code></td><td>红蓝</td><td>默认主题</td></tr><tr><td><code>ThemeType.LIGHT</code></td><td>蓝黄粉</td><td>高亮颜色</td></tr><tr><td><code>ThemeType.DARK</code></td><td>红蓝</td><td>黑色背景</td></tr><tr><td><code>ThemeType.CHALK</code></td><td>红蓝绿</td><td>黑色背景</td></tr><tr><td><code>ThemeType.ESSOS</code></td><td>红黄</td><td>暖色系</td></tr><tr><td><code>ThemeType.INFOGRAPHIC</code></td><td>红蓝黄</td><td>偏亮</td></tr><tr><td><code>ThemeType.MACARONS</code></td><td>紫绿</td><td></td></tr><tr><td><code>ThemeType.PURPLE_PASSION</code></td><td>粉紫</td><td>灰色背景</td></tr><tr><td><code>ThemeType.ROMA</code></td><td>红黑灰</td><td>偏暗</td></tr><tr><td><code>ThemeType.ROMANTIC</code></td><td>红粉蓝</td><td>淡黄色背景</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeline = Timeline(&#123;<span class="string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;)</span><br></pre></td></tr></table></figure><p><strong>列表的</strong> <code>**sort**</code> <strong>方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.sort(key=选择排序依据的函数, reverse=<span class="literal">True</span>|<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li><code>**key**</code>：排序依据的函数。</li><li><code>**reverse**</code>：是否反转排序结果（<code>True</code> 为降序，<code>False</code> 为升序）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据第二个元素数字飘絮排序</span></span><br><span class="line">my_list = [[<span class="string">&quot;a&quot;</span>, <span class="number">33</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">55</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">11</span>]]</span><br><span class="line">my_list.sort(key=<span class="keyword">lambda</span> element: element[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [[&quot;b&quot;, 55], [&quot;a&quot;, 33], [&quot;c&quot;, 11]]</span></span><br></pre></td></tr></table></figure><p>[[面向对象]]</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 语法 </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
