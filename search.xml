<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>王道计组pdf</title>
      <link href="/post/77666db.html"/>
      <url>/post/77666db.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（一）</title>
      <link href="/post/undefined.html"/>
      <url>/post/undefined.html</url>
      
        <content type="html"><![CDATA[<h1>计算机系统概述</h1><h2 id="计算机系统的组成">计算机系统的组成</h2><p>计算机系统由<strong>硬件系统</strong>和<strong>软件系统</strong>共同组成，两者协同工作。<br>系统性能取决于<strong>硬件与软件的综合能力</strong><br>结构：</p><ul><li>软件<ul><li><p><strong>系统软件（中间层）</strong></p><ul><li>管理硬件资源，为应用软件提供运行环境。</li><li><strong>分类</strong>：<ul><li><strong>操作系统</strong>：Windows、Linux、macOS（资源调度核心）</li><li><strong>语言处理程序</strong>：编译器（GCC）、解释器（Python）、汇编器</li><li><strong>数据库管理系统（DBMS）</strong>：MySQL、Oracle</li><li><strong>服务程序</strong>：调试工具、磁盘清理工具、诊断程序</li><li><strong>网络系统</strong>：网络协议栈、通信管理软件、路由器固件</li></ul></li></ul></li><li><p><strong>应用软件（最上层）</strong></p><ul><li>面向用户解决特定领域的问题</li><li><strong>分类</strong>：<ul><li><strong>通用软件</strong>：Office（文字/表格处理）、Photoshop（图像处理）</li><li><strong>行业软件</strong>：AutoCAD（工程设计）、MATLAB（科学计算）</li><li><strong>事务管理</strong>：ERP系统、财务软件</li></ul></li></ul></li></ul></li><li><strong>硬件系统（最底层）</strong><ul><li><strong>主机</strong><ul><li><strong>中央处理器（CPU）</strong>：运算器、控制器、寄存器</li><li><strong>主存储器（内存）</strong>：RAM、ROM</li><li><strong>系统总线</strong>：数据总线、地址总线、控制总线</li></ul></li><li><strong>外部设备</strong></li><li><strong>输入设备</strong>：键盘、鼠标、摄像头</li><li><strong>输出设备</strong>：显示器、打印机</li><li><strong>辅助存储器</strong>：硬盘、SSD、U盘</li></ul></li></ul><blockquote><p>计算机系统性能的好坏，取决于硬件和软件功能的总和。<br>计算机的工作特点是<mark>快速性、准确性、通用性、逻辑性</mark><br>当前世界上计算机用途中领域的<mark>应用数据处理</mark>占的比例最大<br>微型计算机的发展以<mark>微处理器</mark>技术为标志<br>v：寄存器 &gt;Cache&gt;内存</p></blockquote><h2 id="计算机的发展">计算机的发展</h2><p>第一台真正意义上的电子数字计算机——ABC<br>第一台实用的电子数字计算机——ENIAC</p><h3 id="计算机硬件的发展">计算机硬件的发展</h3><p>计算机的逻辑器件：<mark>电子管(真空管)→晶体管→中小规模集成电路→大规模、超大规模集成电路</mark><br>以<mark>元器件的更新</mark>作为计算机技术进步和划分时代的主要标志<br>体积越小，功耗越低，可靠性越高，速度越快<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326084316978.png" alt="image.png"></p><table><thead><tr><th>发展阶段</th><th>使用器件</th><th>运算速度（次 / 秒）</th><th>主存（内存）</th><th>辅存（外存）</th><th>特点</th></tr></thead><tbody><tr><td>第 1 代（1946-1957 年）</td><td>电子管（真空管）</td><td>几千～几万</td><td>水银延迟线、磁鼓、磁芯</td><td>穿孔卡片、穿孔纸带</td><td>使用机器语言编程，无操作系统</td></tr><tr><td>第 2 代（1958-1964 年）</td><td>晶体管</td><td>几十万～几百万</td><td>磁芯</td><td>磁鼓、磁带、磁盘</td><td>主要用汇编语言，开始使用 FORTRAN、COBOL 等高级语言，单道批处理系统</td></tr><tr><td>第 3 代（1965-1971 年）</td><td>集成电路</td><td>几百万～几千万</td><td>半导体存储器</td><td>磁带、磁盘</td><td>高级语言发展，出现 B 语言，多道批处理系统、分时系统</td></tr><tr><td>第 4 代（1972 至今）</td><td>超大规模集成电路</td><td>几十亿～几千亿</td><td>半导体存储器</td><td>磁盘、磁带、光盘、半导体存储器</td><td>各种高级语言（如 C/C++、Java、Python），现代操作系统</td></tr></tbody></table><h3 id="计算机软件的发展">计算机软件的发展</h3><ul><li><strong>编程语言</strong><ul><li><strong>机器语言</strong><br>用<mark>二进制代码</mark>表示的计算机能<mark>直接</mark>识别和执行的一种机器指令的集合。唯一能被硬件直接执行的语言，成为目标程序</li><li><strong>汇编语言</strong><br>用<strong>助记符</strong>（如<code>MOV</code>, <code>ADD</code>）代替机器指令，与机器码<strong>一一对应</strong>，基本保留了机器语言的灵活性，但仍依赖硬件架构</li><li><strong>高级语言</strong><br>面向用户的语言，通过<strong>抽象</strong>隐藏硬件细节，与具体机器无关<ul><li><strong>编译型</strong>（如C/C++）：<br>源代码 → <strong>编译器</strong> → 直接生成<strong>机器码</strong>（或先转为汇编代码再汇编） → 链接为可执行文件（如.exe）。</li><li><strong>解释型</strong>（如Python、JavaScript）：<br>解释器逐行翻译并<strong>边解释边执行</strong>，无独立机器码文件。</li><li><strong>混合型</strong>（如Java）：<br>源代码 → 编译为<strong>中间码</strong>（如字节码） → 由虚拟机（JVM）解释/即时编译（JIT）执行。</li></ul></li><li><strong>面向对象</strong><br>高级语言的<strong>范式演进</strong>，以“对象”为核心组织代码（如C++、Java）</li></ul></li><li><strong>操作系统</strong><ul><li>提供了<strong>在汇编语言和高级语言的使用和实现过程中所需的某些基本操作</strong></li><li>负责<strong>控制并管理计算机系统的全部硬件资源</strong>（eg.CPU、内存、外部设备）和<strong>软件资源</strong>（eg.编译程序、应用程序）</li></ul></li></ul><p>程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器指令，由计算机最终执行。</p><p>高级语言程序转换为机器语言程序，即<strong>翻译程序</strong>：<br>编译、汇编、解释程序可统称翻译程序</p><table><thead><tr><th><strong>类型</strong></th><th><strong>输入</strong></th><th><strong>输出</strong></th><th><strong>特点</strong></th><th><strong>示例语言</strong></th></tr></thead><tbody><tr><td><strong>汇编程序</strong></td><td>汇编语言源代码</td><td>机器码目标文件</td><td>一对一翻译，依赖硬件架构</td><td>x86汇编、ARM汇编</td></tr><tr><td><strong>编译程序</strong></td><td>高级语言源代码</td><td>汇编/机器码文件</td><td>整体翻译，生成独立可执行文件.exe</td><td>C、C++、Go</td></tr><tr><td><strong>解释程序</strong></td><td>高级语言源代码</td><td>直接执行</td><td>逐行翻译，无独立机器码</td><td>Python、JavaScript</td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327160427749.png" alt="image.png"></td><td></td><td></td><td></td><td></td></tr><tr><td><font color="#ff0000">预处理→编译→汇编→链接</font></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><strong>预处理（Preprocessing）</strong><ul><li>预处理器(cpp)对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以i为扩展名的源程序 hello.i。</li></ul></li><li><strong>编译（Compilation）</strong><ul><li>编译器(ccl)对预处理后的源程序进行编译，生成一个<strong>汇编语言源程序</strong> hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。</li></ul></li><li><strong>汇编（Assembly）</strong><ul><li>汇编器将汇编代码转为<strong>机器码目标文件</strong>（<code>.o</code>或<code>.obj</code>）。汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一个称为可重定位目标代码文件 hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。</li></ul></li><li><strong>链接（Linking）</strong><ul><li>链接器(ld)将多个可重定位目标代码文件和标准库函数合并为一个可执行目标文件，简称可执行文件。本例中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。</li></ul></li></ol><p>注：</p><ul><li>v:<mark>编译程序&gt;解释程序</mark><br>解释程序需要便翻译成机器语言边执行，故速度比机器语言慢</li></ul><p>当前计算机的发展趋势</p><ul><li>更微型化：低耗能，较高性能，多用途</li><li>更巨型化：超高速，并行处理，智能化</li></ul><h2 id="计算机硬件">计算机硬件</h2><p>冯·诺依曼结构（也称普林斯顿结构）是计算机设计的理论基础，其核心思想是“<strong>存储程序</strong>”，即程序指令和数据共同存储在存储器中，由控制器按顺序自动执行。<br><strong>存储程序原理</strong>：</p><ul><li><strong>核心思想</strong>：<ul><li>程序与数据<strong>预先存入主存</strong>，启动后计算机自动逐条执行指令，无需人工干预。</li><li><strong>按地址访问</strong>：通过指令中的地址码定位存储单元，而非按内容寻址（相联存储器为特例，按内容或地址选择地址，成为按内容寻址的寄存器，不属冯氏结构基础）</li></ul></li></ul><p>冯诺依曼计算机主要特点：</p><ol><li>指令和数据均采用二进制表示<ul><li><strong>形式无区分</strong>：指令和数据均以<strong>二进制形式</strong>存储在<strong>存储器</strong>中，计算机通过<strong>执行阶段</strong>区分二者。【指令和数据在内存中可以有各种进制<mark>表示</mark>，但是<mark>存放</mark>的必须是二进制】<br>在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。<br>1)二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位制造成本比较低，例如用高、低电平或电荷的正、负极性都可以很方便地表示0和1。<br>2)二进制位 1和 0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。<br>3)进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</li></ul></li></ol><ul><li><strong>取指阶段</strong>：从存储器中读取的是<strong>指令</strong>（由操作码和地址码组成）。</li><li><strong>执行阶段</strong>：根据指令中的地址码访问<strong>数据</strong>或目标地址。</li></ul><ol start="2"><li>指令和数据存放在存储器中，按地址访问。</li><li>指令在存储器中按<strong>顺序</strong>存放。一般情况下，指令是顺序执行的。<ul><li><strong>指令结构</strong>：</li></ul></li></ol><ul><li><strong>操作码</strong>：指明操作类型（如取数、存数、加、减、乘、除、跳转）。</li><li><strong>地址码</strong>：指明操作数在存储器中的位置（地址）或直接数据。</li></ul><ol start="6"><li>机器以<strong>运算器</strong>为中心，输入/输出设备与存储器间的数据传送通过运算器完成，浪费很多可以用于运算的时间<br><strong>现代改进</strong>：当代计算机以<strong>存储器为中心</strong>，输入/输出可通过<strong>DMA（直接内存访问）</strong> 绕过CPU，提升效率。</li><li>计算机硬件由<strong>运算器、控制器、存储器、输入设备/输出设备</strong>5大部件组成。<blockquote><p><strong>注</strong>：现代计算机中，运算器与控制器集成在<strong>CPU</strong>中，存储器主要指<strong>主存（内存）</strong>。<br><strong>内存由存储单元组成</strong>，每个单元有唯一地址，而非由寄存器构成。<br>存储器中可存地址（如指针变量），但地址本质是存储单元的编号。</p></blockquote></li><li><strong>指令流驱动</strong>：程序执行流程由指令序列控制，PC指向当前指令地址，顺序执行或跳转。</li></ol><p>控制器与其他部件之间通过控制器和反馈线相连，这些部件需要在控制器的控制下协调工作<br>图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制ALU 执行什么运算，可以控制主存是进行读操作还是写操作(读/写控制信号)。<br>但是这种设计，每次IO操作都需要运算器参与，浪费了很多可以用于运算的时间<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093328099.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326094434509.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093400793.png" alt="image.png"><br>现代计算机以存储器为核心<br>可以让IO设备直接与存储器交换数据，以提高整体效率<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326094617374.png" alt="image.png">控制器核心为控制单元CU(Control Unit)，主要功能如下：</p><ul><li>用于解释存储器中的指令，并发出各种操作命令来执行指令。</li><li>I/O设备也受CU控制，用于完成相应的输入/输出操作。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093441775.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326093454858.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326095110873.png" alt="image.png">主机细化：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327101101923.png" alt="image.png"></li></ul><h3 id="相关术语">相关术语</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326112214285.png" alt="image.png|350"></p><ol><li><p><font color="#ff0000">主机</font> = <strong>CPU + 内存 + 系统总线</strong>（部分定义包含I/O接口）<br><strong>输入输出接口（I/O接口）</strong>：属于主机与外部设备（如键盘、打印机）的<strong>桥梁</strong>，严格来说属于主机的一部分，但外设本身（如硬盘、显示器）不算主机。</p></li><li><p><strong><font color="#ff0000">存储器</font></strong></p><ul><li><strong>内存（主存、主存储器）</strong>： 临时存储正在运行的程序和数据（断电丢失），相当于办公桌。CPU可以直接访问主存储器<ul><li>存储体</li><li>MAR</li><li>MDR<br>随着硬件技术的发展，内存都制成大规模集成电路芯片，而将<mark>MAR和MDR集成到了CPU芯片中</mark></li></ul></li><li><strong>外存（辅助存储器、外存储器）</strong>：例如硬盘、U盘，长期保存文件（断电不丢），相当于文件柜。<br>辅助存储器中的信息必须调入主存后，才能为CPU所访问。</li></ul></li><li><p><strong><font color="#ff0000">CPU</font>（中央处理器）</strong>：计算机的“大脑”，负责计算和控制，核心由<strong>运算器（ALU）</strong> 和 <strong>控制器（CU）</strong> 组成，通过<strong>寄存器</strong>实现高速数据存取【运算器和控制器中都有寄存器】</p><ul><li><strong><font color="#ff0000">运算器</font></strong>：<ul><li><strong>算术逻辑单元ALU</strong>：执行定点或浮点的算术==运算操作（加减乘除）及逻辑操作（与、或、非、异或、比较、移位），也可执行地址的运算和转换。==属于组合逻辑电路<ul><li>结构<ul><li><strong>加法器</strong>：实现二进制加法，是ALU的基础单元。</li><li><strong>选择逻辑</strong>：通过控制信号选择输入数据（如两个操作数），决定执行何种运算。</li><li><strong>输出控制</strong>：支持结果直接传输或移位（如左移、右移）。</li></ul></li><li><strong>重要性</strong>：计算机性能的关键，因为大部分数据处理依赖ALU的运算速度。</li></ul></li><li>相关寄存器<ul><li><strong>累加器ACC</strong>，一种<strong>专用寄存器</strong>（非ALU直接部件），用于暂存ALU<strong>前一次运算的结果</strong>或<strong>初始操作数（被加数/被减数）</strong>，在加减法中作为运算的基准值。（例如：执行<code>A = A + B</code>时，累加器存放<code>A</code>的值）</li><li><strong>乘商寄存器MQ</strong>：在乘法和除法运算中，存储乘数、商或中间结果。</li><li><strong>操作数寄存器X</strong>：用于临时存储<strong>从主存或指令中获取的第二个操作数（加数、减数、乘数）</strong></li><li><strong>标志寄存器PSW</strong>：也称程序状态寄存器，存放ALU运算得到的一些标志信息或处理机的状态信息，如溢出、进位或借位、结果正负、零标志，是条件执行的基础<ul><li><strong>进位标志</strong>：加法结果超过位数时标记（如99+1=100，进位了）</li><li><strong>零标志</strong>：结果是否为0。</li></ul></li><li>变址寄存器IX</li><li>基址寄存器BR<br>前三个是必备的</li></ul></li></ul></li><li><strong><font color="#ff0000">控制器</font></strong>：计算机的神经中枢，指挥各个部件自动协调工作。<br>核心流程为<strong>1. 从内存取指令（取指） → 2. 分析指令（分析） → 3. 发信号让运算器/内存干活（执行）</strong><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326112932395.png" alt="image.png|350"><ul><li><strong>核心组件</strong>：<ul><li><strong>程序计数器（PC）</strong>：存放下一条指令的<mark>地址</mark>，有自动+1功能（指令长度）<u>与主存的MAR间有一条直接通路</u> 寄存信息、计数功能</li><li><strong>指令寄存器（IR）</strong>：==存放从存储器取出的当前指令，内容来自主存的MDR。==指令中的操作码（用OP(IR)表示）送至 CU（OP(IR)→CU），用以<strong>分析指令</strong>并发出各种微操作命令序列；而地址码 Ad(IR)送往MAR，用以取操作数。<ul><li>暂存当前执行的指令<ul><li>分离 操作码OP和地址码 Ad<ul><li>OP送入控制单元CU，解码</li><li>Ad用于定位操作数在内存中的地址</li></ul></li><li><strong>取指阶段</strong>：IR 接收从内存读取的指令。</li><li><strong>执行阶段</strong>：IR 提供操作码和地址码，驱动 CPU 完成操作（如运算、存数等）<br>注：<br>IR指令寄存器IR用来存放<strong>当前的指令</strong>，IR的内容来自存储器数据寄存器MDR。<br>程序计数器PC用来存放<strong>当前欲执行指令的地址</strong>，PC与存储器地址寄存器MAR之间有一条直接通路。PC自动形成下一条指令的地址(“自动加1”功能)</li></ul></li></ul></li><li><strong>控制单元（CU）</strong>：<mark>分析</mark>存储器中的指令，并发出各种操作命令来执行指令。</li><li><strong>指令译码器</strong>：解析指令的操作码（如“加法”）和地址码（如“操作数位置”）。</li><li><strong>时序部件</strong>：生成时钟信号，同步各操作步骤。</li><li><strong>操作控制部件</strong>：根据译码结果，向ALU、内存等发送控制信号（如“开始加法运算”）。</li><li><strong>中断机构</strong>：处理外部紧急事件（如用户按下键盘）。</li></ul></li><li>相关寄存器</li></ul></li><li><font color="#ff0000">寄存器</font>：CPU内部的“高速临时存储单元”，直接参与运算和控制，速度远快于内存。<ul><li><strong>分类</strong>：</li><li><strong>通用寄存器（GPRs）</strong>：由若干个寄存器组成，早期就是累加器<ul><li>存储临时数据或中间结果（如计算<code>(a+b)*c</code>时，存放<code>a+b</code>的结果）。</li><li>用户可通过编程直接访问（如x86中的<code>EAX</code>、<code>EBX</code>）。</li></ul></li></ul></li></ul></li><li><p><strong><font color="#ff0000">总线</font>（Bus）</strong>：在计算机中连接CPU和其他芯片的导线的集合</p><ul><li><ol><li><strong>地址总线AB</strong></li></ol><ul><li><strong>寻址空间</strong>：地址总线的位数（宽度）决定了CPU可访问的<strong>内存地址空间</strong>。</li><li>若地址总线为 n 位，则寻址空间为 2^n <strong>个存储单元</strong>。</li><li><strong>示例</strong>：<ul><li>20位地址总线 → 2^{20} = 1,048,576 个存储单元（即1MB，若每个单元为1字节）。</li></ul></li><li><strong>存储容量</strong>：存储器的总容量由<strong>地址空间 × 存储单元大小</strong>决定<ul><li>若地址总线为16位（2^{16}=65536 单元），且每个单元为8位（1字节），则总容量为 <strong>64KB</strong>。</li></ul></li><li><strong>CPU操作</strong>：CPU通过地址总线发送地址信号，选中目标存储单元或I/O设备。</li></ul></li><li><strong>2. 数据总线（Data Bus, DB）</strong><ul><li><strong>机器字长</strong>：数据总线的宽度通常等于CPU的<strong>机器字长</strong>，即一次能处理的二进制位数（如32位、64位）。<ul><li>机器字长决定了通用寄存器的位数和ALU的运算能力（如64位CPU可一次处理64位数据）。</li></ul></li><li><strong>并行传输能力</strong>：数据总线的宽度直接影响CPU与外界的数据传输速度。<ul><li><strong>示例</strong>：<ul><li>16位数据总线 → 一次传输2字节。</li><li>32位数据总线 → 一次传输4字节。</li></ul></li></ul></li><li><strong>速度影响</strong>：数据总线越宽，单次传输数据量越大，整体传输速率越高（速率 = 总线宽度 × 时钟频率）。</li></ul></li><li><strong>3. 控制总线（Control Bus, CB）</strong><ul><li><strong>控制信号传输</strong>：负责传递CPU与外部设备间的控制信号，包括：<ul><li><strong>读写命令</strong>：如内存读（MEMR）、内存写（MEMW）。</li><li><strong>中断请求</strong>：如IRQ（中断请求）、NMI（不可屏蔽中断）。</li><li><strong>总线仲裁</strong>：如总线请求（BUSRQ）、总线响应（BUSAK）。</li><li><strong>状态信号</strong>：如就绪（READY）、复位（RESET）。</li></ul></li><li><strong>控制能力</strong>：控制总线的宽度决定了可独立传输的控制信号种类数量。<ul><li>更多的控制线允许更复杂的协调操作（如多设备并行管理）。</li></ul></li></ul></li></ul></li></ol><p>注：<br><strong>地址总线位数</strong>决定可寻址的<strong>存储单元数量</strong>（2^n），而<strong>数据总线宽度</strong>决定每个单元的<strong>数据位宽</strong>（如8位、16位）。</p><ul><li><strong>示例</strong>：<ul><li>16位地址总线 + 8位数据总线 → 地址空间为 2^{16}=65536 单元，每个单元8位，总容量为 <strong>64KB</strong>。</li><li>16位地址总线 + 32位数据总线 → 地址空间仍为65536单元，但每个单元32位，总容量为 <strong>256KB</strong>。</li></ul></li><li><strong>结论</strong>：地址空间仅由地址总线位数决定，与数据总线宽度无关。</li></ul><table><thead><tr><th><strong>总线类型</strong></th><th><strong>核心作用</strong></th><th><strong>决定因素</strong></th><th><strong>典型关联概念</strong></th></tr></thead><tbody><tr><td><strong>地址总线</strong></td><td>指定存储单元位置</td><td>寻址空间（2^n 单元）</td><td>存储容量、内存地址范围</td></tr><tr><td><strong>数据总线</strong></td><td>传输操作数/结果</td><td>机器字长、数据传输速度</td><td>通用寄存器、ALU运算能力</td></tr><tr><td><strong>控制总线</strong></td><td>协调操作与状态同步</td><td>控制信号种类与复杂度</td><td>中断管理、总线仲裁</td></tr></tbody></table><ul><li><strong>AB、DB、CB协同工作</strong>：地址总线定位数据位置，数据总线传输数据内容，控制总线确保操作时序与协调。</li><li><strong>性能平衡</strong>：地址总线宽度决定内存容量，数据总线宽度影响处理速度，控制总线复杂度决定系统灵活性。</li></ul><ol start="5"><li><strong>指令集体系结构</strong>（ISA）：<ul><li><strong>核心作用</strong>：</li><li><strong>硬件与软件的接口</strong>，定义计算机可执行的所有指令集合。</li><li>规定指令的操作类型、操作数地址空间及数据类型（如x86、ARM指令集）。</li><li><strong>层级位置</strong>：</li><li>位于计算机系统层次结构的<strong>软件与硬件之间</strong>，是软件可见的最低层。</li></ul></li></ol><ul><li><strong>关键特性</strong>：<ul><li><strong>软件可见性</strong>：程序员通过ISA编写代码，无需关心底层硬件细节。</li></ul></li></ul><table><thead><tr><th><strong>寄存器/部件</strong></th><th><strong>可见性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>MAR、MDR、IR</strong></td><td>不可见（对程序员透明）</td><td>由硬件自动控制，用户无法直接访问。</td></tr><tr><td><strong>PC（程序计数器）</strong></td><td>部分可见（汇编程序员可见）</td><td>可通过分支指令间接操作（如JMP）。</td></tr><tr><td><strong>状态寄存器（Flag）</strong></td><td>汇编程序员可见</td><td>通过条件码控制程序流程（如JZ、JC）。</td></tr><tr><td><strong>通用寄存器（GPRs）</strong></td><td>汇编程序员可见</td><td>直接参与数据运算（如ADD R1, R2）。</td></tr><tr><td>计算机基本的结构模型</td><td></td><td></td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327122211999.png" alt="image.png"></td><td></td><td></td></tr><tr><td>设主存储器容量为 64Kx32位，且指令字长、存储字长、机器字长三者相等。写出各寄存器的位数，并指出哪些寄存器之间有信息通路。</td><td></td><td></td></tr><tr><td><strong>各寄存器位数分析</strong>：</td><td></td><td></td></tr></tbody></table><ol><li><p><strong>与地址相关的寄存器</strong>：</p><ul><li><strong>MAR（存储器地址寄存器）</strong>：主存容量为64K（$2^{16}$），地址总线宽度为 <strong>16位</strong>。</li><li><strong>PC（程序计数器）</strong>：存放指令地址，与MAR一致，为 <strong>16位</strong>。</li></ul></li><li><p><strong>与数据相关的寄存器</strong>：</p><ul><li><strong>MDR（存储器数据寄存器）</strong>：存储字长为32位，数据总线宽度为32位，故MDR为 <strong>32位</strong>。</li><li><strong>IR（指令寄存器）</strong>：指令字长=存储字长=32位，故IR为 <strong>32位</strong>。</li><li><strong>ACC（累加器）、MQ（乘商寄存器）、X（操作数寄存器）</strong>：机器字长=32位，均为 <strong>32位</strong>。</li></ul></li></ol><p><strong>寄存器间的信息通路</strong>：</p><ol><li><p><strong>取指令阶段</strong>：</p><ul><li><strong>PC → MAR</strong>：程序计数器将指令地址发送至MAR，用于访存取指。</li><li><strong>MDR → IR</strong>：从内存取出的指令通过MDR传送到IR。</li></ul></li><li><p><strong>执行阶段</strong>：</p><ul><li><strong>Ad(IR) → MAR</strong>：指令中的地址字段（如访存地址）从IR提取后发送至MAR。</li><li><strong>MDR → ACC</strong>（取数操作）：内存读取的数据通过MDR传送到ACC。</li><li><strong>ACC → MDR</strong>（存数操作）：ACC中的数据通过MDR写入内存。</li></ul></li></ol><h2 id="计算机系统的层次结构">计算机系统的层次结构</h2><p>系统中的每一层都向其上层提供一个简洁和抽象的接口<br>每一层的实现细节对其上层而言都是“看不见”的，也就是透明的。<br>计算机解决问题的过程就是层次结构中的各层逐层转换的过程。</p><ul><li><strong>下层是上层的基础</strong>（硬件 → 系统软件 → 应用软件）</li><li><strong>上层拓展下层功能</strong>（应用软件通过系统软件操作硬件）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326085951572.png" alt="image.png"></li></ul><hr><p><strong>1. 硬件层（最底层）</strong></p><ul><li><strong>组成</strong>：由逻辑门、寄存器、ALU、总线等物理电路构成。</li><li><strong>功能</strong>：直接执行二进制指令（机器码），完成基本逻辑运算与数据存储。</li><li><strong>特点</strong>：完全依赖物理硬件，无抽象接口。</li></ul><p><strong>2. 微程序层</strong></p><ul><li><strong>组成</strong>：微程序控制器，包含微指令序列。</li><li><strong>功能</strong>：<ul><li>将复杂机器指令分解为<strong>微操作</strong>（如取数、运算、存数）。</li><li>通过微指令控制硬件电路的时序与动作。</li></ul></li><li><strong>示例</strong>：一条<code>ADD</code>指令可能对应多步微操作（从寄存器取数 → ALU计算 → 结果写回）。</li></ul><p><strong>3. 指令系统层（机器语言层）</strong></p><ul><li><strong>组成</strong>：机器指令集（如x86、ARM指令集）。</li><li><strong>功能</strong>：<ul><li>定义计算机可执行的所有机器指令（如<code>MOV</code>, <code>JMP</code>）。</li><li>规定指令的操作类型、操作数位置及数据类型。</li></ul></li><li><strong>特点</strong>：程序员需熟悉具体机器的指令格式与硬件结构。</li></ul><p><strong>4. 操作系统层</strong></p><ul><li><strong>组成</strong>：内核、设备驱动、系统调用接口。</li><li><strong>功能</strong>：<ul><li>管理硬件资源（CPU调度、内存分配、I/O控制）。</li><li>为上层应用提供统一的系统服务（如文件读写、进程管理）。</li></ul></li><li><strong>开发要求</strong>：<ul><li>需深入理解指令集、汇编语言及系统级编程语言（如C）。</li></ul></li></ul><p><strong>5. 汇编语言层</strong></p><ul><li><strong>组成</strong>：助记符（如<code>ADD</code>, <code>MOV</code>）与目标机器指令一一对应。</li><li><strong>功能</strong>：<ul><li>提供机器指令的符号化表示，简化编程。</li><li>需通过<strong>汇编器</strong>转换为机器码。</li></ul></li><li><strong>特点</strong>：<ul><li>程序员仍需熟悉硬件细节（如寄存器布局、内存寻址）。</li></ul></li></ul><p><strong>6. 高级语言层（最顶层）</strong></p><ul><li><strong>组成</strong>：与机器无关的编程语言（如Python、Java、C++）。</li><li><strong>功能</strong>：<ul><li>通过抽象语法（如变量、循环）隐藏硬件细节。</li><li>程序通过<strong>编译器/解释器</strong>转换为机器码。</li></ul></li><li><strong>开发要求</strong>：<ul><li>仅需掌握语法规则、算法与数据结构，无需了解底层硬件。</li></ul></li></ul><p><strong>各层特点对比</strong></p><table><thead><tr><th><strong>层级</strong></th><th><strong>抽象程度</strong></th><th><strong>依赖硬件细节</strong></th><th><strong>开发复杂度</strong></th></tr></thead><tbody><tr><td>高级语言层</td><td>最高</td><td>无</td><td>最低</td></tr><tr><td>汇编语言层</td><td>低</td><td>高</td><td>高</td></tr><tr><td>操作系统层</td><td>中</td><td>中</td><td>中</td></tr><tr><td>指令系统层</td><td>低</td><td>极高</td><td>极高</td></tr><tr><td>硬件层</td><td>无</td><td>完全依赖</td><td>最高</td></tr></tbody></table><ul><li>硬件层与微程序层实现物理计算能力。</li><li>操作系统层管理资源并向上提供接口。</li><li>汇编/高级语言层构建用户可编程的软件生态。</li></ul><blockquote><p>硬件和软件<mark>逻辑</mark>上有等价性，硬件执行<strong>速度高</strong>，软件<strong>灵活</strong><br>软件的功能可以用硬件取代</p></blockquote><table><thead><tr><th><strong>特性</strong></th><th><strong>硬件实现</strong></th><th><strong>软件实现</strong></th></tr></thead><tbody><tr><td><strong>性能与速度</strong></td><td>高（专用电路并行处理，如ASIC、FPGA）</td><td>低（依赖通用CPU串行执行）</td></tr><tr><td><strong>灵活性</strong></td><td>低（功能固化，修改需重新设计电路）</td><td>高（代码可动态更新，适应新需求）</td></tr><tr><td><strong>开发成本</strong></td><td>高（需定制芯片设计、流片费用）</td><td>低（编写代码，复用通用硬件）</td></tr><tr><td><strong>适用场景</strong></td><td>高频交易、实时信号处理、密码学加速</td><td>操作系统、应用软件、动态调整功能的场景</td></tr></tbody></table><h3 id="存储过程">存储过程</h3><ul><li>主存储器：包含存储体、MAR、MDR<ul><li><strong>存储体</strong>：<ul><li>由若干个<strong>存储单元</strong>组成<ul><li>每个存储单元由若干个<strong>存储元件</strong>组成<ul><li>每个存储元件能存储1位二进制数0/1</li></ul></li><li>一个存储单元中可存储一串二进制信息，称这串二进制信息为一个<strong>存储字</strong>，这串二进制信息的位数称为<strong>存储字长</strong>（可以是8位、16位或32位等）</li></ul></li><li>给每个存储单元都赋予一个编号，称为<strong>存储单元的地址</strong></li></ul></li><li><strong>内存地址寄存器（MAR）</strong><ul><li>功能：</li><li>保存<strong>数据目标地址</strong>或<strong>数据源地址</strong>，用于寻址主存单元。</li><li><strong>连接存储器与地址总线</strong>，传递地址信号。</li><li>物理实现：</li><li>集成于CPU中，但逻辑上属于<strong>主存储器</strong>的组成部分。</li><li>位数与容量：</li><li><strong>位数 = 存储单元地址数量</strong>（如10位MAR支持2^10=1024个存储单元，即1KB），反应最多可寻址的存储单元个数<br>存储单元：存放一串二进制代码，存储器一次操作的基本单位。</li><li><mark>MAR长度与<strong>PC（程序计数器）</strong> 一致</mark>，决定寻址空间。</li></ul></li><li><strong>内存数据寄存器（MDR）</strong>：<br><strong>临时缓存从主存（内存）读取或写入的数据或指令</strong>，充当 CPU 与主存之间的<strong>数据中转站</strong><ul><li><strong>读取数据时</strong>：暂存从主存读取的指令或操作数。</li><li><strong>写入数据时</strong>：暂存待写入主存的数据。</li><li>功能：</li><li>是CPU与主存之间的<strong>唯一数据通道</strong></li><li><strong>连接存储器与数据总线</strong>，传输数据信号。</li><li>物理实现：<ul><li>集成于CPU中，逻辑上属于<strong>主存储器</strong>的组成部分。</li></ul></li><li>位数与字长：</li><li><strong>位数 = 存储字长</strong>（如32位MDR对应32位存储单元）。<br>存储字长：存储单元中二进制代码的位数每个存储单元赋予一个地址号</li><li>一般为字节（8位）的整数倍（如32位、64位）。</li></ul></li></ul></li></ul><p>eg1.MAR=4位，MDR=8位<br>存储单元个数16，存储字长8位<br>eg2.若存储字长为8位，MAR的位数(长度)为16位，则存储体的总容量<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327120211029.png" alt="image.png"></p><p><strong>主存储器的核心组件</strong><br>主存储器是计算机中用于存储程序和数据的关键部件，其核心功能是通过地址访问存储单元，完成数据的读写操作。<br><strong>主存储器按地址存取</strong>：通过MAR指定地址，MDR暂存数据，存储体存储二进制信息。</p><table><thead><tr><th><strong>组件</strong></th><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>存储体</strong></td><td>存储二进制数据，由多个存储单元构成，每个单元有唯一地址。</td><td>每个存储单元的大小通常为1字节（8位），地址范围由地址总线的宽度决定。</td></tr><tr><td><strong>地址寄存器MAR</strong></td><td>存放当前要访问的存储单元的地址。</td><td>MAR（Memory Address Register）接收来自CPU或总线的地址信号。</td></tr><tr><td><strong>数据寄存器MDR</strong></td><td>暂存从存储器读出的数据或待写入存储器的数据。</td><td>MDR（Memory Data Register）在读写操作中作为数据缓冲，确保数据稳定传输。</td></tr><tr><td><strong>时序控制逻辑</strong></td><td>产生存储器操作所需的控制信号（如读/写信号、片选信号），协调各部件时序。</td><td>控制逻辑根据CPU指令生成时序信号，确保操作按步骤执行。</td></tr><tr><td>![image.png</td><td>350](<a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326113413143.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250326113413143.png</a>) <strong>读操作流程（MAR→存储体→MDR→CPU）</strong></td><td></td></tr></tbody></table><ol><li><strong>加载地址</strong>：CPU将目标地址送入<strong>MAR</strong>。</li><li><strong>发出读命令</strong>：时序控制逻辑生成<strong>读信号</strong>（Read Enable）。</li><li><strong>数据读取</strong>：存储体根据MAR中的地址定位存储单元，将数据送入<strong>MDR</strong>。</li><li><strong>数据传输</strong>：CPU从MDR中读取数据。</li></ol><p><strong>写操作流程（CPU→MDR→MAR→存储体）</strong></p><ol><li><strong>加载地址与数据</strong>：CPU将目标地址送入<strong>MAR</strong>，待写数据送入<strong>MDR</strong>。</li><li><strong>发出写命令</strong>：时序控制逻辑生成<strong>写信号</strong>（Write Enable）。</li><li><strong>数据写入</strong>：存储体根据MAR中的地址定位存储单元，将MDR中的数据写入该单元。</li></ol><p><strong>时序控制逻辑的作用</strong></p><ul><li><strong>同步操作</strong>：确保地址加载、数据读写等步骤按严格时序执行。<ul><li>例如：在读取时，MAR地址稳定后，才允许存储体输出数据到MDR。</li></ul></li><li><strong>信号生成</strong>：<ul><li><strong>读信号（RE）</strong>：允许存储体输出数据到MDR。</li><li><strong>写信号（WE）</strong>：允许MDR数据写入存储体。</li><li><strong>片选信号（CS）</strong>：在多存储器模块中选择目标模块。</li></ul></li></ul><p>eg.假设CPU执行指令 <code>LOAD [0x1000]</code>（读取地址0x1000的数据）：</p><ol><li>CPU将地址<code>0x1000</code>写入MAR。</li><li>时序逻辑发出读信号，存储体将地址<code>0x1000</code>对应的数据送入MDR。</li><li>CPU从MDR中读取数据并存入寄存器（如AX）。</li></ol><p>CPU通过PC和MAR向存储器发去取指令请求(发送指令地址)并且把读信号送到控制线上，一起告诉存储器要读哪一个地方的信息；<br>读出来的信息传到MDR，如果是指令则传到IR；如果是数据就送到寄存器，再送到ALU计算，或者直接送到ALU。</p><p><mark><strong>计算机如何分辨此时取出的是数据还是指令呢？</strong></mark><br>根据<mark>指令周期</mark>的不同阶段判断。<br>在<strong>取指令</strong>阶段取出的是<strong>指令</strong>，在<strong>执行</strong>指令阶段取出的是<strong>数据</strong>。</p><h2 id="计算机的基本工作原理">计算机的基本工作原理</h2><h3 id="计算机硬件组成的细化">计算机硬件组成的细化</h3><h4 id="加减乘除操作">加减乘除操作</h4><ul><li><strong>累加器ACC</strong>，一种<strong>专用寄存器</strong>（非ALU直接部件），用于暂存ALU<strong>前一次运算的结果</strong>或<strong>初始操作数（被加数/被减数/被乘数/乘机高位/被除数/余数）</strong>，在加减法中作为运算的基准值。（例如：执行<code>A = A + B</code>时，累加器存放<code>A</code>的值）</li><li><strong>乘商寄存器MQ</strong>：在乘法和除法运算中，存储<strong>乘数/商/乘积低位</strong>。<ul><li><strong>乘法存储逻辑</strong>：<ul><li>乘法结果的位数通常是操作数的两倍（如 8位 × 8位 → 16位），因此需两个寄存器存储。</li><li><strong>ACC存储高位，MQ存储低位</strong><br>例如：<code>5 (ACC) × 3 (MQ)</code> → 结果为 <code>15</code>，高位 <code>0</code>（若为 8位系统）存 <code>ACC</code>，低位 <code>15</code> 存 <code>MQ</code>。</li><li><strong>X存储被乘数</strong><br>在乘法前，<code>ACC</code> 的被乘数需暂存至 <code>X</code>，以便释放 <code>ACC</code> 存储结果高位。</li></ul></li><li><strong>除法存储逻辑</strong>：<ul><li><strong>ACC存储余数，MQ存储商</strong>：<br>例如：<code>15 ÷ 4</code> → 商为 <code>3</code>（存 <code>MQ</code>），余数 <code>3</code>（存 <code>ACC</code>）。</li><li><strong>X存储除数</strong>：从主存加载除数到 <code>X</code>，保证除法操作的稳定性。</li></ul></li></ul></li><li><strong>操作数寄存器X</strong>：用于临时存储<strong>从主存或指令中获取的第二个操作数（加数/减数/乘数/除数）</strong></li></ul><table><thead><tr><th>寄存器</th><th>加法</th><th>减法</th><th>乘法</th><th>除法</th></tr></thead><tbody><tr><td><strong>ACC</strong></td><td>被加数 → 和</td><td>被减数 → 差</td><td>被乘数（操作前）→ 乘积高位</td><td>被除数 → 余数</td></tr><tr><td><strong>MQ</strong></td><td>—</td><td>—</td><td>乘数（操作前）→ 乘积低位</td><td>→ 商</td></tr><tr><td><strong>X</strong></td><td>加数</td><td>减数</td><td>被乘数（从ACC复制）</td><td>除数</td></tr><tr><td>M 表示主存储器中某个存储单元的地址</td><td></td><td></td><td></td><td></td></tr><tr><td>(M)表示地址为M的存储单元中的内容</td><td></td><td></td><td></td><td></td></tr><tr><td>ACC 表示累加器</td><td></td><td></td><td></td><td></td></tr><tr><td>(ACC)表示累加器中的内容</td><td></td><td></td><td></td><td></td></tr><tr><td>MQ 表示乘商寄存器</td><td></td><td></td><td></td><td></td></tr><tr><td>(MQ)表示乘商寄存器中的内容</td><td></td><td></td><td></td><td></td></tr><tr><td>X表示操作数寄存器</td><td></td><td></td><td></td><td></td></tr><tr><td>(X)表示操作数寄存器中的内容</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>加法操作过程<ol><li>(M)→X：从主存地址 M 取出内容（加数），送入操作数寄存器 X</li><li>(ACC)+(X)→ACC：累加器 ACC 中的被加数与 X 中的加数相加，结果（和）存回 ACC。</li></ol></li><li>减法操作过程<ol><li>(M)→ X</li><li>(ACC)-(X)→ACC</li></ol></li><li>乘法操作过程<ol><li>(M) → MQ：取出存放在主存中地址为M的存储单元中的内容(M)(乘数)，送到乘商寄存器MQ中</li><li>(ACC)→X：将累加器ACC中的内容(ACC)(被乘数)，送到操作数寄存器X中</li><li>(X) x (MQ)→ ACC // MQ：将操作数寄存器X中的内容(X)(被乘数)与乘商寄存器MQ中的内容(MQ)(乘数)相乘结果(积)的高位保留在累加器ACC中，低位保留在乘商寄存器MQ中</li></ol></li><li>除法操作过程<ol><li>(M)-&gt;X</li><li>(ACC) ÷ (X)→ MQ</li></ol></li></ul><p>共同点：取出存放在主存储器中地址为M的存储单元中的内容(M)，送到某个寄存器中</p><p>y = a * b + c<br>a=2,b=3,c=1,y=0<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327101752137.png" alt="image.png"><br>注：</p><ol><li>程序执行前，由于冯诺依曼“存储程序”的思想，先将程序的机器指令序列（操作码+地址码）存放到存储体</li><li>程序执行前，先将程序的第一条指令的地址存放到PC中，PC=0，</li><li>任何指令的执行都从<strong>取指令</strong>开始，此时 CPU 需要从内存中读取指令。因此，取指令阶段固定为<strong>读操作</strong></li><li>执行阶段由操作码决定读/写</li><li><strong>MAR</strong>：仅用于存储地址，不参与数据处理。</li><li><strong>MDR</strong>：作为 CPU 与主存间的数据缓冲，所有读写均需经过 MDR。</li></ol><p><strong>执行流程</strong>：</p><ol><li><p>取数 <code>a</code> 至 ACC</p><ul><li><strong>指令地址</strong>：<code>0</code>（PC=0）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC=0) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，从内存地址 <code>0</code> 读取指令 <code>000001 0000000101</code>（操作码 <code>取数</code>，地址码 <code>5</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>1</code>。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327105809223.png" alt="image.png"></li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“取数”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=5 → MAR</code>，将IR中保存的指令地址码送至内存的MAR中，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，从地址 <code>5</code> 读取数据 <code>a=2</code>送入MDR。</li><li><code>(MDR) → ACC</code>，将 <code>a=2</code> 存入累加器 ACC。</li></ul></li></ol></li></ul></li><li><p>乘法 <code>a * b</code>，结果存于 ACC</p><ul><li><strong>指令地址</strong>：<code>1</code>（PC=1）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000100 0000000110</code>（操作码 <code>乘法</code>，地址码 <code>6</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>2</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“乘法”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=6 → MAR</code>，发送地址 <code>6</code> 到内存。</li><li><code>M(MAR) → MDR</code>，从地址 <code>6</code> 读取数据 <code>b=3</code>。</li><li><code>(MDR) → MQ</code>，将 <code>b=3</code> 存入乘商寄存器 MQ。</li><li><code>(ACC)=2 → X</code>，将 ACC 的值 <code>2</code> 送入 X 寄存器。</li><li><code>(MQ)*(X) → ACC</code>，ALU 执行 X * MQ，结果为 <code>6</code>，存入 ACC</li></ul></li></ol></li></ul></li><li><p>加法 <code>a * b + c</code>，结果存于 ACC</p><ul><li><strong>指令地址</strong>：<code>2</code>（PC=2）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC=2) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000011 0000000111</code>（操作码 <code>加法</code>，地址码 <code>7</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>3</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“加法”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=7 → MAR</code>，发送地址 <code>7</code> 到内存。</li><li><code>M(MAR) → MDR</code>，从地址 <code>7</code> 读取数据 <code>c=1</code>。</li><li><code>(MDR) → X</code>，将 <code>c=1</code> 送入 X 寄存器。</li><li><code>(ACC)+(X) → ACC</code>，ALU 执行 ACC + X，结果为 <code>6 + 1 = 7</code>，存入 ACC。</li></ul></li></ol></li></ul></li><li><p>存数 <code>a * b + c</code> 至主存单元 <code>y</code></p><ul><li><strong>指令地址</strong>：<code>3</code>（PC=3）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000010 0000001000</code>（操作码 <code>存数</code>，地址码 <code>8</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>4</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“存数”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li><code>Ad(IR)=8 → MAR</code>，发送地址 <code>8</code> 到内存。</li><li><code>(ACC)=7 → MDR</code>，将 ACC 的值 <code>7</code> 存入 MDR。</li><li><code>(MDR) → M(MAR)</code>，将 <code>7</code> 写入内存地址 <code>8</code>（存储变量 <code>y</code>）。</li></ul></li></ol></li></ul></li><li><p>停机</p><ul><li><strong>指令地址</strong>：<code>4</code>（PC=4）</li><li><strong>步骤</strong>：<ol><li><strong>取指令</strong>：<ul><li><code>(PC=4) → MAR</code>，控制器将PC的内容送至内存的MAR，对内存进行寻址，并命令内存做读操作。</li><li><code>M(MAR) → MDR</code>，读取指令 <code>000110 0000000000</code>（操作码 <code>停机</code>）。</li><li><code>(MDR) → IR</code>，指令存入指令寄存器。</li><li><code>(PC) + 1 → PC</code>，PC 自增为 <code>5</code>。</li></ul></li><li><strong>分析指令</strong>：<ul><li><code>OP(IR) → CU</code>，控制单元识别为“停机”指令。</li></ul></li><li><strong>执行指令</strong>：<ul><li>CPU 终止当前进程，结果 <code>y=7</code> 已存入内存地址 <code>8</code>。</li></ul></li></ol></li></ul></li></ol><p><strong>最终结果</strong></p><ul><li><strong>内存地址 <code>8</code></strong>：存储 <code>y=7</code>。</li><li><strong>寄存器状态</strong>：<ul><li><code>ACC=7</code>，<code>MQ=3</code>（乘法中间值），<code>X=1</code>（加法操作数）。</li><li><code>PC=5</code>，指向下一条指令地址（已停机）。</li></ul></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327110944602.png" alt="image.png"></p><h4 id="1-取指令阶段"><strong>1. 取指令阶段</strong></h4><p><strong>目标</strong>：将下一条指令从主存读取到指令寄存器（IR）。<br><strong>步骤</strong>：</p><ol><li><strong>PC → MAR</strong><ul><li><strong>操作</strong>：将程序计数器（PC）当前存储的指令地址送入内存地址寄存器（MAR）。</li><li><strong>说明</strong>：<code>PC→MAR</code> 表示 <code>(PC)</code>（PC 中存储的值）通过数据通路传递到 MAR。</li></ul></li><li><strong>MAR → 地址线，控制器发送读信号</strong><ul><li><strong>操作</strong>：MAR 的内容被送至地址线，控制器向主存发送读信号。</li><li><strong>说明</strong>：主存根据地址线上的地址和读信号，定位存储单元。</li></ul></li><li><strong>主存 → 数据线 → MDR</strong><ul><li><strong>操作</strong>：主存将指定地址的指令通过数据线传输到内存数据寄存器（MDR）。</li></ul></li><li><strong>MDR → IR</strong><ul><li><strong>操作</strong>：MDR 中的指令被送入指令寄存器（IR）。</li><li><strong>结果</strong>：IR 中存储当前待执行的指令。</li></ul></li><li><strong>更新 PC</strong><ul><li><strong>操作</strong>：<code>(PC) + 1 → PC</code>，为取下一条指令准备地址。</li><li><strong>注意</strong>：<ul><li><strong>括号不可省略</strong>：运算时必须写为 <code>(PC)+1→PC</code>，表示对 PC 的值进行运算。</li><li><strong>数据通路省略</strong>：<code>PC→MAR</code> 可简写，但运算表达式需严格保留括号。</li></ul></li></ul></li></ol><h4 id="2-分析指令阶段"><strong>2. 分析指令阶段</strong></h4><p><strong>目标</strong>：解码指令并生成控制信号。<br><strong>步骤</strong>：</p><ol><li><strong>OP(IR) → CU</strong><ul><li><strong>操作</strong>：从 IR 中提取操作码（OP），送入控制单元（CU）。</li></ul></li><li><strong>CU 译码与生成控制信号</strong><ul><li><strong>操作</strong>：CU 根据操作码生成对应的控制信号，分发到各执行部件。</li><li><strong>示例</strong>（取数指令）：<ul><li>CU 生成“读主存”信号，激活总线控制线，准备读取操作数。</li></ul></li></ul></li></ol><h4 id="3-执行指令阶段"><strong>3. 执行指令阶段</strong></h4><p><strong>目标</strong>：执行当前指令的操作（以取数指令为例）。<br><strong>步骤</strong>：</p><ol><li><strong>Ad(IR) → MAR</strong><ul><li><strong>操作</strong>：将 IR 中的地址码（操作数地址）送入 MAR。</li><li><strong>示例</strong>：若指令为 <code>取数a至ACC</code>，地址码指向变量 <code>a</code> 的存储地址。</li></ul></li><li><strong>MAR → 地址线，控制器发送读信号</strong><ul><li><strong>操作</strong>：主存根据 MAR 中的地址和读信号，定位操作数存储单元。</li></ul></li><li><strong>主存 → 数据线 → MDR</strong><ul><li><strong>操作</strong>：主存将操作数通过数据线传输到 MDR。</li></ul></li><li><strong>MDR → ACC</strong><ul><li><strong>操作</strong>：MDR 中的操作数被送入累加器（ACC）。</li><li><strong>结果</strong>：ACC 中存储了所需的数据（如 <code>a=2</code>）。</li></ul></li></ol><h3 id="常见指令">常见指令</h3><p><code>LOAD</code> 指令是计算机体系结构中的一种<strong>数据传输指令</strong>，其核心功能是<strong>将数据从内存（主存）加载到CPU的寄存器中</strong>。例如，在汇编语言中，<code>LOAD R1, [0x1000]</code> 表示将内存地址 <code>0x1000</code> 处的数据加载到寄存器 <code>R1</code> 中。<br><code>LOAD</code> 指令的执行遵循经典的 <strong>5 阶段指令周期</strong>：</p><ol><li><p><strong>取指（Fetch）</strong></p><ul><li>CPU 根据程序计数器（PC）的值，从内存中读取指令（如 <code>LOAD R1, [0x1000]</code>）到指令寄存器（IR）。</li><li>PC 自动递增，指向下一条指令地址。</li></ul></li><li><p><strong>译码（Decode）</strong></p><ul><li>控制单元（CU）解析指令的操作码（<code>LOAD</code>），确定操作类型。</li><li>提取目标寄存器（<code>R1</code>）和内存地址（<code>0x1000</code>）。</li></ul></li><li><p><strong>执行（Execute）</strong></p><ul><li>将内存地址 <code>0x1000</code> 写入存储器地址寄存器（MAR）。</li><li>生成读信号（Read Enable），通知内存准备数据。</li></ul></li><li><p><strong>访存（Memory Access）</strong></p><ul><li>内存根据 MAR 中的地址定位存储单元，将数据送至存储器数据寄存器（MDR）。</li></ul></li><li><p><strong>写回（Write Back）</strong></p><ul><li>将 MDR 中的数据写入目标寄存器 <code>R1</code>，完成加载操作。</li></ul></li><li><p><strong>不同寻址方式对 <code>LOAD</code> 指令的影响</strong><br><code>LOAD</code> 指令的具体行为取决于其使用的<strong>寻址方式</strong>：</p></li></ol><ul><li><p><strong>直接寻址</strong><br>指令中直接包含内存地址（如 <code>LOAD R1, [0x1000]</code>）。<br><strong>优点</strong>：简单直观。<br><strong>缺点</strong>：地址固定，灵活性低。</p></li><li><p><strong>间接寻址</strong><br>指令中的地址指向另一个内存地址（如 <code>LOAD R1, [[R2]]</code>）。<br><strong>优点</strong>：支持动态地址计算。<br><strong>缺点</strong>：需要多次访存，速度较慢。</p></li><li><p><strong>寄存器间接寻址</strong><br>地址存储在寄存器中（如 <code>LOAD R1, [R2]</code>）。<br><strong>优点</strong>：高效灵活，适合循环遍历数组。</p></li><li><p><strong>立即数寻址</strong><br>指令直接包含数据（如 <code>LOAD R1, #42</code>）。<br><strong>注</strong>：严格来说，这属于加载立即数到寄存器，而非内存操作。</p></li></ul><ol><li><p><strong><code>LAD X, ACC</code>（Load Address to ACC）</strong></p><ul><li><strong>功能</strong>：将主存地址 <code>X</code> 的内容加载到累加器 ACC。</li><li><strong>操作</strong>：<br>$R[\text{ACC}] \leftarrow M[X]$</li><li><strong>硬件流程</strong>：<ul><li>将 <code>X</code>（地址码）送入 MAR，读取主存数据到 MDR，再传输到 ACC。</li></ul></li></ul></li><li><p><strong><code>SUB ACC, Z</code>（Subtract）</strong></p><ul><li><strong>功能</strong>：从 ACC 中减去主存地址 <code>Z</code> 的值，结果存回 ACC。</li><li><strong>操作</strong>：<br>$R[\text{ACC}] \leftarrow R[\text{ACC}] - M[Z]$</li><li><strong>硬件流程</strong>：<ul><li>读取 <code>Z</code> 的值到 MDR → 送入 ALU 的 X 寄存器 → ALU 执行减法 → 结果存回 ACC。<br><strong>取值周期（Fetch Cycle）</strong><br><strong>目标</strong>：从主存中读取下一条指令到 IR，并更新 PC。<br><strong>步骤</strong>：</li></ul></li></ul></li><li><p><strong><code>PC → BUS → MAR</code></strong></p><ul><li>程序计数器（PC）的值通过总线送至内存地址寄存器（MAR）。</li></ul></li><li><p><strong><code>M(MAR) → 数据线 → MDR</code></strong></p><ul><li>主存根据 MAR 的地址，通过数据总线将指令送入内存数据寄存器（MDR）。</li><li><strong>控制信号</strong>：控制器发送 <strong>读信号（MemRead=1）</strong>。</li></ul></li><li><p><strong><code>MDR → BUS → IR</code></strong></p><ul><li>MDR 中的指令通过总线送入指令寄存器（IR）。</li></ul></li><li><p><strong><code>(PC) + 1 → PC</code></strong></p><ul><li>PC 自增，指向下一条指令的地址。</li></ul></li></ol><p><strong>执行周期（Execute Cycle）</strong></p><h5 id="1-LAD-X-ACC-的执行流程"><strong>1. <code>LAD X, ACC</code> 的执行流程</strong></h5><ol><li><strong><code>Ad(IR) → BUS → MAR</code></strong><ul><li>将 IR 中的地址码 <code>X</code> 送入 MAR。</li></ul></li><li><strong><code>M(MAR) → 数据线 → MDR</code></strong><ul><li>主存根据 MAR 的地址，通过数据总线将数据送入 MDR。</li><li><strong>控制信号</strong>：控制器发送 <strong>读信号（MemRead=1）</strong>。</li></ul></li><li><strong><code>MDR → BUS → ACC</code></strong><ul><li>MDR 中的数据通过总线送入累加器 ACC。</li></ul></li></ol><h5 id="2-SUB-ACC-Z-的执行流程"><strong>2. <code>SUB ACC, Z</code> 的执行流程</strong></h5><ol><li><strong><code>Ad(IR) → BUS → MAR</code></strong><ul><li>将 IR 中的地址码 <code>Z</code> 送入 MAR。</li></ul></li><li><strong><code>M(MAR) → 数据线 → MDR</code></strong><ul><li>主存根据 MAR 的地址，读取 <code>Z</code> 的值到 MDR。</li></ul></li><li><strong><code>MDR → X</code></strong><ul><li>MDR 的值送入 ALU 的输入寄存器 X。</li></ul></li><li><strong>`ALU 执行减法运算</strong><ul><li><p>ALU 计算 <code>ACC - X</code>，结果存回 ACC。</p><ul><li><code>LAD</code>、<code>SUB</code> 等涉及数据加载的指令 → 读操作（<code>MemRead=1</code>）。</li><li><code>STO</code>（存数指令） → 写操作（<code>MemWrite=1</code>）。</li></ul></li></ul></li><li><strong>总线控制</strong>：<ul><li>数据总线在取值和执行阶段分别传输指令和数据。</li><li>地址总线始终由 MAR 驱动。</li></ul></li></ol><h5 id="1-操作数的加载是否必须通过主存？"><strong>1. 操作数的加载是否必须通过主存？</strong></h5><ul><li><strong>否</strong>：<ul><li>操作数可直接来自寄存器（如 <code>ADD R1, R2</code>），无需访问主存。</li><li>若操作数在主存中（如 <code>ADD [M]</code>），则需通过 <code>X</code> 或 <code>MQ</code> 中转。</li></ul></li><li><strong>示例对比</strong>：<ul><li><strong>直接寄存器操作</strong>：<code>ADD ACC, X</code>（假设指令支持）。</li><li><strong>主存操作</strong>：<code>ADD [M]</code> → <code>(M)→X → (ACC)+(X)→ACC</code>。</li></ul></li></ul><h5 id="2-加法实例"><strong>2. 加法实例</strong></h5><ul><li><strong>指令</strong>：<code>ADD [0x1000]</code></li><li><strong>步骤</strong>：<ol><li>从主存地址 <code>0x1000</code> 加载数据到 <code>X</code>（如 <code>X=5</code>）。</li><li><code>ACC</code> 中的值（如 <code>ACC=10</code>）与 <code>X</code> 相加，结果存回 <code>ACC</code>（<code>ACC=15</code>）。</li></ol></li></ul><h5 id="3-乘法实例"><strong>3. 乘法实例</strong></h5><ul><li><strong>指令</strong>：<code>MUL [0x2000]</code></li><li><strong>步骤</strong>：<ol><li>从主存地址 <code>0x2000</code> 加载乘数到 <code>MQ</code>（如 <code>MQ=3</code>）。</li><li>将 <code>ACC</code> 中的被乘数（如 <code>ACC=5</code>）暂存到 <code>X</code>。</li><li>执行乘法：<code>X=5</code> × <code>MQ=3</code> → 结果高位 <code>0</code>（ACC）、低位 <code>15</code>（MQ）。</li></ol></li></ul><h5 id="4-除法实例"><strong>4. 除法实例</strong></h5><ul><li><strong>指令</strong>：<code>DIV [0x3000]</code></li><li><strong>步骤</strong>：<ol><li>从主存地址 <code>0x3000</code> 加载除数到 <code>X</code>（如 <code>X=4</code>）。</li><li><code>ACC</code> 中的被除数（如 <code>ACC=15</code>）除以 <code>X=4</code> → 商 <code>3</code>（MQ），余数 <code>3</code>（ACC）。</li></ol></li></ul><h2 id="计算机系统的性能指标">计算机系统的性能指标</h2><p>计算机系统的性能指标是用来衡量计算机系统在各种操作和任务中的<strong>工作效率、执行速度以及处理能力</strong>的标准。<br>计算机系统的性能指标可以<strong>帮助人们评估计算机系统</strong>的整体表现，从而更好地了解系统<strong>在不同方面的优势和限制</strong><br>计算机系统的性能指标与硬件和软件都有关</p><ul><li><p>硬件与计算机系统性能的关系</p><ul><li>硬件是构建计算机系统的<strong>物理组件</strong>(例如CPU、内存、外部设备等)。</li><li>硬件对于计算机系统的性能有着重要影响，因为它决定了系统的<font color="#ff0000">计算能力、数据传输速率和存储容量</font>。<ul><li>CPU的时钟频率决定了CPU每秒钟可以执行的指令数量。</li><li>内存带宽会影响数据的读写速率。</li></ul></li></ul></li><li><p>软件与计算机系统性能的关系</p><ul><li>软件包括用于控制、管理、应用计算机系统的各类系统软件和应用软件。</li><li>软件的优化可以显著影响计算机系统的性能，因为<strong>合理的算法和代码</strong>实现可以<strong>更有效地利用硬件资源</strong>。<ul><li>操作系统的调度算法会影响多任务处理的效率，从而影响系统的响应时间。</li><li>在图像处理任务中，优化的软件算法可以减轻CPU和内存的负担，提高图形处理速度。</li><li>软件层面的并行计算可以更好地利用多核处理器，提高吞吐量。</li></ul></li></ul></li><li><p><strong>硬件是性能的上限</strong>，决定了系统的理论能力。</p></li><li><p><strong>软件是性能的下限</strong>，决定了硬件的实际利用率。</p></li><li><p><strong>软硬件协同优化</strong>是提升计算机系统性能的核心路径。</p></li></ul><h3 id="计算机硬件相关性能指标">计算机硬件相关性能指标</h3><h4 id="基本性能指标">基本性能指标</h4><ol><li><strong>机器字长</strong></li><li><strong>主存容量</strong></li><li><strong>吞吐量</strong></li><li><strong>响应时间</strong></li></ol><h4 id="与运行速度相关的性能指标">与运行速度相关的性能指标</h4><ol><li><strong>CPU时钟频率和时钟周期</strong></li><li><strong>CPI</strong></li><li><strong>CPU执行时间</strong></li><li><strong>IPC</strong></li><li><strong>MIPS</strong></li><li><strong>MFLOPS</strong></li></ol><p>概念解释：</p><ol><li><p><strong>机器字长（字长）</strong></p><ul><li><strong>定义</strong>：计算机一次能处理的二进制位数（如32位、64位），即b的数量。<br><mark>机器字长 = 用于整数运算的ALU位数 = 通用寄存器宽度 = 数据总线宽度</mark><ul><li>数据总线宽度（数据字长）= 数据总线一次能并行传送信息的位数（如32位总线一次传输4字节）</li></ul></li><li>早期：指令字长（一个指令字中包含的二进制代码的位数）=存储字长（一个存储单元存储的二进制代码的长度）=机器字长<ul><li>随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。</li><li>若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令</li><li>若指令字长等于存储字长（如均为32位），单次访存即可取指，此时<strong>取指周期=机器周期</strong>。</li></ul></li><li><strong>影响</strong>：<ul><li>字长越长，<strong>数的表示范围</strong>就越大、<strong>精度</strong>也越高。<ul><li><strong>无符号整数</strong>：0∼2<sup>n</sup>−1（n 为字长）。</li><li><strong>有符号整数</strong>：−2<sup>n−1</sup>∼2<sup>n−1</sup>−1</li><li><strong>单精度（32位）</strong>：指数8位，尾数23位，范围约 ±10<sup>38</sup></li><li><strong>双精度（64位）</strong>：指数11位，尾数52位，范围约 ±10<sup>308</sup></li></ul></li><li>字长越长，<strong>计算精度</strong>也越高<br>字长越长，小数部分的位数越多，精度越高。</li><li>字长还会影响<strong>计算速度</strong></li><li><strong>数据处理能力</strong>：字长越大，单次处理的数据量越大。</li><li><strong>地址空间</strong>：32位系统最大支持4GB内存，64位系统支持更大内存。</li><li><strong>硬件复杂度</strong>：字长增加可能提高电路复杂度。</li></ul></li></ul></li><li><p><strong>主存容量</strong></p><ul><li><strong>定义</strong>：主存储器（内存）的总存储容量，通常以GB或TB为单位。</li><li><strong>公式</strong>：<br><strong>主存容量=N×M</strong>(位，即比特b)<br>M：主存中存储单元的总数量。<br>N：每个存储单元可存储的二进制位数（如8位、64位）。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327161644732.png" alt="image.png|400"><br>增加主存(内存)容量可以<strong>减少</strong>程序运行期间对<strong>辅存</strong>(外存)的访问，由于访问内存的速度远大于访问外存的速度，因此可以提高程序的<strong>执行速度</strong>，进而提高计算机系统的性能。</li></ul></li><li><p><strong>吞吐量</strong></p><ul><li><strong>定义</strong>：<font color="#ff0000">单位时间内系统完成的任务量</font>（如每秒处理请求数），系统吞吐量<font color="#f79646">主要取决于主存的存取周期</font>。</li><li><strong>影响因素</strong>：<ul><li>CPU的处理能力</li><li>内存（主存）的访问速度</li><li>外存的访问速度</li></ul></li></ul></li><li><p><strong>响应时间</strong></p><ul><li><strong>定义</strong>：从向计算机系统<font color="#ff0000">提交作业开始</font>，到系统<font color="#ff0000">完成作业为止所需要的时间</font>（包括CPU处理、I/O等待等）。</li><li>通常把用户感觉到的响应时间分成以下两个时间：<ul><li>CPU时间：运行一个程序所花费的时间<ul><li><strong>CPU执行时间</strong>：执行用户程序本身所花费的CPU时间（一般基于此对性能评价）</li><li>系统CPU时间：为执行用户程序而花费在操作系统上的时间</li></ul></li><li>其他时间（等待时间）：用户访问内存(主存)、外存(辅存)、其他外部设备所花费的时间</li></ul></li><li>系统性能和CPU性能有一定的区别：</li><li>系统性能：系统响应时间，与CPU外的其他部分也有关系</li><li>CPU性能：用户CPU时间，即CPU执行时间<br>主频、CPI和指令条数是相互制约的</li></ul></li><li><p><strong>CPU时钟频率与时钟周期</strong></p><ul><li><strong>时钟频率</strong>：CPU每秒的时钟周期数（单位：Hz，如3.0 GHz）<br>比喻：每秒敲鼓次数。<br>频率越高，CPU“敲鼓”越快，理论上干活速度更快。</li><li><strong>时钟周期</strong>：每个<strong>脉冲信号</strong>的时间，单个时钟周期的时间（$T = \frac{1}{\text{频率}}$），如3.0 GHz对应0.333 ns），是<mark>CPU中最小的时间单位</mark>，执行指令的每个动作至少需要1个时钟周期。<br>时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成。<br>时钟周期以相邻状态单元间组合逻辑电路的最大延迟时间为基准确定。<br>时钟周期也以指令流水线的每个流水段的最大延迟时间确定。<br>比喻：每次敲鼓的时间间隔，比如鼓手每0.3秒敲一次<br>周期越短，每个动作越快完成</li><li><strong>作用</strong>：对于同类型的计算机，同一指令执行所需的CPU时钟周期的数量是一样的，因此CPU的时钟频率越高，该指令的执行速度就越快。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327130641138.png" alt="image.png"></li></ul></li><li><p><strong>CPI（Cycles Per Instruction）</strong><br><a href="https://www.doc88.com/p-38199244559254.html">计算机组成原理作业- CPU性能含解答 - 道客巴巴 (doc88.com)</a></p><ul><li><strong>定义</strong>：<mark>执行一条指令所需的平均时钟周期数。</mark><br>不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其 CPI指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，即平均CPI。<br>比喻：炒一盘菜平均需要几次操作<br>CPI越低效率越高</li><li><strong>计算</strong>：<br>$\text{CPI} = \frac{\text{总时钟周期数}}{\text{总指令数}}$<br>$CPI = \sum_{i=1}^{n} (CPI_i \times P_i)$ Pi是相应指令所占比例<br>$总周期 = Σ(指令条数 × CPI)$</li><li><strong>优化</strong>：通过流水线、超标量等技术降低CPI。</li><li><strong>系统结构、指令集、计算机组织</strong>都会影响 CPI，而<strong>时钟频率</strong>并不会影响CPI，但缩短每个时钟周期的时间，可加快指令的执行速度。</li></ul></li><li><p><strong>CPU执行时间</strong><br>即运行一个程序所花费的时间</p><ul><li><strong>公式</strong>：<br>$\text{执行时间} = \text{总时钟周期数} \times \text{时钟周期}$<br>$\text{执行时间} = \text{总指令数} \times \text{CPI} \times \text{时钟周期}$<br>比喻：做一桌菜的总时间 = 菜的数量 × 每道菜的步骤 × 每步的时间</li><li>CPU性能（CPU执行时间）取决于：主频、CPI、指令条数【三者相互制约】</li><li><strong>缩短程序执行时间</strong>：<ul><li>减少指令数（算法优化）</li><li>降低CPI（架构优化）</li><li>提高频率（硬件升级）</li><li>优化数据通路结构，可以有效提高计算机系统的吞吐量</li><li>编译优化</li></ul></li></ul></li><li><p><strong>IPC</strong>（每个周期能做多少事，衡量指令执行速度）</p><ul><li><strong>定义</strong>：每个时钟周期执行的指令数，与CPI互为倒数（$\text{IPC} = \frac{1}{\text{CPI}}$）。<br>比喻：每个动作能炒几盘菜</li><li><strong>示例</strong>：CPI=0.5 → IPC=2，表示每个周期执行2条指令，高效。IPC越高，效率越高</li></ul></li><li><p><strong>IPS</strong>（每秒能做多少事，即）<br>IPC 表示每个时钟周期可运行的指令的数量，IPS 表示<strong>每秒可运行的指令的数量</strong>，$IPS = 频率 × IPC=频率  / 平均CPI$<br>IPS越高，说明CPU处理指令的速度越快</p></li><li><p><strong>MIPS（Million Instructions Per Second）</strong></p></li></ol><ul><li><strong>每秒执行百万条指令数</strong>，衡量CPU的<strong>整数运算吞吐量</strong>。<br>越大，性能越高</li><li><strong>公式</strong>： $\text{MIPS} = \frac{\text{时钟频率} \times \text{IPC}}{10^6} = \frac{\text{总指令数}}{\text{执行时间} \times 10^6}$</li><li>用MIPS对不同的机器进行性能比较有时是不准确的主要原因如下。<ul><li>不同机器的指令集不同，并且指令的功能也不同，在某种机器上的某一条指令的功能可能在另一种机器上需要用多条指令来实现,</li><li>不同机器的CPI和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同</li></ul></li></ul><ol start="10"><li><strong>MFLOPS（Million Floating-Point Operations Per Second）</strong></li></ol><ul><li><strong>每秒百万次浮点运算</strong>，衡量浮点计算能力。</li><li>用于==科学计算的计算机中，是标志系统性能最有用的参数 ==</li><li><strong>计算</strong>：$\text{MFLOPS} = \frac{\text{浮点操作总数}}{\text{执行时间} \times 10^6}$</li><li>MFLOPS不能全面反映计算机系统的性能。MFLOPS仅反映浮点运算速度，其值与所使用的测试程序相关。不同测试程序中包含的浮点运算量不同，测试得到的结果也不相同。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327153330760.png" alt="image.png">GTPEZ<br>采用并行技术是实现高性能计算的重要途径，现今超级计算机均采用多处理器来增强并行处理能力。</li></ul><h3 id="指标间的关系与权衡"><strong>指标间的关系与权衡</strong></h3><table><thead><tr><th><strong>指标</strong></th><th><strong>优化策略</strong></th><th><strong>实际应用中的权衡</strong></th></tr></thead><tbody><tr><td><strong>时钟频率</strong></td><td>提高制程工艺、优化散热</td><td>高频可能导致功耗和发热增加</td></tr><tr><td><strong>CPI/IPC</strong></td><td>改进微架构（如流水线、乱序执行）</td><td>复杂架构可能增加设计成本和延迟</td></tr><tr><td><strong>MIPS/MFLOPS</strong></td><td>优化指令集、并行计算</td><td>MIPS忽略指令类型差异，MFLOPS依赖任务特性</td></tr><tr><td><strong>吞吐量 vs 响应时间</strong></td><td>负载均衡、异步处理</td><td>高吞吐量可能牺牲单任务响应速度</td></tr></tbody></table><h3 id="使用基准程序进行性能评估">使用基准程序进行性能评估</h3><ul><li>基准程序(Benchmark)是一组特定的程序，专门用于评测计算机的性能。</li><li>这些程序能够有效地模拟计算机在处理实际任务时的表现。</li><li>在不同计算机上运行同样的基准程序，通过比较各计算机运行基准程序的时间，从而评测它们各自的性能不同基准程序的评测重点不同，例如CPU性能、图形性能、存储性能、浮点数计算性能、并行计算性能等。目前国际上流行的基准程序主要有SPEC、Linpack、Dhrystone、Whetstone、NPB等。</li><li>使用基准程序进行计算机性能评测也存在一些缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或编译器开发者可能针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得不到准确的性能评测结果。</li></ul><p>衡量计算机系统性能是一项比较复杂的任务，很难仅凭借单一指标进行精确衡量。<br>上述一些衡量计算机性能的指标之间也不是完全独立的，改变其中一项指标可能会影响到其他指标。</p><h2 id="第一章错题">第一章错题</h2><ol><li><p>2017年公布的全球超级计算机TOP500排名中，我国“神威·太湖之光”超级计算机蝉联第其浮点运算速度为93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为()<br>A. 9.3x1013次   B.9.3x1015次   c.9.3千万亿次   D.9.3亿亿次<br>d</p></li><li><p>假定基准程序A在某计算机上的运行时间为100s，其中90s为CPU时间，其余为I/O时间。若CPU速度提高50%，I/0速度不变，则运行基准程序A所耗费的时间是()。A.55s   B. 60s   C.65s   D.70s<br>新CPU时间 = 原CPU时间 / 1.5 = 90秒 / 1.5 = 60秒<br>新总时间 = 新CPU时间 + I/O时间 = 60秒 + 10秒 = 70秒</p></li><li><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250327163149037.png" alt="image.png"></p></li><li><p>有三种不同的处理器A,B和C执行同样的指令集，A的时钟频率为3GHz，CPI为1.5；B的时钟频率为2.5GHz，CPI为1.0；C的时钟频率为4GHz，CPI为2.2.<br>（1）以每秒钟执行的指令数目为标准，哪个处理器的性能最高？<br>（2）如果每个处理器执行一个程序都需花费10秒的时间，求它们的时钟周期数和指令数。<br>（3）我们试图把执行时间减少30%，但这会引起CPI增加20%。问：时钟频率应该是多少才能达到程序执行时间减少30%的目的？<br>(1)已知时钟频率和CPI，可以求MIPS反映性能，分别是2，2.5，1.82 GIPs。B最高<br>(2)时钟周期数=运行时间×f，时钟周期数分别是3，2.5，4 × 10^10<br>CPI=时钟周期数/指令条数，指令数分别是2，2.5，0.18 × 10^10<br>(3)原执行时间 ($T = \frac{\text{指令数} \times \text{CPI}}{\text{频率}}$)<br>新要求：$0.7T = \frac{\text{指令数} \times 1.2\text{CPI}}{\text{新频率}}$<br>解得：$\text{新频率} = \frac{1.2}{0.7} \times \text{原频率} \approx 1.714 \times \text{原频率}$<br>新频率需为1.71f</p></li><li><p>CPU 不包括()<br>A.地址寄存器   B.地址译码器   C.指令寄存器(IR)   D.通用寄存器<br>CPU 主要包括 运算器（ALU、通用寄存器、状态寄存器） 和 控制器（IR、PC、CU）。地址译码器 属于存储器（如主存）的组成部分，用于将地址总线信号转换为对特定存储单元的访问，不属于 CPU 内部结构。</p></li><li><p>在运算器中，不包含()<br>A.状态寄存器   B.数据总线   C. ALU   D.地址寄存器<br>数据总线在运算器中用于传输操作数，选d</p></li><li><p>若一个8位的计算机系统以 16 位来表示地址，则该计算机系统有( )个地址空间<br>A.256   B.65535   C.65536   D. 131072<br>8 位计算机表明计算机字长为8位，即一次可以处理8位的数据；而 地址空间大小仅由地址位数决定，与数据总线宽度（8位）无关，16 位表示地址码的长度，因此该机器有2^6=65536 个地址空间。</p></li><li><p>()是程序运行时的存储位置，包括所需的数据。<br>A.数据通路   B.主存   C.硬盘   D.操作系统<br>b</p></li><li><p>机器 A 的主频为 800MHz，某程序在 A 上运行需要 12s。现在硬件设计人员想设计机器B,希望该程序在B上的运行时间能缩短为 8s，使用新技术后可使B的主频大幅度提高，但在B上运行该程序所需的时钟周期数为在A上的1.5倍。则机器B的主频至少应为( )。<br>时钟周期数=主频×运行时间<br>时钟周期数A=800M×12s     时钟周期数B=1.5×800M×12s<br>主频B=1.5×800M×12s / 8  = 1.8GHz</p></li><li><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330210323965.png" alt="image.png">CPI1=2.5，CPI2=2，MIPS1=500×10^6 / 2.5×10^6=200，MIPS2=500×10^6 / 2×10^6=250；总周期 = Σ(指令条数 × CPI)，总周期1=15，总周期2=10，所以执行时间1=总时钟周期数×时钟周期=15×2ns=30ns，执行时间2=20ns，d</p></li><li><p>若机器 M的主频为 1.5GHz，在 M 上执行程序P的指令条数为 5x10^5，P的平均 CPI为 1.2，则P在M 上的指令执行速度和用户 CPU 时间分别为( )。<br>A.08GIPS,0.4ms       B.08GIPS,0.4us<br>C.1.25GIPS,0.4ms    D. 1.25GIPS,0.4us<br>IPC指令执行速度=主频/CPI=1.5GHz/1.2=1.25GIPS<br>CPU时间=指令数×CPI/主频=5x10^5×1.2/1.5×10^9=0.4ms</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（二）</title>
      <link href="/post/undefined.html"/>
      <url>/post/undefined.html</url>
      
        <content type="html"><![CDATA[<h1>1 计算机内部的数据表示</h1><h2 id="1-1-数值转换与编码">1.1 数值转换与编码</h2><p>基数r：进位计数制中，每个数位所用到的不同数码个数<br>真值（前面带+/-）：现实中用于计算的数据，在计算机中不存在；<br>正数或负数的真值为其绝对值对应的二进制数前面加上正号或负号。<br>例如+1 表示为 +00000001，-1 表示为 -00000001；<br>移码大真值就大<br>补码若符号位相同，数值位越大（即二进制中1的位数越多），码值越大。若 <code>1</code> 的个数相同，<strong>最高位的 <code>1</code> 位置越靠左（权重越大），码值越大</strong>。</p><table><thead><tr><th><strong>进制名称</strong></th><th><strong>基数</strong></th><th><strong>数码范围</strong></th><th><strong>进位规则</strong></th><th><strong>权值</strong></th><th><strong>示例</strong></th><th><strong>二进制转换规则</strong></th><th><strong>表示方法（后缀/前缀）</strong></th><th><strong>C语言表示</strong></th></tr></thead><tbody><tr><td><strong>二进制</strong></td><td>2</td><td>0, 1</td><td>逢二进一</td><td>2^i</td><td>101011<sub>2</sub></td><td>3位二进制 → 1位八进制</td><td>后缀<code>B</code>（如<code>101011B</code>）</td><td><code>0b101011</code></td></tr><tr><td><strong>八进制</strong></td><td>8</td><td>0, 1, 2, 3, 4, 5, 6, 7</td><td>逢八进一</td><td>8^i</td><td>101011<sub>8</sub></td><td>1位八进制 → 3位二进制</td><td>后缀<code>O</code>（如<code>101011O</code>）</td><td><code>0101011</code>（前导0）</td></tr><tr><td><strong>十进制</strong></td><td>10</td><td>0, 1, 2, …, 9</td><td>逢十进一</td><td>10^i</td><td>101011<sub>10</sub></td><td>无直接转换</td><td>无后缀（如<code>101011</code>）</td><td><code>101011</code></td></tr><tr><td><strong>十六进制</strong></td><td>16</td><td>0-9, A-F（10-15）</td><td>逢十六进一</td><td>16^i</td><td>101011<sub>16</sub></td><td>4位二进制 → 1位十六进制</td><td>后缀<code>H</code>（如<code>101011H</code>）</td><td><code>0x101011</code></td></tr><tr><td>2^-1=0.5，2^-2=0.25，2^-3=0.125</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><p><strong>二进制↔八进制数</strong><br>二进制→八进制：从小数点向左右划分，每三个一组，不够的补零<br>八进制→二进制：每个八进制数转换为三位二进制数，前后去0</p></li><li><p><strong>二进制↔十六进制数</strong><br>二进制→十六进制：从小数点向左右划分，每四个一组，不够的补零<br>十六进制→二进制：每个十六进制数转换为四位二进制数，前后去0</p></li><li><p><strong>八进制→十六进制</strong><br>先转二进制，在转十六进制</p></li><li><p><strong>十进制小数→任意进制（除基取余，乘基取整）</strong><br>除基取余针对整数部分，乘基取整针对小数部分<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328084356810.png" alt="image.png"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328084506522.png" alt="image.png"></p><ul><li><strong>注</strong>：<br>若转换后无限循环（精度缺失），需根据精度要求截断。<br>十进制小数转八进制和十六进制小数也可能出现精度缺失</li></ul></li><li><p><strong>BCD码（Binary-Co ded Decimal）</strong></p><ul><li><strong>压缩BCD码</strong>：用<font color="#ff0000">4位</font>二进制表示1位十进制数（如 <code>9 → 1001</code>）。</li><li><strong>非压缩BCD码</strong>：用<font color="#ff0000">8位</font>二进制表示1位十进制数（如 <code>9 → 00001001</code>）。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328090505451.png" alt="image.png"></li><li><strong>常见编码类型</strong>：<ul><li><strong>8421码（自然BCD码）</strong>：<ul><li>加法后若结果超过9（如 <code>1001 + 1001 = 1 0010</code>），需加 <code>0110</code>（6）校正。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328090725385.png" alt="image.png"></li></ul></li><li><strong>余3码</strong>：无权码，每个数比原值大3（如 <code>0 → 0011</code>）。</li><li><strong>2421码</strong>：有权码，5~9的最高位为1（如 <code>5 → 1011</code>）。</li></ul></li></ul></li><li><p><strong>ASCII码</strong></p><ul><li><strong>范围</strong>：<ul><li><code>0-9</code>：<code>30H-39H</code>（48-57）。</li><li><code>A-Z</code>：<code>41H-5AH</code>（65-90）。</li><li><code>a-z</code>：<code>61H-7AH</code>（97-122）。</li></ul></li></ul></li></ol><h2 id="1-2-定点数的编码">1.2 定点数的编码</h2><h3 id="1-2-1-定点数">1.2.1 定点数</h3><ul><li><strong>定义</strong>：小数点位置固定，分为<strong>定点整数</strong>和<strong>定点小数</strong>。</li><li><strong>表示范围</strong>：</li></ul><table><thead><tr><th>类型</th><th>范围（n位）</th><th>8位二进制范围</th></tr></thead><tbody><tr><td><strong>定点整数</strong></td><td>$-2^{n-1} \leq x \leq 2^{n-1} - 1$</td><td>-128~127</td></tr><tr><td><strong>定点小数</strong></td><td>$-1 \leq x \leq 1 - 2^{-(n-1)}$</td><td>-1~0.992</td></tr></tbody></table><ul><li><p>数据范围影响因素</p><ul><li>机器字长：越长，越大</li><li>所采用的机器码：补码和移码所能表示的数据范围，比原码和反码所能表示的数据范围要多一个最小负数。</li></ul></li><li><p><strong>定点整数</strong>：</p><ul><li>小数点固定在数值位最右侧。<br>一般用<mark>补码</mark>表示<br>总位数为 n+1 位，给定真值  x ，其补码 [x]补 定义为：$[x]_{\text{补}} = \begin{cases} x &amp; \text{若 } 0 \leq x &lt; 2^{n}, \2^{n+1} + x &amp; \text{若 } -2^{n} \leq x &lt; 0 \ (\text{mod } 2^{n+1}).\end{cases}$<ul><li><strong>模数</strong>： $2^{n+1}$ ，即补码表示的数值范围在模  $2^{n+1}$  下。<br>以  n = 3 （总位数  n+1 = 4 ）为例：</li><li>x = -5 ：补码为  $2^{4} + (-5) = 16 - 5 = 11$ ，即 <code>1011</code>。</li></ul></li></ul></li><li><p><strong>定点小数</strong>：</p><ul><li>小数点固定在符号位右侧。</li><li><strong>示例</strong>：<code>1.011</code>表示<code>-0.625</code>（补码）。</li></ul></li></ul><p>注：拓展位不一样<br>定点小数：<br>[x]原=1.110<br>[x]原= 1.1100000<br>定点整数：<br>[x]原=1,110<br>[x]原= 1,0000110</p><h3 id="1-2-2-原码">1.2.2 原码</h3><ol><li><p><strong>定义</strong>：</p><ul><li>原码是最基础的二进制表示方法，<strong>符号位 + 数值位</strong>。</li><li><strong>符号位</strong>：最高位，<code>0</code>表示正数，<code>1</code>表示负数。</li><li><strong>数值位</strong>：绝对值的二进制形式。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><code>+5</code>（4位）：<code>0 101</code></li><li><code>-5</code>（4位）：<code>1 101</code></li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>优点</strong><ul><li>与真值的对应关系简单、直观，与真值的转换简单</li><li>用原码实现乘除运算比较简便。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>符号位不能直接参与运算</strong>，用原码实现加减运算比较复杂</li><li><strong>0的表示不唯一，有±0两个编码</strong>：<code>+0</code>（<code>0 000</code>）和 <code>-0</code>（<code>1 000</code>）。</li></ul></li></ul></li></ol><p>原码在计算机中仅用于表示浮点数的尾码<br>计算：<br>加法:正+正或负+负 结果可能溢出<br>减法：负数取反</p><h3 id="1-2-3-反码">1.2.3 反码</h3><ol><li><p><strong>定义</strong>：</p><ul><li><strong>正数</strong>：与原码相同。</li><li><strong>负数</strong>：符号位不变，数值位按位取反。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><code>+5</code>（4位）：<code>0 101</code></li><li><code>-5</code>（4位）：<code>1 010</code></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>符号位可以参与运算</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>最高位(符号位)产生的进位要加到运算结果的低位(循环进位)</li><li>真值0在反码中有两种不同的表示</li></ul></li></ol><h3 id="1-2-4-补码">1.2.4 补码</h3><ol><li><p><strong>定义</strong>：</p><ul><li><strong>正数</strong>：与原码相同。</li><li><strong>负数</strong>：反码加1（符号位不变）。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><code>+5</code>（4位）：<code>0 101</code></li><li><code>-5</code>（4位）：<code>1 011</code>（反码<code>1 010</code> + 1）</li></ul></li><li><p><strong>优点</strong>：</p><ul><li><strong>统一加减法</strong>：减法可转换为加法（<code>A - B = A + (-B)</code>）。</li><li><strong>唯一0表示</strong>：<code>0 000</code>，无<code>-0</code>。使得补码比原码多表示一个最小负数</li><li><strong>硬件友好</strong>：无需额外处理符号位，简化电路设计。</li></ul></li><li><p><strong>缺点</strong>：<br>补码的表示相对原码更加复杂。<br>原码的数值位与真值的绝对值相同。因此，通过原码可以很容易地得出真值。但是，补码就没有这么简单了。</p></li><li><p><strong>补码快速转换</strong>：</p><ul><li>从右往左找到第一个<code>1</code>，该位左侧数值位取反。</li><li><strong>示例</strong>：<code>-5</code>（原码<code>1 101</code> → 补码<code>1 011</code>）。</li></ul></li></ol><p>补码1111 1111是-1<br>补码1000 0000是-128<br>8位补码所表示的真值x的范围：-128 ≤ x ≤ 127<br>16位补码所表示的真值x的范围：-32768 ≤ x ≤ 32767<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328123122040.png" alt="image.png"><br>3. <strong>补码运算示例</strong>：<br>$[A + B]<em>{\text{补}} = [A]</em>{\text{补}} + [B]<em>{\text{补}}, \quad [A - B]</em>{\text{补}} = [A]<em>{\text{补}} + [-B]</em>{\text{补}}$<br>可以验证结果$[A + B]<em>{\text{补}} = [A+B]</em>{\text{补}}$<br>$(-5) + 3 = 11111011_2 + 00000011_2 = 11111110_2 = -2_{10}$<br>[-0.0101]原=[1.1011]补<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328123942413.png" alt="image.png|350">补码的补码是原码<br>[x]补=1,011 0100 [x]原=1,100 1100<br>4. 补码的真值计算公式为：<br>$真值=−符号位×2^{n−1}+剩余位的无符号值$<br>对于 <code>11100000</code>：$真值=−1×2^7+1100000_2=−128+96=−32$<br>技巧：对于n位补码，其真值为最高位的-2^(n-1)加上其余各位的正权重之和。<br>eg.<code>1 1011</code>=-2^4+8+2+1=-5<br>5. $[-x]<em>{\text{补}} = \text{全部位取反}([x]</em>{\text{补}}) + 1$<br><mark>对-40求补运算，就是求40的补码。就是求相反数的补码</mark><br>1. <strong>正数转负数</strong>：<br>- 设[x]补 = <code>00000101</code>（+5）<br>- <strong>取反</strong>：<code>11111010</code><br>- <strong>加1</strong>：<code>11111010 + 1 = 11111011</code><br>- <strong>结果</strong>：[-x]补 = <code>11111011</code>（-5）</p><pre><code>2. **负数转正数**：   - 设\[x\]补 = `11111011`（-5）     - **取反**：`00000100`     - **加1**：`00000100 + 1 = 00000101`     - **结果**：\[-x\]补 = `00000101`（+5）</code></pre><ol start="6"><li>定点小数的补码<br>正数补码和原码相同，负数补码定义为$[X]<em>{\text{补}} = 2 + X$（模2）。<br>负数的补码是其绝对值的“模2补数”。<br>eg.X = -0.101，则：$[X]</em>{\text{补}} = 2 + (-0.101) = 10.000 + 1.011 = 11.011(\text{舍去超过整数位的最高位}) = 1.011 \quad (\text{二进制})$<br>对于整数部分占1位、小数部分占n位的数，补码的一般形式为：$[X]<em>{\text{补}} = 2^{n+1} + X \quad (\text{模 } 2)$<br>eg.n=3，X = -0.101$[X]</em>{\text{补}} = 2^{4} + (-0.101) = 16 - 0.625 = 15.375 \mod 16 = 1.011 \quad (\text{二进制})$  对应补码 <code>1.011</code>（十进制 -0.101）。</li><li>补码加减法的硬件实现<br>补码加减法可通过<strong>同一个加法器</strong>实现，核心设计如下：<ul><li><strong>控制信号 <code>Sub</code></strong>：决定执行加法或减法。</li><li><strong><code>Sub = 0</code></strong>：加法运算，输入为 <code>X</code> 和 <code>Y</code>。</li><li><strong><code>Sub = 1</code></strong>：减法运算，输入为 <code>X</code> 和 <code>Y</code> 的反码，并<strong>末位加1</strong>（通过低位进位实现）。</li><li><strong>电路设计</strong>：</li><li><strong>多路选择器（MUX）</strong>：选择 <code>Y</code> 或 <code>~Y</code>（取反）。</li><li><strong>加法器</strong>：接收 <code>X</code> 和 MUX 输出，同时将 <code>Sub</code> 作为初始<strong>低位进位输入</strong>（减法时 <code>C_in = 1</code>）。<br><strong>示例</strong>：</li><li>减法运算：<code>X - Y</code> 转换为 <code>X + (~Y) + 1</code>，即 <code>[X]补 + [-Y]补</code>。</li><li>电路公式：<code>Result = X + (Y ^ &#123;n&#123;Sub&#125;&#125;) + Sub</code>（异或门实现按位取反）。</li></ul></li></ol><h3 id="1-2-5-移码">1.2.5 移码</h3><ol><li>移码就是在真值上加一个常数 2^n（补码最前一位取反）</li><li>在数轴上，移码所表示的范围对应于真值在数轴上的范围向轴的正方向移动2^n个单元</li><li>移码只用于<strong>定点整数</strong>的表示。</li><li>优点：<ul><li>真值0在移码中只有一种表示。</li><li>移码保持了真值原有的大小顺序，可以<strong>直接比较大小</strong>。最小真值的移码为全0，最大真值的移码为全1，符合人们的习惯</li><li>当浮点数的阶码用移码来表示时，就能很方便地比较阶码的大小。</li></ul></li></ol><p>注：<br><strong>1. 移码与补码的转换适用场景</strong></p><ul><li><strong>移码</strong> 主要用于 <strong>浮点数的阶码（指数部分）</strong>，目的是将指数值转换为无符号整数，便于直接比较大小。</li><li><strong>补码</strong> 用于 <strong>普通有符号整数</strong>，简化加减法运算。</li><li><strong>关键区别</strong>：<ul><li>移码的真值计算依赖 <strong>偏置值</strong>，公式为：$\text{真值} = \text{移码值} - \text{偏置值}$</li><li>补码的真值计算依赖 <strong>符号位和数值位</strong>，无需偏置值。</li><li><font color="#ff0000">移码和补码的转换 仅在浮点数阶码处理时结合使用，普通整数无需混合操作。</font></li></ul></li></ul><p>在IEEE 754中，移码用于表示浮点数的指数（阶码），其核心公式为：</p><ul><li><strong>偏置值</strong>：对于8位阶码，IEEE 754单精度浮点数使用 <strong>Bias = 127</strong>。其他情况是128</li><li><strong>真值范围</strong>：移码值是无符号整数，8位范围为 $0 \leq \text{移码值} \leq 255$，对应真值范围为 $-127 \leq \text{真值} \leq 128$。<br>eg.<strong>真值</strong>：-128  $\text{移码值} = -128 + 127 = -1$<ul><li>由于移码值需为无符号数，负数结果需进行模运算：<br>$-1 \mod 256 = 255 \quad \Rightarrow \quad 255_{(10)} = 11111111_{(2)}$<br>eg.- <strong>真值</strong>：-127  $\text{移码值} = -127 + 127 = 0$</li><li>直接转换为无符号数：$0_{(10)} = 00000000_{(2)}$</li></ul></li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250328131557327.png" alt="image.png|450"><br>n位能表示$2^{n-1}$个原码，$2^n$个补/移码</p><table><thead><tr><th><strong>编码类型</strong></th><th><strong>合法表示范围</strong></th><th><strong>最大的数（二进制）假设8位</strong></th><th><strong>最小的数（二进制）</strong></th><th><strong>真值0的表示</strong></th></tr></thead><tbody><tr><td><strong>原码（n+1位）</strong></td><td>$-(2^n - 1) \leq x \leq 2^n - 1$<br>[-127,127] 255个<br>最小正数1<br>最大负数-1</td><td><code>0,1111111</code>$2^n - 1$</td><td><code>1,1111111</code>$-(2^n - 1)$</td><td><code>0,0000000</code>（+0）<br><code>1,0000000</code>（-0）</td></tr><tr><td><strong>反码（n+1位）</strong></td><td>$-(2^n - 1) \leq x \leq 2^n - 1$<br>[-127,127] 255个<br>最小正数1<br>最大负数-1</td><td><code>0,1111111</code>$2^n - 1$</td><td><code>1,0000000</code>$-(2^n - 1)$</td><td><code>0,0000000</code>（+0）<br><code>1,1111111</code>（-0）</td></tr><tr><td><strong>补码（n+1位）</strong></td><td>$-2^n \leq x \leq 2^n - 1$<br>[-128,127] 256个<br>最小正数1<br>最大负数-1</td><td><code>0,1111111</code>$2^n - 1$</td><td><code>1,0000000</code>$-2^n$</td><td><code>0,0000000</code>（唯一表示）</td></tr><tr><td><strong>移码（8位，偏移量128）</strong></td><td>$-2^n \leq x \leq 2^n - 1$<br>[-128,127] 256个<br>最小正数1<br>最大负数-1</td><td><code>11111111</code>$2^n - 1$</td><td><code>00000000</code>$-2^n$</td><td><code>10000000</code>（偏移后0）</td></tr><tr><td><strong>无符号整数（n+1位）</strong></td><td>$0 \leq x \leq 2^{n+1} - 1$<br>[0,255] 256个</td><td><code>1111111</code>$2^{n+1} - 1$</td><td><code>00000000</code>（0）</td><td><code>00000000</code></td></tr><tr><td><strong>定点小数：原码</strong></td><td>$−(1−2^{−n})≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$</td><td><code>01111111</code>$1-2^{-n}$</td><td><code>1111111</code>$-(1-2^{-n})$</td><td><code>0,0000000</code>（+0）<br><code>1,0000000</code>（-0）</td></tr><tr><td><strong>定点小数：反码</strong></td><td>$−(1−2^{−n})≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$</td><td><code>01111111</code>$1-2^{-n}$</td><td><code>10000000</code>$-(1-2^{-n})$</td><td><code>0,0000000</code>（+0）<br><code>1,1111111</code>（-0）</td></tr><tr><td><strong>定点小数：补码</strong></td><td>$-1≤x≤1−2^{−n}$<br>最小正数$2^{-n}$<br>最大负数$-2^{-n}$</td><td><code>01111111</code>$1-2^{-n}$</td><td><code>10000000</code>（-1）</td><td><code>0,0000000</code>（唯一表示）</td></tr></tbody></table><h3 id="1-2-6-负数大小判断">1.2.6 负数大小判断</h3><p>原码：数值位越大，值越小<br>补码和反码：数值位越小，值越小<br>原码很容易判断大小，而负数的补码、反码很难直接判断大小</p><h3 id="1-2-7-定点数的位数扩展">1.2.7 定点数的位数扩展</h3><h4 id="1-2-7-1-定点整数与定点小数的扩展规则">1.2.7.1 定点整数与定点小数的扩展规则</h4><table><thead><tr><th><strong>类型</strong></th><th><strong>扩展方向</strong></th><th><strong>规则</strong></th></tr></thead><tbody><tr><td><strong>定点整数</strong></td><td>高位扩展</td><td>根据编码方式（原码、补码、反码）决定填充 <code>0</code> 或 <code>1</code>（见下文）。</td></tr><tr><td><strong>定点小数</strong></td><td>低位扩展</td><td>小数部分低位补 <code>0</code>（保持精度），高位扩展规则与编码方式一致。</td></tr></tbody></table><h4 id="1-2-7-2-原码、补码、反码的扩展规则">1.2.7.2 原码、补码、反码的扩展规则</h4><table><thead><tr><th><strong>编码类型</strong></th><th><strong>正数扩展规则</strong></th><th><strong>负数扩展规则</strong></th><th><strong>示例（8位 → 16位）</strong></th></tr></thead><tbody><tr><td><strong>原码</strong></td><td>符号位 <code>0</code>，数值位高位补 <code>0</code></td><td>符号位 <code>1</code>，数值位高位补 <code>0</code></td><td><code>+5</code>（原码 <code>00000101</code> → <code>00000000 00000101</code>）<br><code>-5</code>（原码 <code>10000101</code> → <code>10000000 00000101</code>）</td></tr><tr><td><strong>补码</strong></td><td>符号位 <code>0</code>，数值位高位补 <code>0</code></td><td>符号位 <code>1</code>，数值位高位补 <code>1</code>（符号扩展）</td><td><code>+5</code>（补码 <code>00000101</code> → <code>00000000 00000101</code>）<br><code>-5</code>（补码 <code>11111011</code> → <code>11111111 11111011</code>）</td></tr><tr><td><strong>反码</strong></td><td>符号位 <code>0</code>，数值位高位补 <code>0</code></td><td>符号位 <code>1</code>，数值位高位补 <code>1</code></td><td><code>+5</code>（反码 <code>00000101</code> → <code>00000000 00000101</code>）<br><code>-5</code>（反码 <code>11111010</code> → <code>11111111 11111010</code>）</td></tr></tbody></table><h2 id="1-3-整数表示与运算">1.3 整数表示与运算</h2><ol><li><strong>无符号整数（unsigned）</strong> 没有符号位<ul><li><strong>范围</strong>：$0 \sim 2^{n-1}$<code>（n为机器字长）。 8位2进制范围：</code>[0,255]`</li><li><strong>硬件实现</strong>：直接存储二进制原码，无符号位。<br>无符号数用来存地址</li><li>无符号整数溢出时，结果自动对 $2^n$ 取模（n 为位数）。<ul><li><strong>示例</strong>：<ul><li>8位无符号数：256 \mod 256 = 0，-1 \mod 256 = 255。</li><li>移码计算中，负数真值转换为无符号移码值：$\text{移码值} = (\text{真值} + \text{Bias}) \mod 2^n$<br>如8位移码（Bias=127）：$-128 + 127 = -1 \quad \Rightarrow \quad -1 \mod 256 = 255 = 11111111_{(2)}$</li></ul></li></ul></li></ul></li><li><strong>有符号整数（补码表示）</strong><ul><li><strong>范围</strong>：$- 2^{n-1} \sim 2^{n-1} - 1$。<br>8位2进制范围：<code>[-128,128]</code><br>−128<sub>10</sub>​=1000 0000<sub>2</sub> 补码仍为1000 0000<sub>2</sub></li><li><strong>补码转换规则</strong>：<ul><li><strong>正数</strong>：原码、反码、补码相同。</li><li><strong>负数</strong>：原码符号位不变，数值位取反加1。</li></ul></li></ul></li><li><strong>溢出判断</strong><ul><li><p>加减法溢出判断</p><ul><li><mark>**有符号</mark>数溢出（OF）**：只有符号位相同才有可能溢出<ul><li>看符号位与次高位进位是否异或$OF = C_{符号位} \oplus C_{次高位}$       $0111_2 (+7) + 0001_2 (+1) = 1000_2 (-8) \quad (\text{OF}=1)$</li><li>最高数值的进位C<sub>n-1</sub>与符号位C<sub>n</sub>的进位是否一致$OF = C_{n-1} \oplus C_{n}$<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330101044131.png" alt="image.png"></li><li>变形补码（模4补码）01正溢出，10负溢出<br>模4 补码具有模2补码的全部优点且更易检查加减运算中的溢出问题<br>存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的<br>只在把两个模 4 补码的数送往 ALU 完成加减运算时，才把个数的符号位的值同时送到ALU的双符号位中，即只在 ALU 中采用双符号位<br>采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出。<ul><li><strong>正溢出</strong>：两个正数（符号位为 <code>0</code>）相加，结果符号位为 <code>1</code>（负数）。</li><li><strong>负溢出</strong>：两个负数（符号位为 <code>1</code>）相加，结果符号位为 <code>0</code>（正数）。</li></ul></li></ul></li><li><mark>**无符号</mark>数进位（CF）**：最高位进位（加法）或借位（减法）。</li></ul></li><li><p>2个n位无符号与有符号乘法的溢出条件</p></li><li><p>无符号乘法溢出条件：高n位 ≠0<br>两个n位无符号数的乘积最多需要 <strong>2n位</strong> 表示，范围是 $0 \leq \text{乘积} \leq (2^n - 1)^2$。</p><ul><li>若乘积的 <strong>高n位全为0</strong>，说明结果可用n位无符号数表示（范围 $0 \leq \text{结果} \leq 2^n - 1$），<strong>不溢出</strong>。</li><li>若高n位不全为0，说明结果超出n位范围（&gt; $2^n - 1$），<strong>溢出</strong>。</li></ul></li><li><p>有符号乘法溢出条件：高n+1位≠全0或全1<br>两个n位补码数的乘积最多需要 <strong>2n位</strong> 表示，范围是 $-2^{2n-2} \leq \text{乘积} \leq (2^{n-1}-1)^2$。</p><ul><li>若乘积的 <strong>高n+1位全为0或全为1</strong>，说明结果可用n位补码表示（符号位扩展一致），<strong>不溢出</strong>。</li><li>若高n+1位不全为0或不全为1，说明结果超出n位补码范围，<strong>溢出</strong>。<ul><li>补码乘法需要符号位扩展。若乘积的高n+1位全为0，表示正数且数值在n位范围内。</li><li>若高n+1位全为1，表示负数且数值在n位范围内。</li><li>若高n+1位不一致（如部分0和部分1），说明结果无法正确用n位补码表示。</li></ul></li></ul></li></ul></li></ol><table><thead><tr><th><strong>类型</strong></th><th><strong>溢出条件</strong></th><th><strong>示例（n=4）</strong></th></tr></thead><tbody><tr><td><strong>无符号乘法</strong></td><td>乘积高n位不全为0 → 溢出</td><td>$15 \times 15 = 225$（溢出）</td></tr><tr><td><strong>有符号乘法</strong></td><td>乘积高n+1位不全为0或不全为1 → 溢出</td><td>$-8 \times -8 = 64$（溢出）</td></tr></tbody></table><ul><li>零标志ZF=1 结果为零【都】</li><li>符号标志SF=1 结果为负【有符号数】</li><li><strong>运算器不区分数据类型</strong>：同一电路处理两种数（有符号、无符号），但需通过<strong>标志位</strong>解释结果。</li></ul><table><thead><tr><th><strong>标志位</strong></th><th><strong>名称</strong></th><th><strong>作用</strong></th><th><strong>逻辑表达式</strong></th></tr></thead><tbody><tr><td><strong>ZF</strong></td><td>零标志</td><td>结果为0时置1，否则置0。对所有运算有效。</td><td><code>ZF = 1</code> ⇨ <code>Result == 0</code></td></tr><tr><td><strong>OF</strong></td><td>溢出标志</td><td><strong>仅对有符号数有效</strong>，表示结果超出范围。</td><td><code>OF = C_n ⊕ C_&#123;n-1&#125;</code></td></tr><tr><td><strong>SF</strong></td><td>符号标志</td><td><strong>仅对有符号数有效</strong>，表示结果的符号（最高位）。</td><td><code>SF = Result[n-1]</code></td></tr><tr><td><strong>CF</strong></td><td>进位/借位标志</td><td><strong>仅对无符号数有效</strong>，加法表示进位，减法表示借位。</td><td><code>CF = Sub ⊕ C_out</code></td></tr></tbody></table><ol start="4"><li>数值比较的逻辑<br><strong>(1) 无符号数比较（执行 <code>A - B</code>）</strong></li></ol><table><thead><tr><th><strong>条件</strong></th><th><strong>标志位状态</strong></th><th><strong>结论</strong></th></tr></thead><tbody><tr><td><code>A = B</code></td><td><code>ZF = 1</code></td><td>相等</td></tr><tr><td><code>A &gt; B</code></td><td><code>ZF = 0, CF = 0</code></td><td>A大于B</td></tr><tr><td><code>A &lt; B</code></td><td><code>ZF = 0, CF = 1</code></td><td>A小于B</td></tr><tr><td><strong>(2) 有符号数比较（执行 <code>A - B</code>）</strong></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>条件</strong></th><th><strong>标志位状态</strong></th><th><strong>结论</strong></th></tr></thead><tbody><tr><td><code>A = B</code></td><td><code>ZF = 1</code></td><td>相等</td></tr><tr><td><code>A &gt; B</code></td><td><code>ZF = 0, OF = SF</code></td><td>A大于B</td></tr><tr><td><code>A &lt; B</code></td><td><code>ZF = 0, OF ≠ SF</code></td><td>A小于B</td></tr></tbody></table><ul><li><strong>未溢出（<code>OF = 0</code>）</strong>：直接根据 <code>SF</code> 判断（<code>SF=0</code> 结果非负，<code>SF=1</code> 结果为负）。</li><li><strong>溢出（<code>OF = 1</code>）</strong>：符号位 <code>SF</code> 与实际大小相反，需结合 <code>OF</code> 修正判断。</li></ul><ol start="5"><li>示例分析<br><strong>(1) 无符号数比较</strong></li></ol><ul><li><strong><code>A = 0000 0011 (3), B = 0000 0010 (2)</code></strong>：<ul><li><code>A - B = 0000 0001</code> → <code>ZF = 0, CF = 0</code> → <code>A &gt; B</code>。</li></ul></li><li><strong><code>A = 0000 0000 (0), B = 0000 0001 (1)</code></strong>：<ul><li><code>A - B = 1111 1111</code> → <code>ZF = 0, CF = 1</code> → <code>A &lt; B</code>。</li></ul></li></ul><p><strong>(2) 有符号数比较</strong></p><ul><li><strong><code>A = 0111 (7), B = 1011 (-5)</code></strong>（补码）：<ul><li><code>A - B = 0111 + 0101 = 1100</code> → <code>SF = 1, OF = 1 → </code>A &gt; B`</li></ul></li></ul><table><thead><tr><th><strong>位</strong></th><th>操作</th><th>进位</th></tr></thead><tbody><tr><td>第1位</td><td>1 + 1 = 0，进位1</td><td>C0=1</td></tr><tr><td>第2位</td><td>1 + 0 + 1 = 0，进位1</td><td>C1=1</td></tr><tr><td>第3位</td><td>1 + 1 + 1 = 1，进位1</td><td>C2=1</td></tr><tr><td>第4位</td><td>0 + 0 + 1 = 1，进位0</td><td>C3=0</td></tr></tbody></table><pre><code>OF=C3⊕C2=0⊕1=1（溢出发生）</code></pre><h2 id="1-4-定点数运算">1.4 定点数运算</h2><h3 id="1-4-1-移位运算">1.4.1 移位运算</h3><ul><li><strong>算术移位（有符号数）</strong>：<ul><li><strong>原码</strong>：符号位不变，数值位补0（左移）或舍弃（右移）。</li><li><strong>补码</strong>：正数同原码；负数左移补0，右移补1。</li><li><strong>反码</strong>：负数空位补1</li></ul></li><li><strong>逻辑移位（无符号数）</strong>：统一补0。<br>应用：RGB</li><li><strong>循环移位</strong>：带进位时用于数据高低位交换（如大端转小端）。<br>适合将数据的第字节数据和高字节数据呼唤</li></ul><h4 id="1-4-1-1-逻辑移位（无符号数）">1.4.1.1 逻辑移位（无符号数）</h4><h5 id="1-4-1-1-1-按位或（-）：将某位置1">1.4.1.1.1 按位或（<code>|</code>）：将某位置1</h5><p><strong>用途</strong>：将特定位设为1，其他位保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT3_MASK (1U &lt;&lt; 3)  <span class="comment">// 掩码: 0x00000008</span></span></span><br><span class="line">regData |= BIT3_MASK;         <span class="comment">// 第3位置1</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000000</code> → 结果 <code>0x00000008</code>。</li><li>若 <code>regData = 0x00000004</code> → 结果 <code>0x0000000C</code>（第2位和第3位均为1）。</li></ul><h5 id="1-4-1-1-2-按位与（-）：将某位清0">1.4.1.1.2 按位与（<code>&amp;</code>）：将某位清0</h5><p><strong>用途</strong>：将特定位设为0，其他位保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT5_MASK ~(1U &lt;&lt; 5)  <span class="comment">// 掩码: 0xFFFFFFDF</span></span></span><br><span class="line">regData &amp;= BIT5_MASK;          <span class="comment">// 第5位清0</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000020</code> → 结果 <code>0x00000000</code>。</li><li>若 <code>regData = 0xFFFFFFFF</code> → 结果 <code>0xFFFFFFDF</code>（仅第5位为0）。</li></ul><h5 id="1-4-1-1-3-按位异或（-）：切换某位状态">1.4.1.1.3 按位异或（<code>^</code>）：切换某位状态</h5><p><strong>用途</strong>：若目标位为1则置0，若为0则置1（翻转位状态）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2_MASK (1U &lt;&lt; 2)  <span class="comment">// 掩码: 0x00000004</span></span></span><br><span class="line">regData ^= BIT2_MASK;         <span class="comment">// 切换第2位状态</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000000</code> → 结果 <code>0x00000004</code>（第2位置1）。</li><li>若 <code>regData = 0x00000004</code> → 结果 <code>0x00000000</code>（第2位清0）。</li></ul><h5 id="1-4-1-1-4-按位非（-）：取反所有位">1.4.1.1.4 按位非（<code>~</code>）：取反所有位</h5><p><strong>用途</strong>：将所有位取反（1变0，0变1）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regData = ~regData;  <span class="comment">// 所有位翻转</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x0000000F</code> → 结果 <code>0xFFFFFFF0</code>。</li><li>若 <code>regData = 0x12345678</code> → 结果 <code>0xEDCBA987</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置第1位和第4位，同时清除第3位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_MASK   ((1U &lt;&lt; 1) | (1U &lt;&lt; 4))  <span class="comment">// 0x00000012</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLEAR_MASK ~((1U &lt;&lt; 3))             <span class="comment">// 0xFFFFFFF7</span></span></span><br><span class="line"></span><br><span class="line">regData |= SET_MASK;    <span class="comment">// 第1、4位置1</span></span><br><span class="line">regData &amp;= CLEAR_MASK;  <span class="comment">// 第3位清0</span></span><br></pre></td></tr></table></figure><ul><li>若 <code>regData = 0x00000000</code> → 结果 <code>0x00000012</code>。</li><li>若 <code>regData = 0x00000008</code> → 结果 <code>0x00000010</code>（第3位清0，第4位置1）。</li></ul><table><thead><tr><th><strong>操作符</strong></th><th><strong>作用</strong></th><th><strong>示例代码</strong></th></tr></thead><tbody><tr><td>|</td><td>置1特定位</td><td>regData |= (1U &lt;&lt; n)</td></tr><tr><td>&amp;</td><td>清0特定位</td><td>regData &amp;= ~(1U &lt;&lt; n)</td></tr><tr><td>^</td><td>翻转特定位</td><td>regData ^= (1U &lt;&lt; n)</td></tr><tr><td>~</td><td>取反所有位</td><td>regData = ~regData</td></tr></tbody></table><p>eg1.<br>要将变量 <code>regData</code> 中的第6位（从0开始计数）置1而不影响其他位，假设寄存器的内容保存在变量regData中，可以使用以下C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> b6_mask (1 &lt;&lt; 6)  <span class="comment">// 定义掩码，确保无符号移位</span></span></span><br><span class="line">regData |= b6_mask;        <span class="comment">// 按位或操作置位</span></span><br></pre></td></tr></table></figure><ol><li><strong>掩码定义</strong>：<br><code>#define b6_mask (1 &lt;&lt; 6)</code><br>无符号整型常量1，左移6位后得到二进制掩码 <code>01000000</code>（即十六进制 <code>0x40</code>）。</li><li><strong>置位操作</strong>：<br><code>regData |= b6_mask;</code><ul><li>按位或操作 (<code>|=</code>) 将 <code>regData</code> 的第6位设置为1，其他位保持不变。</li></ul></li></ol><p><strong>假设 <code>regData</code> 初始值为 <code>0x28</code>（二进制 <code>00101000</code>）：</strong><br><code>regData |= b6_mask;  // regData = 0x68 (二进制 01101000)</code><br>eg2.<br>要将变量 <code>regData</code> 中的第6位（从0开始计数）清0而不影响其他位，假设寄存器的内容保存在变量regData中，可以使用以下C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> b6_mask ~(1 &lt;&lt; 6)</span></span><br><span class="line">regData &amp;= b6_mask</span><br></pre></td></tr></table></figure><p>eg3.<br>要将某个8位寄存器的b0和b5的内容清0、b2和b3的内容置1，并且不影响寄该寄存器中的其他各位，请使用C语言编程实现(假设该寄存器的内容保存在变量regData中)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLEAR_MASK ((1U &lt;&lt; 0) | (1U &lt;&lt; 5))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_MASK   ((1U &lt;&lt; 2) | (1U &lt;&lt; 3))</span></span><br><span class="line">regData &amp;= ~CLEAR_MASK;  <span class="comment">// 清0 b0和b5</span></span><br><span class="line">regData |= SET_MASK;     <span class="comment">// 置1 b2和b3</span></span><br></pre></td></tr></table></figure><h4 id="1-4-1-2-算数移位（有符号数）">1.4.1.2 算数移位（有符号数）</h4><p>针对定点数（定点整数、顶点小数）<br>不论正数还是负数，符号位保持不变，仅对数值位进行移位<br>左移×2^n 【&lt;&lt; 对应逻辑左移（高位移除，低位补0）】<br>右移÷2^n 【&gt;&gt; 无符号对应逻辑右移（低位移除，高位补0），有符号对应算术右移（低位移除，低位补符号位）】<br>注意：补码的算数移位：</p><ul><li><strong>右移</strong>：符号位保留（填充符号位）。</li><li><strong>左移</strong>：<ul><li>若左移未溢出，符号位保留。</li><li>若左移导致符号位改变（如正数变负数或负数变正数），则符号位不保留，<strong>溢出发生</strong>。</li></ul></li><li>补码 <code>00001101</code>（+13）左移1位 → <code>00011010</code>（+26），符号位保留。</li><li>补码 <code>11110011</code>（-13）左移2位 → <code>11001100</code>（-52），符号位保留。</li><li>补码 <code>01111111</code>（+127）左移1位 → <code>11111110</code>（-2），符号位改变，<strong>溢出</strong>。</li></ul><table><thead><tr><th><strong>真值</strong></th><th><strong>机器码</strong></th><th><strong>空位添补</strong></th><th><strong>丢位情况</strong></th></tr></thead><tbody><tr><td><strong>正数</strong>（符号位不保留）</td><td>原码=补码=反码</td><td>补0</td><td>- <strong>最高位丢1</strong>：结果溢出（出错）  <br>- <strong>最低位丢1</strong>：精度缺失（值变小）</td></tr><tr><td><strong>负数</strong>（符号位保留1）</td><td><strong>原码</strong></td><td>补0</td><td>- <strong>最高位丢0</strong>：结果溢出（出错）  <br>- <strong>最低位丢0</strong>：精度缺失（绝对值变大）</td></tr><tr><td></td><td><strong>反码</strong></td><td>补1</td><td>- <strong>最高位丢0</strong>：结果溢出（出错）  <br>- <strong>最低位丢1</strong>：精度缺失（绝对值变大）</td></tr><tr><td></td><td><strong>补码</strong></td><td>左移补0右移补1</td><td>- <strong>最高位丢0</strong>：结果溢出（出错）  <br>- <strong>最低位丢1</strong>：精度缺失（值变小）</td></tr><tr><td><strong>有符号定点数</strong>的<strong>补码</strong>的另一种算术移位方法，即“符号位也参与移位”，具体规则如下</td><td></td><td></td><td></td></tr><tr><td>左移：高位移除，低位添补0；移动前后若符号位发生变化，则发生<strong>溢出</strong>。</td><td></td><td></td><td></td></tr><tr><td>右移：低位移除，高位添补符号。</td><td></td><td></td><td></td></tr><tr><td>注：题目中有机器数、寄存器等用机器移动，左移符号位和数值位一起移。算数右移保留符号位</td><td></td><td></td><td></td></tr><tr><td>补码算术左移时，高位移出，低位补0，若左移前后的符号位不同，则发生溢出</td><td></td><td></td><td></td></tr><tr><td>无符号数逻辑左移时，若最高位移出的是1，则发生溢出</td><td></td><td></td><td></td></tr><tr><td>逻辑左移和补码算术左移的结果都一样，都是移出最高位，并在低位补0</td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-4-1-3-循环移位（无符号数）">1.4.1.3 循环移位（无符号数）</h4><p>将无符号数二进制形式中的各个位向左或向右移动，被移出的位会重新出现在另一端，形成循环。<br>在很多处理器架构中，循环移位指令会影响状态寄存器中的<strong>进位标志CF(CarnyFlag)位</strong>，CF标志位用于标识在执行算术或逻辑操作时是否发生了<strong>进位</strong>。<br>根据CF标志位是否加入循环移位过程，循环移位可分为以下四种:<br>小循环：CF不参与循环，但是保留当前循环的移位<br>不带CF标志位的循环右移<br>不带CF标志位的循环左移<br>大循环：CF参与循环<br>带CF标志位的循环右移<br>带CF标志位的循环左移<br>循环移位的应用主要有：<strong>加密算法、哈希函数、优化算法</strong><br>加密算法：通过循环移位可以实现数据的混淆和置换，增强加密算法的安全性。<br>哈希函数：通过循环移位可以用来改变输入数据的排列顺序，以产生不同的哈希值，有利于增强哈希函数的混淆性和扩散性。<br>优化算法:<br>在某些算法中，循环移位可以用于优化性能和节省资源。例如，在图形处理和数字信号处理中，循环移位可以用于加速算法的执行。</p><p>可以使用移位运算操作符(左移“&lt;&lt;”或右移“&gt;&gt;”)和位运算操作符(例如:或运算)来实现。</p><table><thead><tr><th><strong>移位类型</strong></th><th><strong>数值类型</strong></th><th><strong>溢出判断条件</strong></th><th><strong>示例（4位）</strong></th></tr></thead><tbody><tr><td><strong>逻辑左移</strong></td><td>无符号数</td><td>移出有效位（<code>CF = 1</code>）</td><td><code>1100 &lt;&lt; 1 → 1000</code>（未溢出）</td></tr><tr><td><strong>算术左移</strong></td><td>有符号数</td><td>符号位改变（<code>OF = 1</code>）</td><td><code>0100 &lt;&lt; 1 → 1000</code>（溢出）</td></tr><tr><td><strong>逻辑右移</strong></td><td>无符号数</td><td>不会溢出</td><td><code>1100 &gt;&gt; 1 → 0110</code>（无溢出）</td></tr><tr><td><strong>算术右移</strong></td><td>有符号数</td><td>不会溢出</td><td><code>1100 &gt;&gt; 1 → 1110</code>（无溢出）</td></tr></tbody></table><h2 id="1-5-逻辑门">1.5 逻辑门</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330110026671.png" alt="image.png"></p><h3 id="1-5-1-半加器">1.5.1 半加器</h3><p>和数S，进位数C<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330122433587.png" alt="image.png|300"></p><h3 id="1-5-2-一位全加器FA">1.5.2 一位全加器FA</h3><p>一位全加器 = 两个半加器<br>FA是最基本的加法单元</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330121705189.png" alt="image.png"></p><h3 id="1-5-3-串行进位加法器">1.5.3 串行进位加法器</h3><p>将n个全加器相连可得到n位加法器，称为串行进位加法器，如图2.4所示。串行进位也称行波进位，每级进位直接依赖于前一级的进位，即进位信号是<strong>逐级</strong>形成的。<br>在串行进位加法器中，低位运算产生进位所需的时间将影响高位运算的时间。因此，串行进位加法器的最长运算时间主要是由进位信号的<strong>传递时间</strong>决定的，位数越多，延迟时间就越长，所以加快进位产生和提高传递的速度是关键。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330121720156.png" alt="image.png"><br>在n位串行进位加法器中，每个高位的一位全加器FA的运算依赖于相邻低位的一位FA的进位Ci+1因此所有一位FA不能并行运行，其时间关键延迟为(2n+4)T，与串行进位加法器的位数n呈线性关系，<strong>当n较大时性能较差</strong>。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330124049316.png" alt="image.png|400"></p><h3 id="1-5-4-先行进位加法器">1.5.4 先行进位加法器</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330130038330.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330130239644.png" alt="image.png"><br>针对C4，S4：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330125514620.png" alt="image.png|400"></p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330120614661.png" alt="image.png"><br>带符号整数和无符号整数的加减法<strong>可以共用同一加法器</strong>，因为：</p><ol><li>补码设计使得加减法操作与无符号数一致。<strong>硬件无需区分有符号和无符号数</strong>，加法器直接执行二进制位相加。</li><li>减法统一转换为加法，仅需额外取反加1逻辑。</li><li>溢出判断通过独立电路（CF和OF）区分处理，不依赖加法器本身。<ul><li><strong>无符号数溢出</strong>：<br>通过<strong>最高位进位</strong>判断。例如，8位无符号数相加结果超过255时，最高位产生进位（Carry Flag, CF=1）。</li><li><strong>有符号数溢出</strong>：<br>通过<strong>符号位变化</strong>判断。若两个正数相加结果为负，或两个负数相加结果为正，则溢出（Overflow Flag, OF=1）。</li><li><strong>共用加法器，独立标志位</strong>：</li><li>加法器生成结果后，<strong>CF</strong> 和 <strong>OF</strong> 由不同电路独立计算。</li><li>例如，8位运算中：<ul><li><code>CF = 第8位进位</code>。</li><li><code>OF = 第7位进位异或第8位进位</code>。</li></ul></li></ul></li></ol><h2 id="1-6-乘法与除法">1.6 乘法与除法</h2><h3 id="1-6-1-无符号数乘法的硬件逻辑">1.6.1 无符号数乘法的硬件逻辑</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401183330629.png" alt="image.png|400"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330132332682.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250330133038038.png" alt="image.png"></p><h3 id="1-6-2-定点数的乘法运算">1.6.2 定点数的乘法运算</h3><ul><li><strong>原码乘法</strong>：符号位异或，数值位累加并右移。</li><li><strong>补码乘法（Booth算法）</strong>：根据乘数位决定加减被乘数，算数右移。</li><li><strong>原码除法（加减交替法）</strong>：通过余数符号调整商和下一步操作。</li></ul><h4 id="1-6-2-1-原码乘法运算的硬件逻辑实现">1.6.2.1 原码乘法运算的硬件逻辑实现</h4><p>对于定点整数原码乘法，其过程与定点小数原码乘法完全相同，仅将符号位与数值位之间的小数点改为逗号即可。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401185018200.png" alt="image.png"><br>先加法再移位，重复n次<br>符号位不参与运算，符号位单独处理：符号位=x⊕y<br>取绝对值进行乘法计算<br>当前位=1，ACC加上被乘数。=0，不加<br>补位是逻辑右移<br>进行n轮加法、移位<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401200316949.png" alt="image.png|350"></p><h4 id="1-6-2-2-补码乘法运算的硬件逻辑实现">1.6.2.2 补码乘法运算的硬件逻辑实现</h4><p>补码一位乘法运算（Booth算法）：<br>是一种加速乘法计算的方法（比如计算 <code>5 × 3</code>），特别适合用硬件电路实现，比传统的乘法更高效。<br><strong>核心思想：用“加减”代替“乘”</strong><br>硬件不喜欢直接做乘法（电路复杂），但擅长加减和移位。Booth算法把乘法拆解成：</p><ol><li><strong>观察乘数的相邻两位</strong>（比如当前位是<code>1</code>，前一位是<code>0</code>，就表示“需要加被乘数”）。</li><li><strong>被乘数左移</strong>（相当于十进制乘法中的“后面补零”）。</li><li><strong>重复步骤1和2，最后把所有结果加起来</strong>。</li></ol><p><strong>硬件</strong>：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402181608205.png" alt="image.png"></p><ol><li><p><strong>控制逻辑</strong>：</p><ul><li><strong>核心大脑</strong>，协调所有操作：根据乘数位（MQ的当前位和附加位）判断加减、移位操作，控制循环次数（计数器），确保算法按步骤执行。</li></ul></li><li><p><strong>时钟</strong>：</p><ul><li><strong>同步时序</strong>，确保每一步操作（如加减、移位）在固定时钟周期内完成，保持硬件同步。</li></ul></li><li><p><strong>计数器（Cn）</strong>：</p><ul><li><strong>记录迭代次数</strong>，例如n位乘法需计数n次，控制循环终止。</li></ul></li><li><p><strong>ACC（累加器）</strong>：</p><ul><li><strong>存储部分积</strong>，保存当前累加结果，每次操作后与ALU结果同步，参与算术右移。</li></ul></li><li><p><strong>MQ（乘商寄存器）</strong>：</p><ul><li><strong>存储乘数及附加位</strong>，初始存放乘数Y，末尾附加一位Y₋₁（初始为0）；每次右移时，ACC和MQ联合移位。</li></ul></li><li><p><strong>ALU（算术逻辑单元）</strong>：</p><ul><li><strong>执行加减操作</strong>，根据控制信号对ACC和[X]补（或被乘数补码）进行加减，结果写回ACC。</li></ul></li><li><p><strong>选择器（多路复用器）</strong>：</p><ul><li><strong>选择操作数</strong>，例如选择被乘数[X]补或其补码（−[X]补）输入ALU，实现加减操作切换。</li></ul></li><li><p><strong>译码器</strong>：</p><ul><li><strong>解析操作码</strong>，将MQ的当前位（Y₀）和附加位（Y₋₁）转换为控制信号（如“加”“减”或“不移位”）。</li></ul></li><li><p><strong>反相器</strong>：</p><ul><li><strong>生成补码</strong>，将被乘数取反后加1，用于实现减法操作（−[X]补）。</li></ul></li></ol><p>辅助位-MQ中最低位=1，ACC+[x]补<br>=0，不加<br>=-1，ACC+[-x]补（会有辅助电路实现[-x]的转换）<br>补位是算数右移<br>进行n轮加法、移位，最后再多来一次加法<br>被乘数A，B采用双符号位补码，符号位参与运算；乘数C采用单符号位补码，符号参与移位，且在尾部增加一位附加位0<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250401200540813.png" alt="image.png|400"><br>补码一位乘法中，最多需要 n 次移位，n+1次加法运算，共2n+1位。<br>原码乘法移位和加法运算最多均为n次。<br>凡是原码运算，不论加减乘除，符号位都单独处理，其中乘除运算的结果符号由参加运算的两个操作数符号相“异或”得到。</p><p>【2020年 题43】有实现x×y的两个C语言函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">umul</span> <span class="params">(<span class="type">unsigned</span> x, <span class="type">unsigned</span> y)</span> &#123; <span class="keyword">return</span> x*y; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">imul</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br></pre></td></tr></table></figure><p>假定某计算机M中ALU只能进行加减运算和逻辑运算。请回答下列问题。<br>(1) 若M的指令系统中<strong>没有</strong>乘法指令，但有加法、减法和移位等指令，则在M上也能实现上述两个函数中的乘法运算，为什么？<br>(2) 若M的指令系统中有乘法指令，则基于ALU、移位器、寄存器以及相应控制逻辑实现乘法指令时，<strong>控制逻辑</strong>的作用是什么？<br>(3) 针对以下三种情况：①<strong>没有乘法指令</strong>；②有使用<strong>ALU</strong>和<strong>移位器</strong>实现的乘法指令；③有使用<strong>阵列乘法器</strong>实现的乘法指令，函数umul()在哪种情况下<strong>执行时间</strong>最长？哪种情况下执行的时间最短？说明理由。<br>(4) n位整数乘法指令可保存2n位乘积，当仅取低n位作为乘积时，其结果可能会发生溢出。当n=32、x= 231−1 、y=2时，带符号整数乘法指令和无符号整数乘法指令得到的x×y的2n位乘积分别是什么（用十六进制表示）？此时函数umul()和imul()的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低位作为乘法结果时，如何用2n位乘积进行溢出判断？<br>解答：<br>(1) 乘法本质上是<strong>重复累加</strong>和<strong>位移操作</strong>的组合。以二进制乘法为例，假设计算 <code>x * y</code>，可以将 <code>y</code> 的每一位分解为权重（如第 <code>i</code> 位对应 <code>2^i</code>），通过将 <code>x</code> 左移 <code>i</code> 位后累加到结果中。例如：  <code>5 * 3 = 5 * (0011B) = (5 &lt;&lt; 1) + (5 &lt;&lt; 0) = 10 + 5 = 15</code>。</p><ul><li><strong>软件实现流程</strong>：<ol><li>初始化结果为0。</li><li>逐位检查乘数 <code>y</code> 的每一位：<ul><li>若当前位为1，将 <code>x</code> 左移对应位数后加到结果中。</li><li>若当前位为0，跳过加法。</li></ul></li><li>重复上述步骤直到处理完所有位。</li></ol></li><li><strong>符号处理</strong>（针对有符号乘法 <code>imul</code>）：<ul><li>取 <code>x</code> 和 <code>y</code> 的绝对值进行无符号乘法。</li><li>根据符号位异或（<code>x ^ y</code>）确定结果的符号，最终修正结果。</li></ul></li></ul><p>(2) 控制逻辑的作用是<strong>控制循环次数，控制加法和移位操作</strong>。</p><ol><li><p><strong>操作选择</strong>：</p><ul><li>根据乘数的当前位（或附加位）决定加减操作。</li><li>例如，在 Booth 算法中，通过检查 <code>CnCn-1</code>（当前位和前一位）的组合选择：<ul><li><code>01</code>：加被乘数</li><li><code>10</code>：减被乘数</li><li><code>00/11</code>：不操作</li></ul></li></ul></li><li><p><strong>移位控制</strong>：</p><ul><li>管理算术右移（补码运算）或逻辑右移（无符号运算）的时机和位数。</li><li>例如，每次加减操作后执行右移，保持符号位不变。</li></ul></li><li><p><strong>迭代计数</strong>：</p><ul><li>控制乘法步骤的循环次数。对于 <code>n</code> 位数，通常需要 <code>n</code> 次迭代。</li><li>在 Booth 算法中，需额外处理附加位，总次数为 <code>n+1</code> 次加减和 <code>n</code> 次移位。</li></ul></li><li><p><strong>符号处理</strong>（针对补码乘法）：</p><ul><li>自动扩展符号位，确保运算过程中符号正确参与。</li></ul></li></ol><p><strong>(3) 三种情况下的执行时间对比</strong></p><table><thead><tr><th><strong>情况</strong></th><th><strong>执行时间</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td>① 无乘法指令（软件实现）</td><td><strong>最长</strong></td><td>需要循环逐位处理，每次循环包含条件判断、加法和移位操作，时间复杂度为 <code>O(n)</code>。</td></tr><tr><td>② ALU+移位器(通用硬件实现)</td><td><strong>中等</strong></td><td>硬件加速，但仍需多周期完成（如 <code>n</code> 次迭代），时间复杂度为 <code>O(n)</code>。</td></tr><tr><td>③ 阵列乘法器(专用硬件实现)</td><td><strong>最短</strong></td><td>全并行电路，通过门电路直接计算每一位乘积，单周期完成，时间复杂度为 <code>O(1)</code>。</td></tr><tr><td>①的执行时间最长，③的执行时间最短。</td><td></td><td></td></tr><tr><td>对于①，需要使用其他指令和算法来模拟乘法操作。常见的方法是通过编写（软件）程序使用加法、位移和逻辑操作来实现乘法功能，需要反复执行很多条指令，而对于每条指令，都需要经历“取指、译码、取数、执行、保存结果”这一过程，②和③都是硬件乘法指令，所以①的执行时间最长。</td><td></td><td></td></tr><tr><td>对于②和③，都只需用一条乘法指令实现乘法操作。</td><td></td><td></td></tr><tr><td>对于③，阵列乘法器是专门用于执行乘法操作的硬件电路，可以在一个时钟周期内完成乘法运算。由于其硬件实现的特性，阵列乘法器通常是执行乘法操作最高效的方式。所以③的执行时间最短。</td><td></td><td></td></tr><tr><td>对于②，ALU和位移器实现的乘法指令通常需要多个时钟周期来完成乘法运算。它通过将乘法操作划分为一系列的加法、位移和逻辑操作来实现。尽管比情况①中的方法更高效，但仍然需要多个时钟周期来执行，因此相对于情况③中的阵列乘法器，执行时间较长。</td><td></td><td></td></tr></tbody></table><ul><li><strong>阵列乘法器</strong>：<br>通过门电路并行生成所有部分积，并一次性相加，无需循环。例如，32位乘法器包含32×32个与门和加法器，直接输出64位结果。</li><li><strong>ALU+移位器实现</strong>：<br>需要逐位迭代（如Booth算法），每个周期完成一次加减和移位，共需 <code>n</code> 个周期。</li></ul><p><strong>(4) 32位乘法的溢出分析与乘积表示</strong><br><strong>给定条件</strong>：</p><ul><li><code>n = 32</code></li><li><code>x = 2^31 - 1 = 0x7FFFFFFF</code>（32位补码最大正数）</li><li><code>y = 2</code></li></ul><p><strong>64位乘积计算</strong>：</p><ul><li><strong>无符号乘法</strong>（<code>umul</code>）：<ul><li><code>x = 0x7FFFFFFF</code>（无符号值为 <code>2^31 - 1</code>）</li><li><code>x * y = (2^31 - 1) * 2 = 2^32 - 2 = 0xFFFFFFFE</code><br>32位无符号整数的表示范围是$[0,2^{32}-1]$</li><li><strong>64位乘积</strong>：<code>0x00000000FFFFFFFE</code>（高32位全0，无溢出）。</li></ul></li><li><strong>有符号乘法</strong>（<code>imul</code>）：<ul><li><code>x = 0x7FFFFFFF</code>（补码最大正数 <code>+2^31 - 1</code>）</li><li><code>x * y = (2^31 - 1) * 2 = 2^32 - 2</code>，但32位补码范围为 32位无符号整数的表示范围是$[-2^{31},2^{31}-1]$，结果 <code>2^32 - 2</code> 超出范围。</li><li><strong>64位乘积</strong>：<code>0xFFFFFFFE</code>（低32位） + 高32位符号扩展为 <code>0xFFFFFFFF</code> → 完整乘积为 <code>0xFFFFFFFFFFFFFFFE</code>（即 <code>-2</code> 的补码）。</li></ul></li></ul><p>对于无符号整数乘法运算，当仅取乘积的低 n 位作为结果时，<strong>若 2n  位乘积的高 n 位不全为0，则说明结果发生了溢出</strong>。以下是详细的解释：</p><ul><li><strong>输入范围</strong>：两个 n 位无符号整数的取值范围为 $0 \leq x, y \leq 2^n - 1$</li><li><strong>乘积范围</strong>：它们的乘积最大为 $(2^n - 1) \times (2^n - 1) = 2^{2n} - 2^{n+1} + 1$，需要 2n  位才能完整表示。</li><li><strong>截断后的结果</strong>：若仅取乘积的低 n 位（即忽略高 n 位），则低 n 位的表示范围为 $0 \leq \text{结果} \leq 2^n - 1$。</li><li><strong>溢出条件</strong>：当实际乘积 $x \times y &gt; 2^n - 1$  时，低 n 位无法正确表示真实值，此时发生溢出。</li></ul><p>高n位的意义：</p><ul><li><strong>二进制表示</strong>：乘积的 2n  位可拆分为高 n 位和低 n 位，即：$x \times y = (\text{高 } n \text{ 位}) \times 2^n + (\text{低 } n \text{ 位})$</li><li><strong>高 n 位的作用</strong>：<ul><li>若高 n 位全为0，说明乘积 $x \times y \leq 2^n - 1$ ，未溢出。</li><li>若高 n 位不全为0，说明乘积 $x \times y \geq 2^n$ ，低 n 位无法容纳真实值，发生溢出。</li></ul></li></ul><p><strong>例1：未溢出（高 n 位全0）</strong></p><ul><li>设 n = 4 ，x = 15(1111_2) ，y = 1(0001_2) 。</li><li>乘积：$15 \times 1 = 15(0000\ 1111_2)$ 。</li><li>高4位为 <code>0000</code>，低4位为 <code>1111</code>，结果未溢出。</li></ul><p><strong>例2：溢出（高 n 位不全0）</strong></p><ul><li>设 n = 4 ，x = 15(1111_2) ，y = 15(1111_2) 。</li><li>乘积：$15 \times 15 = 225(1110\ 0001_2)$ 。</li><li>高4位为 <code>1110</code>，低4位为 <code>0001</code>，实际值远超 2^4 - 1 = 15 ，溢出发生。</li></ul><p><strong>溢出判断</strong>：</p><ul><li><p><strong>无符号乘法</strong>（<code>umul</code>）：</p><ul><li><strong>判断方法</strong>：检查高32位是否全为0。</li><li><strong>结果</strong>：高32位为 <code>0x00000000</code>，未溢出，返回 <code>0xFFFFFFFE</code>。</li></ul></li><li><p><strong>有符号乘法</strong>（<code>imul</code>）：</p><ul><li><strong>判断方法</strong>：结果是否超出 <code>[-2^31, 2^31 - 1]</code>。</li><li><strong>结果</strong>：<code>0xFFFFFFFE</code> 对应 <code>-2</code>，但实际数学结果为 <code>+2^32 - 2</code>，溢出发生，返回值为截断后的错误结果。</li></ul></li></ul><h4 id="1-6-2-3-无符号阵列乘法器">1.6.2.3 无符号阵列乘法器</h4><p>原码、补码一位乘法的硬件逻辑实现，需要在时钟节拍下、通过控制逻辑的控制，执行相应轮次的“加法、右移”操作来实现，速度较慢。<br>为了提高运算速度，可以仅采用<strong>组合逻辑电路</strong>以<strong>专用硬件</strong>方式构建阵列乘法器<br><strong>硬件结构</strong><br>阵列乘法器的核心由<strong>与门阵列</strong>和<strong>加法器阵列</strong>组成，典型结构如下：</p><ul><li><strong>输入</strong>： n 位无符号被乘数  $X = x_{n-1}x_{n-2}…x_0$ ， n 位无符号乘数  $Y = y_{n-1}y_{n-2}…y_0$ 。</li><li><strong>输出</strong>： 2n 位无符号乘积  $P = p_{2n-1}p_{2n-2}…p_0$ 。</li></ul><p>由  n × n  个与门 和 n × ( n - 1 )个全加器构成</p><table><thead><tr><th><strong>特性</strong></th><th><strong>阵列乘法器</strong></th><th><strong>串行乘法器（原码/补码一位乘法）</strong></th></tr></thead><tbody><tr><td><strong>硬件复杂度</strong></td><td>高（需要  O(n^2)  门电路）</td><td>低（仅需加法器、移位器和控制逻辑）</td></tr><tr><td><strong>运算速度</strong></td><td>快（组合逻辑延迟）</td><td>慢（需  n  个时钟周期）</td></tr><tr><td><strong>适用场景</strong></td><td>高性能计算、专用硬件</td><td>通用处理器、资源受限场景</td></tr><tr><td><strong>控制逻辑</strong></td><td>无（纯组合逻辑）</td><td>需状态机控制加减和移位操作</td></tr><tr><td>![image.png</td><td>200](<a href="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402194158184.png">https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402194158184.png</a>)</td><td></td></tr></tbody></table><h4 id="1-6-2-4-补码阵列乘法器">1.6.2.4 补码阵列乘法器</h4><ul><li><strong>核心思想</strong>：将补码乘法转换为无符号乘法，并通过符号修正处理负数。</li></ul><h3 id="1-6-3-定点数的除法运算">1.6.3 定点数的除法运算</h3><h4 id="1-6-3-1-原码除法">1.6.3.1 原码除法</h4><p>恢复余数法，不恢复余数法（加减交替法）<br>前提条件：<br>除数≠0<br>定点小数：|被除数| ＜ |除数|<br>定点整数：|被除数| ≥ |除数|</p><ul><li><strong>恢复余数法</strong><ul><li><code>|x|补+[-|Y|]补</code><ul><li>结果为正，商1，左 移+<code>[-|Y|]补</code> 【正1左负】</li><li>结果为负，商0，+<code>[|Y|]补</code>（恢复）【负0恢左负】<ul><li>恢复后左移+<code>[-|Y|]补</code><ul><li>结果为正/负，重复上述步骤，直到商位为n<br>商位的符号位是异或的结果</li></ul></li></ul></li></ul></li></ul></li><li><strong>不恢复余数法</strong><ul><li><code>|x|补+[-|Y|]补</code><ul><li>结果为正，商1，左移+<code>[-|Y|]补</code> 【正1左负】</li><li>结果为负，商0，左移+<code>|Y|补</code>【负0左正】<br>商位的符号位是异或的结果</li></ul></li></ul></li></ul><h4 id="1-6-3-2-补码除法">1.6.3.2 补码除法</h4><p>加减交替法<br>符号位参与运算<br>被除数/余数，除数采用<mark>双符号位</mark></p><ul><li><code>[X]补</code>+<code>[Y]补</code><ul><li>和除数<code>[Y]补</code> 同号，商1，左移+<code>[-Y]补</code> 【同1左负】</li><li>和除数<code>[Y]补</code> 异号，商0，左移+<code>[Y]补</code> 【异0左正】</li></ul></li><li>左移n次，余数×2^-n</li><li>商位满足后，将<strong>商位的最后一位改成1</strong>（精度差≤2^n）</li></ul><p>商位的符号位是异或的结果<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250402210721111.png" alt="520578617831cd6b53059193def8c15.jpg|400"></p><table><thead><tr><th><strong>特性</strong></th><th><strong>原码一位乘法</strong></th><th><strong>补码一位乘法（Booth算法）</strong></th></tr></thead><tbody><tr><td><strong>符号处理</strong></td><td>符号位单独处理：<code>符号 = x⊕y</code></td><td>符号位参与运算，无需单独处理</td></tr><tr><td><strong>操作数形式</strong></td><td>取绝对值进行乘法计算</td><td>直接使用补码参与运算</td></tr><tr><td><strong>核心步骤</strong></td><td>1. 加法后移位<br>2. 重复<code>n</code>次</td><td>1. 根据乘数末位和附加位判断加减<br>2. 算术右移<br>3. 重复<code>n</code>次</td></tr><tr><td><strong>加减条件</strong></td><td>当前位为<code>1</code>：ACC加被乘数<br>当前位为<code>0</code>：不操作</td><td>根据<code>CnCn-1</code>组合：<br><code>01</code>加被乘数，<code>10</code>减被乘数，<code>00/11</code>不操作</td></tr><tr><td><strong>移位方式</strong></td><td><strong>逻辑右移</strong>（高位补<code>0</code>）</td><td><strong>算术右移</strong>（符号位保持不变）</td></tr><tr><td><strong>加法次数</strong></td><td>最多<code>n</code>次</td><td>最多<code>n+1</code>次（可能多一次修正）</td></tr><tr><td><strong>移位次数</strong></td><td><code>n</code>次</td><td><code>n</code>次</td></tr><tr><td><strong>结果形式</strong></td><td>符号位与数值位分离</td><td>直接得到补码结果</td></tr></tbody></table><table><thead><tr><th><strong>特性</strong></th><th><strong>原码不恢复余数法（加减交替法）</strong></th><th><strong>补码不恢复余数法</strong></th></tr></thead><tbody><tr><td><strong>符号处理</strong></td><td>符号位单独处理：<code>符号 = x⊕y</code></td><td>符号位参与运算</td></tr><tr><td><strong>余数调整</strong></td><td>最终余数为负时需恢复余数</td><td>余数无需恢复，直接修正商</td></tr><tr><td><strong>商的确定</strong></td><td>根据余数符号：<br>余数正商<code>1</code>，余数负商<code>0</code></td><td>异号相除时：<br>余数与除数同号商<code>1</code>，否则商<code>0</code></td></tr><tr><td><strong>核心操作</strong></td><td>1. 余数正：减除数<br>2. 余数负：加除数<br>3. 重复<code>n</code>次</td><td>1. 余数与除数同号：减除数<br>2. 余数与除数异号：加除数<br>3. 重复<code>n</code>次</td></tr><tr><td><strong>移位方向</strong></td><td>左移</td><td>左移</td></tr><tr><td><strong>余数修正</strong></td><td>若最终余数为负，需加除数恢复</td><td>无需恢复余数</td></tr></tbody></table><ul><li>原码除法（加减交替法）仅在最终余数为负时恢复余数。</li><li>补码除法通过余数与除数的符号关系直接确定商。</li></ul><p><strong>操作次数</strong>：</p><ul><li>原码乘法：<code>n</code>次加法 + <code>n</code>次移位。</li><li>补码乘法：最多<code>n+1</code>次加法 + <code>n</code>次移位。</li><li>除法：均需<code>n</code>次迭代。</li></ul><p><strong>区别总结</strong></p><ol><li><p><strong>移位方式</strong>：</p><ul><li>原码乘法：逻辑右移（高位补<code>0</code>）。</li><li>补码乘法：算术右移（符号位不变）。</li></ul></li><li><p><strong>修正操作</strong>：</p><ul><li>原码除法需要恢复余数，补码除法直接修正商。</li></ul></li><li><p><strong>符号参与</strong>：</p><ul><li>原码运算符号独立，补码运算符号融入数值。</li></ul></li></ol><h2 id="1-7-浮点数表示与运算">1.7 浮点数表示与运算</h2><h3 id="1-7-1-浮点运算步骤">1.7.1 <strong>浮点运算步骤</strong></h3><ul><li><strong>对阶</strong>：小阶向大阶对齐，尾数右移两个阶的绝对插值（精度损失）。</li><li><strong>尾数运算</strong>：加减后规格化，处理溢出。</li><li><strong>舍入</strong>：就近舍入、向零舍入等。</li></ul><h3 id="1-7-2-浮点数的溢出">1.7.2 <strong>浮点数的溢出</strong></h3><ul><li>上溢：阶码超过最大允许值（OF=1）<br>单精度浮点数阶码最大为 127，若计算结果阶码超过 127，则上溢</li><li>下溢：运算结果的绝对值小于机器所能表示的最小绝对值<br>运算结果在0至规格化最小正数之间时称为正下溢，运算结果在0至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。<br>单精度浮点数阶码最小为 -126，若计算结果阶码低于 -126，则下溢</li></ul><h3 id="1-7-3-浮点数表示范围">1.7.3 <strong>浮点数表示范围</strong></h3><p>阶码和尾数都是<strong>原码</strong>表示时：</p><ul><li><strong>阶码 E</strong>（假设 k+1 位，1 位阶符 + k 位数值）：<ul><li><strong>最大值</strong>：$E_{\text{max}} = +(2^k - 1)$</li><li><strong>最小值</strong>：$E_{\text{min}} = -(2^k - 1)$</li></ul></li><li><strong>尾数 M</strong>（假设 n+1 位，1 位数符 + n 位数值）：<ul><li><strong>正数范围</strong>：$+2^{-n} \leq M \leq (1 - 2^{-n})$</li><li><strong>负数范围</strong>：$-(1 - 2^{-n}) \leq M \leq -2^{-n}$<br>如果都用<strong>补码</strong>表示：</li></ul></li><li><strong>阶码 E（k+1 位补码）</strong>：<ul><li><strong>最大值</strong>：$E_{\text{max}} = 2^{k} - 1$</li><li><strong>最小值</strong>：$E_{\text{min}} = -2^{k}$</li></ul></li><li><strong>尾数 M（n+1 位补码，定点小数）</strong>：<ul><li><strong>正数范围</strong>：$2^{-n} \leq M \leq 1 - 2^{-n}$</li><li><strong>负数范围</strong>：$-1 \leq M \leq -2^{-n}$</li></ul></li></ul><table><thead><tr><th><strong>类型</strong>（基数=2）</th><th><strong>公式</strong></th><th><strong>说明</strong></th><th></th></tr></thead><tbody><tr><td><strong>正数最大值</strong></td><td>$2^{E_{\text{max}}} \times M_{\text{max}}$</td><td>阶码最大，尾数最大正数。</td><td></td></tr><tr><td><strong>正数最小值</strong></td><td>$2^{E_{\text{min}}} \times M_{\text{min}}$</td><td>阶码最小，尾数最小正数（即精度）。</td><td></td></tr><tr><td><strong>负数最小值</strong></td><td>$2^{E_{\text{max}}} \times M_{\text{min}}$</td><td>阶码最大，尾数最小负数。</td><td></td></tr><tr><td><strong>负数最大值</strong></td><td>$2^{E_{\text{min}}} \times M_{\text{max}}$</td><td>阶码最小，尾数最大负数。</td><td></td></tr><tr><td>3位阶码 + 3位尾数，原码表示：</td><td></td><td></td><td></td></tr></tbody></table><ol><li><p><strong>阶码</strong>（1位阶符 + 2位数值）：</p><ul><li>最大值：$E_{\text{max}} = +3$（二进制 <code>0,11</code>）</li><li>最小值：$E_{\text{min}} = -3$（二进制 <code>1,11</code>）</li></ul></li><li><p><strong>尾数</strong>（1位数符 + 2位数值）：</p><ul><li>正数范围：<ul><li>最大值：$M_{\text{max}} = +0.75$（二进制 <code>0.11</code>）</li><li>最小值：$M_{\text{min}} = +0.25$（二进制 <code>0.01</code>）</li></ul></li><li>负数范围：<ul><li>最小值：$M_{\text{min}} = -0.75$（二进制 <code>1.11</code>）</li><li>最大值：$M_{\text{max}} = -0.25$（二进制 <code>1.01</code>）</li></ul></li></ul></li><li><p><strong>浮点数范围</strong>：</p><ul><li><strong>正数最大值</strong>：$2^{+3} \times 0.75 = 8 \times 0.75 = 6$</li><li><strong>正数最小值</strong>：$2^{-3} \times 0.25 = 0.125 \times 0.25 = 0.03125$</li><li><strong>负数最小值</strong>：$2^{+3} \times (-0.75) = 8 \times (-0.75) = -6$</li><li><strong>负数最大值</strong>：$2^{-3} \times (-0.25) = 0.125 \times (-0.25) = -0.03125$</li></ul></li></ol><p>eg.<br>(1) 设浮点数字长为8位，其中阶码3位（含1位阶符），尾数5位（含1位数符），阶码和尾数均以原码表示，基数r为8，则浮点数的最大最小值分别是多少？<br>(2) 设定点数原码为8位，则定点数的最大最小值分别是多少？<br>(3) 比较 (1) 和 (2) 能得出什么结论？</p><ul><li>浮点数最大值：$8^{+3}×(+0.9375)= +480$</li><li>浮点数最小值：$8^{+3}×(-0.9375)= -480$</li><li>定点数最大值：$+(2^{7}-1)= +127$</li><li>定点数最小值：$-(2^{7}-1)= -127$</li><li>结论：浮点数有效扩大了数据表示范围</li></ul><h3 id="1-7-4-浮点数的规格化">1.7.4 <strong>浮点数的规格化</strong></h3><p>规格化是调整浮点数的尾数和阶码，使得尾数的有效数字集中在高位，以最大化精度。不同基数（ r ）的浮点数规格化条件不同<br>浮点数规格化的好处是：增加数据的表示精度（精度最高）；使浮点数的表示形式唯一<br>当尾数为<mark>补码</mark>表示，且为 1.0xxxx形式时为规格化数。<strong>符号位与小数点后第一位相反</strong><br><mark>原码</mark>表示时，正数的规格化形式为0.1x···，负数的规格化形式为 1.1x···。<strong>尾数第一位固定为 1</strong><br>2^110ⅹ0.0111规格化右移1位，110B=6，6-1=5=101B。∴2^101ⅹ0.1110</p><table><thead><tr><th>**基数  r **</th><th><strong>规格化条件</strong></th><th><strong>左规操作</strong></th><th><strong>右规操作</strong></th></tr></thead><tbody><tr><td><strong>2</strong></td><td>尾数数值部分最高位为1</td><td>尾数左移1位，阶码减1</td><td>尾数右移1位，阶码加1</td></tr><tr><td><strong>4</strong></td><td>尾数数值部分最高2位不全为0</td><td>尾数左移2位，阶码减1</td><td>尾数右移2位，阶码加1</td></tr><tr><td><strong>8</strong></td><td>尾数数值部分最高3位不全为0</td><td>尾数左移3位，阶码减1</td><td>尾数右移3位，阶码加1</td></tr><tr><td><strong>16</strong></td><td>尾数数值部分最高4位不全为0</td><td>尾数左移4位，阶码减1</td><td>尾数右移4位，阶码加1</td></tr></tbody></table><ol><li><p><strong>规格化条件</strong>：</p><ul><li>基数  r = 2^k  时，尾数数值部分的 <strong>最高  k  位不全为0</strong>。</li><li>例如：<ul><li>r = 4 = 2^2  → 最高2位不全为0。</li><li>r = 8 = 2^3  → 最高3位不全为0。</li></ul></li></ul></li><li><p><strong>左规与右规操作</strong>：</p><ul><li><strong>左规</strong>：尾数左移  k  位，阶码减1（确保有效数字前移）。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329122019961.png" alt="image.png|400"></li><li><strong>右规</strong>：尾数右移  k  位，阶码加1（防止溢出或调整精度）。 <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329122140256.png" alt="image.png|400"></li></ul></li></ol><p>eg.<br>r=4，二进制浮点数 110.0101</p><ul><li>非规格化表示<ul><li>$4^{11}\times0.0001100101$，操作：$4^{11}$ 减1， 0.0001100101 左移2位</li><li>$4^{100}\times0.000001100101$ ，操作：$4^{100}$ 减2， 0.000001100101 左移4位</li></ul></li><li>规格化表示<ul><li>$4^{10}\times0.0110010100$</li><li>$4^{10}\times0.01100101000$</li></ul></li></ul><p>浮点数规格化后的表示范围：<br>阶码和尾数都是<strong>原码</strong>表示时：</p><ul><li><strong>阶码 E</strong>（假设 k+1 位，1 位阶符 + k 位数值）：<ul><li><strong>最大值</strong>：$E_{\text{max}} = +(2^k - 1)$</li><li><strong>最小值</strong>：$E_{\text{min}} = -(2^k - 1)$</li></ul></li><li><strong>尾数 M</strong>（假设 n+1 位，1 位数符 + n 位数值）：<ul><li><strong>正数范围</strong>：$+2^{-1} \leq M \leq (1 - 2^{-n})$</li><li><strong>负数范围</strong>：$-(1 - 2^{-n}) \leq M \leq -2^{-1}$<br>只有尾数的最小正数和最大负数从$2^{-n}$变成$2^{-1}$</li></ul></li></ul><p>阶码和尾数都是<strong>补码</strong>表示时：</p><ul><li><strong>阶码 E（k+1 位补码）</strong>：<ul><li><strong>最大值</strong>：$E_{\text{max}} = 2^{k} - 1$</li><li><strong>最小值</strong>：$E_{\text{min}} = -2^{k}$</li></ul></li><li><strong>尾数 M（n+1 位补码，定点小数）</strong>：<ul><li><strong>正数范围</strong>：$2^{-1} \leq M \leq 1 - 2^{-n}$</li><li><strong>负数范围</strong>：$-1 \leq M \leq -(2^{-1}+2^{-n})$</li></ul></li></ul><p>eg1.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)，将十进制数-56写成二进制定点数和浮点数(要求规格化表示)，并分别写出它们各自的机器数(原码、反码、补码)形式。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329115350757.png" alt="image.png">eg2.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)将十进制数 +13/128 写成二进制定点数和浮点数(要求规格化表示)，并写出它们各自的机器数(原码、反码、补码)形式。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329115731894.png" alt="image.png">注：$2^{-11}$是$2^{-3}$<br>eg3.设浮点数字长为16位，其中阶码5位(含1位阶符)，尾数11位(含1位数符)，写出十进制数- 53/512对应的浮点规格化数的原码、反码和补码以及阶码用移码、尾数用补码的形式。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329120730451.png" alt="image.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329121728139.png" alt="image.png"></p><h3 id="1-7-5-浮点数的加减法">1.7.5 <strong>浮点数的加减法</strong></h3><p><strong>1. 对阶（对齐阶码）</strong></p><ul><li><strong>原则</strong>：小阶向大阶对齐，尾数右移（差值为阶码差的绝对值）。</li><li><strong>操作</strong>：<ul><li>较小阶码的尾数<strong>算术右移</strong>（补符号位），右移位数 = 阶码差值。</li><li>阶码更新为较大的阶码。</li></ul></li><li><strong>关键</strong>：右移可能导致尾数低位丢失（需隐藏保留，后续舍入处理）。<br><strong>2. 尾数求和/差</strong></li><li><strong>操作</strong>：对阶后的尾数按<strong>补码规则直接加减</strong>。</li><li><strong>溢出判断</strong>：<ul><li>双符号位为 <code>01</code> 或 <code>10</code>：尾数溢出，需右归（见步骤3）。</li><li>双符号位一致（<code>00</code> 或 <code>11</code>）：直接进入规格化。</li></ul></li></ul><p><strong>3. 规格化</strong></p><ul><li><strong>目标</strong>：使尾数最高有效位与符号位不同（即形如 <code>0.1xxx</code> 或 <code>1.0xxx</code>）。<br>左-右+</li></ul><table><thead><tr><th><strong>情况</strong></th><th><strong>操作</strong></th><th><strong>调整阶码</strong></th></tr></thead><tbody><tr><td><strong>左归</strong>（<code>00.0xxx</code> 或 <code>11.1xxx</code>）</td><td>尾数左移，直到最高有效位为1</td><td>阶码减少左移次数</td></tr><tr><td><strong>右归</strong>（<code>01.xxx</code> 或 <code>10.xxx</code>）</td><td>尾数右移1位</td><td>阶码加1</td></tr><tr><td><strong>溢出处理</strong></td><td>上溢（<code>01.xxx</code>）：触发异常</td><td>下溢（<code>10.xxx</code>）：置为机器零（阶码全0）</td></tr><tr><td><strong>4. 舍入与最终结果</strong></td><td></td><td></td></tr></tbody></table><ul><li><strong>舍入</strong>：规格化后对尾数低位进行截断或舍入<ul><li>截断法：直接丢弃超出机器字长的尾数低位（导致误差积累）</li><li>末位恒置1法：将机器字长内的尾数的最低位恒置为1（损失1位精度，但误差积累较小）</li><li>0舍1入法：当需要丢弃的尾数低位中的最高位为1时，将机器字长内的尾数的最低位加1</li></ul></li><li><strong>阶码检查</strong>：若阶码超出范围（上溢/下溢），按溢出规则处理。<br>注：如果是转补码，按隐藏符号位的最后一个1算。eg.<code>[x]补=11,10100(1)，[-x]补=00,01011(1)</code><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7e8a9d22d02d94cba50966f9772de0f.jpg" alt="7e8a9d22d02d94cba50966f9772de0f.jpg"></li></ul><h3 id="1-7-6-IEEE-754-浮点数运算">1.7.6 <strong>IEEE 754 浮点数运算</strong></h3><p>任何一个二进制数N可表示：N=r<sup>E</sup>×M</p><ol><li>对阶 → 2. 尾数加减 → 3. 规格化 → 4. 舍入 → 5. 溢出判断 → 输出结果。<br><strong>1. 对阶（对齐阶码）</strong></li></ol><ul><li><strong>阶码表示</strong>：采用移码（偏置码），单精度偏置值为 <code>127</code>，双精度为 <code>1023</code>。</li><li><strong>对齐规则</strong>：<ul><li>小阶向大阶对齐，尾数<strong>算术右移</strong>（移位数 = 阶差绝对值），右移时隐藏位（最高位）需显式参与。</li><li><strong>移码加减规则</strong>：阶码相加减时，需按移码运算公式处理（实际运算需转换为真值后再调整偏置值）。<br><strong>2. 尾数运算（原码运算）</strong></li></ul></li><li><strong>隐藏位处理</strong>：<ul><li>运算前需恢复隐藏的 <code>1.</code>（规格化数的隐含前导1）。</li><li>运算后需重新隐藏（规格化后保留前导1）。</li></ul></li><li><strong>运算规则</strong>：<ul><li><strong>加法</strong>：两尾数直接相加（原码加减需处理符号位，实际硬件中可能转换为补码运算）。</li><li><strong>减法</strong>：转换为加法（减数符号取反）。<br><strong>3. 规格化</strong></li></ul></li><li><strong>规格化条件</strong>：尾数必须满足 <code>1.xxxxx...</code>（原码形式）。</li><li><strong>规格化操作</strong>：</li></ul><table><thead><tr><th><strong>情况</strong></th><th><strong>操作</strong></th><th><strong>阶码调整</strong></th></tr></thead><tbody><tr><td><strong>左规</strong>（尾数形式为 <code>0.xxxx</code>）</td><td>尾数左移1位，阶码减1</td><td>阶码减1</td></tr><tr><td><strong>右规</strong>（尾数形式为 <code>1b.xxxx</code>）</td><td>尾数右移1位，阶码加1</td><td>阶码加1</td></tr><tr><td><strong>4. 舍入处理</strong></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>模式</strong></th><th><strong>规则</strong></th></tr></thead><tbody><tr><td><strong>就近舍入（默认）</strong></td><td>舍入到最近的数，中间值向偶数（末位为0）舍入。</td></tr><tr><td><strong>朝正∞舍入</strong></td><td>结果向正无穷方向舍入（取右侧更大的可表示数）。</td></tr><tr><td><strong>朝负∞舍入</strong></td><td>结果向负无穷方向舍入（取左侧更小的可表示数）。</td></tr><tr><td><strong>截断（朝0舍入）</strong></td><td>直接丢弃多余位，结果向0方向舍入。</td></tr><tr><td><strong>5. 溢出判断</strong></td><td></td></tr></tbody></table><ul><li><strong>上溢</strong>：<ul><li>阶码超过最大可表示值（单精度阶码全1，即 <code>11111111</code>，对应真值 <code>+127</code>）。</li><li>结果视为 <code>±∞</code>（根据符号位）。</li></ul></li><li><strong>下溢</strong>：<ul><li>阶码低于最小可表示值（单精度阶码全0，即 <code>00000000</code>，对应真值 <code>-126</code>）。</li><li>结果视为<strong>非规格化数</strong>或<strong>机器零</strong>（尾数全0）。</li></ul></li></ul><p><strong>与补码浮点运算的差异</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>IEEE 754</strong></th><th><strong>补码浮点运算</strong></th></tr></thead><tbody><tr><td><strong>阶码表示</strong></td><td>移码（偏置码）</td><td>补码</td></tr><tr><td><strong>尾数表示</strong></td><td>原码（隐含前导1，需显式参与运算）</td><td>补码（显式符号位）</td></tr><tr><td><strong>规格化规则</strong></td><td>尾数必须为 <code>1.xxxx</code></td><td>补码尾数最高位与符号位不同（如 <code>0.1xxx</code> 或 <code>1.0xxx</code>）</td></tr><tr><td><strong>舍入模式</strong></td><td>支持多种舍入方式（如就近舍入、向偶数舍入）</td><td>通常仅截断或简单舍入</td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329091853718.png" alt="image.png"></td><td></td><td></td></tr><tr><td><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329092307636.png" alt="image.png">浮点数相加：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250405194750013.png" alt="image.png"></td><td></td><td></td></tr><tr><td>浮点数相乘：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406064555148.png" alt="image.png"></td><td></td><td></td></tr><tr><td>浮点数相除：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406064740616.png" alt="image.png"></td><td></td><td></td></tr></tbody></table><h3 id="1-7-7-浮点数结构">1.7.7 <strong>浮点数结构</strong></h3><p>用<strong>阶码（指数）</strong> 和<strong>尾数</strong>表示数值，适合大范围和高精度需求。 <strong>IEEE 754标准</strong></p><ul><li><strong>单精度（32位）</strong>：1位符号 + 8位阶码（偏置值127） + 23位尾数。$([2^{-126},(2 - 2^{-23})\times2^{127}])$<br>$(2 - 2^{-23})\times2^{127}$即$2^{128}-2^{104}$</li><li><strong>双精度（64位）</strong>：1位符号 + 11位阶码（偏置值1023） + 52位尾数。$([2^{-1022},(2 - 2^{-52})\times2^{1023}])$</li><li><strong>阶码范围</strong>：单精度 <code>-126 ~ +127</code>，双精度 <code>-1022 ~ +1023</code>。</li><li><strong>偏移常数</strong>：偏移常数（Bias）用于浮点数的阶码（指数）编码，将实际指数转换为无符号整数存储。对于 n 位阶码，偏移常数为：$2^{n-1}-1$<br>单精度浮点数（32位）偏移常数127<br><strong>作用</strong>：将实际指数范围对称分布在正负区间，避免存储负指数时使用符号位<br>为什么不采用标准的128，而采用127?<ul><li><p>若偏移值为128，<strong>最小规格化数的实际指数为-127</strong>（对应二进制阶码<code>00000001</code>），其倒数为2^127。</p></li><li><p>但单精度浮点数的最大可表示值约为2^127（指数上限为+127）。此时倒数与最大值相等，<strong>可能引发溢出</strong>（因符号位或特殊值冲突）。</p></li><li><p>若偏移值为127，<strong>最小规格化数的实际指数为-126</strong>（对应阶码<code>00000001</code>），其倒数为2^126，而单精度的指数上限仍为+127。此时倒数2^126<strong>完全在可表示范围内</strong>，不会溢出。</p></li></ul></li><li>IEEE 754标准中，<strong>规格化数</strong>的尾数有一个隐含的<strong>最高位1</strong><br>1. <strong>节省存储空间</strong>：<br>实际存储的尾数部分不包含这个1（例如单精度浮点数的23位尾数），但在计算时会自动补上。这相当于“白嫖”一个额外比特，<strong>提高精度</strong>。<br>2. <strong>扩展动态范围</strong>：<br>隐含的1使规格化数的实际值为 1.尾数×2^指数，而非 0.尾数×2^指数，从而能表示更大的数值范围。</li></ul><h3 id="1-7-8-特殊值">1.7.8 <strong>特殊值</strong></h3><p>IEEE 754定义了多种特殊值，用于处理边界情况和异常运算：</p><table><thead><tr><th><strong>数值分类</strong></th><th><strong>符号S</strong></th><th><strong>阶码E</strong></th><th><strong>尾数M</strong></th><th><strong>真值公式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>正零（+0）</strong></td><td>0</td><td>全0（0）</td><td>0</td><td>+0</td><td>符号为0，表示正零。</td></tr><tr><td><strong>负零（-0）</strong></td><td>1</td><td>全0（0）</td><td>0</td><td>-0</td><td>符号为1，表示负零。实际使用中与+0等效，但符号位不同。</td></tr><tr><td><strong>非规格化正数</strong></td><td>0</td><td>全0（0）</td><td>M \neq 0</td><td>(-1)^0 \times 2^{-126} \times 0.M</td><td>用于表示接近零的极小正数，无隐藏位1，指数固定为-126。</td></tr><tr><td><strong>非规格化负数</strong></td><td>1</td><td>全0（0）</td><td>M \neq 0</td><td>(-1)^1 \times 2^{-126} \times 0.M</td><td>类似非规格化正数，但符号为负。</td></tr><tr><td><strong>正无穷大（+∞）</strong></td><td>0</td><td>全1（255）</td><td>0</td><td>+∞</td><td>表示数值溢出（如非零数除以0），符号为0。</td></tr><tr><td><strong>负无穷大（-∞）</strong></td><td>1</td><td>全1（255）</td><td>0</td><td>-∞</td><td>类似正无穷大，但符号为负。</td></tr><tr><td><strong>NaN（非数）</strong></td><td>0或1</td><td>全1（255）</td><td>M \neq 0</td><td>\text{NaN}</td><td>表示无效运算结果（如0/0、负数平方根），尾数非0。</td></tr><tr><td><strong>规格化正数</strong></td><td>0</td><td>1 \leq E \leq 254</td><td>任意M</td><td>(-1)^0 \times 2^{E-127} \times 1.M</td><td>常规正数，隐藏位1自动补到尾数前，指数范围为-126到+127。</td></tr><tr><td><strong>规格化负数</strong></td><td>1</td><td>1 \leq E \leq 254</td><td>任意M</td><td>(-1)^1 \times 2^{E-127} \times 1.M</td><td>常规负数，隐藏位1自动补到尾数前，指数范围同上。</td></tr></tbody></table><ol><li><p><strong>正零与负零</strong>：</p><ul><li>实际运算中两者等效（如  +0 = -0 ），但符号位不同，某些场景（如函数极限）可能区分两者。</li></ul></li><li><p><strong>非规格化数</strong>：</p><ul><li><strong>作用</strong>：<ul><li>解决“<strong>阶码下溢</strong>”问题。当数值小于最小规格化数（ $2^{-126}$ ）时，用非规格化数平缓过渡到零。</li><li>避免计算结果突然归零（例如  $1.0 \times 2^{-127}$  无法用规格化数表示，但可用非规格化数  $0.5 \times 2^{-126}$ 表示）。</li></ul></li></ul></li><li><p><strong>无穷大（±∞）</strong>：</p><ul><li><strong>作用</strong>：<ul><li>标记数值溢出（如  1.0 / 0.0 ）或不可达值。</li><li>使程序在溢出时继续运行，而非直接崩溃（例如浮点数除0返回无穷大，整数除0则报错）。</li></ul></li></ul></li><li><p><strong>NaN（非数）</strong>：</p><ul><li><strong>作用</strong>：<ul><li>表示无效运算（如  0/0 、 ∞/∞ 、负数平方根）。</li><li>程序可通过检测NaN跳过错误，避免中断（例如返回NaN后继续执行后续逻辑）。</li></ul></li></ul></li><li><p><strong>规格化数</strong>：</p><ul><li><strong>隐藏位1</strong>：尾数前隐含的1无需存储，节省1位空间，提升精度（例如23位尾数实际表示24位数值）。</li><li><strong>指数范围</strong>：阶码E偏移127，实际指数范围为  $-126 \leq E \leq +127$</li></ul></li></ol><ul><li><p><strong>非规格化数应用</strong>：<br>计算  $1.0 \times 2^{-128}$ （远小于最小规格化数  $2^{-126}$ ），可用非规格化数表示为  $0.25 \times 2^{-126}$ 。</p></li><li><p><strong>无穷大应用</strong>：<br>当计算  1.0 / 0.0  时，结果为  +∞ ，程序可继续执行后续操作（如判断结果是否为无穷大）。</p></li><li><p><strong>NaN应用</strong>：<br>计算  $\sqrt{-1}$ 时返回NaN，程序员可捕获此结果并处理异常。</p></li></ul><p>总结：</p><ul><li>非规格化数：缓冲极小值，避免数值突变。</li><li>无穷大：标记溢出，防止程序崩溃。</li><li>NaN：兜底无效运算，增强容错能力。</li></ul><p>注：</p><ul><li><p>浮点数加减法第一步是<strong>对阶</strong><br>对阶的规则是：小阶向大阶看齐。即阶码小的数的尾数<mark>算术右移</mark>，每右移一位，阶码加 1直到两数的阶码相等为止。<br>因此不存在阶码减小、尾数左移。<mark>只有阶码增大，尾数右移</mark>。<br>对阶不会引起阶码<strong>上溢或下溢</strong><br><strong>右规、尾数舍入</strong>时可能引起阶码<strong>上溢</strong><br><strong>左规</strong>时可能引起阶码<strong>下溢</strong></p></li><li><p>在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有<strong>规格化后阶码</strong>超出所能表示的范围时，才发生溢出。<br>判断浮点数运算是否溢出，取决于阶码是否上溢。阶码下溢可以通过非规格化数来表示。尾数上溢或下溢，可以通过左移或右移进行调整。</p></li><li><p>与非规格化浮点数相比，采用规格化浮点数的目的主要是为了增加数据的表示精度</p></li><li><p>运算结果在0至规格化最小正数之间时称为正下溢，运算结果在0至规格化最大负数之间时称为负下溢，正下溢和负下溢统称下溢。</p></li><li><p><strong>舍入</strong>是浮点数的概念，定点数没有舍入的概念。</p></li><li><p>浮点数舍入的情况有两种：对阶、右规格化。</p></li><li><p>舍入不一定产生误差，如向下舍入11.00 到11.0时是没有误差的</p></li><li><p>浮点数表示中基数的值是约定好的，因此将其隐含。</p></li><li><p>阶移尾原</p></li><li><p>偏置值=2^(n-1)-1</p></li><li><p>阶码决定范围，尾数决定精度。在浮点数总位数不变的情况下。<strong>阶码</strong>位数越多，<strong>尾数</strong>位数越少。即<strong>范围越大，精度越低</strong></p></li><li><p><strong>阶码</strong>的值决定了<strong>小数点的位置</strong></p></li><li><p><strong>基数</strong>越大，在运算中尾数<strong>右移</strong>的可能性越小，运算的<strong>精度损失越小</strong>。</p></li><li><p>由于<strong>基数</strong>大时发生因对阶或尾数溢出需右移及规格化需左移的次数显著减少，因此运算<strong>速度</strong>可以提高。</p></li><li><p><strong>基数</strong>越大，可表示的数的<strong>范围</strong>越大，所表示的数的个数越多，精度降低。</p></li><li><p>IEEE 754浮点数格式位数有限(单精度32位、双精度64位)，无法精确表示无限循环小数。</p></li></ul><h2 id="1-8-C语言中的数据类型及转换">1.8 C语言中的数据类型及转换</h2><p>无论是无符号数还是有符号数，C语言程序并不检测数据在加、减、乘等运算中产生的<strong>溢出</strong>现象。<br>程序员应尽量避免出现这种情况，所编制的应用程序应具有对溢出进行判断的功能。<br>char 8<br>short 16<br>int 32<br>long 64<br>float 32<br>double 64<br>65535=1111 1111 1111 1111<br><mark>都是按照补码形式存储的</mark><br><font color="#f79646">定义的变量值是真值，存储的是补码，输出的值是真值，要把补码转成有符号位的原码</font><br>eg.<br>unsigned short x = unsigned short = 65535;<br>short y = (short)x;<br>y存储的值是1111 1111 1111 1111，补码全为1对应的十进制真值是-1</p><h2 id="1-9-有符号数与无符号数的转换">1.9 有符号数与无符号数的转换</h2><ol><li><strong>转换规则</strong><ul><li>当位数相同的<strong>有符号数</strong>与<strong>无符号数</strong>相互转换时，<strong>二进制位保持不变</strong>，仅改变解释方式。<br>注：如果是<strong>负数</strong>，要转换成<strong>补码</strong>形式。同样，如果无符号转有符号，第一位是1，是负数，也要转成补码</li><li><strong>有符号数 → 无符号数</strong>：符号位被当作数值的一部分。<br>①若从小字长转换到大字长，则要先对原数字的高位部分进行扩展，若原数字是无符号整数，则进行零扩展；若原数字是有符号整数，则进行符号扩展。<br>②若从大字长转换到小字长，则直接截取低位部分。也就是说，先进行字长的转换，再进行符号的转换。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> x = <span class="number">-4321</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y = (<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="comment">// x的二进制补码：11101111 11101111</span></span><br><span class="line"><span class="comment">// y被解释为无符号数：61215</span></span><br></pre></td></tr></table></figure></li><li><strong>无符号数 → 有符号数</strong>：最高位被当作符号位。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> x = <span class="number">65535</span>;  <span class="comment">// 二进制全1</span></span><br><span class="line"><span class="type">short</span> y = (<span class="type">short</span>)x;</span><br><span class="line"><span class="comment">// y的二进制补码10000000 00000001解释为有符号数：-1</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-10-不同字长整数之间的转换">1.10 不同字长整数之间的转换</h2><ol><li><strong>大字长 → 小字长（截断高位）</strong><ul><li><strong>规则</strong>：直接截断高位部分，保留低位部分。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">165537</span>;      <span class="comment">// 0010 1000 0110 1010 0001</span></span><br><span class="line"><span class="type">short</span> y = (<span class="type">short</span>)x;  <span class="comment">// 保留低16位，1000 0110 1010 0001 当前是补码，负数，转真值1,111 1001 0101 1111 → 十进制-31071</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> u = <span class="number">-34991</span>;      <span class="comment">// 存储为补码，-34491全部取反+1 0,111 1111 1111 1111 0111 0111 0101 0001</span></span><br><span class="line"><span class="type">short</span> v = (<span class="type">short</span>)u;  <span class="comment">// 保留低16位0111 0111 0101 0001 → 十进制30545</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>小字长 → 大字长（符号扩展或零扩展）</strong><ul><li><strong>规则</strong>：<ul><li><strong>有符号数</strong>：进行<strong>符号扩展</strong>（高位填充原符号位）。</li><li><strong>无符号数</strong>：进行<strong>零扩展</strong>（高位填充0）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> x = <span class="number">-4321</span>;      <span class="comment">// 二进制补码：11101111 11101111（符号位1）</span></span><br><span class="line"><span class="type">int</span> y = x;            <span class="comment">// 符号扩展为11111111 11111111 11101111 11101111 → 十进制-4321</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> u = <span class="number">61215</span>;  <span class="comment">// 二进制：11101111 11101111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v = u;        <span class="comment">// 零扩展为00000000 00000000 11101111 11101111 → 十进制61215</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>注：</p><ol><li><p><strong>混合运算的隐式转换</strong></p><ul><li>若表达式中混合有符号和无符号数，<strong>有符号数会被隐式转换为无符号数</strong>，可能导致逻辑错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="comment">// 条件为假，因为-1被转换为无符号数（即4294967295）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据溢出与截断</strong></p><ul><li>大字长转小字长可能导致<strong>数据丢失</strong>（如<code>int</code>→<code>short</code>）。</li><li>小字长转大字长时，需明确扩展方式以避免数值错误。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250329144222273.png" alt="image.png"></li></ul></li><li><p><strong>字符型转换的特殊性</strong></p><ul><li><code>char</code>类型(8位)默认按无符号整数处理，转换为<code>int</code>时进行<strong>零扩展</strong>。</li></ul></li></ol><h2 id="1-11-浮点数之间的转换">1.11 浮点数之间的转换</h2><table><thead><tr><th>转换方向</th><th>情况描述</th></tr></thead><tbody><tr><td><code>float</code> → <code>double</code></td><td>值相同</td></tr><tr><td><code>double</code> → <code>float</code></td><td>大数可能溢出，高精度发生舍入</td></tr><tr><td><code>float/double</code> → <code>int</code></td><td>小数部分向 0 截断，大数可能溢出</td></tr><tr><td><code>int</code> → <code>float</code></td><td>比较大的数无法精确表示</td></tr><tr><td><code>int</code> → <code>double</code></td><td>值相同</td></tr><tr><td>假设变量 <code>i</code>、<code>f</code>、<code>d</code> 的类型分别是 <code>int</code>、<code>float</code> 和 <code>double</code>，判断下列 C 语言关系表达式是否恒为真。</td><td></td></tr></tbody></table><ol><li><code>i == (int)(float) i;</code><ul><li>结果：不恒为真</li><li>原因：<code>i</code> 转换为 <code>float</code> 型时就可能出现精度缺失，可不考虑再转回 <code>int</code> 型。</li></ul></li><li><code>f == (float)(int) f;</code><ul><li>结果：不恒为真</li><li>原因：<code>f</code> 转换为 <code>int</code> 型时就可能出现小数部分向 0 截断 ，可不考虑再转回 <code>float</code> 型。</li></ul></li><li><code>i == (int)(double) i;</code><ul><li>结果：恒为真</li><li>原因：<code>i</code> 转换为 <code>double</code> 型后数值不变，因此再转回 <code>int</code> 型后数值不变。</li></ul></li><li><code>f == (float)(double) f;</code><ul><li>结果：恒为真</li><li>原因：<code>f</code> 转换为 <code>double</code> 型后数值不变，因此再转回 <code>float</code> 型后数值不变。</li></ul></li><li><code>d == (float) d;</code><ul><li>结果：不恒为真</li><li>原因：<code>d</code> 转换为 <code>float</code> 型时可能出现大数溢出和高精度舍入。</li></ul></li><li><code>f == -(- f);</code><ul><li>结果：恒为真</li><li>原因：浮点数取负仅将其数符（最高位）取反即可。</li></ul></li></ol><h2 id="1-12-数据存储和边界对齐">1.12 数据存储和边界对齐</h2><ol><li>大小端存储<ul><li><strong>小端</strong>：低对低，高对高（如 <code>0x1234</code> 存储为 <code>34 12</code>）。</li><li><strong>大端</strong>：低对高，高对低（如 <code>0x1234</code> 存储为 <code>12 34</code>）。  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406115230806.png" alt="image.png|200">指令的二进制编码按 <strong>操作码 → 操作数 → 立即数</strong> 的顺序排列。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/20250406115722956.png" alt="image.png|400"><br>在指令编码中，操作码（Opcode）和寄存器编号按顺序连续存放。操作码 MOV 为 40H，存放在地址 1000H；寄存器 EAX 的编号为 12H，存放在地址 1001H。<strong>立即数</strong>按大小端规则存放在后续地址<br>在阅读以小端方式存储的机器代码时，要注意字节是按相反顺序显示的。</li></ul></li><li>数据边界对齐存储<br><strong>边界对齐（Alignment）</strong> 是计算机内存管理的重要机制，要求数据在内存中的 <strong>起始地址</strong> 必须是其 <strong>自身大小的整数倍</strong>。现代计算机（尤其是 RISC 架构）普遍采用边界对齐存储，以优化访存效率。</li></ol><table><thead><tr><th><strong>数据类型</strong></th><th><strong>对齐要求（地址必须是…的倍数）</strong></th><th><strong>32位系统示例</strong></th></tr></thead><tbody><tr><td>字节（char）</td><td>1</td><td>地址任意（如 <code>0x0000</code>, <code>0x0001</code>）</td></tr><tr><td>半字（short）</td><td>2</td><td>地址为偶数（如 <code>0x0002</code>, <code>0x0004</code>）</td></tr><tr><td>字（int）</td><td>4</td><td>地址为4的倍数（如 <code>0x0004</code>, <code>0x0008</code>）</td></tr><tr><td>在 C 语言中，结构体（<code>struct</code>）的对齐需满足以下条件：</td><td></td><td></td></tr></tbody></table><ol><li><strong>成员对齐</strong>：每个成员的起始地址必须满足 <code>地址 % 对齐值 = 0</code>。</li><li><strong>结构体对齐</strong>：结构体总长度必须是 <strong>最大成员对齐值</strong> 的整数倍（不足则填充）。</li></ol><p>eg.<br><strong>1. 结构体 A：<code>struct A &#123; int a; char b; short c; &#125;</code></strong></p><ul><li><strong>成员对齐</strong>：</li></ul><table><thead><tr><th><strong>地址范围</strong></th><th><strong>内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>0x0000-0x0003</code></td><td><code>int a</code>（4字节）</td><td>对齐到 4 的倍数（0x0000）</td></tr><tr><td><code>0x0004</code></td><td><code>char b</code>（1字节）</td><td>对齐到 1 的倍数（0x0004）</td></tr><tr><td><code>0x0005</code></td><td><strong>填充 1 字节</strong></td><td>确保 <code>short c</code> 对齐到 2 的倍数</td></tr><tr><td><code>0x0006-0x0007</code></td><td><code>short c</code>（2字节）</td><td>对齐到 2 的倍数（0x0006）</td></tr></tbody></table><ul><li><strong>总大小</strong>：<ul><li>实际占用：<code>4 + 1 + 1（填充） + 2 = 8字节</code></li><li>结构体对齐：最大对齐值为4，8是4的倍数，无需额外填充。</li></ul></li></ul><p><strong>2. 结构体 B：<code>struct B &#123; char b; int a; short c; &#125;</code></strong></p><ul><li><strong>成员对齐</strong>：</li></ul><table><thead><tr><th><strong>地址范围</strong></th><th><strong>内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>0x0000</code></td><td><code>char b</code>（1字节）</td><td>对齐到 1 的倍数（0x0000）</td></tr><tr><td><code>0x0001-0x0003</code></td><td><strong>填充 3 字节</strong></td><td>确保 <code>int a</code> 对齐到 4 的倍数</td></tr><tr><td><code>0x0004-0x0007</code></td><td><code>int a</code>（4字节）</td><td>对齐到 4 的倍数（0x0004）</td></tr><tr><td><code>0x0008-0x0009</code></td><td><code>short c</code>（2字节）</td><td>对齐到 2 的倍数（0x0008）</td></tr><tr><td><code>0x000A-0x000B</code></td><td><strong>填充 2 字节</strong></td><td>确保结构体总大小为 4 的倍数</td></tr></tbody></table><ul><li><strong>总大小</strong>：<ul><li>实际占用：<code>1 + 3（填充） + 4 + 2 = 10字节</code></li><li>结构体对齐：最大对齐值为4，10不是4的倍数，需填充2字节至12字节。</li></ul></li></ul><p><strong>边界对齐 vs 边界不对齐</strong></p><ol><li>对齐存储</li></ol><ul><li><strong>特点</strong>：<ul><li>数据按对齐要求紧密排列，填充字节插入以对齐地址。</li><li><strong>优点</strong>：单次访存读取完整数据，效率高。</li><li><strong>缺点</strong>：可能浪费少量空间。</li></ul></li></ul><ol start="2"><li>不对齐存储</li></ol><ul><li><strong>特点</strong>：<ul><li>数据连续存放，无填充字节。</li><li><strong>缺点</strong>：跨存储字的数据需多次访存并拼接，效率低。</li></ul></li></ul><p><strong>应用场景</strong></p><ul><li><p><strong>RISC架构</strong>：强制边界对齐，确保指令流水线高效运行。</p></li><li><p><strong>嵌入式系统</strong>：权衡空间与效率，通常选择对齐存储。</p></li><li><p><strong>网络协议</strong>：数据包按对齐格式传输，避免接收端处理复杂度。</p></li><li><p><strong>结构体设计建议</strong>：</p><ul><li>按成员对齐值降序排列（如 <code>int → short → char</code>），减少填充字节。</li></ul></li></ul><h2 id="1-13-第二章错题">1.13 第二章错题</h2><ol><li>已知 [x]补 =1,0000000，则[-x]补 是(D)<br>A.0,1111111   B.0,0000001   C.1.0000000   D.无法表示<br><code>1,0000000</code>表示真值-128（最小负数）。  计算[-x]补 )，即求+128的补码。然而，8位补码的最大正数为+127，+128超出表示范围，<strong>无法表示</strong>。</li><li>设x为真值，x* 为其绝对值，满足 [-x*]补=[-x]补 当且仅当<br>A. x任意   B.x为正数   c.x为负数   D.以上都不对<br>当x为正数时，x* = x，等式成立<br>当x为0时，等式成立<br>当x为负数时，x* = -x， [x]补≠[-x]补，等式不成立<br>b是充分条件，选d</li><li>由3个“1”和5个“0”组成的8位二进制补码，能表示的最小整数是()。<br>A.-126   B.-125   C.-32   D.-3<br>补码若符号位相同，数值位越大（即二进制中1的位数越多），码值越大。此处1位数一样，<strong>最高位的 <code>1</code> 位置越靠左（权重越大），对应的绝对值越小，码值越大</strong>。故补码为1000 0011，真值为-125<br>刚开始想的补码1110 0000，是一个无效补码，因为补码的最小负数是<code>10000000</code>（-128），而<code>11100000</code>不是合法的补码表示。</li><li>若某浮点数为$2^{11}×1.1011$，其中阶码为原码表示，尾数为补码表示，则该浮点数()<br>A.需要将尾数数值部分右移1位规格化<br>B.需要将尾数数值部分右移2位规格化<br>C.需要将尾数数值部分左移1位规格化<br>D.已经规格化<br>补码负数规格化，符号位为1，则尾数最高位应为0，将尾数数值部分左移1位规格化，即为$2^{10}×1.0110$</li><li>-0.4375的IEEE754单精度浮点数表示为()<br>A.BEE0 0000H   B.BF60 0000H    C.BF70 0000H   D.C0E0 0000H<br>-0.4375=-0.0111，应该转化为$2^{-2}×(-1.11)$，S=1，E=125=01111101，M=11，选A</li><li>有如下C语言程序段：short si=-32767;unsigned short usi = si;执行上述两条语句后，usi的值为()。<br>A.-32767   B.32767   C.32768   D.32769<br>因为si是负数，先转换成补码形式1000 0000 0000 0001，转换成无符号数后为32769</li><li>unsigned short usi=65535:short si = usi;执行上述程序段后，si的值为()。<br>A.-1   B.-32767   C.-32768   D.-65535<br>1111 1111 1111 1111，第一个1看作符号位，负数，转补码，即1000 0000 0000 0001，-1</li><li>一个C语言程序在一台32位机器上运行。程序中定义了三个变量x，y和z，x和z为int型，y为short型当x=127，y=-9时，执行赋值语句z=x+y后，x，y和z的值分别是()。<br>A.x=0000007FH，y=FFF9H，2=00000076H<br>B.x=0000007FH，y=FFF9H，Z=FFFF0076H<br>C.x=0000007FH，y=FFF7H，Z=FFFF0076H<br>D.X=0000007FH，y=FFF7H，2=00000076H<br><code>x</code> 为 <code>int</code> 型（32位），赋值为 <code>127</code>，其补码为0x0000007\text{F}<br><code>y</code> 为 <code>short</code> 型（16位），赋值为 <code>-9</code>，其补码为0xFFF7<br><code>y</code> 从 <code>short</code> 提升为 <code>int</code> 时，进行符号扩展0xFFFFFFF7<br>执行 <code>z = x + y</code>：  $\begin{align*}0x0000007\text{F} &amp; \quad (\text{十进制 } 127) \+,0xFFFFFFF7 &amp; \quad (\text{十进制 } -9) \\hline0x00000076 &amp; \quad (\text{十进制 } 118)\end{align*}$ d</li><li>对于相同位数(设为N位，不考虑符号位)的二进制补码小数和十进制小数，二进制小数能表示的数的个数/十进制小数所能表示数的个数为()。<br>A.$(0.2)^N$   B.$(0.2)^{N-1}$  C.$(0.02)^N$   D.$0.02^{N-1}$<br>N位二进制小数共有2^N种状态，每种状态都能表示一个不同的小数，而十进制小数能表示的数的个数为 10^N，二者的商为(0.2)^N</li><li>下列关于补码和移码关系的叙述中，()是不正确的。<br>A.相同位数的补码和移码表示具有相同的数据表示范围<br>B.0的补码和移码表示相同<br>C.同一个数的补码和移码表示，其数值部分相同，而符号相反<br>D.一般用移码表示浮点数的阶码，而补码表示定点整数<br>0的补码是0000 0000，0的移码是1000 0000，选b</li><li>一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则下列说法中正确的是()。<br>A.若采用移码表示，偏置值为127，则此整数最小为-64<br>B若采用移码表示，偏置值为128，则此整数最大为123<br>C.若采用补码表示，则此整数最小为-96<br>D.若采用补码表示，则此整数最大为 252<br>当采用补码表示时，要使得数值最大，就要让符号位为0，且把“1”放在高位，得到的补码为01111110B=126<br>要使得数值最小，就要让符号位为1，且把“1”放在低位，得到的补码为 10011111B=-97。<br>当采用移码表示时，设偏置值为128，要使数值最大，就要把“1”放在高位，得到的移码为11111100B，转补码是0111 1100=124<br>设偏置值为127，要使得数值最小，则应把“1”放在低位，得到的移码为 0,011 1111B，【错误：转补码是1,011 1111B，转原码是1,100 0001B=-65。移码和补码的转换仅适用于特定场景】，真值=移码值−偏置值=63−127=−64，A 正确。</li><li>在计算机中，通常用来表示主存地址的是()<br>A.移码   B.补码   C.原码   D.无符号数<br>主存地址都是正数，因此不需要符号位，因此直接采用无符号数表示。</li><li>ALU作为运算器的核心部件，其属于()<br>A.时序逻辑电路 B.组合逻辑电路 C.控制器 D.寄存器<br>ALU 是由组合逻辑电路构成的，最基本的部件是并行加法器。单纯的ALU 不能够存储运算结果和中间变量，因此往往将 ALU 和寄存器或暂存器相连。</li><li>下列四个补码整数存放于8位寄存器中，算术左移不会发生溢出的是()。A. 80H  B. 90H  C.B0H  D.C0H<br>80H=(1000 0000)&lt;&lt;1=00000000，左移前的符号位为1，左移后的符号位为0，溢出；90H=(10010000)&lt;&lt;1=0010 0000，左移前的符号位为1，左移后的符号位为0，溢出；B0H=(1011 0000)&lt;&lt;1=01100000，左移前的符号位为1，左移后的符号位为0，溢出。C0H=(11000000)&lt;&lt;1=10000000，左移前的符号位为1，左移后的符号位为1，未溢出，选项D正确。</li><li>设机器数字长8位(含1位符号位)，若机器数BAH为补码，算术左移1位和算术右移1位分别得()。<br>A. F4H,EDH  B. B4H,6DH  C.74H,DDH  D. BSH,EDH<br>题目中有机器数、寄存器等用机器移动，符号位和数值位一起移。BAH=(10111010)，算术左移1位得(01110100)= 74H，左移前后的符号位不同，溢出；算术右移1位得(1101 1101)= DDH。</li><li>在定点运算器中，无论是采用双符号位还是采用单符号位，必须有()。<br>A.译码电路，它一般用“与非”门来实现<br>B.编码电路，它一般用“或非”门来实现<br>C.溢出判断电路，它一般用“异或”门来实现<br>D.移位电路，它一般用“与或非”门来实现<br>无论采用单符号位还是双符号位，运算器必须包含<strong>溢出判断电路OF=Cn​⊕Cn−1​</strong><ul><li><strong>译码电路（A）</strong>：用于指令译码，属于控制单元功能，非运算器必需。</li><li><strong>编码电路（B）</strong>：用于信号编码，非运算核心部件。</li><li><strong>移位电路（D）</strong>：乘除运算需要移位，但纯加减运算无需移位，非必需。</li></ul></li><li>机器运算发生溢出的根本原因是()<br>A.寄存器的位数有限                 B.运算中将符号位的进位丢弃<br>C.运算中将符号位的借位丢弃  D.数据运算中发生错误<br>a</li><li>关于模4补码，下列说法正确的是()。<br>A.模4补码和模2补码不同，它不容易检查乘除运算中的溢出问题B.每个模4补码存储时只需一个符号位<br>C.存储每个模4 补码需要两个符号位<br>D.模4补码，在算术与逻辑单元中为一个符号位<br>模4补码（即双符号位补码）是一种用于检测运算溢出的编码方式。c</li><li>某计算机字长为8位，CPU中有一个8位加法器。已知无符号数x=69，y=38，若在该加法器中计算x-y，则加法器的两个输入端信息和输入的低位进位信息分别为()。<br>A.01000101、00100110、0<br>B.01000101、11011001、1<br>C.01000101、11011010、0<br>D.01000101、11011010、1<br>x=01000101，y=00100110，-y的补码=11011010，低位进位Sub为1，d</li><li>某8位计算机中，x和y是两个有符号整数，用补码表示，[x]补=44H，[y]补=DCH，则x-2y的机器数及相应的溢出标志OF分别是()。<br>[x]补=44H = 01000100，[y]补=DCH = 11011100。执行 x - 2y 时，先将 y 算术左移一位，得到 10111000，未溢出，然后各位取反，再与 x 相加，做减法时 sub = 1，即 01000100+01000111 + 1=10001100(8CH)，两个加数的符号都为 0，而结果的符号为 1，因此发生了溢出，即 OF = 1。</li><li>某C语言代码段如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> si=<span class="number">65536</span>;</span><br><span class="line"><span class="type">short</span> i=si;</span><br><span class="line"><span class="type">unsigned</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=j<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;王道&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;计算机教育&quot;</span>);</span><br></pre></td></tr></table></figure>当上述代码段执行到i分支条件的判断时，会根据标志寄存器中的()决定执行顺序最终的输出结果是()。<br><a href="http://A.CF">A.CF</a>、王道   B.CF.计算机教育   C.OF,王道   D.OF，计算机教育<br><strong><code>int si = 65536</code></strong>：00000000 00000001 00000000 00000000<br><strong><code>short i = si</code></strong>：截取低16位 <code>0x0000</code>，转换为有符号 <code>short</code>，值为 <strong>0</strong>。<br><strong><code>unsigned j = 0</code></strong>：<code>j-1</code> 为 <code>0-1</code>，无符号运算结果为 <code>UINT_MAX</code>（如32位为 <code>4294967295</code>）。<br><strong>比较 <code>i &lt;= j-1</code></strong>：<ul><li><p>有符号 <code>i</code>（0）转换为无符号 <code>0</code>，与无符号 <code>j-1</code>（<code>UINT_MAX</code>）比较。</p></li><li><p><strong>无符号比较规则</strong>：通过进位标志 <code>CF</code> 判断。若 <code>a &lt;= b</code>，则 <code>CF=1</code>（借位）或 <code>ZF=1</code>（相等）。</p></li><li><p>此处 <code>0 &lt;= UINT_MAX</code> 为真，触发 <code>CF=1</code>，条件成立。</p><ul><li><strong>CF（进位标志）</strong>：无符号比较时，<code>CF=1</code> 表示被减数小于减数。</li><li><strong>OF（溢出标志）</strong>：有符号运算溢出时触发，此处不适用。<br><strong>A. CF、王道</strong>。</li></ul></li></ul></li><li>【2024 统考真题】C语言代码段如下，执行该代码段后，j的值是()。int i=32777;short si=i;int j=si;<br>A.-32777   B.-32759   C.32759   D.32777<br>2^15=32768，i=000…0 1000000000001001，将32 位有符号数i强制转换为 16 位有符号数si机器数为1000000000001001，补码1,111111111110111，si=-32759。</li><li>设机器数字长8位(含1位符号位)，若机器数BAH为原码，算术左移1位和算术右移1位分别得()。<br>A. F4H,EDH   B. B4H,6DH   C.F4H,9DH   D.BSH,EDH<br>若机器数 BAH为补码，其余条件同上题，则有<br>A.F4H, DDH   B.B4H,6DH   C.F4H,9DH   D. BSH,EDH<br>BA=1,0111010<br>原码时：算数左移1,1110100 FAH；算数右移1,0011101 9DH<br>补码时：算术左移1,1110100 FAH；算数右移1,1011101 DDH</li><li>在规格化浮点运算中，若某浮点数为2^5x1.10101，其中尾数为补码表示，则该数()。<br>A.不需规格化                          B.需右移规格化<br>C.需将尾数左移一位规格化   D.需将尾数左移两位规格化<br>补码浮点数规格化应该形如 1.0xxx，尾数左移1位，变为 1.01010，2^4×1.01010。c</li><li>下列关于对阶操作说法正确的是()<br>A.在浮点加减运算的对阶操作中，若阶码减小，则尾数左移<br>B.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移；若阶码减小，则尾数左移<br>C.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移<br>D.以上都不对<br>对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况，因此选项 A、B 错误。选c</li><li>若某单精度浮点数、某原码、某补码、某移码的 32 位机器数均为 0xF0000000，则这些数从大到小的顺序是()<br>A.浮原补移   B.浮移补原   C.移原补浮   D.移补原浮<br>x=1111 000…0，浮点数=-2^113；原码=-111 000…0=-1879048192；补码=-0001 000…0=-268435456；移码=x-128=1,879,048,192<br>选d</li><li>已知 foat 型采用 IEEE 754单精度浮点格式,若x、y为foat型变量,且x=-126,y= 15.75,则执行语句 z=x+y时，在浮点运算单元中进行对阶操作后的结果是()<br>A.x不变，y为010000101,0.001111110…0<br>B.x不变，y为010000110,0.001111110…0<br>C.y不变，x为 110000101,0.001111110…0<br>D.y不变，x为 110000110,0.001111110…0<br>-126 = -1.11111 × 2^6，阶码：<code>6 + 127 = 133 → 10000101</code><br>15.75 = 1.11111 × 2^3，阶码：<code>3 + 127 = 130 → 10000010</code><br>y是小阶，要向大阶6对齐，y的尾数相应右移3位，变为0.00111111B<br>a</li><li>在 IEEE 754 标准浮点格式中，非规格化浮点数表示为<br>A.阶码为 0，尾数为任意非0的二进制数<br>B.阶码为 255，尾数全为 0<br>C.阶码为 255，尾数为任意非0的二进制数<br>D.阶码为 0，尾数全为 0<br>在 IEEE 754 标准格式中，阶码全为0，尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行下去。</li><li>假设已定义三个 int 型变量 x、y和 z，sizeof(int)=4，double 型采用 IEEE 754 双精度浮点数格式，变量 dx、dy 和 dz 的声明和初始化如下：double dx=(double)x;double dy=(double)y;double dz=(double)z;则下列关系表达式中永远为真的是()。<br>I. dx+ dy == (double)(x+y)<br>Il. dx × dx &gt;= 0<br>III. dx/dx == dy/dy<br>IV.(dx + dy)+ dz== dx + (dy + dz)<br>A. I和 II   B.II和III   C.III和IV   D.II和IV<br>选项I非永真，因为x+y可能溢出，而 dx+dy 不会溢出。如果是dx+ dy == (double)x+(double)y正确；选项Ⅱ永真，符号和数值部分分开计算，不管结果是否溢出，都不会影响乘积的符号；选项III非永真，dx 和 dy 中只要有一个为 0、另一个不为0 就不相等；选项 IV 永真，因为dx、dy 和 dz 是由 32 位 int 型转换得到的，double 型可以精确地表示 int 型，且对阶时尾数移动位数不会超过 52 位，因此尾数不会舍入，于是不会发生大数吃小数的情况。</li><li>在按字节编址的计算机中，采用小端方式存储数据，某静态二维数组b的声明如下：<code>static short b[2][4]=&#123;&#123;2,9,-1,5&#125;,&#123;3,1,-6,2&#125;&#125;;</code>若b的首地址为 0x8049820，采用按行优先存储，地址0x804982c中的内容是()<br>A. FAH   B. FFH   C.00H   D.05H<br>short型占2字节，采用按行优先存储，<code>b[0][0]</code>的地址为 0x8049820，<code>b[0][1]</code>的地址为 0x8049822，以此类推，<code>b[1][2]</code>的地址为 0x804982c。d对应值为-6，补码表示为 1111 1111 1111 1010，FFFAH，采用小端方式存储，因此地址 0x804982c存放的是低位字节 FAH。</li><li>在按字节编址的 32 位计算机中，按边界对齐方式为以下结构型变量x分配存储空间：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   struct cont info&#123;</span><br><span class="line">    char id;</span><br><span class="line">    unsigned post;</span><br><span class="line">    char phone;</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure>若x的首地址为 0x8049820，则成员变量phone的起始地址为()<br>A.0x8049828   B.0x8049826   C.0x8049825   D.0x8049822<br>char放到0x8049820，unsigned默认是unsigned int，起始地址应该是4的整数倍，0x8049821不可以，往后直到0x8049824可以，占四个字节，char是0x8049828</li><li>【2009 统考真题】浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7(均含2位符号位)。若有两个数X=2^7×29/32和Y=2^5×5/8，则用浮点加法计算X+Y的最终结果是( )。<br>A.001111100010   B.001110100010<br>C.010000010001   D.发生溢出<br>29的二进制是11101，尾数共7位，写成0011101，除32，即2^5，定点整数的小数点在最后，即0011101.，向左移动五位，00,11101，X=00,111;00,11101<br>5的二进制是101，扩展位数0000101，向左3位，即0000,101，前面多的0省略并补充位数，即00,10100，Y=00.101;00,10100<br>对阶：Y=00,111;00,00101<br>尾数相加：01,00010<br>规格化：右规，即01,000;00,10001(0)，阶码01，溢出，d</li><li>【2014 统考真题】float 型数据常用 IEEE 754 单精度浮点格式表示。假设两个 foat 型变量x和y分别存放在 32位寄存器和12中,若(fl)=CC90 0000H,(f2)=B0C0 0000H,则x和y之间的关系为()<br>A.x&lt;y且符号相同      B. x&lt;y 且符号不同<br>C.x&gt;y且符号相同      D.x&gt;y且符号不同<br>x，y都是负数，(f1)和(12)对应的二进制分别是(110011001001.),和(101100001100…)，(f1)的绝对值为 1.001×2^26，(f2)的绝对值为 1.1×2^-30，(1)的绝对值比(12)的绝对值大，而符号为负，真值大小相反，即(f1)的真值比(f2)的真值小，即 x&lt;y。a</li><li>【2018 统考真题】某 32 位计算机按字节编址，采用小端方式。若语句“inti=0:”对应指令的机器代码为“C7 45 FC 00 00 00 00”，则语句“inti=-64:”对应指令的机器代码是()。<br>A. C7 45 FC CO FF FF FF   B. C 45 FC OC FF FF FF<br>C. C7 45 FC FF FF FF CO   D. C7 45 FC FF FF FF OC</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/post/bae4ff13.html"/>
      <url>/post/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h1>Redis</h1><p><a href="https://www.notion.so/1-133d2775339a8027b65cf4a2fa4776a6?pvs=21">黑马点评1</a></p><p><a href="https://www.notion.so/2-137d2775339a807eaf12c3684a75bee5?pvs=21">黑马点评2</a></p><p><a href="https://www.notion.so/3-13dd2775339a80db9b7bfe8444b8a975?pvs=21">黑马点评3</a></p><p><a href="https://www.notion.so/4-13dd2775339a80078852e9fb3d26d39a?pvs=21">黑马点评4</a></p><p><a href="https://redis.io/">https://redis.io/</a></p><h1>NoSQL</h1><p>Redis是一种键值型的NoSQL数据库</p><p><code>NoSql</code>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<code>非关系型数据库</code>。</p><ul><li><p><strong>结构化与非结构化</strong></p><p>传统关系型数据库是结构化数据，每张表在创建的时候都有严格的约束信息，如字段名、字段数据类型、字段约束等，插入的数据必须遵循这些约束。而NoSQL则对数据库格式没有约束，可以是键值型，也可以是文档型，甚至是图格式</p></li><li><p><strong>关联与非关联</strong></p><p>传统数据库的表与表之间往往存在关联，例如外键约束</p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合</p><p><img src="images/images/image.png" alt="image.png"></p></li><li><p>事务</p><p>传统关系型数据库能满足事务的ACID原则(原子性、一致性、独立性及持久性)，而非关系型数据库无法全部满足</p></li></ul><p>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</p><h2 id="SQL-VS-NoSQL">SQL VS NoSQL</h2><table><thead><tr><th></th><th>SQL</th><th>NoSQL</th></tr></thead><tbody><tr><td>数据结构</td><td>结构化</td><td>非结构化</td></tr><tr><td>数据关联</td><td>关联的</td><td>无关联的</td></tr><tr><td>查询方式</td><td>SQL查询</td><td>非SQL</td></tr><tr><td>事务特性</td><td>ACID</td><td>BASE</td></tr><tr><td>存储方式</td><td>磁盘</td><td>内存</td></tr><tr><td>扩展性</td><td>垂直</td><td>水平</td></tr><tr><td>使用场景</td><td>1）数据结构固定2）相关业务对数据安全性、一致性要求较高</td><td>1）数据结构不固定2）对一致性、安全性要求不高3）对性能要求高</td></tr></tbody></table><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h1>Redis VS MySQL</h1><p>**Redis：**Remote Dictionary Server远程词典服务器</p><ul><li><strong>内存存储</strong>：Redis 是一个基于<strong>内存</strong>的 <strong>Key-Value</strong> 数据库，主要将数据存储在内存中，读写速度非常快。其性能优势在于数据能够在几微秒内完成读写操作，因此适合对响应时间要求较高的场景。</li><li>单线程，每个命令具有原子性</li><li>低延迟，速度快(基于内存、IO多路复用、良好的编码)</li><li><strong>持久化</strong>：虽然 Redis 是内存数据库，但它支持将数据持久化到磁盘中以避免数据丢失。常见的持久化机制有 RDB 和 AOF。</li><li><strong>数据类型丰富</strong>：除了简单的字符串类型，Redis 还支持哈希、列表、集合、有序集合等数据结构，适合不同业务场景的数据操作。</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li><li><strong>应用场景</strong>：<ul><li><strong>缓存</strong>：用于存储热点数据，如热点商品、新闻、排行榜等，减少对数据库的压力。</li><li><strong>会话管理</strong>：在分布式应用中，Redis 常用来存储用户会话信息。</li><li><strong>计数器和限流器</strong>：由于 Redis 的高性能，常用来实现各类实时计数操作，如商品点击量统计。</li><li><strong>消息队列</strong>：Redis 还可以用于实现简单的消息队列功能。</li></ul></li></ul><p><strong>MySQL：</strong></p><ul><li><strong>磁盘存储</strong>：MySQL 是一个基于<strong>磁盘</strong>的关系型数据库，数据存储在磁盘中，并使用索引等机制来优化查询性能。</li><li><strong>结构化数据</strong>：MySQL 适合处理结构化的<strong>二维表</strong>数据，支持复杂的 SQL 查询，事务处理能力强，保证数据一致性。</li><li><strong>持久化和事务性</strong>：MySQL 的数据持久存储在磁盘上，即使服务器宕机，数据也能安全保存。同时，MySQL 支持 ACID 事务，确保数据操作的原子性和一致性。</li><li><strong>应用场景</strong>：<ul><li><strong>结构化数据存储</strong>：如用户信息、订单数据等需要通过关系表存储和查询的数据。</li><li><strong>事务处理</strong>：MySQL 在复杂的事务处理中表现良好，适合需要高数据一致性的场景，如银行、财务等系统。</li></ul></li></ul><h2 id="结合应用场景">结合应用场景</h2><ul><li><strong>缓存</strong>：Redis 通常作为 MySQL 的缓存层，用于加速查询。MySQL 负责持久存储，而 Redis 则存储热点数据，减轻 MySQL 压力，提升系统的整体性能。</li><li><strong>高并发场景</strong>：对于短时间内大量访问的热点数据（如电商秒杀、新闻排行榜），将其存储在 Redis 中以提供更高效的读写性能。</li><li><strong>企业广泛应用</strong>：Redis 和 MySQL 的结合在现代互联网公司中非常常见，既保障了数据的持久性和一致性（通过 MySQL），又提供了高速缓存和高并发处理能力（通过 Redis）。</li></ul><p>这种组合能够很好地满足企业级应用中对高并发处理和数据持久化的不同需求。</p><p>中文文档：<a href="https://www.redis.net.cn/tutorial/3501.html">Redis 教程_redis教程</a></p><h1>使用</h1><h2 id="windows安装">windows安装</h2><p><img src="images/image%201.png" alt="image.png"></p><p>在redis安装目录下打开cmd</p><p>启动：输入redis-server.exe redis.windows.conf</p><p>停止：Ctrl+C</p><p>客户端连接：再次在redis安装目录下打开cmd，输入redis-cli.exe</p><p>默认连接6379</p><p><img src="images/images/image%202.png" alt="image.png"></p><p>更改连接地址</p><p><img src="images/images/image%203.png" alt="image.png"></p><p>设置密码：删除注释，requirepass顶格，修改foobared为密码</p><p><img src="images/images/image%204.png" alt="image.png"></p><p>redis-cli.exe -h localhost -p 6379 -a 123456</p><p>可视化界面连接</p><p><img src="images/image%205.png" alt="image.png"></p><h2 id="Linux安装">Linux安装</h2><p>sudo apt update<br>sudo apt install -y gcc tcl</p><p>下载redis-6.2.6.tar.gz</p><p><strong><code>cd</code>到<code>/usr/local/src</code>目录执行以下命令进行解压操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p><strong>解压成功后依次执行以下命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.6</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="images/image%206.png" alt="image.png"></p><h3 id="启动redis">启动redis</h3><ul><li><p>前台启动【不推荐】：会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><p><strong>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</strong></p></li><li><p>后台启动【不推荐】：必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下</p><ul><li><p>因为我们要修改配置文件，因此我们需要先将原文件备份一份</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure></li><li><p>然后修改<code>redis.conf</code>文件中的一些配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure></li><li><p>Redis其他常用配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="built_in">dir</span> .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动Redis</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录cd /usr/local/src/redis-6.2.6</span></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>停止Redis服务</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 ps -ef | grep redis查询pid</span><br><span class="line"><span class="comment"># 通过kill命令直接杀死进程kill -9 redis进程ids</span></span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -a 来指定密码</span></span><br><span class="line">redis-cli -a 132537 shutdown</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>开机自启【推荐】</strong></p><p>通过配置来实现开机自启</p><ul><li><p>首先，新建一个系统服务文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure></li><li><p>将以下命令粘贴进去</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">// Type=forking 不知道为什么这行不删掉启动超时</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>然后重载系统服务</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>现在，我们可以用下面这组命令来操作redis了</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li><li><p>执行下面的命令，可以让redis开机自启</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>数据类型</h1><p><strong>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</strong></p><p><img src="images/image-20220524205926164.png" alt="image-20220524205926164.png"></p><p><img src="701cbe108e6e43bebf491be26887bf55.png" alt="701cbe108e6e43bebf491be26887bf55.png"></p><p><img src="images/image%207.png" alt="image.png"></p><ul><li>hash 适合存储对象</li><li>list 按照插入顺序排序，可以有重复元素 eg.朋友圈点赞列表</li><li>set 无序集合，没有重复元素 eg.qq共同好友</li><li>sorted set 有序集合，没有重复元素eg.排行榜</li></ul><h3 id="Key结构"><strong>Key结构</strong></h3><ul><li><p>Redis没有类似MySQL中Table的概念，那么我们该如何区分不同类型的Key呢？</p></li><li><p>例如：需要存储用户、商品信息到Redis，有一个用户的id是1，有一个商品的id恰好也是1，如果此时使用id作为key，那么就回冲突，该怎么办？</p></li><li><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范</p><ul><li>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下<code>项目名:业务名:类型:id</code></li><li>这个格式也并非是固定的，可以根据自己的需求来删除/添加词条，这样我们就可以把不同数据类型的数据区分开了，从而避免了key的冲突问题</li><li>例如我们的项目名叫reggie，有user和dish两种不同类型的数据，我们可以这样定义key<ul><li>user相关的key：<code>reggie:user:1</code></li><li>dish相关的key：<code>reggie:dish:1</code></li></ul></li></ul></li><li><p>如果value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>reggie:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>reggie:dish:1</td><td>{“id”:1, “name”: “鲟鱼火锅”, “price”: 4999}</td></tr></tbody></table></li><li><p>并且在Redis的桌面客户端中，也会以相同前缀作为层次结构，让数据看起来层次分明，关系清晰</p></li></ul><h3 id="1-String（字符串）">1. <strong>String（字符串）</strong></h3><ul><li><p><strong>描述</strong>：Redis 中最基本的数据类型，每个键都对应一个字符串类型的值。可以是文本或二进制数据（如图片、视频等）。</p><p>value是字符串，不过根据字符串的格式不同，又可以分为3类</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同，字符串类型的最大空间不能超过512M</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET</td><td>添加或者修改一个已经存在的String类型的键值对</td></tr><tr><td>GET</td><td>根据key获取String类型的value</td></tr><tr><td>MEST</td><td>批量添加多个String类型的键值对</td></tr><tr><td>MGET</td><td>根据多个key获取多个String类型的value</td></tr><tr><td>INCR</td><td>让一个整型的key自增1，适用于计数器</td></tr><tr><td>INCRBY</td><td>让一个整形的key自增并指定步长值，例如：incrby num 2，让num值自增2</td></tr><tr><td>INCRBYFLOAT</td><td>让一个浮点类型的数字自增并指定步长值</td></tr><tr><td><code>SET key seconds value</code></td><td>设置键 <code>key</code> 对应的值为 <code>value</code> ，并将key的过期时间设为seconds秒。eg.验证码过期</td></tr><tr><td><code>SETNX key value</code></td><td>添加一个String类型的键值对，前提是这个key不存在，否则不执行，可以理解为真正的新增。eg.分布式锁</td></tr><tr><td><code>SETEX key seconds value</code></td><td>添加一个String类型的键值对，并指定有效期（s），一旦时间到了，Redis 会自动删除该键。</td></tr><tr><td>APPEND</td><td>在键 <code>key</code> 的值后追加内容</td></tr></tbody></table></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>缓存对象的简单属性</strong>：如用户的登录状态、验证码、单个配置项。</li><li><strong>计数器</strong>：用户浏览次数、点赞数等。</li></ul></li></ul><p>更多命令：<a href="https://www.redis.net.cn/tutorial/3508.html">Redis 字符串(String)_redis教程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name xiaoming</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="title function_">age</span></span><br><span class="line"><span class="params">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">20</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line"><span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">30</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age</span><br><span class="line"><span class="string">&quot;30&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex city <span class="number">10</span> beijing</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get city</span><br><span class="line"><span class="string">&quot;beijing&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="title function_">city</span></span><br><span class="line"><span class="params">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx k1 <span class="title function_">v1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx k1 <span class="title function_">v2</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure><p>set命令会转成字符串存储</p><h3 id="2-Hash（哈希）">2. <strong>Hash（哈希）</strong></h3><ul><li><p><strong>描述</strong>：也叫散列，其中value是一个无序字典，类似于Java中的HashMap结构。适用于存储对象，类似于一个小型的键值对集合。一个键对应一个哈希表，可以存储多个字段和字段值</p><p><img src="images/image%208.png" alt="image.png"></p><p>String结构是将对象序列化为JSON字符串后存储，当我们要修改对象的某个属性值的时候很不方便</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><p><img src="images/image%209.png" alt="image.png"></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>HSET key field value</td><td>添加或者修改hash类型key的field的值</td></tr><tr><td>HGET key field</td><td>获取一个hash类型key的field的值</td></tr><tr><td>HDEL key field</td><td>删除指定字段</td></tr><tr><td>HMSET</td><td>批量添加多个hash类型key的field的值</td></tr><tr><td>HMGET</td><td>批量获取多个hash类型key的field的值</td></tr><tr><td>HGETALL</td><td>获取一个hash类型的key中的所有的field和value</td></tr><tr><td>HKEYS key</td><td>获取一个hash类型的key中的所有的字段</td></tr><tr><td>HVALS key</td><td>获取一个hash类型的key中的所有的值</td></tr><tr><td>HINCRBY</td><td>让一个hash类型key的字段值自增并指定步长</td></tr><tr><td>HSETNX</td><td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr><tr><td>HGETALL key</td><td>获取一个hash类型的key中的所有的字段和值</td></tr></tbody></table></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>存储用户信息</strong>：如用户的基本资料（姓名、年龄、地址等），将用户的各个属性存储为哈希表的字段。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset <span class="number">001</span> name <span class="title function_">xiaoming</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset <span class="number">001</span> age <span class="number">20</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget <span class="number">001</span> name</span><br><span class="line"><span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget <span class="number">001</span> age</span><br><span class="line"><span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel <span class="number">001</span> age</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget <span class="number">001</span> age</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hkeys <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset <span class="number">001</span> age <span class="number">30</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hkeys <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hvals <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;30&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hgetall <span class="number">001</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;30&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-List（列表）">3. <strong>List（列表）</strong></h3><ul><li><p><strong>描述</strong>：列表类型是<strong>有序</strong>的字符串集合，可以包含<strong>重复</strong>元素。列表中的元素按照插入顺序排序。支持从两端插入或删除元素。与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p><img src="images/image%2010.png" alt="image.png"></p><ul><li>特征也与LinkedList类似：<ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul></li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>LPUSH key value1 …</td><td>向列表左侧插入一个或多个元素</td></tr><tr><td>RPUSH key value1 …</td><td>向列表右侧插入一个或多个元素</td></tr><tr><td>LPOP key</td><td>移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td>RPOP key</td><td>移除并返回列表右侧的第一个元素</td></tr><tr><td>LLEN key</td><td>获取列表长度</td></tr><tr><td>LRANGE key star end</td><td>返回一段角标范围内的所有元素。 lrange list 0 -1返回所有元素</td></tr><tr><td>BLPOP和BRPOP</td><td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr><tr><td>BRPOP key1 [key2] timeout</td><td>移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr></tbody></table><p>如何利用List结构模拟一个栈?<br>入口和出口在同一边</p><p>如何利用List结构模拟一个队列?<br>入口和出口在不同边</p><p>如何利用List结构模拟一个阻塞队列?<br>入口和出口在不同边<br>出队时采用BLPOP或BRPOP</p></li><li><p><strong>应用场景</strong>：适合存储按时间顺序排列的数据</p><ul><li><strong>消息队列</strong>：利用 <code>LPUSH</code> 和 <code>RPOP</code> 可以实现先进先出的消息队列。</li><li><strong>朋友圈点赞列表</strong>：按时间顺序存储点赞用户的列表。</li><li><strong>评论区</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list <span class="title function_">zhang</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop list</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; llen <span class="title function_">list</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhang&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange list <span class="number">0</span> -<span class="number">1</span></span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop list <span class="number">10</span></span><br><span class="line">(nil)</span><br><span class="line">(<span class="number">10.</span>04s)</span><br></pre></td></tr></table></figure><p><code>0 -1</code>：这些参数指定了要检索的元素的范围，从索引 0 开始到索引 <code>-1</code> 结束（<code>-1</code> 在 Redis 中表示列表的最后一个元素）</p><p><code>lpush</code> 命令会将元素添加到列表的头部，所以最后插入的元素 <code>c</code> 会成为列表的第一个元素（索引 0），而 <code>a</code> 会成为最后一个元素。</p><p>brpop*移除并获取列表 “list” 的最后一个元素，如果列表为空，则等待 10 秒，*如果操作成功，<code>BRPOP</code> 返回一个包含两个元素的数组：第一个元素是被移除的元素，第二个元素是它所属的列表的键名。</p><h3 id="4-Set（集合）">4. <strong>Set（集合）</strong></h3><ul><li><p><strong>描述</strong>：<strong>无序</strong>集合，集合中的元素是<strong>唯一</strong>的，不能重复。通过<strong>哈希表</strong>实现，所以查找、插入、删除操作的时间复杂度都是 O(1)。</p><p><img src="images/image%2011.png" alt="image.png"></p><p>与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SADD key member …</td><td>向set中添加一个或多个元素</td></tr><tr><td>SREM key member …</td><td>移除set中的指定元素</td></tr><tr><td>SCARD key</td><td>返回set中元素的个数</td></tr><tr><td>SISMEMBER key member</td><td>判断一个元素是否存在于set中</td></tr><tr><td>SMEMBERS key</td><td>获取key中的所有元素</td></tr><tr><td>SINTER key1 key2 …</td><td>求key1与key2的交集</td></tr><tr><td>SUNION key1 key2 …</td><td>求key1与key2的并集</td></tr><tr><td>SDIFF key1 key2 …</td><td>求key1与key2的差集</td></tr></tbody></table></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>共同好友</strong>：存储用户的好友列表，可以很方便地取两个用户的共同好友。</li><li><strong>标签系统</strong>：存储用户的兴趣标签，方便进行交集和并集的操作。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd set a b c <span class="title function_">d</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers set</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd set a <span class="title function_">d</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers set</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard <span class="title function_">set</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s a d s <span class="title function_">o</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sinter set s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sunion set s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sdiff set s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sdiff s set</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s a b c <span class="title function_">d</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;s&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-Sorted-Set（有序集合）">5. <strong>Sorted Set（有序集合）</strong></h3><ul><li><p><strong>描述</strong>：是一个可排序的set集合，与集合类似，元素也是<strong>唯一</strong>的，但每个元素都会关联一个double类型的分数（score），Redis 会根据分数从小到大自动排序。元素不能重复，但分数可以相同。与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p><img src="images/image%2012.png" alt="image.png"></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>ZADD key score member1…</td><td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td>ZREM key member</td><td>删除sorted set中的一个指定元素</td></tr><tr><td>ZSCORE key member</td><td>获取sorted set中的指定元素的score值</td></tr><tr><td>ZRANK key member</td><td>获取sorted set 中的指定元素的排名</td></tr><tr><td>ZCARD key</td><td>获取sorted set中的元素个数</td></tr><tr><td>ZCOUNT key min max</td><td>统计score值在给定范围内的所有元素的个数</td></tr><tr><td>ZINCRBY key increment member</td><td>让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td>ZRANGE key min max</td><td>按照score排序后，获取指定排名范围内的元素</td></tr><tr><td>ZRANGEBYSCORE key min max</td><td>按照score排序后，获取指定score范围内的元素</td></tr><tr><td>ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><code>升序</code>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><code>降序</code>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li><strong>排行榜</strong>：如游戏中的积分排行榜，用户的分数决定排名。</li><li><strong>延时队列</strong>：通过分数来表示任务的执行时间，按时间顺序执行任务。</li></ul></li></ul><p>按value排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd sset <span class="number">10.0</span> a <span class="number">9.0</span> b</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd sset <span class="number">9.5</span> c</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;9&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;9.5&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby sset <span class="number">20</span> b</span><br><span class="line"><span class="string">&quot;29&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrem sset <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange sset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h3 id="通用命令"><strong>通用命令</strong></h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>KEYS</td><td>查看符合模板的所有key，不建议在生产环境设备上使用，因为Redis是单线程的，执行查询的时候会阻塞其他命令，当数据量很大的时候，使用KEYS进行模糊查询，效率很差</td></tr><tr><td>DEL</td><td>删除一个或多个指定的key</td></tr><tr><td>EXISTS</td><td>判断key是否存在，1在0不在</td></tr><tr><td>EXPIRE</td><td>给一个key设置有效期，有效期到期时该key会被自动删除，s单位</td></tr><tr><td>TTL</td><td>查看一个KEY的剩余有效期，s单位，若未设置有效期返回-1</td></tr><tr><td>TYPE</td><td>返回key所存储的值的类型</td></tr></tbody></table><p>可以通过<code>help [command]</code> 可以查看一个命令的具体用法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;001&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;sset&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;set&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;s&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">aaa</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type name</span><br><span class="line">string</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type set</span><br><span class="line">set</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type sset</span><br><span class="line">zset</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> -<span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex test <span class="number">100</span> zhang</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">test</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">97</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del <span class="title function_">test</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Redis-应用广泛的原因：">Redis 应用广泛的原因：</h3><ol><li><strong>高性能</strong>：Redis 基于内存存储，具有极高的读写性能，适合存储和访问热点数据。</li><li><strong>多种数据结构</strong>：支持丰富的数据类型，能够处理多种业务场景。</li><li><strong>简单易用</strong>：Redis 提供的命令十分直观，可以快速上手。</li><li><strong>持久化</strong>：虽然 Redis 是内存数据库，但它提供了多种持久化选项以保证数据的安全性。</li><li><strong>企业应用场景</strong>：<ul><li>高并发情况下的数据缓存（如商品、新闻、排行榜等）。</li><li>实时统计和计数功能。</li><li>用户会话管理和社交功能中的好友关系处理等。</li></ul></li></ol><h1><strong>在 Java 中操作 Redis</strong></h1><p>目前主流的Redis的Java客户端有三种</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即<br>spring-boot-starter-data-redis</p><p>在 Java 中操作 Redis 时，<strong>Jedis</strong> 和 <strong>Spring Data Redis</strong> 是两种常用的库，它们各有优缺点。以下是它们的比较和使用场景：</p><ul><li><strong>选择</strong>：<ul><li>如果你需要一个简单的、直接的 Redis 客户端，Jedis 是一个不错的选择。</li><li>如果你的应用程序已经使用 Spring，或者你需要更多的功能和集成，Spring Data Redis 将是更好的选择。</li></ul></li></ul><h2 id="Jedis"><a href="https://so.csdn.net/so/search?q=Jedis&amp;spm=1001.2101.3001.7020"><strong>Jedis</strong></a></h2><ul><li><strong>概述</strong>：<ul><li>Jedis 是一个简单的、直观的 Redis 客户端库，提供了基本的 Redis 操作API。</li><li>它是一个轻量级的库，适合直接与 Redis 交互。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>简单易用</strong>：Jedis 的 API 设计简单，容易上手。</li><li><strong>直接控制</strong>：开发者可以直接使用 Redis 命令，提供了较高的灵活性。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>管理连接</strong>：需要手动管理 Redis 连接，可能会导致连接池管理和性能问题。</li><li><strong>缺少集成</strong>：与 Spring 的集成不如 Spring Data Redis 方便。</li></ul></li></ul><p>Maven 坐标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jedis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--单元测试--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.7.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意，运行前要先启动 Redis</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1. 建立连接</span></span><br><span class="line">jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.40.128&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 2. 设置密码</span></span><br><span class="line"><span class="comment">// jedis.auth(&quot;123456&quot;);</span></span><br><span class="line"><span class="comment">// 3. 选择库</span></span><br><span class="line">jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lr&quot;</span>);</span><br><span class="line">System.out.println(res);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDowm</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;17&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:2&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Jedis</code>本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p></li><li><p>新建一个<code>util</code>，用于存放我们编写的工具类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 配置连接池</span></span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line"><span class="comment">// 最大连接</span></span><br><span class="line">poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 最大空闲连接</span></span><br><span class="line">poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 最小空闲连接</span></span><br><span class="line">poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置最长等待时间，ms</span></span><br><span class="line">poolConfig.setMaxWaitMillis(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// 创建连接池对象</span></span><br><span class="line">jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.40.128&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>); <span class="comment">// host,port,timeout,[password]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure></li><li><p>但后面我们使用<code>SpringDataRedis</code>的时候，可以直接在<code>yml</code>配置文件里配置这些内容</p></li></ul><h2 id="Spring-Data-Redis"><strong>Spring Data Redis</strong></h2><p><a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><strong>概述</strong>：<ul><li>Spring Data Redis 是一个用于 Spring 应用程序的 Redis 数据访问库，提供了更高级别的抽象和 Spring 生态系统的集成。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>易于集成</strong>：与 Spring 框架无缝集成，支持 Spring 的注解和依赖注入。</li><li><strong>自动化管理</strong>：提供了对连接池的管理，简化了 Redis 连接的创建和管理。</li><li><strong>高级特性</strong>：支持 Redis 的许多高级特性，如事务、发布/订阅、消息队列、哨兵、集群等</li><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul></li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><table><thead><tr><th>API</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>redisTemplate.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td>redisTemplate.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td>redisTemplate.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td>redisTemplate.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td>redisTemplate.opsForzSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td>redisTemplate</td><td></td><td>通用的命令</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作步骤：">操作步骤：</h3><ul><li>导入Spring Data Redis 的maven坐标</li><li>配置Redis数据源</li><li>编写配置类，创建RedisTemplate对象</li><li>通过RedisTemplate对象操作Redis</li></ul><h3 id="1-导入依赖"><strong>1. 导入依赖</strong></h3><p>Maven 坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-application-yml"><strong>2. application.yml</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: <span class="number">192.168</span><span class="number">.40</span><span class="number">.128</span></span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      #      password: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      database: <span class="number">1</span></span><br><span class="line">      jedis:</span><br><span class="line">        pool:</span><br><span class="line">          max-active: <span class="number">8</span></span><br><span class="line">          max-idle: <span class="number">8</span></span><br><span class="line">          min-idle: <span class="number">0</span></span><br><span class="line">          max-wait: 100ms</span><br></pre></td></tr></table></figure><h3 id="3-编写配置类，创建RedisTemplate对象">3. 编写配置类，创建RedisTemplate对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.config;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span> <span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;开始创建redis模板对象&quot;</span>);</span><br><span class="line"><span class="comment">// 是 Spring Data Redis 提供的核心类，用于对 Redis 进行各种操作</span></span><br><span class="line"><span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line"><span class="comment">// 设置 Redis 的连接工厂，用来与 Redis 服务器建立连接</span></span><br><span class="line">redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="comment">// 将 Redis 的 key 设置为字符串序列化，这样所有 key 会以可读的字符串形式存储。</span></span><br><span class="line">redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"><span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RedisTemplate-的序列化器设置"><strong>RedisTemplate 的序列化器设置</strong></h3><p>RedisTemplate可以接收任意Object作为值写入Redis</p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果\xAC\xED\x00\x05t\x00\x06\xE5\xBC\xA0\xE4\xB8\x89</p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>在Spring Data Redis中，<code>RedisTemplate</code> 是一个核心组件，用于操作Redis数据库。默认情况下，<code>RedisTemplate</code> 使用 <code>JdkSerializationRedisSerializer</code> 作为其键（Key）的序列化器，这意味着键将使用Java标准序列化机制进行序列化。</p><p>当您执行如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br></pre></td></tr></table></figure><p>键 <code>&quot;city123&quot;</code> 将被序列化为一个二进制形式，如在Redis命令行中通过 <code>keys *</code> 命令看到的那样。</p><p>为了避免使用Java标准序列化，您可以通过自定义 <code>RedisTemplate</code> 的序列化器来更改这一行为。通常，对于值（Value），不需要更改序列化器，因为从Redis中获取时将自动进行反序列化。</p><ol><li><p>默认行为</p><p><code>RedisTemplate</code> 默认使用 <code>JdkSerializationRedisSerializer</code> 来序列化键。这意味着键会被序列化为二进制格式，可能不利于可读性和调试。</p></li><li><p>自定义序列化器</p><p>通过将键序列化器设置为 <code>StringRedisSerializer</code>，你可以确保所有的键都以字符串形式存储和读取。这提高了可读性，并且使得在使用 Redis CLI 或其他工具时，更容易查看和管理数据。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置键的序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值的序列化器</p><p>对于值的序列化，通常你可以保持默认设置，因为当你从 Redis 中获取值时，它会自动反序列化为 Java 对象。你可以根据需求更改值的序列化器，例如使用 <code>Jackson2JsonRedisSerializer</code> 以便将对象序列化为 JSON 格式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键的序列化器</span></span><br><span class="line">redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值的序列化器</span></span><br><span class="line"><span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-通过RedisTemplate对象操作Redis">4. 通过RedisTemplate对象操作Redis</h3><p>Spring Data Redis中提供了一个高度封装的类：RedisTemplate，针对jedis客户端中大量api进行了归类封装，将同一类型操作封装为operation接口，具体分类如下:</p><ul><li><strong>ValueOperations</strong>：用于操作字符串类型的数据。</li><li><strong>HashOperations</strong>：用于操作哈希类型的数据（键值对）。</li><li><strong>ListOperations</strong>：用于操作列表类型的数据。</li><li><strong>SetOperations</strong>：用于操作集合类型的数据。</li><li><strong>ZSetOperations</strong>：用于操作有序集合类型的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.test;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="comment">// 启动整个 Spring 应用上下文，模拟一个真实的 Spring 环境，用于集成测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(redisTemplate); <span class="comment">// 非null证明连接成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作字符串类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">valueOperations.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;lr&quot;</span>);</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">System.out.println(username);</span><br><span class="line"><span class="comment">// del</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="comment">// setex</span></span><br><span class="line">valueOperations.set(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">// setnx</span></span><br><span class="line">valueOperations.setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">valueOperations.setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;2&quot;</span>); <span class="comment">// fale</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作哈希类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"><span class="comment">// hset</span></span><br><span class="line">hashOperations.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lr&quot;</span>);</span><br><span class="line">hashOperations.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="comment">// hget</span></span><br><span class="line"><span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(age); <span class="comment">// lr</span></span><br><span class="line"><span class="comment">// hkeys 用set集合</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">System.out.println(keys); <span class="comment">// [name]</span></span><br><span class="line"><span class="comment">// hvals 用list集合</span></span><br><span class="line"><span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">System.out.println(values); <span class="comment">// [lr]</span></span><br><span class="line"><span class="comment">// hdel</span></span><br><span class="line">hashOperations.delete(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作列表类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"><span class="comment">// lpush</span></span><br><span class="line">listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">// lrange</span></span><br><span class="line"><span class="type">List</span> <span class="variable">mylist</span> <span class="operator">=</span> listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(mylist);</span><br><span class="line"><span class="comment">// rpop</span></span><br><span class="line">listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line"><span class="comment">// llen</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">System.out.println(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作列表类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"><span class="comment">// sadd</span></span><br><span class="line">setOperations.add(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">setOperations.add(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="comment">// smembers</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> setOperations.members(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">System.out.println(set1);</span><br><span class="line"><span class="comment">// scard</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> setOperations.size(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">System.out.println(size);</span><br><span class="line"><span class="comment">// sinter</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">intersect</span> <span class="operator">=</span> setOperations.intersect(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">System.out.println(intersect);</span><br><span class="line"><span class="comment">// sunion</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">union</span> <span class="operator">=</span> setOperations.union(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">System.out.println(union);</span><br><span class="line"><span class="comment">// srem</span></span><br><span class="line">setOperations.remove(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作有序集合类型的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"><span class="comment">// zadd</span></span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="number">12</span>);</span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// zrange</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">zset</span> <span class="operator">=</span> zSetOperations.range(<span class="string">&quot;zset1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(zset);</span><br><span class="line"><span class="comment">// zincrby</span></span><br><span class="line">zSetOperations.incrementScore(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// zrem</span></span><br><span class="line">zSetOperations.remove(<span class="string">&quot;zset1&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span> &#123; <span class="comment">// 定义一个User类，name，age</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;user:10&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lr&quot;</span>, <span class="number">45</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:10&quot;</span>);</span><br><span class="line">System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用命令操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// keys</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line"><span class="comment">// exists</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">set1</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line"><span class="type">DataType</span> <span class="variable">type</span> <span class="operator">=</span> redisTemplate.type(key);</span><br><span class="line">System.out.println(type.name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// del</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringRedisTemplate"><strong>StringRedisTemplate</strong></h2><p><img src="images/image%2013.png" alt="image.png"></p><ul><li><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="images/image%2014.png" alt="image.png"></p></li><li><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了</p></li><li><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringRedisTemplate源码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title class_">RedisTemplate</span>&lt;String, String&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">StringRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setKeySerializer(RedisSerializer.string());</span><br><span class="line">      <span class="built_in">this</span>.setValueSerializer(RedisSerializer.string());</span><br><span class="line">      <span class="built_in">this</span>.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">      <span class="built_in">this</span>.setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>不需要自己定义RedisConfiguration，直接使用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 手动序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;userdata&quot;</span>, json);</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userdata</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;userdata&quot;</span>);</span><br><span class="line"><span class="comment">// 手动反序列化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">readValue</span> <span class="operator">=</span> mapper.readValue(userdata, User.class);</span><br><span class="line">System.out.println(readValue);</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.notion.so/147d2775339a80fba43fcec357283b64?pvs=21">高级篇</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/post/79666db.html"/>
      <url>/post/79666db.html</url>
      
        <content type="html"><![CDATA[<p>数据的<mark>逻辑</mark>结构是指<mark>数据元素之间</mark>的逻辑关系，它与所使用的计算机无关。</p><p>数据的<mark>物理</mark>结构，又称<mark>存储结构</mark>，是指数据结构在计算机中的表示，它包括数据元素的表示和元素的表示，其中数据元素之间的关系在计算机中有<strong>顺序</strong>存储结构和<strong>链式</strong>存储结构两种。</p><p><mark>逻辑结构</mark><br>集合，线性，树，图</p><ul><li>线性结构：线性表，栈，队列，串</li><li>非线性结构：树，图</li></ul><p>物理结构(存储结构)</p><ul><li>顺序</li><li>链式</li><li>索引</li><li>散列(Has存储)</li></ul><p>运算的定义针对:逻辑结构<br>运算的实现针对:存储结构</p><p><mark>数据&gt;数据元素&gt;数据项</mark></p><p>算法特性(必须全具备)</p><ul><li>有穷性：算法必须有穷，程序可以无穷</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h1>复杂度</h1><h2 id="1-线性查找时间复杂度"><strong>1. 线性查找时间复杂度</strong></h2><ul><li><strong>最坏情况</strong>：目标元素在最后一个位置，需遍历整个链表，时间复杂度为 <strong>O(n)</strong>。</li><li><strong>平均情况</strong>：假设目标元素在各位置概率相等，平均比较次数为 <strong>(n+1)/2</strong>，时间复杂度 <strong>O(n)</strong></li></ul><h2 id="2-单循环链表的头尾访问"><strong>2. 单循环链表的头尾访问</strong></h2><ul><li><strong>带尾指针的单循环链表</strong>：<ul><li>找表头结点：通过尾指针的 <code>next</code> 直接访问，时间复杂度 <strong>O(1)</strong>。</li><li>找表尾结点：直接访问尾指针，时间复杂度 <strong>O(1)</strong>。</li></ul></li><li><strong>带头结点的单循环链表</strong>：<ul><li>找表头结点：直接访问头结点，时间复杂度 <strong>O(1)</strong>。</li><li>找表尾结点：需从头遍历到尾，时间复杂度 <strong>O(n)</strong>。</li></ul></li></ul><h2 id="3-链表合并的时间复杂度"><strong>3. 链表合并的时间复杂度</strong></h2><ul><li><strong>将长度为 n 的单链表链接到长度为 m 的单链表之后</strong>：<ul><li>需要找到链表 m 的尾节点（耗时 <strong>O(m)</strong>），然后修改其 <code>next</code> 指针指向链表 n 的头节点（耗时 <strong>O(1)</strong>）。</li><li>总时间复杂度为 <strong>O(m)</strong>。</li></ul></li></ul><h2 id="4-插入操作的时间复杂度"><strong>4. 插入操作的时间复杂度</strong></h2><ul><li><strong>数组的插入操作</strong>（假设在位置 i 插入元素）：<ul><li><strong>移动次数</strong>：需将第 i 个位置后的所有元素后移，共移动 <strong>n - i</strong> 次。</li><li><strong>总移动次数</strong>：插入所有可能位置（共 <strong>n+1</strong> 种）的移动次数总和为  <strong>(n+1)/2</strong></li><li><strong>平均移动次数</strong>：n/2，时间复杂度 <strong>O(n)</strong>。</li></ul></li><li><strong>链表的插入操作</strong>（假设已知插入位置的前驱节点）：<ul><li>仅需修改指针，时间复杂度 <strong>O(1)</strong>。</li><li>若需遍历找到插入位置，时间复杂度 <strong>O(n)</strong>。</li></ul></li></ul><h2 id="5-删除操作的时间复杂度"><strong>5. 删除操作的时间复杂度</strong></h2><ul><li><strong>数组的删除操作</strong>（假设删除位置 i 的元素）：<ul><li><strong>移动次数</strong>：需将第 i 个位置后的所有元素前移，共移动 <strong>n - i - 1</strong> 次。</li><li><strong>总移动次数</strong>：删除所有可能位置（共 <strong>n</strong> 种）的移动次数总和为  <strong>n(n-1)/2</strong></li><li><strong>平均移动次数</strong>： <strong>(n-1)/2</strong>，时间复杂度 <strong>O(n)</strong>。</li></ul></li><li><strong>链表的删除操作</strong>（假设已知删除节点的前驱节点）：<ul><li>仅需修改指针，时间复杂度 <strong>O(1)</strong>。</li><li>若需遍历找到删除节点，时间复杂度 <strong>O(n)</strong>。</li></ul></li></ul><ol><li><strong>链表与数组的差异</strong>：<ul><li><strong>链表</strong>的插入和删除操作时间复杂度取决于是否已知操作位置的前驱节点：<ul><li>已知前驱节点：<strong>O(1)</strong>。</li><li>需遍历查找位置：<strong>O(n)</strong>。</li></ul></li><li><strong>数组</strong>的插入和删除操作需移动元素，时间复杂度为 <strong>O(n)</strong>。</li></ul></li></ol><table><thead><tr><th>操作</th><th>数组（平均 / 最坏）</th><th>链表（已知前驱节点）</th><th>链表（需遍历）</th></tr></thead><tbody><tr><td><strong>插入元素</strong></td><td>O(n)</td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>删除元素</strong></td><td>O(n)</td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>查找元素</strong></td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td><strong>访问头节点</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td><strong>访问尾节点</strong></td><td>O(1)（有尾指针）</td><td>O(1)（带尾指针）</td><td>O(n)（无尾指针）</td></tr></tbody></table><h1>线性表</h1><p>顺序存储的物理和逻辑是一一对应的<br>链式存储可用于存储线性和非线性的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10    <span class="comment">// 线性表初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INCREMENT 2     <span class="comment">// 容量不足时的增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;        <span class="comment">// 元素类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;          <span class="comment">// 操作状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType* data;         <span class="comment">// 存储空间基址</span></span><br><span class="line">    <span class="type">int</span> length;             <span class="comment">// 当前元素个数</span></span><br><span class="line">    <span class="type">int</span> capacity;           <span class="comment">// 当前分配的存储容量</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.data = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.data) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.capacity = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.data) &#123;</span><br><span class="line">        <span class="built_in">free</span>(L.data);</span><br><span class="line">        L.data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前驱元素</span></span><br><span class="line"><span class="function">Status <span class="title">PriorElem</span><span class="params">(SqList L, ElemType cur_e, ElemType &amp;pre_e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == cur_e) &#123;</span><br><span class="line">            pre_e = L.data[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容处理</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.capacity) &#123;</span><br><span class="line">        ElemType* newbase = (ElemType*)<span class="built_in">realloc</span>(L.data,</span><br><span class="line">            (L.capacity + LIST_INCREMENT) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.data = newbase;</span><br><span class="line">        L.capacity += LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListTraverse</span><span class="params">(SqList L, <span class="type">void</span> (*visit)(ElemType))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">MergeSortedLists</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化结果表</span></span><br><span class="line">    Lc.capacity = La.length + Lb.length;</span><br><span class="line">    Lc.data = (ElemType*)<span class="built_in">malloc</span>(Lc.capacity * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Lc.data) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length &amp;&amp; j &lt; Lb.length) &#123;</span><br><span class="line">        Lc.data[k++] = (La.data[i] &lt;= Lb.data[j]) ? La.data[i++] : Lb.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; La.length) Lc.data[k++] = La.data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; Lb.length) Lc.data[k++] = Lb.data[j++];</span><br><span class="line"></span><br><span class="line">    Lc.length = k;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L, i, i * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入元素后: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(L, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">ListDelete</span>(L, <span class="number">3</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除第3个元素: %d\n&quot;</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(L, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并测试</span></span><br><span class="line">    SqList La, Lb, Lc;</span><br><span class="line">    <span class="built_in">InitList</span>(La);</span><br><span class="line">    <span class="built_in">InitList</span>(Lb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(La, i, i * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">ListInsert</span>(Lb, i, i * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MergeSortedLists</span>(La, Lb, Lc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;合并后结果: &quot;</span>);</span><br><span class="line">    <span class="built_in">ListTraverse</span>(Lc, PrintElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源清理</span></span><br><span class="line">    <span class="built_in">DestroyList</span>(L);</span><br><span class="line">    <span class="built_in">DestroyList</span>(La);</span><br><span class="line">    <span class="built_in">DestroyList</span>(Lb);</span><br><span class="line">    <span class="built_in">DestroyList</span>(Lc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表的合并">顺序表的合并</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2070.png" alt="Untitled 8 70"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2067.png" alt="Untitled 9 67"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2063.png" alt="Untitled 10 63">时间复杂度Q(ListLength(La)+ListLength(Lb))<br>空间复杂度O(1)</p><h2 id="单链表">单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p>普通变量是LNode.成员名，指针变量是LinkList-&gt;成员名<br>Linklist强调单链表，LNode*强调结点</p><p>定义链表L：LNode * L == LinkList L(更常用)<br>定义结点指针：LNode *p(更常用) == LinkList p<br>L-&gt;next有两层含义，可以表示L的后继节点指针，又可表示L的指针域（单链表的指针域只有后继指针域，双链表的指针域分为前驱指针域和后继指针域））<br>p = L就是p = 头结点，p = L-&gt;next就是让p = 头结点的后一个节点。</p><p>头指针：是指向链表第一个结点的指针<br>首元结点：是指向链表中存储第一个数据元素a1的结点<br>头结点：是在链表的首元结点之前附设的一个结点。链表中的头结点仅起到标识的作用。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/5e68616c9b390b7ef84a08401462f0d.jpg" alt="5e68616c9b390b7ef84a08401462f0d"><br>带<mark>头结点</mark>的好处：</p><ol><li>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。</li><li>便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此统一。</li><li>头结点的指针域可以为空，可以存放长度等，但<mark>不计入链表的长度值</mark>。</li></ol><p>表示空表</p><ul><li>无头结点：头指针为空</li><li>有头结点：头结点的指针域为空</li></ul><p>链表特点：</p><ul><li>结点在存储器中位置任意</li><li>只能通过头指针进入链表，顺序扫描。寻找第一个结点很容易。<mark>顺序表是随机存储法</mark></li><li>结点空间可以动态申请和释放</li><li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li><li>缺点：存储密度小，利用率小，每个结点的指针域额外占用存储空间</li><li>静态链表中的指针表示的是数组下标</li></ul><h2 id="头插（逆序）">头插（逆序）</h2><p>带头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/7ae0a7bd64d74b5d9a149f7849e38f93.gif" alt="7ae0a7bd64d74b5d9a149f7849e38f93"><br>不带头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/e062fe1ed673468681ecce4d84a865ae.gif" alt="e062fe1ed673468681ecce4d84a865ae"></p><h2 id="尾插">尾插</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2075.png" alt="Untitled 7 75|Untitled 7 75.png"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/IMG_20231010_091813.jpg" alt="IMG_20231010_091813"><br>带头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/f47832ac0b274b19b1fb2e5ba8d5fcb9.gif" alt="f47832ac0b274b19b1fb2e5ba8d5fcb9"><br>不带头结点同上</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a9b4f515e81d49d9abbc6456ff2bb60e.jpg" alt="a9b4f515e81d49d9abbc6456ff2bb60e"></p><h2 id="带头结点的单链表">带头结点的单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化带头结点的链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="keyword">return</span> ERROR;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = i*<span class="number">2</span>;  <span class="comment">// 测试数据</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_T</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LNode *tail = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = i*<span class="number">3</span>;  <span class="comment">// 测试数据</span></span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置插入</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;  <span class="comment">// 找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListTraverse</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不带头结点的单链表">不带头结点的单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *NoHeadList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化不带头结点的链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(NoHeadList &amp;L)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i*<span class="number">2</span>;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法建立链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_T</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Node *tail = <span class="literal">NULL</span>;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data = i*<span class="number">3</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!L) &#123;</span><br><span class="line">            L = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置插入</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;  <span class="comment">// 特殊处理第一个结点</span></span><br><span class="line">        Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(NoHeadList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || !L) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;  <span class="comment">// 特殊处理第一个结点</span></span><br><span class="line">        Node *q = L;</span><br><span class="line">        e = q-&gt;data;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node *q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListTraverse</span><span class="params">(NoHeadList L)</span> &#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(NoHeadList &amp;L)</span> &#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么不是 <code>free(*r)</code>？</strong></p><ul><li><code>free()</code> 的参数必须是一个指针，指向动态分配的内存块的起始地址。</li><li>如果 <code>r</code> 是一个指针变量（例如 <code>int* r</code>），则 <code>free(r)</code> 是正确的用法，因为 <code>r</code> 本身就是一个指针。</li><li>如果 <code>r</code> 是一个指向指针的指针（例如 <code>int** r</code>），则 <code>free(*r)</code> 是正确的用法，因为 <code>*r</code> 是一个指针，指向动态分配的内存块</li></ul><h2 id="代码思路整理">代码思路整理</h2><h2 id="1-结构差异对比">1. 结构差异对比</h2><table><thead><tr><th>特性</th><th>带头结点</th><th>不带头结点</th></tr></thead><tbody><tr><td>初始化</td><td>需要创建头结点，头指针指向头结点</td><td>直接置空指针</td></tr><tr><td>首元结点处理</td><td>统一通过头结点的 next 指针访问</td><td>直接通过头指针访问</td></tr><tr><td>空表判断</td><td>L-&gt;next == NULL</td><td>L == NULL</td></tr><tr><td>插入 / 删除首结点</td><td>不需要特殊处理</td><td>需要单独处理头指针变化</td></tr><tr><td>算法复杂度</td><td>各操作时间复杂度 O (n)，但边界处理更简单</td><td>时间复杂度相同，但需要更多条件判断</td></tr></tbody></table><h2 id="2-关键实现要点">2. 关键实现要点</h2><ul><li><strong>头插法</strong>：新结点始终插入到链表头部</li><li><strong>尾插法</strong>：需要维护尾指针以提高效率</li><li><strong>位置索引</strong>：统一采用1-based索引</li><li><strong>内存管理</strong>：每次操作后及时释放内存</li><li><strong>错误处理</strong>：对非法位置进行有效性检查</li></ul><h2 id="3-推荐使用场景">3. 推荐使用场景</h2><ul><li><strong>带头结点</strong>：适合需要频繁进行首结点操作的场景</li><li><strong>不带头结点</strong>：适合内存敏感或需要直接操作首结点的场景</li></ul><h2 id="双链表">双链表</h2><p>在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了由两个方向不同的链，表头结点的prior指向NULL，表尾结点的next指向NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span>    <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span>     <span class="comment">// 后继指针</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br></pre></td></tr></table></figure><h2 id="初始化双链表"><strong>初始化双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作（在节点-p-后插入节点-s）"><strong>插入操作（在节点 p 后插入节点 s）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterDNode</span><span class="params">(DNode *p, DNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;     <span class="comment">// 1. s 的后继指向 p 的后继</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)           <span class="comment">// 如果 p 不是最后一个节点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">// 2. p 的后继的前驱指向 s</span></span><br><span class="line">    s-&gt;prior = p;          <span class="comment">// 3. s 的前驱指向 p</span></span><br><span class="line">    p-&gt;next = s;           <span class="comment">// 4. p 的后继指向 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作（删除节点-p-的后继节点）"><strong>删除操作（删除节点 p 的后继节点）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterDNode</span><span class="params">(DNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;next) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    DNode *q = p-&gt;next;  <span class="comment">// q 指向待删除节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">// 1. p 的后继指向 q 的后继</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next)         <span class="comment">// 如果 q 不是最后一个节点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// 2. q 的后继的前驱指向 p</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">// 3. 释放 q 的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环双链表">循环双链表</h2><p>表头结点的prior指向表尾结点，表尾结点的next指向头结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20129.png" alt="Untitled 1 129"><br>对称性：p→prior→next = p = p→next→prior</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">prior</span>;</span>   <span class="comment">// 前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 后继指针</span></span><br><span class="line">&#125; CDNode, *CDLinkList;</span><br></pre></td></tr></table></figure><h2 id="初始化循环双链表"><strong>初始化循环双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCDLinkList</span><span class="params">(CDLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));  <span class="comment">// 创建头结点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = L;  <span class="comment">// 头结点的前驱指向自己</span></span><br><span class="line">    L-&gt;next = L;   <span class="comment">// 头结点的后继指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作（在节点-p-后插入节点-s）-2"><strong>插入操作（在节点 p 后插入节点 s）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterCDNode</span><span class="params">(CDNode *p, CDNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性</span></span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next;     <span class="comment">// 1. s 的后继指向 p 的后继</span></span><br><span class="line">    s-&gt;prior = p;          <span class="comment">// 2. s 的前驱指向 p</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;    <span class="comment">// 3. p 的后继的前驱指向 s</span></span><br><span class="line">    p-&gt;next = s;           <span class="comment">// 4. p 的后继指向 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作（删除节点-p-的后继节点）-2"><strong>删除操作（删除节点 p 的后继节点）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterCDNode</span><span class="params">(CDNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || p-&gt;next == p) <span class="keyword">return</span>;  <span class="comment">// 检查参数合法性（空表或只有头结点）</span></span><br><span class="line"></span><br><span class="line">    CDNode *q = p-&gt;next;  <span class="comment">// q 指向待删除节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;    <span class="comment">// 1. p 的后继指向 q 的后继</span></span><br><span class="line">    q-&gt;next-&gt;prior = p;   <span class="comment">// 2. q 的后继的前驱指向 p</span></span><br><span class="line">    <span class="built_in">free</span>(q);              <span class="comment">// 3. 释放 q 的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306144931.jpg" alt="Pasted image 20250306144931"><br>1234——s的前驱和后继-&gt;pnext的前驱-&gt;p的后继<br>s-&gt;prior=p;<br>s-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;perior=s;<br>p-&gt;next=s;<br>3214——pnext的前驱-&gt;s的后继-&gt;s的前驱-&gt;p的后继<br>3241——pnext的前驱-&gt;s的后继-&gt;p的后继-&gt;s的前驱<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2096.png" alt="Untitled 3 96"><br>不用头指针的原因：由表头找到表尾较费时，删表头O(1)，插表尾O(n)<br>让L指向尾指针：都是O(1)<br>终止条件：判断是否等于头指针<br>单链表：<br>p≠NULL;<br>p→next≠NULL;<br>单循环链表：<br>p≠L;<br>p→next≠L;</p><p>带尾指针的循环链表的合并(Tb合并在Ta之后)<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20225.png" alt="Untitled 225|Untitled 225.png"><br>p存表头结点（p = Ta→next）→Tb表头连接Ta表尾（Ta→next = Tb→next→next）→释放Tb表头结点（delete Tb→next）→修改指针（Tb→next = p）</p><h2 id="插入操作（以双链表为例）"><strong>插入操作（以双链表为例）</strong></h2><ol><li><strong><code>s-&gt;next = p-&gt;next;</code></strong>：<ul><li>将新节点 <code>s</code> 的后继指向 <code>p</code> 的后继。</li></ul></li><li><strong><code>if (p-&gt;next) p-&gt;next-&gt;prior = s;</code></strong>：<ul><li>如果 <code>p</code> 不是最后一个节点，将 <code>p</code> 的后继的前驱指向 <code>s</code>。</li></ul></li><li><strong><code>s-&gt;prior = p;</code></strong>：<ul><li>将新节点 <code>s</code> 的前驱指向 <code>p</code>。</li></ul></li><li><strong><code>p-&gt;next = s;</code></strong>：<ul><li>将 <code>p</code> 的后继指向 <code>s</code>。</li></ul></li></ol><h2 id="删除操作（以双链表为例）"><strong>删除操作（以双链表为例）</strong></h2><ol><li><strong><code>p-&gt;next = q-&gt;next;</code></strong>：<ul><li>将 <code>p</code> 的后继指向 <code>q</code> 的后继。</li></ul></li><li><strong><code>if (q-&gt;next) q-&gt;next-&gt;prior = p;</code></strong>：<ul><li>如果 <code>q</code> 不是最后一个节点，将 <code>q</code> 的后继的前驱指向 <code>p</code>。</li></ul></li><li><strong><code>free(q);</code></strong>：<ul><li>释放 <code>q</code> 的内存。</li></ul></li></ol><h2 id="双链表-2"><strong>双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterDNode</span><span class="params">(DNode *p, DNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterDNode</span><span class="params">(DNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !p-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next) q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDLinkList</span><span class="params">(DLinkList L)</span> &#123;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line"></span><br><span class="line">    DNode *s1 = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s1-&gt;data = <span class="number">10</span>;</span><br><span class="line">    InsertAfterDNode(L, s1);</span><br><span class="line"></span><br><span class="line">    DNode *s2 = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s2-&gt;data = <span class="number">20</span>;</span><br><span class="line">    InsertAfterDNode(s1, s2);</span><br><span class="line"></span><br><span class="line">    PrintDLinkList(L);  <span class="comment">// 输出：10 20</span></span><br><span class="line"></span><br><span class="line">    DeleteAfterDNode(L);</span><br><span class="line">    PrintDLinkList(L);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环双链表-2"><strong>循环双链表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CDNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CDNode, *CDLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCDLinkList</span><span class="params">(CDLinkList &amp;L)</span> &#123;</span><br><span class="line">    L = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAfterCDNode</span><span class="params">(CDNode *p, CDNode *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !s) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteAfterCDNode</span><span class="params">(CDNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || p-&gt;next == p) <span class="keyword">return</span>;</span><br><span class="line">    CDNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintCDLinkList</span><span class="params">(CDLinkList L)</span> &#123;</span><br><span class="line">    CDNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != L) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CDLinkList L;</span><br><span class="line">    InitCDLinkList(L);</span><br><span class="line"></span><br><span class="line">    CDNode *s1 = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    s1-&gt;data = <span class="number">10</span>;</span><br><span class="line">    InsertAfterCDNode(L, s1);</span><br><span class="line"></span><br><span class="line">    CDNode *s2 = (CDNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CDNode));</span><br><span class="line">    s2-&gt;data = <span class="number">20</span>;</span><br><span class="line">    InsertAfterCDNode(s1, s2);</span><br><span class="line"></span><br><span class="line">    PrintCDLinkList(L);  <span class="comment">// 输出：10 20</span></span><br><span class="line"></span><br><span class="line">    DeleteAfterCDNode(L);</span><br><span class="line">    PrintCDLinkList(L);  <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表">静态链表</h2><p>用数组实现的链表结构，它通过数组的下标来模拟链表的指针。静态链表的特点是不需要动态分配内存，而是预先分配一个<strong>固定大小</strong>的数组来存储链表节点。<br>静态链表的结构</p><ul><li><p><strong>数组存储</strong>：</p><ul><li>静态链表使用数组来存储节点，每个节点包含两个部分：<ul><li><strong>数据域</strong>：存储数据。</li><li><strong>游标（或指针域）</strong>：存储下一个节点的数组下标。</li></ul></li><li>数组的每个位置可以看作一个节点，游标指向下一个节点的位置。</li></ul></li><li><p><strong>头结点和空闲链表</strong>：</p><ul><li>静态链表通常有一个头结点，用于指向链表的第一个节点。</li><li>空闲链表用于管理未使用的数组位置，方便插入新节点。</li></ul></li></ul><p>为什么不需要移动元素</p><h2 id="插入操作"><strong>插入操作</strong></h2><ul><li><strong>插入新节点</strong>：<ul><li>从空闲链表中获取一个空闲位置（数组下标）。</li><li>修改游标，将新节点插入到链表中。</li><li><strong>不需要移动其他元素</strong>，只需修改游标。</li></ul></li></ul><h2 id="删除操作"><strong>删除操作</strong></h2><ul><li><strong>删除节点</strong>：<ul><li>将要删除的节点从链表中移除。</li><li>将该节点的位置加入空闲链表。</li><li><strong>不需要移动其他元素</strong>，只需修改游标。</li></ul></li></ul><h2 id="修改游标"><strong>修改游标</strong></h2><ul><li>静态链表通过修改游标（数组下标）来维护链表结构，而不是通过移动数据元素。</li><li>这种方式类似于动态链表，但使用数组下标代替指针。</li></ul><p><strong>与动态链表的对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>动态链表</strong></th><th><strong>静态链表</strong></th></tr></thead><tbody><tr><td><strong>存储结构</strong></td><td>使用指针连接节点</td><td>使用数组下标（游标）连接节点</td></tr><tr><td><strong>内存分配</strong></td><td>动态分配内存</td><td>预先分配固定大小的数组</td></tr><tr><td><strong>插入/删除</strong></td><td>修改指针</td><td>修改游标</td></tr><tr><td><strong>移动元素</strong></td><td>不需要移动元素</td><td>不需要移动元素</td></tr><tr><td><strong>内存管理</strong></td><td>需要动态内存管理</td><td>不需要动态内存管理</td></tr><tr><td><strong>适用场景</strong></td><td>数据量不确定，频繁插入删除</td><td>数据量固定，内存受限的场景</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">// 游标（下一个节点的下标）</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node staticList[MAX_SIZE];  <span class="comment">// 静态链表数组</span></span><br><span class="line"><span class="type">int</span> head;                   <span class="comment">// 头结点下标</span></span><br><span class="line"><span class="type">int</span> freeList;               <span class="comment">// 空闲链表头结点下标</span></span><br></pre></td></tr></table></figure><h2 id="插入操作-2"><strong>插入操作</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (freeList == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;静态链表已满，无法插入新节点！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲链表中获取一个节点</span></span><br><span class="line">    <span class="type">int</span> newNodeIndex = freeList;</span><br><span class="line">    freeList = staticList[freeList].next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    staticList[newNodeIndex].data = data;</span><br><span class="line">    staticList[newNodeIndex].next = staticList[head].next;</span><br><span class="line">    staticList[head].next = newNodeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作-2"><strong>删除操作</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev = head;</span><br><span class="line">    <span class="type">int</span> curr = staticList[head].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticList[curr].data == data) &#123;</span><br><span class="line">            <span class="comment">// 从链表中移除节点</span></span><br><span class="line">            staticList[prev].next = staticList[curr].next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将节点加入空闲链表</span></span><br><span class="line">            staticList[curr].next = freeList;</span><br><span class="line">            freeList = curr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = staticList[curr].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未找到要删除的元素！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态链表不需要移动元素</strong>，因为它通过修改游标（数组下标）来维护链表结构。</li><li>插入和删除操作只需修改游标，而不需要移动数据元素。</li><li>静态链表适用于内存受限的场景，但灵活性不如动态链表。</li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2046.png" alt="Untitled 2 46"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%203%2040.png" alt="Untitled 3 40"><br>顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取<br>在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂<br>双链表中可以快速访问任何一个结点的前驱和后继结点,选项D正确。</p><h2 id="错题">错题</h2><p>^3afb0f</p><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png" alt="Pasted image 20250306152709">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152709.png" alt="Pasted image 20250306152709">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306152828.png" alt="Pasted image 20250306152828">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306154314.png" alt="Pasted image 20250306154314">d</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306160930.png" alt="Pasted image 20250306160930">链式存储设计时，各个不同结点的<mark>存储空间</mark>可以不连续，但结点内的<mark>存储单元地址</mark>必须连续</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161045.png" alt="Pasted image 20250306161045"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306161310.png" alt="Pasted image 20250306161310"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162035.png" alt="Pasted image 20250306162035"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162229.png" alt="Pasted image 20250306162229"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163931.png" alt="Pasted image 20250306163931">设单链表递增有序，首先要在单链表中找到第一个大于x的结点的直接前驱p，在p之后插入该结点。查找的时间复杂度为 O(n)，插入的时间复杂度为 0(1)，总时间复杂度为 O(n)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162259.png" alt="Pasted image 20250306162259"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162245.png" alt="Pasted image 20250306162245"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162348.png" alt="Pasted image 20250306162348">b有关因为需要遍历链表找到倒数第二个节点。d无关，因为尾指针 r 直接指向最后一个节点，无需遍历</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306162745.png" alt="Pasted image 20250306162745">d线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素 a50 不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306163806.png" alt="Pasted image 20250306163806">改四个指针域，分别是:新结点的前驱指针域，指向第一个结点:新结点的后继指针域，指向第二个结点;第一个结点的后继指针域，指向新结点;第二个结点的前驱指针域，指向新结点。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306164359.png" alt="Pasted image 20250306164359">带头结点的循环单链表工为空表时，满足L-&gt;next == L，即头结点的指针域与L的值相等,而不是头结点的指针域与工的地址相等。注意，带头结点的循环单链表中不存在空指针。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306165707.png" alt="Pasted image 20250306165707">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170529.png" alt="Pasted image 20250306170529"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306170531.png" alt="Pasted image 20250306170531">对于选项 A，删除尾结点* p 时，需要找到* p的前一个结点，时间复杂度为 O(n)。对于选项B，删除首结点* p时，需要找到* p结点,这里没有直接给出头结点指针，而通过尾结点的 prior指针找到* p 结点的时间复杂度为 O(n)。对于选项 D，删除尾结点* p 时，需要找到* p 的前一个结点，时间复杂度为 O(n)。对于C，执行这四种算法的时间复杂度均为 O(1)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171120.png" alt="Pasted image 20250306171120">在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为 O(1)。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在 0(1)的时间找到尾结点:若只有表头指针，则需要遍历整个链表找到尾结点，时间为0(n)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171301.png" alt="Pasted image 20250306171301">对一个空循环单链表，有 head-&gt;next== head，推理 head-&gt;next-&gt;next== head-&gt;next== head。对含有一个元素的循环单链表，头结点(头指针 head 指示)的 next 域指向这个唯一的元素结点，该元素结点的next 域指向头结点，因此也有 head-&gt;next-&gt;next=head。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306171913.png" alt="Pasted image 20250306171913">对于两种双链表，删除首结点的时间复杂度都是 0(1)。对于非循环双链表，删除尾结点的时间复杂度是 0(m);对于循环双链表，删除尾结点的时间复杂度是0(1)。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172027.png" alt="Pasted image 20250306172027">对于选项 A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为 O(n);而删除第一个元素时，为保持循环单链表的性质(尾结点指向第一个结点)，要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为 O(n)。对于选项 B,双链表的情况与单链表的相同，一个是 O(n),一个是 O(1)。对于选项C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置,时间复杂度为 0(n);删除第一个元素的时间复杂度为 O(1)。对于选项 D，与选项 A 的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为0(1)</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306172625.png" alt="Pasted image 20250306172625">静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306173426.png" alt="Pasted image 20250306173426">静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。并非每个空间都存储了元素，因此会造成存储空间的浪费。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174519.png" alt="Pasted image 20250306174519"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306174543.png" alt="Pasted image 20250306174543"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306175206.png" alt="Pasted image 20250306175206">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191738.png" alt="Pasted image 20250306191738"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250306191747.png" alt="Pasted image 20250306191747"></li><li></li></ol><h1>栈LIFO</h1><p>栈和队列都是<strong>操作受限</strong>线性表<br>应用：撤销，递归，进制转换，迷宫求解，表达式求值，括号匹配，处理函数或过程调用时的局部变量、返回地址、参数，深度优先遍历DFS<br>在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。<br>栈只能操作栈顶</p><h2 id="顺序栈">顺序栈</h2><p>在非空顺序栈中栈底指针始终指向栈底元素,栈顶指针始终指向栈顶元素的下一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307111852.png" alt="Pasted image 20250307111852">栈顶指针：S.top，初始时设置S.top=-1<br>栈底 0<br>栈顶元素：S.data[S.top]<br>入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶 S.data[++S.top] = x<br>出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1 x = S.data[S.top–]<br>栈空条件：S.top == -1<br>栈满条件：S.top== MaxSize-1<br>栈长：S.top+1<br>另一种常见的方式是：<br>初始设置栈顶指针 S.top=0<br>入栈时先将值送到栈顶，栈顶指针再加 1<br>出栈时，栈顶指针先减1，再取栈顶元素<br>栈空条件是 S.top== 0<br>栈满条件是S.top== MaxSize.<br>顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">SElemType* base;</span><br><span class="line">SElemType* top;</span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307121133.png" alt="Pasted image 20250307121133|200"><br>top指示真正栈顶元素之上的下标地址<br>stacksize表示栈的最大容量，共stacksize-1个元素<br>空栈：base== top<br>栈满：top-base== stacksize<br>下溢：栈空还要弹出元素，一般当作一种结束条件<br>上溢：是错误</p><p>3+2的前缀表达形式就是+ 3 2<br>3+2的后缀表达形式就是3 2 +<br>后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)</p><h2 id="共享栈">共享栈</h2><p>两个栈共享一个数组空间的好处：存储空间，降低上溢出发生的机率。其存取数据的时间复杂度均为0(1)，所以对存取效率没有什么影响。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112107.png" alt="Pasted image 20250307112107"><br>两个栈的栈顶指针都指向栈顶元素<br>top0=-1时0号栈为空，top1=Maxsize 时1号栈头空<br>仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满<br>当0号栈入栈时 top0 先加再赋值，1号栈入栈时 top1 先减1再赋值，出栈时则刚好相反<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%2047.png" alt="Untitled 2 47|500"></p><h2 id="链栈">链栈</h2><p>使用单链表实现，且所有操作都是在表头进行，没有头结点，Lhead指向栈顶元素<br>栈顶-&gt;栈底<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112353.png" alt="Pasted image 20250307112353"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkNode,LiStack;</span><br></pre></td></tr></table></figure><p>采用链式存储，便于结点的插入与删除<br>链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行<br>需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同<br>有多少种不同的出栈序列<br>卡特兰数：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_1203_103148.png" alt="Screenshot_2023_1203_103148|90 "></p><ul><li><strong>时间复杂度</strong><ul><li>链栈和顺序栈的进栈和出栈操作时间复杂度均为 O(1)</li></ul></li><li><strong>空间性能</strong>：<ul><li>链栈不需要预先分配固定空间，但每个节点需要额外的指针域。</li><li>顺序栈需要预先分配固定空间，可能导致内存浪费，但存取方便。</li></ul></li><li><strong>选择建议</strong><ul><li>如果栈的长度变化不可预料，建议使用链栈。</li><li>如果栈的长度变化在可控范围内，建议使用顺序栈。</li></ul></li></ul><h2 id="错题-2">错题</h2><p>1.<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112815.png" alt="Pasted image 20250307112815">栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同<br>2. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307112922.png" alt="Pasted image 20250307112922">栈和队列都是限制存取点的线性结构<br>3. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113142.png" alt="Pasted image 20250307113142">顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间<br>4. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307113421.png" alt="Pasted image 20250307113421">对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而循环单链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于选项C，插入和删除结点后，找尾结点所需的时间为 O(n)。<br>5. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114112.png" alt="Pasted image 20250307114112">第n个元素第一个出栈，说明前n-1个元素都已经按顺序入栈d<br>6. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114354.png" alt="Pasted image 20250307114354">d<br>7. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307114611.png" alt="Pasted image 20250307114611">p3=1第一个出栈，此时栈内有p1,p2;2第二个出栈，所以2只可能是p2或者p4,p5…;因此选C<br>8. 将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-* -g+时,用栈来存放暂时还不能确定运算次序的操作符。若栈初始时为空,则转换过程中同时保存在栈中的操作符的最大个数是() A. 5 B. 7 C. 8 D. 11<br>在转换过程中，栈中的操作符最多有5个。这种情况出现在第二个“+”号入栈后，栈中的操作符分别为：“-”，“”，“(”，“(”，“+”。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190631.png" alt="Pasted image 20250307190631"><br>9. <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190913.png" alt="Pasted image 20250307190913"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307190923.png" alt="Pasted image 20250307190923"><br>10.</p><h1>队列FIFO</h1><p><mark>头删尾插</mark><br>栈和队列是受限的线性表，它们的共同点是只允许在端点处插入和删除元素。<br>栈只允许在一端进行插入、删除操作<br>队列只允许在一端进行插入,在另一端进行删除<br>应用：缓冲区，层次遍历，CPU资源竞争，广度优先搜索BFS，消息队列<br>采用<mark>尾指针</mark>的循环单链表适合作为队列的存储结构<br>队列一般情况下需要修改队尾指针，但是当队列为空时需要同时修改头尾指针<br>最适合用作链式队列的链表是带有队头指针和队尾指针的非循环单链表<br>为了防止队列发生假溢出，应该使用循环队列</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307122136.png" alt="Pasted image 20250307122136|400"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> data[MaxSize];</span><br><span class="line"> <span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>初始时:Q.front=Q.rear=0。<br>入队操作：队不满时，先送值到队尾元素，再将队尾指针加1<br>出队操作：队不空时，先取队首元素值，再将队首指针加1<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123048.png" alt="Pasted image 20250307123048|500"><br>不能用 Q.rear== Maxsize 作为队列满的条件(d)中，队列中仅有一个元素，但仍满足该条件。这时入队出现“上溢出””，但这种溢出并不是真正的溢出，在 data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。</p><h2 id="循环队列">循环队列</h2><p>因为每次入队或者出队都是font或者rear向后移动一位,font指针无法往前移动,此时就会造成删除的空间无法使用，循环队列即可解决问题<br>把存储队列元素的表从逻辑上视为一个环,称为循环队列<br>当队首指针 Q.front=Maxsize-1后，再前进一个位置就自动到0，这可以利用除法取模运算(%)来实现。<br>初始时：Q.front=Q.rear=0。<br>队首指针进1：Q.front=(Q.front+1)%Maxsize。<br>队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。<br>队列长度：(Q.rear+Maxsize-Q.front)%Maxsize。<br>出入队时：指针都按顺时针方向进1<br>循环队列需要几个参数来确定?以及各个参数的含义？<br>需要2个参数,第一个参数是front,第二个参数是rear;<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307123713.png" alt="Pasted image 20250307123713|500"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307124944.png" alt="Pasted image 20250307124944"><br>队满条件：（Q.rear+1）%MaxSize== Q.front<br>队空条件：Q.front== Q.rear</p><h2 id="链式队列">链式队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> &#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br></pre></td></tr></table></figure><p>不带头结点时，当Q.front== NULL且Q.rear== NULL 时，链式队列为空<br>插入r→next=s;s-&gt;next=NULL;r=s;<br>用链头作为队头</p><h2 id="静态队列">静态队列</h2><p>基于数组实现的，如果是普通数组，规定front指向第一个元素的位置，rear指向最后一个元素位置的下一个位置<br>如果front指向第一个的前一个元素，rear就指向最后一个元素。<br>初始状态（队空条件）：Q-&gt;front == Q-&gt;rear == 0。<br>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。<br>出队操作：队不空时，先取队头元素值，再将队头指针加1。</p><h2 id="双端队列">双端队列</h2><p>允许两端都可以进行插入和删除操作的线性表<br>输入受限：一端插入删除，另一端删除<br>输出受限：一端插入删除，另一端插入</p><h2 id="错题-3">错题</h2><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307131237.png" alt="Pasted image 20250307131237">c</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307171220.png" alt="Pasted image 20250307171220">循环队列中，每删除一个元素，队首指针 front=(front+1)%6，每插入一个元素，队尾指针 rear=(rear+1)%6。上述操作后，front=0，rear=3</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307172039.png" alt="Pasted image 20250307172039">虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的入队和出队时间复杂度均为O(1)。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175308.png" alt="Pasted image 20250307175308">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174201.png" alt="Pasted image 20250307174201">因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要 0(n)的时间。选项 B、C和D均可在 0(1)的时间内找到队首和队尾。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307174444.png" alt="Pasted image 20250307174444">队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素,则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，修改队尾指针为rear=front。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175540.png" alt="Pasted image 20250307175540"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307175551.png" alt="Pasted image 20250307175551"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180416.png" alt="Pasted image 20250307180416"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307180430.png" alt="Pasted image 20250307180430"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307181119.png" alt="Pasted image 20250307181119">第一个元素进入队列后存储在A[0]处，此时 front 和 rear 值都为0。入队时因为要执行(rear+1)%n 操作，所以若入队后指针指向 0，则 rear 初值为 n-1，而因为第一个元素在A[0]中，插入操作只改变rear 指针，所以front为0不变</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182400.png" alt="Pasted image 20250307182400">利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得 R1，C入栈，计算得 R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D依次计算得栈深为 4、3、3。因此选择选项 B</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182639.png" alt="Pasted image 20250307182639"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182649.png" alt="Pasted image 20250307182649"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182804.png" alt="Pasted image 20250307182804">b</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250307182833.png" alt="Pasted image 20250307182833">c</li><li></li></ol><h1>数组</h1><p>线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。<br>特点：结构固定——定义后，维数和维界不再改变。<br>LOC(aij)=基地址+偏移量<br>数组偏移量基址<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20138.png" alt="Untitled 138|Untitled 138.png|300"><br>以行为例，地址=基地址+(i×n+j)×元素大小</p><p>三维数组：a mno<br>三维数组计算a ijk的公式为d=i* n* o+j* o+k，就是d高* 长* 宽+d长* 高+d宽</p><p>typedef elemtype array2【m】【n】;<br>等价<br>typedef elemtype array1[n];<br>typedef array1 array2[m];</p><h2 id="压缩存储">压缩存储</h2><p>为多个值相同的元只分配一个存储空间；对零元不分配空间。<br><strong>特殊矩阵的压缩存储</strong>方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。目的：减少不必要的存储空间</p><p>一维数组a[i]的存放地址=起始地址+i* sizeof(ElemType)<br>存储目的：把一个<strong>n维的数组定义为其数据元素为n-1维数组类型的一维数组</strong>。<br>二维数组的存储结构：<br><mark>行优先存储</mark>：定义二维数组 a：int a【4】【5】。由下图可知，对于行优先，a【2】【3】是第几个元素的求法为：行标2之前的行已填满元素，每行元素有5个，行标2所指的行的元素个数由列标指示出来，因此a【2】【3】是第2x5+3+1=14个元素，a【2】【3】之前有13个元素。<br><mark>列优先存储</mark>：对于列优先，a【2】【3】是第几个元素的求法为：列标3之前的列已填满元素，每列元素有4个，列标3所指的列的元素个数由行标指示出来，因此a【2】【3】是第3x4+2+1=15个元素，a【2】【3】之前有14个元素。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/8ee2d0ea49804b7991042179b2c863fb.jpg" alt="8ee2d0ea49804b7991042179b2c863fb"></p><p>按列<br> LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))* L<br>按行<br>LOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))* L</p><h2 id="特殊矩阵">特殊矩阵</h2><p>矩阵下标默认从1开始<br>数组默认从0开始</p><h2 id="对称矩阵">对称矩阵</h2><p>n阶方阵，aij=aji（1⩽i,j⩽n）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104031.png" alt="Pasted image 20250308104031|200">存储策略：只存储主对角线+上/下三角区<br>元素个数为n(n+1)/2<br>n阶矩阵A可以用一维数组B== [n(n+1)/2]== 以行序为主序存储其下三角（包括对角线）中的元素，那么B[k]与aij之间存在一一对应关系：<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308104132.png" alt="Pasted image 20250308104132|350"></p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/c694632cf58d4933a61613c570a30ddb.jpg" alt="c694632cf58d4933a61613c570a30ddb"></p><p>一般存下三角+主对角线，用等差数列，上三角i，j互换就可以</p><h2 id="三角阵">三角阵</h2><p>存储方法与对称矩阵类似，使用n(n+1)/2+1个存储空间，其中最后一个空间用来存放常数c，在一维数组中的存储结果如下图：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/a588174886ae4654a8ae7fafcb71d526.jpg" alt="a588174886ae4654a8ae7fafcb71d526"><br>下三角：i&lt;j时，有aij=0<br>上三角：i&gt;j时，有aij=0 上三角为0<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20131.png" alt="Untitled 1 131|Untitled 1 131.png|300"><br>上三角矩阵的压缩存储公式<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0815_075029.png" alt="Screenshot_2023_0815_075029|350"></p><h2 id="三对角矩阵">三对角矩阵</h2><p>n(n&gt;=3)阶三对角矩阵中的非零元素都集中在以主对角线为中心的带状区域中，其他区域均为零元，也即当|i-j|&gt;1时，有aij=0。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308120026.png" alt="Pasted image 20250308120026"></p><ul><li>对于 n×nn×n 的三对角矩阵：<ul><li>第 1 行和最后 1 行只有 2 个非零元素。</li><li>中间的行有 3 个非零元素。<br>那么以行序将这些非零元素存储到一维数组B[3n-3]中，那么对应关系是：<br>k=2i+j−3（数组下标从0开始）<br>那么以行序将这些非零元素存储到一维数组B[3n-2]中，那么对应关系是：<br>k=2i+j−2（数组下标从1开始）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/89d0f9130782418894dfe03158fe2059.jpg" alt="89d0f9130782418894dfe03158fe2059"></li></ul></li></ul><h2 id="稀疏矩阵">稀疏矩阵</h2><p>0的个数比非零的多<br>稀疏矩阵进行压缩存储通常有两种方法:顺序存储(三元组)和链式存储(十字链表)<br>稀疏矩阵采用压缩存储后的缺点主要是<mark>丧失随机存取的特性</mark></p><h2 id="错题-4">错题</h2><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308111917.png" alt="Pasted image 20250308111917">A[0][0] 存放在 B[0]<br>对于第 i行，存储的元素为i0 i1 … ii<br>第 i 行的元素个数为 i+1<br>前 i 行的元素总数为：1+2+3+⋯+i=(i+1)i/2</li><li>二维数组 A 按行优先存储，其中每个元素占1个存储单元。若 A11的存储地址为420，A33的存储地址为446，则A55的存储地址为()<br>由行优先存储得到aij的地址地址=基地址+(i×n+j)×元素大小，得出基地址407，12列，故a55=472</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114043.png" alt="Pasted image 20250308114043">k=2i+j- 2，195</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114656.png" alt="Pasted image 20250308114656"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308114705.png" alt="Pasted image 20250308114705"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115002.png" alt="Pasted image 20250308115002"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115013.png" alt="Pasted image 20250308115013"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308115654.png" alt="Pasted image 20250308115654">总数=2+28×3+1=2+84=87或k=2i+j-3</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122246.png" alt="Pasted image 20250308122246">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122545.png" alt="Pasted image 20250308122545">按上三角存储，m7,2对应的是m2,7，在它之前有： 第1列：1 第2列：2 第6列：6 第7列：1 前面一共1+2+3+4+5+6+1个元素，共22个元素，数组下标从0开始，故下标为m2,7的数组下标为22。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308122839.png" alt="Pasted image 20250308122839"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308123055.png" alt="Pasted image 20250308123055"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308124253.png" alt="Pasted image 20250308124253|400">按列优先次序存储，A[6,7]处于第7行第8列，前面有7列，每一列8x5个单元，再加上第8列前面的6个元素6x5，即7x8x5+6x5=310</li><li></li></ol><h1>串</h1><p>定义：是由零个或多个字符组成的有限序列<br>S=’a1a2a3……an’<br>编号默认从1开始<br>串值用单引号括起来<br>子串：串中任意个连续的字符组成的子序列<br>字符串的子串数目为n(n+1)/2 + 1<br>主串：包含子串的串<br>字符在主串中的位置：字符在串中的序号<br>子串在主串中的位置：子串的第一个字符在主串中的位置<br>例如，有串 A=‘china Beijing’，B=‘Beijing’，c=‘china’，则它们的长度分别头13、7 和 5。B 和C是A的子串，B在A中的位置是 7,c 在A中的位置是1。<br>串是一种特殊的线性表，数据元素之间呈线性关系。但线性表以单个元素为操作对象，而串以整体（子串）为操作对象。</p><h2 id="串的存储结构">串的存储结构</h2><h2 id="定长顺序存储">定长顺序存储</h2><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。<br>定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> ch[MaxLen]; <span class="comment">// 每个分量存储一个字符</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h2 id="堆分配存储表示">堆分配存储表示</h2><p>堆分配存储表示仍然以一组地址<mark>连续</mark>的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中<mark>动态</mark>分配得到的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *ch; <span class="comment">// 按串长分配存储区，ch指向串的基地址</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h2 id="块链存储表示">块链存储表示</h2><p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a)是结点大小为4(每个结点存放4个字符)的链表，最后一个结点占不满时通常用“#”补上;图 4.1(b)是结点大小为1的链表。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308125233.png" alt="Pasted image 20250308125233|400"></p><h2 id="字符串的模式匹配">字符串的模式匹配</h2><p>字符串的模式匹配是指在主串中找到与模式串相同的子串，并返回其所在位置。常见的模式匹配算法包括朴素模式匹配算法和KMP算法。</p><h2 id="1-朴素模式匹配算法"><strong>1. 朴素模式匹配算法</strong></h2><p><strong>基本思想</strong></p><ul><li>将主串中所有长度为  m  的子串依次与模式串对比，直到找到一个完全匹配的子串或所有子串都不匹配为止。</li><li>最多需要对比  n - m + 1  个子串。<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308131814.png" alt="Pasted image 20250308131814|250"><br><strong>时间复杂度</strong></li><li>最坏情况下，时间复杂度为  O(nm) ，其中  n  是主串长度， m  是模式串长度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(HString S, HString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, i;</span><br><span class="line">    HString sub;</span><br><span class="line">    <span class="built_in">InitString</span>(sub);</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="built_in">StrLength</span>(S);</span><br><span class="line">        m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">        i = pos;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">SubString</span>(sub, S, i, m);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">StrCompare</span>(sub, T) != <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化实现（直接通过数组下标）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index1</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= pos &amp;&amp; pos &lt;= S[<span class="number">0</span>]) &#123;</span><br><span class="line">        i = pos;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">2</span>; <span class="comment">// i 指向下一个子串的第一个位置</span></span><br><span class="line">                j = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) <span class="comment">// S 中存在 T</span></span><br><span class="line">            <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-KMP算法"><strong>2. KMP算法</strong></h2><p><strong>基本思想</strong></p><ul><li>利用已经匹配过的模式串信息，避免主串指针回溯。<ul><li>特点是在模式匹配时，指示主串的指针不会变小</li></ul></li><li>通过预处理模式串，生成 <code>next</code> 数组，记录模式串中每个位置的最长公共前后缀长度。</li></ul><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308132051.png" alt="Pasted image 20250308132051"><br><strong>时间复杂度</strong></p><ul><li>预处理 <code>next</code> 数组的时间复杂度为  O(m) 。</li><li>匹配过程的时间复杂度为  O(n) 。</li><li>总时间复杂度为  O(n + m) 。<br><strong>核心思想</strong></li><li>在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位j与主串位 i比较时，两个字符不相等，则i的位移方式是 <code>next[j]</code> ，而不是从头开始匹配。主串位指针i不变</li><li><code>next</code> 数组的定义：<code>next[j]</code> 表示模式串中前  j  个字符的最长公共前后缀长度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(SString T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> next[T[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">getNext</span>(T, next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>next</code> 数组的优化（<code>nextval</code> 数组）</strong></p><ul><li>通过进一步优化 <code>next</code> 数组，减少不必要的比较。</li><li>当 <code>T[i] == T[j]</code> 时，<code>nextval[i] = nextval[j]</code>；否则，<code>nextval[i] = j</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><strong>朴素模式匹配算法</strong></th><th><strong>KMP算法</strong></th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>O(nm)</td><td>O(n + m)</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(1)</td><td>O(m) （<code>next</code> 数组）</td></tr><tr><td><strong>主串指针回溯</strong></td><td>需要回溯</td><td>不需要回溯</td></tr><tr><td><strong>适用场景</strong></td><td>模式串较短，主串较小</td><td>模式串较长，主串较大</td></tr></tbody></table><ul><li><strong>朴素模式匹配算法</strong>：实现简单，但效率较低，适合小规模数据。</li><li><strong>KMP算法</strong>：通过预处理模式串，避免主串指针回溯，适合大规模数据。</li><li><strong><code>nextval</code> 数组</strong>：进一步优化 <code>next</code> 数组，减少不必要的比较。</li></ul><h2 id="模式串示例">模式串示例</h2><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308141430.png" alt="Pasted image 20250308141430"><br>next：</p><ol><li>前两个0,1</li><li>之后在当前索引前找两个正向的最大公共子串，next为第一个子串的下一个索引值，例如索引6，看1—5有aba公共子串，next6为4</li></ol><p>nextval：</p><ol><li>第一个为0</li><li>之后看对应的next值所对应的索引字母，例如索引为3的nextval，对应的next为1，对应的索引字母为a，索引3的字母也为a，nextval为索引为1的nextval；若不是同一个字母，nextval则为对应的next值，例如索引为6的对应next4的字母为b，6为a，不一样，nextval为当前next值4<br>T = “abacab”<br>next = [0, 1, 1, 0, 1, 2]<br>nextval = [0, 1, 0, 1, 0, 1]</li></ol><p>ababaaababaa<br>next=<code>[011234223456]</code></p><p>aaab<br>next=<code>[0123]</code><br>nextval=<code>[0003]</code></p><h2 id="错题-5">错题</h2><ol><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143227.png" alt="Pasted image 20250308143227"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143253.png" alt="Pasted image 20250308143253"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308143322.png" alt="Pasted image 20250308143322"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308144541.png" alt="Pasted image 20250308144541"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/66d2e1adc05dd53c7bb762eebfa395b.jpg" alt="66d2e1adc05dd53c7bb762eebfa395b|400"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308145836.png" alt="Pasted image 20250308145836">next<code>[0112342]</code> nextval<code>[0101042]</code> j-nextval<code>[6]</code>=2</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152637.png" alt="Pasted image 20250308152637">a</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308151042.png" alt="Pasted image 20250308151042">由于i=j=5时失效，故主串和模式串的位序都是从0开始的。此时i=5，next<code>[j]</code>=next<code>[5]</code>=2，c<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152257.png" alt="Pasted image 20250308152257|300"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250308152151.png" alt="Pasted image 20250308152151">b</li></ol><h1>二叉树</h1><ol><li><strong>树的定义</strong><ul><li><strong>m叉树</strong>：每个结点最多有 <code>m</code> 个子结点，可以为空树。</li><li><strong>树的度</strong>：所有结点的度的最大值。<ul><li><strong>度为m的树</strong>：各结点的度的最大值<br>至少有一个结点度=m<br>至少有m+1个结点</li></ul></li><li><strong>叶子结点</strong>（终端结点）：没有子结点的结点。</li><li><strong>分支结点</strong>（非终端结点）：至少有一个子结点的结点。</li><li><strong>根结点</strong>：唯一没有前驱的结点，既可以是叶子结点（空树），也可以是分支结点。</li></ul></li><li><strong>结点与度的关系</strong><ul><li><strong>结点数 = 总度数 + 1</strong><br>（每个结点被父结点指向一次，根结点无父结点）</li><li><strong>分支数 = 结点数 - 1 = 总度数</strong><br>（每个分支对应一个子结点）</li><li><strong>节点度数关系</strong> n0​=n2​+2n3​+…+(k−1)nk​+1</li><li><h2 id="总节点数与度数关系"><strong>总节点数与度数关系</strong></h2>对于完全二叉树或多叉树：<br>n=1+n1+2n2+3n3（总分支数 + 根节点）<br>n=n0+n1+n2+n3（总节点数）<br>总度数=n-1=n1+2n2+3n3<br>3.<strong>树的路径与高度</strong></li><li><strong>路径长度</strong>：根到每个结点的路径长度之和。</li><li><strong>树的深度/深度</strong>：根结点的层数（通常从 1 开始）。</li></ul></li></ol><h2 id="树的性质">树的性质</h2><ol><li><strong>结点数范围</strong><ul><li><strong>高度为 <code>h</code> 的 m 叉树</strong>：<ul><li><strong>至少</strong>有 <code>h</code> 个结点（每层仅 1 个结点）。</li><li><strong>至多</strong>有 <code>(m^h - 1)/(m - 1)</code> 个结点（满 m 叉树）<br>二叉树2^n-1个</li></ul></li><li><strong>高度为 <code>h</code>、度为 <code>m</code> 的树</strong>：至少 <code>h + m - 1</code> 个结点</li><li>度为 m、具有 n个结点的树的最大高度h为n-m+1</li><li>度为m的树中<strong>第i层</strong>上至多有**m^(i-1)个结点(i≥1)</li></ul></li><li><strong>最小高度公式</strong><ul><li><strong>具有 <code>n</code> 个结点的 m 叉树</strong>的最小高度logm(n(m-1)+1)</li></ul></li><li><strong>树的形态数</strong><ul><li><code>n</code> 个结点的二叉树共有 <code>C(2n, n)/(n+1)</code> 种不同形态（卡塔兰数）。</li><li>例：3 个结点的二叉树有 5 种形态。</li></ul></li></ol><h2 id="二叉树">二叉树</h2><ol><li><strong>定义与性质</strong><ul><li><strong>二叉树</strong>：每个结点最多有 2 个子结点，且左右子树<strong>有序</strong>。</li><li><strong>度为2</strong>的树至少有3个结点，而二叉树可以为空</li><li><strong>非空二叉树</strong>的叶子结点数 <code>n0</code> 与二分支结点数 <code>n2</code> 的关系：n0=n2+1</li><li><strong>高度 H 的二叉树</strong>：</li><li>最多节点数：2k − 1（满二叉树）</li><li>最少节点数：k（退化为链式结构）</li><li>第i层至多有2^(i-1)个结点</li></ul></li><li><strong>特殊二叉树</strong><ul><li><strong>满二叉树</strong>：<ul><li>高度 <code>h</code>，结点数 <code>2^h - 1</code>。</li><li>只有最后一层有叶子结点，不存在度为 1 的结点。</li></ul></li><li><strong>完全二叉树</strong>：<ul><li>由满二叉树删除最底层最右侧连续若干结点形成。</li><li><strong>性质</strong>：<ul><li>叶子结点只出现在<strong>最后两层</strong>。</li><li>最多一个度为 1 的结点（左孩子），为最后一个分支结点，其结点编号为<code>[n/2]</code>，且n为偶数时，若为奇数，每个分支都有左右孩子</li><li>编号为 <code>i</code> 的结点，左孩子为 <code>2i</code>，右孩子为 <code>2i + 1</code>。</li><li>按层次编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点</li><li>i≤<code>[n/2]</code>（向下取整）为<strong>分支结点</strong>，i&gt;<code>[n/2]</code>（向上取整）为<strong>叶子结点</strong></li><li>结点数为 <code>n</code> 时，叶子结点数 <code>n0 = ⌈n/2⌉</code>（向上取整）</li><li>满二叉树一定是完全二叉树</li><li>当结点数目一定时，具有最小深度的二叉树是完全二叉树</li><li>最少节点数：2^(h−1)</li><li>最多节点数：2^h − 1</li><li>深度（高度）公式：  log2(n+1)向上取整 或 (log2n)+1向下取整</li><li>度为0、1、2的节点关系：<br>n0=n2+1n0​=n2​+1，且 n0+n2n0​+n2​ 必为奇数。<ul><li><strong>偶数节点数 2k</strong>：n1=1, n0=k, n2​=k−1</li><li><strong>奇数节点数 2k−1</strong>：n1​=0,n0​=k, n2​=k−1</li></ul></li></ul></li></ul></li><li><strong>偶数节点数</strong>：编号最大的分支节点（编号 n/2）仅有左子女。</li><li><strong>奇数节点数</strong>：所有分支节点均有左右子女。</li></ul></li></ol><h2 id="二叉排序树（BST）">二叉排序树（BST）</h2><ol><li><p><strong>定义</strong></p><ul><li>左子树所有结点值 &lt; 根结点值 &lt; 右子树所有结点值。</li><li><strong>中序</strong>遍历结果为<mark>有序</mark>序列。</li><li>左子树和右子树又各是一颗二叉排序树</li><li>最左结点数值最小</li><li>对于n个结点的二叉排序树，其最大高度值为n</li><li>可用于元素的排序、搜索</li></ul></li><li><p><strong>操作与性质</strong></p><ul><li><strong>插入与查找</strong>：<ul><li>平均时间复杂度 <code>O(log2n)</code>（平衡时）。</li><li>最坏时间复杂度 <code>O(n)</code>（退化为链表）。</li></ul></li><li><strong>删除操作</strong>：<ul><li><strong>叶子结点</strong>：直接删除。</li><li><strong>单子树结点</strong>：用子树替代被删结点。</li><li><strong>双子树结点</strong>：用前驱（左子树最大结点）或后继（右子树最小结点）替代。</li></ul></li></ul></li></ol><h2 id="平衡二叉树（AVL-树）">平衡二叉树（AVL 树）</h2><ul><li>任意结点的左右子树高度差绝对值 ≤ 1【胖、多 搜索效率更高】</li><li>查找时间复杂度稳定为 <code>O(log n)</code>。</li><li><strong>平衡因子</strong> = 左子树深度 - 右子树深度，取值范围为 {-1, 0, 1}。</li><li>若所有结点平衡因子为 0，则为<strong>满二叉树</strong>。</li><li>平均查找长度为O(log2n)</li><li><ul><li>最大深度：O(log⁡2n)O(log2​n)</li></ul></li></ul><p><strong>二叉树的构造</strong></p><p><strong>平衡调整操作</strong></p><ul><li><strong>最小不平衡子树</strong>：只需调整最近失衡的子树，上层结点会自动平衡。<br>当插入或删除导致平衡因子超出范围时，需通过旋转调整树结构。调整分为四种情况：</li></ul><ol><li><p><strong>LL 型（右单旋转）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在左子树的左子树中。</li><li><strong>操作</strong>：以失衡结点为轴，向右旋转。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A (失衡)            B</span><br><span class="line">   /                  /   \</span><br><span class="line">  B        →        C       A</span><br><span class="line"> /</span><br><span class="line">C</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>RR 型（左单旋转）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在右子树的右子树中。</li><li><strong>操作</strong>：以失衡结点为轴，向左旋转。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A (失衡)                B</span><br><span class="line"> \                   /   \</span><br><span class="line">  B        →        A       C</span><br><span class="line">   \</span><br><span class="line">    C</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>LR 型（先左旋后右旋）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在左子树的右子树中。</li><li><strong>操作</strong>：先对左子树左旋（转为 LL 型），再对失衡结点右旋。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A              A            C</span><br><span class="line"> /              /           /   \</span><br><span class="line">B      →       C     →    B       A</span><br><span class="line"> \            /</span><br><span class="line">  C          B</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>RL 型（先右旋后左旋）</strong>：</p><ul><li><strong>触发条件</strong>：新结点插入在右子树的左子树中。</li><li><strong>操作</strong>：先对右子树右旋（转为 RR 型），再对失衡结点左旋。</li><li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A              A                C</span><br><span class="line"> \              \             /   \</span><br><span class="line">  B      →       C     →    A       B</span><br><span class="line"> /                \</span><br><span class="line">C                  B</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311120615.png" alt="Pasted image 20250311120615|400"></p><p>从所插入结点的路径向上查找，找到违反平衡因子的根结点连续的三个结点，min-mid-max，再按二叉排序树的性质插入剩下的结点<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309124217.png" alt="Pasted image 20250309124217|400"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115540.png" alt="Pasted image 20250311115540|300"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115547.png" alt="Pasted image 20250311115547|250"></p><h2 id="B-树">B 树</h2><ol><li><p><strong>阶数 m</strong>：节点最多有 m 棵子树（m&gt;=3）</p></li><li><p><strong>节点子树数约束</strong>：</p><ul><li>根节点：至少 2 棵子树（除非仅一个节点）。</li><li>非根节点：至少<code>[m/2]</code>棵子树（如 m=5 ，至少 3 棵子树）<br><strong>叶子结点</strong>：均位于同一层，不存储数据（或存储空指针）。<br><strong>关键字与子树关系</strong>：</li><li>关键字数 = 子树数 - 1。</li><li>非叶节点有 j 棵子树时，含 j-1 个关键字。<br><strong>关键字规则</strong>：</li><li>所有关键字按升序排列。</li><li>关键字将子树划分为区间，如结点含关键字  k1, k2 ，则子树范围为 ( -∞, k1), ( k1, k2) , ( k2, ±∞)。</li></ul></li><li><p><strong>2-3树</strong>：3阶B树，非叶节点有2或3棵子树。</p></li><li><p><strong>B+树</strong>：支持顺序查找；B树支持多路查找。</p><ul><li><strong>根结点</strong>：至少 2 棵子树（除非树为空）。<br><strong>B 树的操作</strong></li></ul></li><li><p><strong>插入</strong>：</p><ul><li>若结点关键字数超过上限( m-1 ），需<strong>分裂</strong>：<ul><li>将中间关键字提升到父结点，左右部分形成新结点。</li><li>若父结点也溢出，递归分裂直到根结点。</li></ul></li></ul></li><li><p><strong>删除</strong>：</p><ul><li><strong>非叶子结点删除</strong>：用前驱或后继关键字替代。</li><li><strong>叶子结点删除</strong>：<ul><li>若删除后关键字数 ≥<code>[m/2]</code>-1，直接删除。</li><li>否则需向兄弟结点借关键字或合并结点。</li></ul></li></ul></li></ol><h3 id="B-树与-B-树的区别"><strong>B+ 树与 B 树的区别</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>B 树</strong></th><th><strong>B+ 树</strong></th></tr></thead><tbody><tr><td><strong>关键字存储</strong></td><td>所有结点均存储数据</td><td>仅叶子结点存储数据，非叶结点为索引</td></tr><tr><td><strong>叶子结点链接</strong></td><td>无</td><td>叶子结点通过指针链接，支持顺序遍历</td></tr><tr><td><strong>查询效率</strong></td><td>随机查询效率高</td><td>范围查询和顺序遍历效率高</td></tr><tr><td><strong>结构复杂度</strong></td><td>结点结构简单</td><td>非叶结点仅存索引，结构更紧凑</td></tr></tbody></table><ul><li><strong>AVL 树</strong>：通过平衡因子和旋转操作维持平衡，适用于频繁查找的场景。</li><li><strong>B 树</strong>：多路平衡查找树，减少磁盘 I/O 次数，适合文件系统和数据库索引。</li><li><strong>B+ 树</strong>：在 B 树基础上优化范围查询，广泛应用于数据库和操作系统中。</li></ul><h2 id="二叉树的存储结构">二叉树的存储结构</h2><h2 id="顺序存储">顺序存储</h2><ol><li><strong>适用场景</strong>：完全二叉树。</li><li><strong>原理</strong>：<ul><li>通过数组下标直接计算父子关系（如父结点 <code>i</code> 的左孩子为 <code>2i</code>，右孩子为 <code>2i+1</code>）。</li><li>若树非完全二叉树，需填充空结点以保证结构，导致内存浪费。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：快速定位父子结点，无需额外指针。</li><li><strong>缺点</strong>：<ul><li>单支树（深度为 <code>k</code>）需数组长度为 <code>2^k - 1</code>（指数级内存消耗）。</li><li>非完全二叉树存在大量空位。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="type">bool</span> isEmpty;</span><br><span class="line">&#125; t[MAXSIZE];</span><br></pre></td></tr></table></figure></li></ol><h2 id="链式存储">链式存储</h2><p><strong>空链域数量</strong>：</p><ul><li>在含 <code>n</code> 个结点的二叉链表中，共有 <code>n+1</code> 个空链域。</li><li><strong>推导</strong>：<ul><li>每个结点有 2 个指针（左、右），总指针数为 <code>2n</code>。</li><li>树的边数为 <code>n-1</code>（树的性质），即使用的指针数为 <code>n-1</code>。</li><li>空链域数 = 总指针数 - 使用指针数 = <code>2n - (n-1) = n+1</code>。</li></ul></li><li><strong>用途</strong>：空链域可用于构造线索二叉树（标记前驱/后继）。</li></ul><ol><li><strong>二叉链表</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：无法直接找到父结点，需从根遍历。</li><li><strong>空链域</strong>：<code>n+1</code> 个（同前文推导）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20132.png" alt="Untitled 1 132|Untitled 1 132.png|300"><br><strong>三叉链表</strong>：<br>空链域：n+2个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild, *parent;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：增加父结点指针，方便反向查找  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309152923.png" alt="Pasted image 20250309152923|400"></li></ul></li></ol><h2 id="二叉树的遍历">二叉树的遍历</h2><ol><li><p><strong>遍历顺序</strong>：</p><ul><li><strong>先序遍历</strong>：根 → 左 → 右</li><li><strong>中序遍历</strong>：左 → 根 → 右</li><li><strong>后序遍历</strong>：左 → 右 → 根</li><li><strong>层序遍历</strong>：自上而下、从左到右逐层遍历。</li></ul></li><li><p><strong>递归实现与栈的关系</strong>：</p><ul><li>递归遍历的本质是隐式使用系统调用栈，空间复杂度为树高  O(h) 。</li><li><strong>前序序列与中序序列的关系</strong>：<ul><li>前序序列相当于<strong>入栈顺序</strong>，中序序列相当于<strong>出栈顺序</strong>。</li><li>例如：前序 <code>[A,B,C]</code> 和中序 <code>[B,A,C]</code>，可唯一确定一棵二叉树。</li></ul></li></ul></li><li><p><strong>层序遍历实现</strong>：</p><ul><li><mark>**队列</mark>辅助**：<ol><li>根结点入队。</li><li>循环：出队结点访问，并将其左右孩子入队。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        BiTNode* p;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>特点</strong>：按层输出，适合求树的最小宽度或层次相关操作。</li></ul></li></ol><p><strong>遍历序列的唯一性</strong></p><ol><li><strong>单一遍历序列无法唯一确定二叉树</strong>：<ul><li>例如：前序 <code>[A,B]</code> 可对应两种结构（B为左孩子或右孩子）。</li></ul></li><li><strong>唯一确定条件</strong>：<ul><li><strong>中序 + 前序/后序/层序</strong>：可唯一还原二叉树。</li><li><strong>前序 + 后序</strong>：仅当树是满二叉树时可唯一确定。<br>若只给出一棵二叉树的前/中/后/层 序遍历的一种，不能唯一确定一棵二叉树。<br>一定是由中+前/后/序<br>若有一个<mark>叶结点</mark>是二叉树中某个子树的<mark>中序</mark>遍历结果序列的最后一个结点，则它一定是该子树的<mark>前序</mark>遍历结果序列的最后一个结点<br><strong>前、中、后遍历序列中<mark>叶子结点</mark>的相对位置是不变的</strong><br>若一棵二叉树的中序序列和后序序列相同，则二叉树为空树或二叉树任一结点没有右子树；反之，前序和中序相同，左<br>若先序和后序相反，则高度=结点数<br>已知先/后序与中序：<br>x轴是中序，y轴是 先序 或 倒的后序<br>找最高点M，在M左侧找最高点L，右侧最高点R，连接，递归<br>如果先序遍历序列和层序遍历序列相同，则这个二叉树是一个单支树</li></ul></li></ol><h2 id="线索二叉树">线索二叉树</h2><p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。</strong><br><strong>由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在</strong><mark><strong>遍历</strong></mark><strong>的过程中修改空指针的过程。</strong><br>若无左子树，令lchild指向其前驱结点；<br>若无右子树，令rchild指向其后继结点。<br>左前驱，右后继<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/v2-014d37e12cb6f8fa81143a1ae372f854_b.png" alt="v2-014d37e12cb6f8fa81143a1ae372f854_b|400"><br>还需要增加两个标志语表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。<br>l</p><ol><li>ltag== 0，指向左孩子；ltag== 1，指向前驱结点【指线索/指针/地址】</li><li>rtag== 0，指向右孩子；rtag== 1，指向后继结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag; <span class="comment">// 0:孩子指针；1:线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><ul><li><code>ltag=1</code>：左指针指向前驱；<code>rtag=1</code>：右指针指向后继。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/10ae36162db147adb9e3662d9072f8dd.png" alt="10ae36162db147adb9e3662d9072f8dd"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310102313.png" alt="Pasted image 20250310102313|400"></li></ul></li></ol><p>有了这些前驱后继信息的好处是：在查找某个结点时就可以类似链表那样很方便的从表头遍历到表尾，并且空间复杂度只有 O ( 1 ) 。而前面二叉树的遍历中，无论递归还是非递归，都要用到栈，空间复杂度跟二叉树的具体形态有关。<br>二叉树在线索化后，仍不能有效求解的问题是<mark>后序线索二叉树中求后序后继</mark></p><ul><li><strong>逻辑结构</strong>：描述数据元素之间的抽象关系，如二叉树、链表、图等。<ul><li><strong>二叉树</strong>：一种分层结构，每个结点最多有两个子结点，用于表达数据间的层次关系，属于逻辑结构。</li></ul></li><li><strong>物理结构</strong>：描述数据在计算机内存中的具体存储方式，如顺序存储（数组）、链式存储（指针）等。<ul><li><strong>线索二叉树</strong>：在链式存储的基础上，通过修改空指针为线索（前驱/后继），优化遍历效率，属于物理结构。</li></ul></li></ul><p><strong>后序线索二叉树无法有效求解后序后继的原因</strong><br>后序遍历的顺序为 <strong>左→右→根</strong>，根结点最后被访问。后序线索化的局限性体现在以下场景：<br><strong>场景 1：分支结点的左右子树均为叶结点</strong><br>假设结点 <code>A</code> 是父结点 <code>P</code> 的左孩子，且 <code>A</code> 的左右子树均为叶结点：</p><ul><li><p><strong>后序遍历顺序</strong>：左叶 → 右叶 → <code>A</code> → <code>P</code> 的右子树 → <code>P</code> → …</p></li><li><p><strong>问题</strong>：<code>A</code> 的后继应为 <code>P</code> 的右子树的最左下叶结点，但 <code>A</code> 的右指针可能直接指向 <code>P</code>（作为线索），无法跳转到 <code>P</code> 的右子树，导致无法直接找到正确后继。<br><strong>场景 2：根结点的右子树非空</strong></p></li><li><p><strong>后序遍历顺序</strong>：左子树 → 右子树 → 根结点。</p></li><li><p><strong>问题</strong>：根结点的右指针指向实际右子结点，而非线索化的后继（因为根结点是最后一个被访问的结点，没有后继）。</p></li><li><p><strong>示例</strong>：根结点 <code>R</code> 有右子树，遍历到 <code>R</code> 时，其右指针指向右子结点，而非空，无法通过线索直接确定后继。<br><strong>关键限制</strong></p></li><li><p><strong>无法回溯父结点</strong>：后序线索仅记录直接前驱/后继，但某些后继需要通过父结点的右子树路径确定。</p></li><li><p><strong>依赖栈或父指针</strong>：在非线索化遍历中，栈用于记录路径以回溯父结点；而线索化无法提供此信息，导致必须额外维护栈。</p></li><li><p>先序线索二叉树 ABDGECF<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%206%2080.png" alt="Untitled 6 80|Untitled 6 80.png|400"><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%207%2076.png" alt="Untitled 7 76|Untitled 7 76.png|400"></p></li><li><p>中序线索二叉树<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%208%2071.png" alt="Untitled 8 71|Untitled 8 71.png|400"></p></li></ul><ol><li><strong>中序线索树</strong>：<ul><li>某结点有右孩子 → 其后继为右子树的最左下结点。</li><li>某结点有左孩子 → 其前驱为左子树的最右下结点。<br>注意：</li></ul></li><li><strong>限制</strong>：<ul><li><strong>后序线索二叉树</strong>：无法高效求解后序后继（需栈支持）。</li><li><strong>前序/中序线索树</strong>：可无栈遍历，时间复杂度 O(n)，空间复杂度O(1)</li></ul></li><li><strong>线索化目的</strong>：<ul><li>利用空链域（<code>n+1</code>个）记录前驱/后继，加速遍历。</li><li><strong>实质</strong>：遍历时修改空指针为线索。</li></ul></li></ol><p><strong>应用场景</strong></p><ol><li><p><strong>求树深度</strong>：</p><ul><li>递归遍历左右子树深度，取最大值加1。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">Depth</span>(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线索化优势</strong>：</p><ul><li>遍历无需栈，空间复杂度优化为  O(1) 。</li><li>适用于频繁遍历但插入/删除较少的场景。</li></ul></li><li><p><strong>设计选择</strong>：</p><ul><li>频繁查找前驱/后继 → 线索二叉树。</li><li>频繁插入/删除 → 普通链式存储。</li></ul></li></ol><ul><li>线索化本质是空间换时间，适用于遍历密集型操作。</li></ul><h2 id="树的存储结构">树的存储结构</h2><ol><li><strong>双亲表示法</strong>：<ul><li><strong>原理</strong>：每个结点存储数据及其父结点索引（根结点的父结点索引为空）。</li><li><strong>优点</strong>：<ul><li>快速查找父结点（时间复杂度  O(1) ）。</li><li>存储结构简单，仅需一个数组即可表示整棵树。</li></ul></li><li><strong>缺点</strong>：<ul><li>查找子结点需遍历整个表（时间复杂度  O(n) ）。</li><li>插入或删除结点时需维护索引一致性，复杂度较高。</li></ul></li><li><strong>适用场景</strong>：频繁查找父结点且子结点操作较少的场景，如家谱关系管理。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310130809.png" alt="Pasted image 20250310130809|500"></li></ul></li><li><strong>孩子表示法</strong>：<ul><li><strong>原理</strong>：每个结点存储数据及子结点链表的头指针。</li><li><strong>优点</strong>：<ul><li>快速查找子结点（直接通过链表访问，时间复杂度  O(k) ， k  为子结点数）。</li><li>适合动态增删子结点的场景。</li></ul></li><li><strong>缺点</strong>：<ul><li>查找父结点需从根结点遍历，效率低（时间复杂度  O(n) ）。</li><li>存储空间较大（每个结点需额外维护链表指针）。</li></ul></li><li><strong>适用场景</strong>：需要频繁操作子结点（如文件系统目录树）。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310131023.png" alt="Pasted image 20250310131023"></li></ul></li><li><strong>二叉树表示法（孩子兄弟表示法）</strong>：<ul><li><strong>原理</strong>：将普通树转换为二叉树，规则如下：<ul><li><strong>左指针</strong>指向第一个孩子结点（最左子结点）。</li><li><strong>右指针</strong>指向当前结点的下一个兄弟结点。</li></ul></li><li><strong>特点</strong>：<ul><li>一个普通树转化成的二叉树一定没有右子树。</li><li><strong>森林转换</strong>：先把森林转化为二叉树，再存储二叉树（如森林 {T1, T2}转换为 T1-&gt;T2）。</li></ul></li><li><strong>优点</strong>：<ul><li>统一使用二叉树结构，可复用二叉树的遍历、插入、删除等算法。</li><li>节省存储空间（仅需两个指针）。</li></ul></li><li><strong>缺点</strong>：<ul><li>逻辑结构需通过指针关系间接理解，初次接触可能较难适应。</li><li>遍历时需区分“孩子”与“兄弟”指针，逻辑稍复杂。</li></ul></li><li><strong>适用场景</strong>：需要利用二叉树算法处理一般树或森林的场景（如编译器语法树）。<br>双亲表示法是顺序存储结构，孩子表示法和孩子兄弟表示法是链式存储结构</li></ul></li></ol><ul><li><p><strong>存储效率</strong>：</p><ul><li>双亲表示法最节省空间，但功能单一；</li><li>孩子兄弟表示法在空间和功能间取得平衡，适合通用场景。</li></ul></li><li><p><strong>操作效率</strong>：</p><ul><li>若需频繁查找父结点，双亲表示法最优；</li><li>若需频繁操作子结点，孩子表示法或双亲孩子表示法更优。</li></ul></li><li><p>**转换：</p><ul><li><strong>树 → 二叉树</strong>：  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310160725.png" alt="Pasted image 20250310160725|300"></li><li><strong>森林 &lt;-&gt; 二叉树</strong>：  <img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310161030.png" alt="Pasted image 20250310161030|400"><br>森林-&gt;二叉树，右子树非空（因为各树根节点通过右指针链接）<br>二叉树-&gt;森林，若根节点有右子树，则右子树拆分成独立的树<br><strong>森林与二叉树的转换</strong>是唯一的，且右指针为空的数量与非终端结点数相关<br>森林树的数量=森林结点数-边数<br><strong>森林的非终端结点数 n → 二叉树右指针为空的结点数 n+1</strong>：<br>非终端节点指有子结点的节点（包括跟根节点）<br>每个非终端结点对应一个右指针，最后一个兄弟右指针为空。<br><strong>森林的叶结点数 = 二叉树左指针为空的结点数</strong><br>原森林的叶结点在二叉树中无左孩子<br>高度为h的满二叉树对应森林所含树的个数为h</li></ul></li><li><p><strong>树转二叉树</strong>：无右子树。</p></li><li><p><strong>森林转二叉树</strong>：右子树存在（各树根通过右指针链接）。</p></li></ul><h2 id="树的遍历方式">树的遍历方式</h2><h2 id="树的先根遍历（深度优先遍历）">树的先根遍历（深度优先遍历）</h2><p>先访问树的根节点，然后依次先根遍历根的每棵子树。这种遍历方式和二叉树的先序遍历（先访问根节点，再访问左子树，最后访问右子树）类似。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%20234.png" alt="Untitled 234|Untitled 234.png"></p><h2 id="树的后根遍历（深度优先遍历）">树的后根遍历（深度优先遍历）</h2><p>先依次后根遍历根的每棵子树，然后再访问根节点。这种遍历方式类似于二叉树的中序遍历（先访问左子树，再访问根节点，最后访问右子树） 。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%201%20135.png" alt="Untitled 1 135|Untitled 1 135.png"></p><h2 id="树的层次遍历（广度优先遍历）">树的层次遍历（广度优先遍历）</h2><p>按照层次，从根节点开始，一层一层地访问节点，同一层的节点按照从左到右的顺序进行访问。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%202%20119.png" alt="Untitled 2 119|Untitled 2 119.png"></p><h2 id="森林的遍历方式">森林的遍历方式</h2><p>森林是由 m（m≥0）棵互不相交的树组成的集合。</p><h2 id="森林的先序遍历">森林的先序遍历</h2><p>依次对森林中的各个树进行先根遍历，这等同于依次对与森林对应的二叉树进行先序遍历。具体过程是：先访问森林中第一棵树的根节点，然后先序遍历第一棵树的子树森林，接着先序遍历除去第一棵树之后剩余的树组成的森林。</p><h2 id="森林的中序遍历">森林的中序遍历</h2><p>依次对森林中的各个树进行后根遍历，也就相当于依次对与森林对应的二叉树进行中序遍历。具体过程为：先中序遍历森林中第一棵树的子树森林，然后访问第一棵树的根节点，接着中序遍历除去第一棵树之后剩余的树组成的森林。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310163959.png" alt="Pasted image 20250310163959"><br>关键结论 ：</p><ul><li><strong>顺序存储</strong>适合完全二叉树，否则内存浪费严重。</li><li><strong>线索二叉树</strong>通过利用空链域优化遍历，但后序线索化无法完全消除栈依赖。</li><li><strong>普通树转二叉树</strong>后右子树为空（根无兄弟），森林转换则通过右指针链接各树根。</li><li><strong>三叉链表</strong>以空间换时间，支持父结点快速访问。</li></ul><h2 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h2><p>是对数据压缩和编码长度的优化</p><ol><li><strong>带权路径长度（WPL）</strong><ul><li><strong>定义</strong>：树中所有叶结点的带权路径长度之和。</li><li><strong>公式</strong>：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310172719.png" alt="Pasted image 20250310172719|400"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173324.png" alt="Pasted image 20250310173324|450"><br>加权平均长度=带权路径长度/所有结点频次之和_</li></ul></li><li><strong>哈夫曼树（最优二叉树）</strong><ul><li><strong>目标</strong>：构造 WPL 最小的二叉树。</li><li><strong>特点</strong>：<ul><li>权值越小的叶结点离根越远，路径长度越大。</li><li>构造过程中新建  n-1  个内部结点，总结点数为  2n-1 。</li><li>不存在度为 1 的结点（n0=n2+1，已知n0叶结点可求n2双分支节点）</li><li>n个初始节点构造哈夫曼树共新建n-1个双分支结点，因此哈夫曼树的节点总数是2n-1，是奇数</li><li>权值最小的两个结点互为兄弟。</li><li>用一组权值构造出的哈夫曼树可能不唯一（左右子树不同），但带权路径长度唯一<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173511.png" alt="Pasted image 20250310173511|500"></li></ul></li></ul></li><li><strong>前缀编码</strong><ul><li><strong>定义</strong>：没有一个编码是另一个编码的前缀，保证解码唯一性【检查所有编码是否互不为前缀】</li><li><strong>实现方式</strong>：通过哈夫曼树生成可变长度编码，左分支标记为 <code>0</code>，右分支标记为 <code>1</code>。</li></ul></li></ol><h2 id="哈夫曼树构造步骤">哈夫曼树构造步骤</h2><ol><li><strong>初始化</strong>：将  n  个权值作为独立的单结点树。</li><li><strong>合并子树</strong>：<ul><li>每次选择权值最小的两棵树合并，生成新结点作为其父结点，权值为子树权值之和。</li><li>重复此过程直至只剩一棵树。</li></ul></li><li><strong>贪心算法依据</strong>：局部最优选择（合并最小权值树）保证全局最优（WPL 最小）。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310173701.png" alt="Pasted image 20250310173701|500"></li></ol><h2 id="应用场景与优势">应用场景与优势</h2><ol><li><p><strong>数据压缩</strong>：</p><ul><li>对高频字符分配短编码，低频字符分配长编码，显著减少总编码长度。</li></ul></li><li><p><strong>文件传输</strong>：</p><ul><li>结合前缀编码，实现高效无损压缩（如 ZIP、JPEG 中的哈夫曼编码）。</li></ul></li><li><p><strong>唯一性与最优性</strong>：</p><ul><li>哈夫曼树不唯一（左右分支标记可互换），但所有哈夫曼树的 WPL 相同且最小。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li>构造哈夫曼树： O(n \log n) （使用优先队列优化选择最小权值）。</li><li>生成编码： O(n) 。</li></ul></li></ol><h2 id="并查集">并查集</h2><p><strong>并查集</strong>是一种用于管理<strong>不相交集合</strong>的数据结构，支持以下两种核心操作：</p><ol><li><strong>查询（Find）</strong>：确定元素属于哪个集合（通常通过根节点标识）<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311104951.png" alt="Pasted image 20250311104951|400"></li><li><strong>合并（Union）</strong>：将两个集合合并为一个集合。<br>并查集的结构是一种<mark>双亲表示法</mark>存储的树</li></ol><p><strong>应用场景</strong>：</p><ul><li>判断图的连通分支数（如判断森林中有几棵树）。</li><li>动态连通性问题（如网络节点是否可达）。</li><li>Kruskal 算法中判断边是否会形成环。</li></ul><p><strong>核心构成</strong></p><ol><li><strong>数组 <code>parent[]</code></strong>：<ul><li>记录每个节点的父节点。</li><li>根节点的父节点指向自身（即 <code>parent[root] = root</code>）。</li></ul></li><li><strong>函数 <code>find(x)</code></strong>：<ul><li>查找节点 <code>x</code> 所属集合的根节点。</li></ul></li><li><strong>函数 <code>union(x, y)</code></strong>：<ul><li>合并 <code>x</code> 和 <code>y</code> 所属的集合。</li></ul></li></ol><p><strong>基本实现与时间复杂度</strong></p><ol><li><p><strong>未优化版本</strong>：</p><ul><li><strong><code>find(x)</code></strong>：逐层向上查找根节点，最坏时间复杂度为  O(n) 。</li><li><strong><code>union(x, y)</code></strong>：需要先调用 <code>find(x)</code> 和 <code>find(y)</code>，时间复杂度  O(n) 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化：每个节点的父节点指向自己</span></span><br><span class="line">parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">while</span> parent[x] != x:</span><br><span class="line">        x = parent[x]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">    root_x = find(x)</span><br><span class="line">    root_y = find(y)</span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        parent[root_y] = root_x</span><br></pre></td></tr></table></figure></li><li><p><strong>优化目标</strong>：</p><ul><li>通过<strong>路径压缩</strong>和<strong>按秩合并</strong>，将操作的时间复杂度优化至  O(\alpha(n)) ，其中α(n) 是阿克曼函数的反函数（实际应用中接近常数）。</li></ul></li></ol><p><strong>优化方法</strong></p><ol><li><strong>按秩合并（Union by Rank）</strong>：<ul><li><strong>原理</strong>：将小树合并到大树中，避免树高度过高。</li><li><strong>实现</strong>：<ul><li>用 <code>rank[]</code> 数组记录每个根节点的树高（或节点数）。</li><li>合并时，将小树的根节点指向大树的根节点。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rank = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">    root_x = find(x)</span><br><span class="line">    root_y = find(y)</span><br><span class="line">    <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 小树合并到大树</span></span><br><span class="line">    <span class="keyword">if</span> rank[root_x] &gt; rank[root_y]:</span><br><span class="line">        parent[root_y] = root_x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[root_x] = root_y</span><br><span class="line">        <span class="keyword">if</span> rank[root_x] == rank[root_y]:</span><br><span class="line">            rank[root_y] += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><strong>路径压缩（Path Compression）</strong>：<ul><li><strong>原理</strong>：在 <code>find(x)</code> 过程中，将路径上的所有节点直接指向根节点，缩短后续查找路径。</li><li><strong>实现</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">        parent[x] = find(parent[x])  <span class="comment"># 递归压缩路径</span></span><br><span class="line">    <span class="keyword">return</span> parent[x]</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>操作</th><th>未优化</th><th>按秩合并</th><th>按秩合并 + 路径压缩</th></tr></thead><tbody><tr><td><code>find(x)</code></td><td>O(n)</td><td>O(log n)</td><td>O(α(n)）</td></tr><tr><td><code>union(x, y)</code></td><td>O(n)</td><td>O(log n)</td><td>O(α(n)）</td></tr></tbody></table><ul><li>**阿克曼函数 α(n) ：增长极慢，对任何实际输入的n（如n &lt;= 10^80），α(n) &lt;= 5。</li></ul><p><strong>应用示例</strong></p><ol><li><p><strong>连通分支数统计</strong>：</p><ul><li>初始化每个节点为独立集合。</li><li>遍历所有边，执行 <code>union(u, v)</code>。</li><li>最终统计根节点数量即为连通分支数。</li></ul></li><li><p><strong>Kruskal 算法</strong>：</p><ul><li>按边权重排序后，依次选择边并检查是否连通（<code>find(u) == find(v)</code>）。</li><li>若未连通，执行 <code>union(u, v)</code> 并加入生成树。</li></ul></li></ol><p><strong>常见问题</strong></p><ol><li><p><strong>如何判断编码是否合法？</strong></p><ul><li><strong>前缀编码冲突</strong>：若某编码是另一编码的前缀，则无法唯一解码。</li><li><strong>哈夫曼编码性质</strong>：通过构造哈夫曼树生成的编码天然为前缀编码，保证唯一性。</li></ul></li><li><p><strong>为什么并查集适合动态连通性问题？</strong></p><ul><li>并查集支持高效的动态合并与查询操作，时间复杂度接近常数，适合处理大规模数据。</li></ul></li></ol><ul><li><strong>并查集的核心优化</strong>：路径压缩 + 按秩合并，时间复杂度接近  O(1) 。</li><li><strong>应用场景</strong>：连通性问题、图论算法、动态等价类划分。</li></ul><p>并查集：路径压缩 + 按秩合并 → 时间复杂度O(α(n))<br>应用：连通分支数统计、Kruskal 算法、动态连通性检测。</p><h2 id="错题-6">错题</h2><ol><li><strong>完全二叉树结点数计算</strong><ul><li>例：第 6 层有 8 个叶子结点，总结点数最多为 111，最少为 39。</li><li><strong>最多</strong>：第6层有8个叶结点，说明第7层不存在。前5层满（25−1=31），第6层最多有2^5=32个节点，其中8个为叶结点，非叶节点为24个。总节点数：31+24×2+8=111。</li><li><strong>最少</strong>：第6层的8个叶结点集中在左侧，第6层有8个节点（均为叶结点）。总节点数：前5层满（31） + 第6层8个 = 39。</li></ul></li><li><strong>完全二叉树叶结点数</strong><ul><li>例：768 个结点的完全二叉树，叶结点数为 <code>384</code>（<code>n0 = ⌈768/2⌉</code>）。</li></ul></li><li><strong>B 树关键字数范围</strong>：<ul><li>对于 5 阶 B 树（ m=5 ）：<ul><li>非根结点关键字数： 2 \leq \text{关键字数} \leq 4 。</li><li>根结点关键字数： 1 \leq \text{关键字数} \leq 4 。</li></ul></li></ul></li><li><strong>B 树高度与结点数关系</strong>：<ul><li>含  n  个关键字的  m  阶 B 树，最小高度  h  满足：<br>n &lt;= (m-1)(1 + m + m^2 + … + m^(h-1)) = m^h - 1</li><li>最大高度  h  满足：<br>n &gt;= 2(<code>[m/2]</code>^(h-1) - 1)</li></ul></li><li>设有一棵度为3的树，其中度为3的结点数n3=2，度为2的结点数n2=1，叶结点数n0=6，则该树的结点总数为() A. 12  B.9 C.10 D.&gt;=9 的任意整数<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311124831.png" alt="Pasted image 20250311124831"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134338.png" alt="Pasted image 20250309134338"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134401.png" alt="Pasted image 20250309134401"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134836.png" alt="Pasted image 20250309134836">若森林F有 15 条边、25 个结点，则下包含树的个数是( )。8/9/10/11<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309134844.png" alt="Pasted image 20250309134844"></li><li>二叉树为空意味着二叉树（）<br>A.根结点没有子树 B.不存在 C.没有结点 D.由一些没有赋值的空结点构成<br>二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图(图中不能没有结点)</li><li>设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为( )。 A. h B. 2h-1 C. 2h+1 D. h+1<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309142623.png" alt="Pasted image 20250309142623"></li><li>具有n个结点且高度为n的二叉树的数目为()。A. log2n B. n/2 C. n D. 2^n-1<br>d</li><li>设二叉树有 2n个结点，且m&lt;n，则不可能存在()的结点<br>A. n 个度为 0  B. 2m 个度为 0  C.2m 个度为1  D.2m 个度为2<br>叶子结点数 n0=n2+1，总结点数：n0+n1+n2=2n。带入A对；B是n0=2m，得4m-1+n1=2n，当m=1,n=2,n1=1符合；C是n1=2m，得n2=(2n-2m-1)/2，矛盾不存在；D是n2=2m，得4m+1+n1=2n，当m=1,n=3，符合</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309150857.png" alt="Pasted image 20250309150857">若一棵二叉树有 126 个结点，在第7层(根结点在第1层)至多有( )个结点。<br>A. 32 B.64 C.63 D.不存在第7层<br>要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有 127 个结点，126 仅比 127 少1个结点，只能少在第7层，所以第7层最多有 2^6-1=63 个结点。</li><li>一棵有 124 个叶结点的完全二叉树，最多有()个结点。<br>A. 247 B. 248 C.249 D.250<br>124&lt;2^7=128，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120 个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1 个左孩子(不改变叶结点数)，因此结点总数=2^7-1+120+1=248。<br>也可以用总结点数为偶数2k，n1=1, n0=k, n2​=k−1，k=124，求出</li><li>某完全二叉树T中，结点个数最大的层有8个结点，则T中至多有()个结点。<br>A. 8  B.15  C.23  D. 31<br>在完全二叉树中，第4层刚好最多有8个结点(前4层对应高度为4的满二叉树)，若第5层也有8个结点，则对应于结点个数最多的情况，此时树高为5，总结点数为15+8=23。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153206.png" alt="Pasted image 20250309153206">I正确；II若该结点非根结点，其双亲指针还会指向父结点，共 三个指针。但根结点度为 2 时，无双亲指针，仅被两个孩子指向，只有两个指针；IIIn=1（无双亲根节点） 时，唯一结点是叶结点且无指针指向</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153328.png" alt="Pasted image 20250309153328"><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309153335.png" alt="Pasted image 20250309153335"></li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309154115.png" alt="Pasted image 20250309154115"><strong>奇数节点数 2k−1</strong>：n1​=0,n0​=k, n2​=k−1</li><li>对于任意一棵高度为5且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元(仅存放结点的数据信息)，则存放该二叉树需要的存储单元数量至少是()。A.31 B. 16 C.15 D.10<br>即使实际只有10个结点，存储时仍需覆盖所有可能的位置，以确保父结点与子结点的位置关系可通过下标直接计算。因此，存储单元数量至少为2^5-1=31</li><li>设n,m 为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D.n是m子孙<br>c</li><li>设n,m 为一棵二叉树上的两个结点，在后序遍历时，n在m前的充分条件是( )。A.n在m右方 B. n是m 祖先 C.n在m左方 D. n是m 子孙<br>d</li><li>对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用( )次序的遍历实现编号 A.先序 B.中序 C.后序 D.层次<br>c</li><li>一棵二叉树的先序遍历序列为 1234567，它的中序遍历序列可能是()。<br>A. 3124567 B. 1234567 C.4135627 D.1463572<br>b</li><li>某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用()遍历方法最合适。A. 中序 B.层次 C.后序 D.先序<br>删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。</li><li>某二叉树T采用二叉链表存储结构，T的中序遍历序列为一个升序序列，要求采用某种方法对 T进行某种操作之后得到一棵新的二叉树T,要求 T&quot;的中序遍历序列为一个降序序列，则下列关于该算法的叙述中，正确的是()<br>A. 采用中序遍历的方法最合适 B. 采用后序遍历的方法最合透<br>C.T中的根结点还是原T中的根结点 D. T中的叶结点不一定是原T中的叶结点<br>选项 B（采用后序遍历的方法最合适）<ul><li>后序遍历（左→右→根）允许先递归处理左右子树，再交换当前结点的左右子树。这种顺序确保子树已完全处理后再调整父结点的结构，避免逻辑混乱。通过后序遍历交换所有分支结点的左右子树，最终中序遍历序列自然逆序为降序。因此，后序遍历是最合适的方法。<br>选项 C（T’中的根结点还是原T中的根结点）</li><li>镜像翻转操作仅交换分支结点的左右子树，不会改变根结点的位置或值。因此，根结点保持不变，选项 C 正确。<br>选项 D（T’中的叶结点不一定是原T中的叶结点）</li><li>叶结点没有左右子树，交换操作对其无影响，原叶结点在 T’ 中仍为叶结点（仅位置可能变化）。因此，选项 D 错误</li></ul></li><li>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是()。<br>A. 不确定  B.0个  C.1个 D.2 个<br>根结点的左指针：1 个空链域，最右侧叶结点的右指针：1 个空链域，所以线索化后，树中空链域有2个。</li><li>某二叉树的先序序列和后序序列正好相反，则该二叉树一定是()。<br>A.空或只有一个结点           B.高度等于其结点数<br>C.任意一个结点无左孩子   D.任意一个结点无右孩子<br>最多只有一个子结点，即树退化为单链结构（如所有结点只有右孩子或只有左孩子）此时，树的高度等于结点数 h=n，b。C或D属于选项 B 的子集</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310122100.png" alt="Pasted image 20250310122100">d</li><li>若一棵二叉树的前序遍历序列为 a,e,b,d,c，后序遍历序列为 b,c,d,e,a，则根结点的孩子结点()。A.只有e  B.有e、b  C.有e、c  D.无法确定<br>根 <code>a</code> 的唯一孩子是左孩子 <code>e</code></li><li>先序序列为 a,b,c,d的不同二叉树的个数是( )。13/14/15/16<br>(C4 8)/ 5 = 14</li><li>利用二叉链表存储森林时，根结点的右指针是()。<br>A. 指向最左兄弟 B.指向最右兄弟 C.一定为空 D.不一定为空<br>森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。</li><li>设森林F中有3棵树，第 1、2、3 棵树的结点个数分别为 M1,M2和M3，与森林F对应的二叉树根结点的右子树上的结点个数是()<br>A. M1 B.M1+M2 C.M3 D.M2+M3<br>d</li><li>设森林 F中有 4棵树，第 1、2、3、4 棵树的结点数分别为 a、b、c和 d，与森林F对应的二叉树的根结点的左子树上的结点数是()<br>A. a  B. b+c+d  C.a-1  D. a+b+c<br>c</li><li>设森林F对应的二叉树是一棵具有 16 个结点的完全二叉树，则森林F中树的数目和结点最多的树的结点数分别是() A. 2和8  B.2和9  C.4和8  D. 4和9<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310165243.png" alt="Pasted image 20250310165243|250"></li><li>设X是树T中的一个非根结点，B是T所对应的二叉树。在B中，X是其双亲结点的右孩子，下列结论中正确的是()。<br>A.在树T中，X是其双亲结点的第一个孩子<br>B.在树T中，X一定无右边兄弟<br>C.在树T中，X一定是叶结点<br>D.在树T中，X一定有左边兄弟在二叉树<br>B中，X是其双亲的右孩子，因此在树T中，X必是其双亲结点的右兄弟，换句话说，X在树中必有左兄弟。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310170049.png" alt="Pasted image 20250310170049">A. 双亲表示法中，每个非根结点有一个指向双亲的指针。若树有 n个结点，则双亲指针数为 n−1，正确；B对；C. O(n)；D对</li><li>已知一棵有 2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点个数是()。 A. 115  B. 116  C. 1895 D.1896</li><li>下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是<br>A. 24,10,5 和 24,10,7      B. 24,10,5 和 24,12,7<br>C. 24,10,10 和 24,14,11  D. 24,10,5 和 24,14,6</li><li>根据使用频率为5个字符设计的哈夫曼编码不可能是()<br>A. 000,001,010,011,1   B.0000,0001,001,01,1<br>C. 000,001,01,10,11     D. 00,100,101,110,111<br>D构造出来有度为1的结点，不对</li><li>设哈夫曼编码的长度不超过 4，若已对两个字符编码为1和 01，则还最多可对( )个字符编码。<br>根据前缀编码规则，得到新编码必须以00开头，且总长度&lt;=4，0000，0001，0010，0011，共四个</li><li>一棵哈夫曼树共有 215 个结点，对其进行哈夫曼编码，共能得到( )个不同的码字。A. 107   B. 108  C.214   D. 215<br>树有 <code>n</code> 个叶子结点，则总结点数为 <code>2n - 1</code>，得到n=108</li><li>并查集中最核心的两个操作是:查找，查找两个元素是否属于同一个集合;合并，若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为 10(0~9)的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9 的顺序进行查找和合并操作，最终并查集共有( )个集合。A. 1 B.2 C.3D.4<br>初始时，0~9各自成一个集合。查找 1-2 时，合并{1}和{2};查找 3-4 时，合并{3}和{4};查找 5-6 时，合并(5}和(6};査找 7-8时，合并{7}和{8}:查找 8-9 时，合并{7,8,和{9};查找1-8 时，合并(1,2和{7,8,9}:查找 0-5 时，合并(0}和{5,6}:查找 1-9 时，它们属于同一个集合。最终的集合为10,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项 C。</li><li>下列关于大根堆(至少含2个元素)的叙述中正确的是<br>I. 可以将堆看成一棵完全二叉树      II. 可采用顺序存储方式保存堆<br>III. 可以将堆看成一棵二叉排序树    IV. 堆中的次大值一定在根的下一层<br>A. 仅1、II      B. 仅1、III       C. 仅I、II、IV        D. 仅I、II、IV<br>c</li><li>已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二又树中无右孩子的结点的个数是() A. 115    B. 116    C. 1895    D. 1896<br>非叶子结点=1895，数转换成的二叉树没有右孩子，原树中每个非叶结点对应一个无右孩子的结点，无右孩子结点数为1895，根节点也无右孩子+1，1896</li><li>有n(n&gt;0)个分支结点的满二叉树的深度是<br>A. n^2-1    B. log2(n+1)+1    C. log2(n+1)     D. log2(n-1)<br>满二叉树的结点总数 N 与深度 h的关系为:N=2^h -1<br>分支结点数 n 与叶子结点数L的关系为:n=L-1<br>对于满二叉树，叶子结点数  L=2^(h-1)，因此:n=2^(h-1)-1<br>可得:h=log2(n+1)+1</li><li>若将关键字1，2，3，4，5，6，7 依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的分支结点的个数是()<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311115823.png" alt="Pasted image 20250311115823|400">3</li><li>一个关键字序列为{50，20，60，30，35}，依次构造平衡二叉树，当插入25后引起不平衡，则应进行的平衡旋转是()型旋转 LL?<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123317.png" alt="Pasted image 20250311123317"></li><li>对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是<br>A. 92，20，91，34，88，35              B. 95，22，91，24，94，71<br>C. 21，89，77，29，36，38              D. 12，25，71，68，33，34<br>由二叉排序树的性质可知，一个数后面的数字都要全部大于或全部小于它 b选项的91后面既有小于它的数，也有大于它的数</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311123606.png" alt="Pasted image 20250311123606"></li><li>设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平3.在平衡二叉树中插入一个结点后造成了不平衡，因子为1，则应作()型调整以使其平衡。 A.LL B. LR C.RL D.RR<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311130434.png" alt="Pasted image 20250311130434">c</li><li></li></ol><h1>图</h1><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311143034.png" alt="Pasted image 20250311143034|450">由顶点集  V （非空）和边集  E  组成，记为G = (V, E)</p><ul><li><strong>注意</strong>：线性表、树可以为空，但图不能为空（V ≠ ∅）</li></ul><h2 id="无向图与有向图">无向图与有向图</h2><ol><li><p><strong>无向图</strong>：</p><ul><li><strong>边（Edge）</strong>：无序对 (v, w) = (w, v)</li><li><strong>度数性质</strong>：所有顶点的度数之和= 2 × |E|（必为偶数）</li></ul></li><li><p><strong>有向图</strong>：</p><ul><li><strong>弧（Arc）</strong>：有序对  &lt;v, w&gt;≠ &lt;w, v&gt; 。</li><li><strong>度数性质</strong>：<ul><li>入度：指向该顶点的边数。</li><li>出度：从该顶点出发的边数。</li></ul></li></ul></li></ol><ul><li>稀疏图：顶点很多而边很少的图</li><li>稠密图：顶点多边也多的图</li></ul><h2 id="图的分类">图的分类</h2><ol><li><strong>简单图</strong>：<ul><li>无重复边，无自环（顶点到自身的边）。</li></ul></li><li><strong>多重图</strong>：<ul><li>允许两点间有多条边（适用于交通网络等场景）。</li></ul></li><li><strong>完全图</strong>（也称简单完全图）： 对于给定的一组顶点，顶点间都存在边<ul><li><strong>无向完全图</strong>：任意两顶点间均有边，边数=n(n-1)/2</li><li><strong>有向完全图</strong>：任意两顶点间有两条方向相反的弧，弧数= n(n-1)</li></ul></li><li>生成子图：点都有</li><li><strong>极大连通分量</strong>：子图连通，且包含尽可能多的顶点和边<br><strong>极大连通子图</strong>：要求子图必须连通，而且包含尽可能多的顶点和边<br><strong>极小连通子图</strong>：既要保持子图连通又要使得边数最少的子图<br><strong>连通分量</strong>：<mark>无向</mark>图中的<strong>极大连通子图</strong><br><strong>强连通分量</strong>：<mark>有向</mark>图中的极大连通分量（在有向图中考虑强连通性）</li><li>无向<mark>连通图</mark>的<mark>生成树</mark>：是包含<strong>全部顶点</strong>的一个<strong>极小连通子图</strong> n-1条边<br><mark>非连通</mark>的<mark>生成森林</mark>：非连通图分解的多个连通分量，多个连通分量对应的多棵生成树</li><li>有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。</li><li><mark>完全图一定是连通图，但连通图不一定是完全图</mark></li></ol><h2 id="连通性与路径">连通性与路径</h2><ol><li><p><strong>无向图的连通性</strong>：</p><ul><li><strong>连通图</strong>：任意两顶点间存在路径，最少边数 = n-1（树结构）。</li><li><strong>非连通图</strong>：最多边数=(n-1)(n-2)/2（一个孤立顶点，其余构成完全图）。</li></ul></li><li><p><strong>有向图的连通性</strong>：</p><ul><li><strong>强连通图</strong>：任意两顶点间双向可达，最少弧数=n（环形结构）。</li><li><strong>弱连通图</strong>：忽略方向后为连通无向图。</li></ul></li><li><p><strong>路径与环</strong>：</p><ul><li><strong>简单路径</strong>：顶点不重复出现，最多 n 个顶点，n-1 条边。</li><li><strong>回路（环）</strong>：起点与终点相同的路径。</li><li>若一个图有n个顶点，且有大于n-1条边，此图一定有<strong>环</strong></li></ul></li></ol><h2 id="生成树与生成森林">生成树与生成森林</h2><ol><li><strong>生成树</strong>：<ul><li><strong>定义</strong>：无向连通图的极小<mark>连通</mark>子图，包含所有顶点和n-1条边。</li><li><strong>性质</strong>：<ul><li>删除任意一条边会破坏连通性。</li><li>添加任意一条边会形成回路。<br><strong>生成树 G′</strong> 是图 G 的一个子图，满足以下条件：</li></ul></li></ul></li><li><strong>连通性</strong>：G′ 是连通的。</li><li><strong>无环性</strong>：G′ 是无环的。</li><li><strong>极小性</strong>：G′ 是 GG 的极小连通子图（删除任意一条边会破坏连通性）。</li><li><strong>顶点集</strong>：G′ 包含 GG 的所有顶点（V′=V）。</li><li><strong>生成森林</strong>：<ul><li><strong>定义</strong>：非连通图的多个连通分量对应的生成树的集合。</li></ul></li></ol><h3 id="关键公式与结论">关键公式与结论</h3><ul><li>对于n个顶点的<strong>无向图G</strong><ul><li>若G是<mark>连通</mark>图，&gt;= <mark>n-1</mark>条边（树），若|E|&gt;n-1，则一定有<strong>回路</strong>。</li><li>保证G在<strong>任何</strong>情况下均连通的最少边数:(n-1)(n-2)/2+1</li><li>若G是<mark>非连通</mark>图，&lt;= <mark>C2 n − 1</mark>条边【即(n-1)(n-2)/2】，若超过此值，图必<strong>连通</strong></li><li>无向完全图共有C2 n条边【即n(n-1)/2】</li></ul></li><li>对于n个顶点的<strong>有向图G</strong><ul><li>若G是<mark>强连通</mark>图，&gt;= <mark>n</mark>条边（形成简单回路）</li><li><mark>有向完全</mark>图共有<mark>2C2 n</mark> 条边【即n(n-1)】</li></ul></li><li>求有向图的强连通分量<ul><li>找入度或出度为0的顶点</li><li>依次删掉这些顶点以及相连的弧，直到没有存在入度或出度为0的顶点、</li><li>删掉的顶点以及剩下的有向图，就是强连通分量<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311164300.png" alt="Pasted image 20250311164300|400"></li></ul></li><li><strong>顶点度数</strong>：<ul><li>无向图顶点最大度数 = n-1</li><li>有向图顶点最大度（入度 + 出度） = 2(n-1)</li></ul></li></ul><h3 id="算法与应用">算法与应用</h3><ol><li><p><strong>判断回路</strong>：</p><ul><li><strong>有向图</strong>：拓扑排序、深度优先遍历（DFS）检测环。</li><li><strong>无向图</strong>：并查集或DFS检测环。</li></ul></li><li><p><strong>连通分量</strong>：</p><ul><li><strong>无向图</strong>：广度优先遍历（BFS）或DFS求所有连通分量。</li><li><strong>有向图</strong>：Kosaraju算法求强连通分量。</li></ul></li><li><p><strong>最小生成树</strong>：</p><ul><li><strong>Kruskal算法</strong>：按边权升序选择，避免成环。</li><li><strong>Prim算法</strong>：从顶点出发逐步扩展最小边。</li></ul></li></ol><ul><li><strong>完全图边数</strong>：<ul><li>无向完全图边数  n(n-1)/2，有向完全图弧数n(n-1)</li></ul></li><li><strong>邻接表结点数</strong>：<ul><li>无向图邻接表结点总数  2|E| ，有向图邻接表结点总数  |E| 。</li></ul></li></ul><h2 id="图的存储结构">图的存储结构</h2><h3 id="邻接矩阵（数组、顺序存储）">邻接矩阵（数组、顺序存储）</h3><ul><li>用 n×n 矩阵表示顶点间关系，适用于稠密图。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311142927.jpg" alt="Pasted image 20250311142927|500"><br>无向图邻接矩阵：</li></ul><ol><li>无向图的邻接矩阵一定是一个<strong>对称矩阵</strong>。 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。</li><li>对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个顶点的度</li><li>求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍， <code>A[i][j]</code>为 1就是邻接点。</li><li>无向图非零元素至少有2 * 边数个</li><li>在含有 n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为n^2 - 2e</li><li></li></ol><p>有向图邻接矩阵：</p><ol><li>主对角线上数值依然为0，但矩阵并不对称。</li><li>有向图入度是一列和，出度是一行和==（出行入列）==</li><li>与无向图同样的办法，判断顶点vi​到vj​是否存在弧，只需要查找矩阵中<code>A[i][j]</code>是否为1即可。</li></ol><p>邻接矩阵的 存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">VertexType Vex[MaxVertexNum];<span class="comment">//顶点表</span></span><br><span class="line">EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵，边表</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧树</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><ul><li>在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。</li><li>当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeType可定义为值为0和1的枚举类型。</li><li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。</li><li>邻接矩阵表示法的空间复杂度为O(n^2)， 其中n为图的顶点数|V|</li><li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li><li><mark>稠密图</mark>适合使用邻接矩阵的存储表示。</li><li><code>A^n[i][j]</code>表示从顶点 i 到 j 的长度为 n 的路径数目<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312110923.png" alt="Pasted image 20250312110923|400"></li></ul><h3 id="邻接表（顺序-链式）">邻接表（顺序+链式）</h3><p>结合顺序+链序存储，不唯一<br>对于<mark>稀疏图</mark>，采用邻接表表示将极大地节省存储空间<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311145242.png" alt="Pasted image 20250311145242|400"></p><ul><li><strong>无向图</strong>：每个顶点的邻接表存储其邻接顶点，总边结点数为 2|E|，所需的存储空间为<mark>O(|V|+2|E|)</mark></li><li><strong>有向图</strong>：邻接表存储出边，逆邻接表存储入边，总边结点数为 |E|，所需的存储空间为 <mark>O(|V|+|E|)</mark><br>有向图邻接表的总结点个数 = 表头结点数（顶点数 ∣V∣） + 表结点数（边数 ∣E∣）</li></ul><table><thead><tr><th>操作</th><th>邻接表</th><th>邻接矩阵</th></tr></thead><tbody><tr><td><strong>查找邻边</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>判断边是否存在</strong></td><td>O(d)</td><td>O(1)</td></tr><tr><td><strong>计算出度（有向图）</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>计算入度（有向图）</strong></td><td>O(n+e)</td><td>O(n)</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(n+e)</td><td>O(n2)</td></tr></tbody></table><ul><li><strong>邻接表</strong>：<ul><li>适合稀疏图（边数远小于 n^2）。</li><li>需要频繁查找邻边的场景（如DFS/BFS遍历）。</li></ul></li><li><strong>邻接矩阵</strong>：<ul><li>适合稠密图（边数接近 n^2）。</li><li>需要频繁判断边是否存在的场景（如最短路径算法）</li></ul></li></ul><h3 id="十字链表（有向图）">十字链表（有向图）</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%209%2069.png" alt="Untitled 9 69|Untitled 9 69.png"></p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Screenshot_2023_0824_165443.png" alt="Screenshot_2023_0824_165443"></p><p>顶点节点表三个格子，边节点表四个格子<br>弧节点表：<br>第一个格子是当前节点的索引<br>第二个格子是箭头所指节点的索引<br>第三个格子先空着，前两个格子全部写完，再由节点表的第二个格子指向与弧节点表的第二个格子索引值一样的弧节点的第三个格子，弧节点表的第三个格子依次指向下一个索引值一样的边节点，后面没有了写”空“<br>第四个格子是当前行的最后一个弧界点就写“空”<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312111806.png" alt="Pasted image 20250312111806|400"><br>在十字链表中，既容易找到Vi为尾的弧，也容易找到Vi为头的弧，因而容易求得顶点的出度和入度<br>图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。</p><h3 id="邻接多重表（无向图）">邻接多重表（无向图）</h3><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Untitled%2010%2065.png" alt="Untitled 10 65|Untitled 10 65.png"><br>顶点节点两个格子，弧节点四个格子<br>弧节点：<br>第一个格子是当前节点的索引<br>第三个格子是箭头所指节点的索引（连完之后把线叉掉）<br>两两节点一起，顶点节点空格指向所有弧节点中一/三节点索引一样的二/四空格，直到没有写“空 ”<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312113325.png" alt="Pasted image 20250312113325|400"></p><p>空间复杂度O(|V|+|E|)<br>删除边、结点方便</p><table><thead><tr><th>特性</th><th>邻接矩阵</th><th>邻接表</th><th>十字链表</th><th>邻接多重表</th></tr></thead><tbody><tr><td>空间复杂度</td><td>O(|V|^2)</td><td>无向图：O(|V| + 2|E|) 有向图：O(|V| + |E|)</td><td>O(|V| + |E|)</td><td>O(|V| + |E|)</td></tr><tr><td>找相邻边</td><td>遍历对应行或列，时间复杂度O(|V|)</td><td>找有向图的入边需遍历整个邻接表</td><td>很方便</td><td>很方便</td></tr><tr><td>删除边或顶点</td><td>删边方便，删顶点需大量移动数据</td><td>无向图中删边或顶点都不方便</td><td>很方便</td><td>很方便</td></tr><tr><td>适用于</td><td>稠密图</td><td>稀疏图和其他</td><td>只能存有向图</td><td>只能存无向图</td></tr><tr><td>表示方式</td><td>唯一</td><td>不唯一</td><td>不唯一</td><td>不唯一</td></tr></tbody></table><table><thead><tr><th>图类型</th><th>存储结构</th><th>操作类型</th><th>时间复杂度说明</th></tr></thead><tbody><tr><td><strong>无向图</strong></td><td>邻接矩阵</td><td>查找相邻边</td><td>遍历对应行 / 列，时间复杂度 O(|V|)（|V|为顶点数）</td></tr><tr><td></td><td></td><td>删除边</td><td>直接修改矩阵元素，时间复杂度 O(1)</td></tr><tr><td></td><td></td><td>计算顶点的度</td><td>统计对应行 / 列非零元素个数，时间复杂度 O(|V|)</td></tr><tr><td></td><td>邻接表</td><td>查找相邻边</td><td>遍历顶点对应链表，时间复杂度 O(d)（d为顶点度）</td></tr><tr><td></td><td></td><td>删除边</td><td>需遍历链表找到对应边结点，时间复杂度 O(d)</td></tr><tr><td></td><td></td><td>计算顶点的度</td><td>统计顶点对应链表的结点数，时间复杂度 O(d)</td></tr><tr><td></td><td>邻接多重表</td><td>查找相邻边</td><td>通过指针直接定位关联边，时间复杂度 O(1)（理想情况，实际与存储组织相关）</td></tr><tr><td></td><td></td><td>删除边</td><td>标记或移除边结点，时间复杂度 O(1)（需提前定位边，定位时间另计）</td></tr><tr><td></td><td></td><td>计算顶点的度</td><td>统计顶点关联的边结点数，时间复杂度 O(d)</td></tr><tr><td><strong>有向图</strong></td><td>邻接矩阵</td><td>查找出边</td><td>遍历对应行，时间复杂度 O(|V|)</td></tr><tr><td></td><td></td><td>查找入边</td><td>遍历对应列，时间复杂度 O(|V|)</td></tr><tr><td></td><td></td><td>删除边（出边 / 入边）</td><td>直接修改矩阵元素，时间复杂度 O(1)</td></tr><tr><td></td><td></td><td>计算出度</td><td>统计对应行非零元素个数，时间复杂度 O(|V|)</td></tr><tr><td></td><td></td><td>计算入度</td><td>统计对应列非零元素个数，时间复杂度 O(|V|)</td></tr><tr><td></td><td>邻接表</td><td>查找出边</td><td>遍历顶点对应链表，时间复杂度 O(d出)（d出为出度）</td></tr><tr><td></td><td></td><td>查找入边</td><td>需遍历全表，时间复杂度 O(|V| + |E|)（|E|为边数）</td></tr><tr><td></td><td></td><td>删除出边</td><td>遍历链表找到对应边结点，时间复杂度 O(d出)</td></tr><tr><td></td><td></td><td>计算出度</td><td>统计顶点对应链表的结点数，时间复杂度 O(d出)</td></tr><tr><td></td><td></td><td>计算入度</td><td>需遍历全表统计，时间复杂度 O(|V| + |E|)</td></tr><tr><td></td><td>十字链表</td><td>查找出边 / 入边</td><td>通过结点指针直接定位，时间复杂度 O(1)（理想情况，实际与存储组织相关）</td></tr><tr><td></td><td></td><td>删除边（出边 / 入边）</td><td>调整指针关系，时间复杂度 O(1)（需提前定位边，定位时间另计）</td></tr><tr><td></td><td></td><td>计算出度 / 入度</td><td>直接读取结点记录的出度 / 入度值（十字链表可存储度数信息），时间复杂度 O(1)</td></tr></tbody></table><p>稀疏矩阵用三元组：(x,y,z):(行，列，非零值）的顺序表；十字链表（有向图）存储</p><h2 id="图的遍历">图的遍历</h2><h3 id="深度优先遍历（DFS）">深度优先遍历（DFS）</h3><ol><li><p><strong>核心思想</strong>：</p><ul><li>类似树的<strong>先序遍历</strong>，沿着一条路径尽可能深入探索，直到无法继续时回溯。</li><li><mark>递归</mark>或显式使用<mark>栈</mark>实现。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>树高较大</strong>：DFS 的递归深度或栈深度可能接近图的顶点数（如单链结构）。</li><li><strong>空间复杂度</strong>：最坏情况下为O(|V|) ，由递归栈深度或显式栈大小决定。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li><strong>邻接矩阵</strong>： O(|V|^2) 。<ul><li>每个顶点需遍历所有其他顶点以查找邻接点。</li></ul></li><li><strong>邻接表</strong>： O(|V| + |E|) 。<ul><li>仅遍历实际存在的边。</li></ul></li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>稠密图</strong>（邻接矩阵效率更高）。</li><li><strong>拓扑排序</strong>、<strong>强连通分量</strong>（如 Tarjan 算法）。</li></ul></li></ol><h3 id="广度优先遍历（BFS）">广度优先遍历（BFS）</h3><ol><li><p><strong>核心思想</strong>：</p><ul><li>类似树的<strong>层序遍历</strong>，逐层访问顶点。</li><li>使用<mark>队列</mark>作为辅助数据结构，<strong>每个顶点仅入队一次</strong>。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>最短路径</strong>：BFS 天然适合求解无权图的最短路径问题。</li><li><strong>连通分量</strong>：通过 BFS 可遍历一个连通分量中的所有顶点。</li></ul></li><li><p><strong>时间复杂度</strong>：</p><ul><li><strong>邻接矩阵</strong>： O(|V|^2) 。</li><li><strong>邻接表</strong>： O(|V| + |E|) 。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>稀疏图</strong>（邻接表更高效）。</li><li><strong>社交网络分析</strong>（如六度分隔理论）。</li></ul></li></ol><h4 id="生成树与生成森林-2"><strong>生成树与生成森林</strong></h4><ol><li><p><strong>广度优先生成树</strong>：</p><ul><li><strong>邻接表不唯一性</strong>：邻接表中顶点的邻接顺序不固定，导致生成树结构可能不同。</li><li><strong>邻接矩阵唯一性</strong>：邻接矩阵的邻接顺序固定（按顶点编号），生成树唯一。</li></ul></li><li><p><strong>广度优先生成森林</strong>：</p><ul><li>针对非连通图，每个连通分量生成一棵广度优先生成树。</li></ul></li></ol><table><thead><tr><th>特性</th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>遍历方式</td><td>深度优先（单路径深入）</td><td>广度优先（逐层扩展）</td></tr><tr><td>数据结构</td><td>栈（递归或显式栈）</td><td>队列</td></tr><tr><td>空间复杂度</td><td>O(∣V∣)（最坏情况）</td><td>O(∣V∣)（队列存储顶点）</td></tr><tr><td>时间复杂度</td><td>邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣)</td><td>邻接矩阵 O(∣V∣^2)，邻接表 O(∣V∣+∣E∣)</td></tr><tr><td>应用场景</td><td>拓扑排序、路径存在性检测</td><td>最短路径、连通分量统计</td></tr></tbody></table><h4 id="关键结论"><strong>关键结论</strong></h4><ul><li><strong>时间复杂度与存储结构的关系</strong>：<ul><li>邻接矩阵需遍历所有顶点，时间复杂度较高；邻接表仅遍历实际边，效率更高。</li></ul></li><li><strong>生成树的唯一性</strong>：<ul><li>邻接表因邻接顺序不固定，生成树可能不唯一；邻接矩阵生成树唯一。</li></ul></li><li><strong>空间复杂度</strong>：<ul><li>DFS 和 BFS 的最坏空间复杂度均为O(|V|) ，与搜索路径无关。</li></ul></li></ul><h2 id="错题-7">错题</h2><ol><li>一个有 28 条边的非连通无向图至少有()个顶点。7/8/9/10<br>为了使顶点数最小，应使其中一个连通分量为孤立顶点（无边），另一个连通分量为完全图（边数最多），完全图边数n(n-1)/2，可得n=8，总顶点数=n+1=9</li><li>在有n个顶点的有向图中，顶点的度最大可达() A. n B. n-1 C.2n D.2n-2<br>在有向图中，顶点的度等于入度与出度之和。n个顶点的有向图中，任意一个顶点最多还可以与其他n-1个顶点有一对指向相反的边相连。注意，数据结构中仅讨论简单图。</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311161002.png" alt="Pasted image 20250311161002">一个连通图的生成树是一个极小连通子图，显然它是无环的，因此选项 Ⅱ、 正确。极大连通子图称为连通分量，G’连通但非连通分量。这里再补充一下“极大连通子图”:若图本来就是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。</li><li>具有51个顶点和21条边的无向图的连通分量最多为 A. 33 B.34 C. 45 D.32<br>要想连通分量最多，就要使图中孤立的点数量最多（每一个孤立的点都是一个连通分量）  问题转为最少用多少点可连21条边，设用x个点.则有x(x-1)/2≥21，得xmin=7  ，这7个点作为1个连通分量，剩余51-7=44个孤立的点，每一个点作为一个连通分量，故连通分量最多为1+(51-7)=45个</li><li>在如下图所示的有向图中，共有()个强连通分量。1/2/3/4<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311162046.png" alt="Pasted image 20250311162046|150">2个，b和其他</li><li>若具有 n个顶点的图是一个环，则它有()棵生成树 A. n B. n C. n-1 D.1<br>环图删除任意一条边可形成生成树，共有 nn 种选择</li><li>若一个具有 n个顶点、e条边的无向图是一个森林，则该森林中必有()棵树。<br>A.n  B.e  C.n-e  D.1<br>n个结点的树有n—1条边，假设有x棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是n+1，边数是e+x，从而可知x=n—e，也就是n—e棵树了</li><li>下列关于无向连通图特性的叙述中，正确的是()<br>I.所有顶点的度之和为偶数<br>II.边数大于顶点个数减1<br>III.至少有一个顶点的度为1<br>A. 只有I    B.只有II    C.I和II    D.I和III<ul><li>I正确（度数之和为边数两倍，必为偶数）。</li><li>II错误（树结构边数 n−1，不大于顶点数减1）。</li><li>III错误（环图所有顶点度为2）。</li></ul></li><li>若无向图 G=(V,E)中含有6个顶点，要保证图 G在任何情况下都是连通的，则需要的边数最少是() 8/9/10/11<br>特定情况下6条，就连通；任意情况下，<mark>n-1个点的完全图+单独出去的一条边连剩下一个点</mark>，答案是11。如果题目求的是有向图，<mark>n-1个点的有向完全图+单独出去的一条边连剩下一个点</mark>，答案是21<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165458.png" alt="Pasted image 20250311165458|300"></li><li>对于无向图G=(V,E)，下列选项中，正确的是()。<br>A.|V|&gt;|E|时，G 一定是连通的<br>B.当|V|&lt;|E|时，G一定是连通的<br>C.当|V|=|E|-1时，G一定是不连通的<br>D.当|V|=|E|+1时，G一定是不连通的<br>d<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311171144.png" alt="Pasted image 20250311171144"></li><li>用有向无环图描述表达式(x+y)((x+y)/x)，需要的顶点个数至少是5/6/8/9<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250311165839.png" alt="Pasted image 20250311165839|300">5</li><li><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312122108.png" alt="Pasted image 20250312122108">bd</li><li>假设有 n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)<br><strong>删出边</strong>：遍历v的顶点表结点及其边表，删除出边，最多n-1条，时间复杂度O(n)。<br><strong>删入边</strong>：扫描整个边表（含剩余顶点表结点及边表），删除v的入边，时间复杂度O(n+e)。</li><li>假设有 n个顶点、e条边的有向图用邻接表表示，则某个顶点v的入度时间复杂度为()。A. O(n) B. O(e) C. O(n+e) D. O(ne)<br>为了求顶点v的入度，只需要遍历邻接表中的所有边表，检查每条边是否指向顶点&quot;，这相当于遍历整个邻接表，因此算法的时间复杂度为 O(n+e)。</li><li>无向图邻接多重表求顶点b，d的度<img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250312125659.png" alt="Pasted image 20250312125659|400"><br>b的入度1，出度2；d的入度1，出度3</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/post/b8b0eacd.html"/>
      <url>/post/b8b0eacd.html</url>
      
        <content type="html"><![CDATA[<h1>基础概念和常识</h1><h2 id="Java-SE-vs-Java-EE">Java SE vs Java EE</h2><ul><li>Java SE（Java Platform，Standard Edition）: Java 平台<mark>标准版</mark>，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。</li><li>Java EE（Java Platform, Enterprise Edition ）：Java 平台<mark>企业版</mark>，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。</li></ul><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><h2 id="JVM-vs-JDK-vs-JRE">JVM vs JDK vs JRE</h2><h3 id="JVM">JVM</h3><p>Java 虚拟机（Java Virtual Machine, JVM）是运行 <mark>Java 字节码</mark>的虚拟机。JVM 有针对<strong>不同系统</strong>的特定实现（Windows，Linux，macOS），目的是<strong>使用相同的字节码，它们都会给出相同的结果</strong>。<em>字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在</em>。</p><p>如下图所示，不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure …）通过各自的编译器编译成 <code>.class</code> 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309183756.png" alt="Pasted image 20250309183756"></p><h3 id="JDK和JRE">JDK和JRE</h3><p>JDK是一个功能齐全的java开发工具包，供开发者使用，用于<strong>创建和编译</strong>java程序。它包含了<strong>JRE以及编译器javac和其他工具</strong>（eg.javadoc文档生成器、jdb调试器、jconsole监控工具、javap反编辑工具）<br>JRE是<mark>运行已编译java程序所需要的环境</mark>，主要包括：</p><ul><li>JVM：java虚拟机</li><li>Java基础类库（<strong>Class Library</strong>）：一组标准的类库，提供常用的功能和API（eg.IO操作、网络通信、数据结构等）<br>即：JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309184829.png" alt="Pasted image 20250309184829|400"><br><strong>从JDK9开始</strong>：用模块系统（94个模块）+ jlink工具取代传统JRE，<strong>JDK11起不再单独提供JRE</strong>。开发者可<strong>用jlink打包应用仅依赖的模块</strong>，生成<strong>轻量级定制运行时镜像</strong>（例如仅保留20个必要模块），使运行环境体积减少80%+，同时提升部署效率、降低内存占用、增强安全性，<strong>完美适配容器化/微服务等云原生场景</strong><br><strong>核心逻辑</strong>：模块化 = 按需裁剪 + 轻量部署</li></ul><h2 id="字节码">字节码</h2><p>Java字节码（<code>.class</code>文件）是<strong>JVM</strong>的通用指令，<strong>独立于硬件平台</strong>（不面向任何特定的处理器，只面向JVM虚拟机），由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。平衡了执行效率与跨移植性（虽效率仍低于C/C++等编译型语言）。<br><strong>Java 程序从源代码到运行的过程</strong><br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190054.png" alt="Pasted image 20250309190054|500"><br>程序运行时，JVM通过<strong>解释器逐行翻译字节码为机器码</strong> <code>.class-&gt;机器码</code>（初始速度较慢），而对高频调用的<strong>热点代码</strong>，<strong>JIT编译器</strong>（属于<mark>运行</mark>时编译）会动态编译并缓存对应机器码，后续直接执行加速。<br>机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。<br>Java高效跨平台 = <strong>字节码中间层</strong> + <strong>解释与JIT编译协同</strong>（冷代码解释执行，热代码编译缓存）<br>热代码：方法和代码块是经常需要被调用的<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190159.png" alt="Pasted image 20250309190159|500"><br>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309190229.png" alt="Pasted image 20250309190229|200"></p><h2 id="为什么说java语言”编译与解释并存“">为什么说java语言”编译与解释并存“</h2><p>Java 的执行过程结合了<strong>编译型语言</strong>和<strong>解释型语言</strong>的特性，具体体现为以下两个阶段：</p><ul><li><strong>编译型</strong>：源码需预先编译为字节码（静态编译）</li><li><strong>解释型</strong>：字节码由解释器逐行翻译执行（动态解释）<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309191659.png" alt="Pasted image 20250309191659|300"><br>改善：</li><li><strong>混合模式</strong>：先将源码编译成字节码，到执行期间，再将字节码直译，之后执行。java和LLVM是这种技术的代表产物<br><strong>为什么说 Java 语言“编译与解释并存”？</strong><br>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。<br>Java程序需<strong>先编译为字节码</strong>（平台无关的中间代码），再通过JVM的<strong>解释器逐行翻译为机器码执行</strong>，这一过程体现了解释型语言的特性；而针对高频执行的<strong>热点代码</strong>，JVM的<strong>JIT编译器</strong>会在运行时将其<strong>动态编译为本地机器码并缓存</strong>（类似编译型语言的特性），后续直接调用以大幅提升效率。这种“冷代码解释+热代码编译”的混合模式，既保留了跨平台灵活性，又通过运行时优化逼近了编译型语言的性能。</li></ul><h2 id="AOT">AOT</h2><p><strong>JDK9引入的AOT（预编译）直接在运行前将字节码<mark>静态</mark>编译为机器码</strong>（C、 C++，Rust，Go 等语言就是静态编译），消除JIT预热开销，显著提升启动速度并降低内存消耗，尤其适配云原生场景对快速扩容的需求。相较于JIT的运行时动态优化，AOT牺牲了部分极限性能（如高并发吞吐量），但通过<strong>预编译加固代码安全性</strong>（防反编译和修改），在微服务等轻量级应用中优势明显。<br><strong>JIT 与 AOT 两者的关键指标对比</strong>:<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250309192909.jpg" alt="Pasted image 20250309192909|400"><br>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p><strong>GraalVM作为技术桥梁</strong>：不仅支持Java/JVM生态的AOT编译，还能运行JS/Python等非JVM语言，实现多语言混合编程（GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译）。<br><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong><br>AOT虽在<strong>启动速度和资源占用</strong>上优势显著，但其<strong>静态编译特性</strong>与Java生态广泛依赖的<strong>动态能力</strong>存在根本冲突：</p><ol><li><strong>动态特性失效</strong><br>如反射（运行时获取/修改类信息）、动态代理（如Spring AOP）、字节码生成（如CGLIB基于ASM实时创建<code>.class</code>）等操作，均需<strong>运行时动态修改或加载类</strong>。而AOT要求所有代码<strong>预先编译为机器码</strong>，导致这些灵活机制无法实时生效，直接破坏Spring等框架的核心功能。</li><li><strong>技术生态兼容性</strong><br>Java主流框架（Spring/Hibernate）大量通过注解、反射注入依赖关系，若强制AOT需<strong>代码全量静态可分析</strong>，开发者需大幅改写业务代码或框架适配（如Spring Native项目），显著增加复杂度。</li><li><strong>性能取舍</strong><br>AOT的静态优化无法像JIT基于<strong>运行时热点分析</strong>做深度优化（如方法内联、逃逸分析），对长期运行的高并发服务，JIT的渐进式优化更能释放极限性能。<br><strong>实例</strong>：CGLIB动态代理通过ASM在内存中即时生成代理类的字节码，若用AOT提前编译，则代理逻辑无法动态插入，导致@Transactional等依赖代理的注解失效。</li></ol><p><strong>结论</strong>：AOT与JIT是<strong>场景互补</strong>而非替代</p><ul><li><strong>短时任务/云函数</strong>：AOT优先（秒级启动）</li><li><strong>复杂业务/传统应用</strong>：JIT维持动态灵活性</li><li><strong>混合方案</strong>：GraalVM等工具允许部分AOT+JIT（如预编译基础库，核心业务保持动态）</li></ul><h2 id="Oracle-JDK-VS-OpenJDK">Oracle JDK VS OpenJDK</h2><p><strong>开源与商业化的博弈</strong><br>OpenJDK作为<strong>开源参考实现</strong>，遵循GPL协议允许自由修改与分发（如阿里基于其定制Dragonwell），而Oracle JDK虽衍生自OpenJDK，但<strong>部分高级功能闭源</strong>（如早期Java Flight Recorder），且受BCL/OTN协议约束——JDK 17后免费商用仅限3年，长期需付费许可。</p><p><strong>功能与生态平衡</strong></p><ul><li><strong>特性差异</strong>：Oracle JDK曾独占JFR性能监控等工具，但<strong>Java 11后两者核心功能趋同</strong>，Oracle将多数组件开源捐赠，削弱了独家优势。</li><li><strong>更新策略</strong>：OpenJDK以<strong>3个月为周期快速迭代</strong>（试水新特性），Oracle JDK则以6个月为周期整合稳定版本，实际通过第三方（如Amazon Corretto）提供OpenJDK的LTS支持，弥补了官方长期支持的缺失。</li></ul><p><strong>为何OpenJDK不可替代？</strong></p><ol><li><strong>开源自由</strong>：企业可深度定制（如适配云环境、优化GC算法），避免受限于Oracle的商业策略；</li><li><strong>零成本商用</strong>：无版本时间锁，尤其适合需长期维护的遗留系统（如JDK 8无限期免费）；</li><li><strong>云原生适配</strong>：主流云厂商（AWS/Azure/AliCloud）均基于OpenJDK发行优化版，天然适配容器化、Serverless等场景。</li></ol><p><strong>协议风险警示</strong><br>Oracle JDK的OTN协议要求<strong>Java 17+商用付费</strong>，且禁止修改二进制代码；而OpenJDK的GPLv2允许自由使用与二次开发，这对企业构建自主技术栈至关重要。</p><p><strong>选型结论</strong></p><ul><li><strong>常规场景</strong>：优先选择<strong>OpenJDK发行版</strong>（如Corretto/Dragonwell），兼顾免费、稳定与生态兼容；</li><li><strong>特殊需求</strong>：若依赖Oracle独家工具（如JMC深度诊断），可短期使用Oracle JDK，但需评估后续版本付费风险。</li></ul><h2 id="Java-VS-C">Java VS C++</h2><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h1>基本语法</h1><p>注释：单行、多行、文档</p><h2 id="移位运算符">移位运算符</h2><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为<mark>二进制数</mark>，移位就是将其向左或向右移动若干位的运算。<br><strong>一、三种移位运算符本质</strong></p><ol><li><p><strong><code>&lt;&lt;</code> 左移</strong><br>二进制整体向左移动，<strong>低位补0，高位丢弃</strong></p><ul><li>示例：<code>5 &lt;&lt; 2</code> → <code>0000 0101</code> → <code>0001 0100</code> = 20</li><li><strong>等效计算</strong>：<code>x * 2ⁿ</code>（适用于非溢出场景）</li></ul></li><li><p><strong><code>&gt;&gt;</code> 带符号右移</strong><br>二进制向右移动，<strong>高位补符号位（正补0，负补1），低位丢弃</strong></p><ul><li>示例：<code>-8 &gt;&gt; 1</code> → <code>1111 1000</code> → <code>1111 1100</code> = -4</li><li><strong>等效计算</strong>：<code>x / 2ⁿ</code>（向下取整）</li></ul></li><li><p><strong><code>&gt;&gt;&gt;</code> 无符号右移</strong><br>二进制向右移动，<strong>高位强制补0，低位丢弃</strong></p><ul><li>示例：<code>-8 &gt;&gt;&gt; 1</code> → <code>1111 1000</code> → <code>0111 1100</code> = 124（int类型）</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">midPoint</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心公式：中间值 = low + ((high - low) &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">return</span> low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、关键特性与使用场景</strong></p><ol><li><p><strong>高效计算</strong></p><ul><li>直接映射CPU指令（如SHL/SHR），比乘除法快10倍以上（实测示例）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能对比：移位 vs 乘法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1024</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 等效 1024*8</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;移位耗时：&quot;</span> + (end - start) + <span class="string">&quot;ns&quot;</span>); <span class="comment">// 约5ns</span></span><br><span class="line"></span><br><span class="line">start = System.nanoTime();</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">8</span>;</span><br><span class="line">end = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;乘法耗时：&quot;</span> + (end - start) + <span class="string">&quot;ns&quot;</span>); <span class="comment">// 约20ns</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内存优化</strong></p><ul><li>用int/long存储多个布尔标志（每个位表示一个状态）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限管理示例：读(1&lt;&lt;0)、写(1&lt;&lt;1)、执行(1&lt;&lt;2)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;   <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXECUTE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;<span class="comment">// 0100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">userA</span> <span class="operator">=</span> READ | WRITE; <span class="comment">// 0011（有读写权限）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>哈希算法应用</strong></p><ul><li><strong>HashMap中的扰动函数</strong>：通过无符号右移增强散列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将高16位特征混合到低16位，减少哈希碰撞</li></ul></li></ol><p><strong>三、注意</strong></p><ol><li><p><strong>移位位数超限</strong></p><ul><li>移位位数超过类型位数时，实际移位数为 <code>位数 % 类型长度</code></li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span> &lt;&lt; <span class="number">34</span>;  <span class="comment">// 等效 3 &lt;&lt; (34%32)=2 → 3*4=12</span></span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">5L</span> &lt;&lt; <span class="number">66</span>;<span class="comment">// 等效 5L &lt;&lt; (66%64)=2 → 5*4=20</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>类型隐式转换</strong></p><ul><li>对<code>byte/short/char</code>移位时，自动转为int操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0b1000_0000</span>; <span class="comment">// -128</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> b &lt;&lt; <span class="number">2</span>;  <span class="comment">// 转换为int操作：-128 &lt;&lt; 2 = -512</span></span><br></pre></td></tr></table></figure></li><li><p><strong>符号位陷阱</strong></p><ul><li>带符号右移保留符号位，无符号右移强制补零</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">negative</span> <span class="operator">=</span> -<span class="number">8</span>;          <span class="comment">// 1111...1000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">signedShift</span> <span class="operator">=</span> negative &gt;&gt; <span class="number">1</span>;  <span class="comment">// 1111...1100 (-4)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">unsignedShift</span> <span class="operator">=</span> negative &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 0111...1100 (2147483644)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="continue-VS-break-VS-return">continue VS break VS return</h2><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。<br><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</li><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line">xixi</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">xixi</span><br><span class="line"><span class="number">3</span></span><br><span class="line">haha</span><br></pre></td></tr></table></figure><h2 id="基本类型">基本类型</h2><p>Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一</p><table><thead><tr><th>类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768（-(2^{15})） ~ 32767（(2^{15}) - 1）</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808（-(2^{63})） ~ 9223372036854775807（(2^{63}) -1）</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘\u0000’</td><td>0 ~ 65535（(2^{16}) - 1）</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0.0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0.0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1（逻辑上）</td><td>-</td><td>false</td><td>true、false</td></tr><tr><td><strong>补充说明</strong>：</td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><p><strong><code>boolean</code>类型</strong>：</p><ul><li>逻辑上为1位，但实际存储依赖JVM实现（通常用1字节或4字节存储）。</li><li>默认值为<code>false</code>，取值范围仅为<code>true</code>和<code>false</code>。</li></ul></li><li><p><strong>浮点数精度</strong>：</p><ul><li><code>float</code>为单精度浮点数，精度约6-7位小数。</li><li><code>double</code>为双精度浮点数，精度约15位小数。</li></ul></li><li><p><strong>字符类型</strong>：</p><ul><li><code>char</code>为16位无符号整数，表示Unicode字符，范围为<code>0</code>到<code>65535</code>。</li></ul></li><li><p><strong>默认值规则</strong>：</p><ul><li>类成员变量（字段）有默认值，局部变量必须显式初始化，否则编译报错。</li></ul></li></ol><h3 id="基本类-VS-包装类">基本类 VS 包装类</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>基本类型</strong></th><th><strong>包装类</strong></th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>- 局部变量：栈中<br>- 成员变量：堆中（未static修饰）</td><td>堆中（对象实例）</td></tr><tr><td><strong>占用空间</strong></td><td>极小（如<code>int</code>：4字节，<code>boolean</code>：1位逻辑值）</td><td>较大（对象头+实例数据，通常16字节以上）</td></tr><tr><td><strong>默认值</strong></td><td>有默认值（如<code>int</code>：0，<code>boolean</code>：false）</td><td><code>null</code>（未赋值时）</td></tr><tr><td><strong>比较方式</strong></td><td>== 比较值</td><td>equals()比较值，== 比较对象的内存地址</td></tr><tr><td><strong>泛型支持</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>逃逸分析</strong></td><td>无（直接存储值）</td><td>可能通过逃逸分析优化为栈上分配（如局部对象未逃逸出方法）</td></tr></tbody></table><ol><li><p><strong>局部变量</strong></p><ul><li>基本类型：栈中（如方法内的<code>int a = 10;</code>）</li><li>包装类：堆中（如<code>Integer b = 20;</code>）</li></ul></li><li><p><strong>成员变量</strong></p><ul><li>基本类型：堆中（如<code>int a = 10;</code>）</li><li>包装类：堆中（如<code>Integer b = 20;</code>）</li></ul></li><li><p><strong>静态变量</strong></p><ul><li>基本类型：方法区（JDK 1.7及之前）或元空间（JDK 1.8+）</li><li>包装类：方法区（JDK 1.7及之前）或元空间（JDK 1.8+）</li></ul></li></ol><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量（堆中）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量（方法区/元空间）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量（栈中）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逃逸分析优化：局部对象可能分配在栈中</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">70</span>); <span class="comment">// 可能栈上分配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<br><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><ol><li><p><strong>栈与堆的误区</strong></p><ul><li>基本类型的存储位置取决于作用域：局部变量在栈中，成员变量在堆中。</li><li>包装类始终是对象，通常分配在堆中，但可能通过逃逸分析优化为栈上分配。</li></ul></li><li><p><strong>性能权衡</strong></p><ul><li><strong>基本类型</strong>：性能高，内存占用小，但功能受限（如不支持泛型）。</li><li><strong>包装类</strong>：功能强大（如支持泛型、集合操作），但内存开销大。</li></ul></li><li><p><strong>默认值与空指针</strong></p><ul><li>基本类型有默认值，包装类未赋值时为<code>null</code>，使用时需注意空指针异常。</li></ul></li><li><p><strong>比较方式</strong></p><ul><li>对于基本数据类型用== 比较值。包装类用equals()比较值，== 比较对象的内存地址</li></ul></li></ol><h3 id="适用场景"><strong>适用场景</strong></h3><ul><li><strong>基本类型</strong>：性能敏感场景（如循环计算、数组存储）。</li><li><strong>包装类</strong>：泛型集合、数据库映射（如<code>List&lt;Integer&gt;</code>）、API设计（如方法参数可为<code>null</code>）。</li><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li></ul><h2 id="包装类型的缓存机制">包装类型的缓存机制</h2><table><thead><tr><th><strong>包装类</strong></th><th><strong>缓存范围</strong></th><th><strong>缓存实现方式</strong></th></tr></thead><tbody><tr><td><code>Byte</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Short</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Integer</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Long</code></td><td>-128 ~ 127</td><td>全部缓存（256个对象）</td></tr><tr><td><code>Character</code></td><td>0 ~ 127</td><td>全部缓存（128个对象）</td></tr><tr><td><code>Boolean</code></td><td><code>true</code> / <code>false</code></td><td>全部缓存（2个对象）</td></tr><tr><td><code>Float</code></td><td>无缓存</td><td>每次创建新对象</td></tr><tr><td><code>Double</code></td><td>无缓存</td><td>每次创建新对象</td></tr></tbody></table><p><strong>缓存机制的作用</strong></p><ol><li><p><strong>性能优化</strong></p><ul><li>频繁使用的小范围数值直接复用缓存对象，避免重复创建。</li><li>示例：<code>Integer i1 = 40;</code> 直接从缓存中获取对象，无需<code>new</code>。</li></ul></li><li><p><strong>内存节省</strong></p><ul><li>缓存常用对象，减少堆内存占用。</li><li>示例：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code>的缓存对象总数仅约1000个。</li></ul></li><li><p><strong>代码简洁</strong></p><ul><li>自动装箱（如<code>Integer i = 10;</code>）隐式调用<code>valueOf()</code>，利用缓存机制。</li></ul></li></ol><p><strong>缓存机制的实现</strong></p><ol><li><p><strong><code>Integer</code>缓存源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i); <span class="comment">// 超出缓存范围，创建新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(low + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Character</code>缓存源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) <span class="comment">// 仅缓存0~127</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c); <span class="comment">// 超出缓存范围，创建新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Boolean</code>缓存源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE); <span class="comment">// 直接返回缓存对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。<br>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。<br>4. <strong>比较方式</strong></p><ul><li>== 比较:仅适用于缓存范围内的对象（如Integeri1=40;Integer i2= 40;）</li><li><strong><code>equals()</code>比较</strong>：适用于所有场景，推荐使用。</li></ul><ol start="2"><li><p><strong>缓存范围外的对象</strong></p><ul><li>超出缓存范围（如Integeri1=200;Integeri2=200;）会创建新对象，== 比较结果为 false</li></ul></li><li><p><strong>浮点数无缓存</strong></p><ul><li>Float 和 Double 每次装箱都会创建新对象，== 比较结果始终为 false</li></ul></li></ol><p><strong>经典面试题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;           <span class="comment">// 使用缓存</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>); <span class="comment">// 创建新对象</span></span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>发生装箱，<code>i1</code>通过<code>valueOf()</code>从<mark>缓存</mark>中获取对象，等价于 <code>Integer i1=Integer.valueOf(40)</code>，<code>i1</code> 直接使用的是缓存中的对象</li><li><code>i2</code>通过<code>new</code>创建新对象。</li><li>== 比较内存地址，结果为 false</li></ul><h3 id="最佳实践"><strong>最佳实践</strong></h3><ol><li><p><strong>比较包装类对象</strong></p><ul><li>始终使用<code>equals()</code>方法，避免== 的潜在问题。</li></ul></li><li><p><strong>自动装箱与缓存</strong></p><ul><li>理解自动装箱（如<code>Integer i = 10;</code>）隐式调用<code>valueOf()</code>，利用缓存机制。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li>在频繁使用小范围数值时，优先使用基本类型（如<code>int</code>），避免包装类的内存开销。</li></ul></li></ol><h2 id="自动装箱和拆箱">自动装箱和拆箱</h2><ol><li><p><strong>装箱</strong></p><ul><li>将基本类型转换为对应的包装类对象。</li><li>示例：<code>Integer i = 10;</code></li><li>实际调用：<code>Integer.valueOf(10)</code></li></ul></li><li><p><strong>拆箱</strong></p><ul><li>将包装类对象转换为基本类型。</li><li>示例：<code>int n = i;</code></li><li>实际调用：<code>i.intValue()</code></li></ul></li></ol><p><strong>性能问题</strong></p><ul><li><strong>频繁拆装箱</strong>会显著影响性能（如循环中大量使用包装类）。</li><li><strong>优化建议</strong>：在性能敏感场景优先使用基本类型。</li></ul><p><strong>反例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 每次循环都会装箱</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i; <span class="comment">// 拆箱后再装箱</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化后</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 使用基本类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i; <span class="comment">// 无拆装箱开销</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么浮点数运算会有精度丢失的风险">为什么浮点数运算会有精度丢失的风险</h2><ul><li>计算机以二进制存储浮点数，部分十进制小数无法精确表示（如0.2）。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>; <span class="comment">// 0.100000024</span></span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>; <span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="解决方案：BigDecimal"><strong>解决方案：<code>BigDecimal</code></strong></h3><ol><li><p><strong>精确计算</strong></p><ul><li>使用<code>BigDecimal</code>避免精度丢失。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> a.subtract(b); <span class="comment">// 0.2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>比较方式</strong></p><ul><li><strong><code>equals()</code></strong>：比较值和精度（<code>1.0</code> ≠ <code>1.00</code>）。</li><li><strong><code>compareTo()</code></strong>：仅比较值（<code>1.0</code> = <code>1.00</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.20&quot;</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.compareTo(y) == <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="大整数处理">大整数处理</h2><h3 id="BigInteger">BigInteger</h3><ul><li>用于处理超出<code>long</code>范围的整数。</li><li>内部通过<code>int[]</code>数组存储数据。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789012345678901234567890&quot;</span>);</span><br><span class="line">System.out.println(bigInt.add(BigInteger.ONE)); <span class="comment">// +1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数值溢出问题">数值溢出问题</h3><ul><li>基本类型有固定范围，超出后会发生溢出。</li><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808（溢出）</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="变量">变量</h2><h3 id="成员变量-VS-局部变量">成员变量 VS 局部变量</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>成员变量</strong></th><th><strong>局部变量</strong></th></tr></thead><tbody><tr><td><strong>语法形式</strong></td><td>属于类，可被<code>public</code>/<code>private</code>/<code>static</code>等修饰</td><td>定义在方法/代码块中或作为参数，仅能被<code>final</code>修饰</td></tr><tr><td><strong>存储位置</strong></td><td><code>static</code>修饰：方法区/元空间<br>非<code>static</code>修饰：堆内存</td><td>栈内存</td></tr><tr><td><strong>生存时间</strong></td><td>随对象创建而存在，随对象销毁而消亡</td><td>随方法调用生成，随方法结束消亡</td></tr><tr><td><strong>默认值</strong></td><td>自动赋默认值（如<code>int</code>→0，<code>boolean</code>→false）</td><td>必须显式初始化，否则编译报错</td></tr><tr><td><strong>作用域</strong></td><td>类内全局可见（受访问修饰符限制）</td><td>仅在定义的方法/代码块内有效</td></tr><tr><td><font color="#0070c0">成堆</font></td><td></td><td></td></tr></tbody></table><p><strong>为什么成员变量有默认值？</strong></p><ol><li>先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。</li><li>默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。<strong>成员变量在运行时可借助反射等方法手动赋值，而局部变量不行</strong></li><li>对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量（堆内存）</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 默认值 null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">// 默认值 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量（栈内存）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;      <span class="comment">// 必须显式初始化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(num1 + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;   <span class="comment">// 成员变量手动赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>;      <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量有什么作用？"><a href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">静态变量有什么作用？</a></h3><ol><li><p><strong>共享性</strong></p><ul><li>被<code>static</code>修饰，属于类而非实例，所有对象共享同一份内存。</li><li>示例：计数器统计对象创建次数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123; count++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存效率</strong></p><ul><li>仅分配一次内存，节省资源。</li><li>示例：全局配置常量。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_USERS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问方式</strong></p><ul><li>通过类名直接访问（如<code>Config.MAX_USERS</code>）。</li><li>若被<code>private</code>修饰，需通过类方法访问。</li></ul></li></ol><table><thead><tr><th><strong>场景</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>全局常量</td><td><code>public static final double PI = 3.14159;</code></td></tr><tr><td>资源共享</td><td>数据库连接池的配置参数</td></tr><tr><td>工具类方法</td><td><code>Math</code>类中的<code>sqrt()</code>方法</td></tr><tr><td>单例模式</td><td>通过静态变量持有唯一实例</td></tr></tbody></table><h3 id="字符型常量-VS-字符串常量">字符型常量 VS 字符串常量</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>字符常量</strong></th><th><strong>字符串常量</strong></th></tr></thead><tbody><tr><td><strong>定义形式</strong></td><td>单引号包裹单个字符：<code>'A'</code></td><td>双引号包裹0-N个字符：<code>&quot;Hello&quot;</code></td></tr><tr><td><strong>本质</strong></td><td><code>char</code>类型（2字节），可参与算术运算</td><td><code>String</code>对象（堆内存），存储地址值</td></tr><tr><td><strong>内存占用</strong></td><td>固定2字节</td><td>可变长度（UTF-8编码英文1字节/字符，中文3字节）</td></tr><tr><td><strong>比较方式</strong></td><td>== 比较值</td><td><code>equals()</code>比较内容，== 比较地址</td></tr><tr><td>⚠️ 注意 <code>char</code> 在 Java 中占两个字节。</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantExample</span> &#123;</span><br><span class="line">    <span class="comment">// 字符常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">LETTER_A</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 2字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREETING</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 内存占用：英文5字符→5字节（UTF-8）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>; <span class="comment">// 2字节存储Unicode</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; <span class="comment">// 6字节（UTF-8）</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Character.BYTES); <span class="comment">// 输出2</span></span><br><span class="line">        System.out.println(str.getBytes().length); <span class="comment">// 输出6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>字符常量</strong></p><ul><li>用于单个字符处理（如ASCII运算）。</li><li>示例：<code>char c = 'A' + 1;</code> → <code>'B'</code>。</li></ul></li><li><p><strong>字符串常量</strong></p><ul><li>用于文本处理，注意不可变性（每次修改生成新对象）。</li><li>示例：<code>String s = &quot;Hi&quot;; s += &quot;!&quot;;</code> → 新建对象<code>&quot;Hi!&quot;</code>。</li></ul></li><li><p><strong>性能优化</strong></p><ul><li>高频操作字符串时用<code>StringBuilder</code>减少内存开销。</li></ul></li></ol><h2 id="方法">方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态方法为什么不能调用非静态成员?</a></h3><p>根本原因：<mark>生命周期与内存分配</mark><br>静态方法与非静态成员的<strong>加载时机</strong>和<strong>内存归属</strong>存在本质差异：</p><table><thead><tr><th><strong>特性</strong></th><th><strong>静态方法</strong></th><th><strong>非静态成员</strong></th></tr></thead><tbody><tr><td><strong>内存分配时机</strong></td><td>类加载阶段分配内存（JVM加载类时）</td><td>对象实例化时分配内存（<code>new</code>关键字创建对象时）</td></tr><tr><td><strong>内存归属</strong></td><td>类级别（方法区/元空间）</td><td>对象级别（堆内存）</td></tr><tr><td><strong>访问依赖</strong></td><td>不依赖对象实例</td><td>必须通过对象实例访问</td></tr></tbody></table><ol><li><strong>时序矛盾</strong><br>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li><li><strong>内存安全</strong><br>非静态成员属于对象实例，不同实例的成员变量值可能不同。静态方法无对象上下文（无<code>this</code>指针），无法确定访问哪个实例的成员。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 非静态成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法尝试访问非静态成员 → 编译错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(instanceVar); // 错误：无法访问非静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法可自由访问非静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(instanceVar); <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法-VS-实例方法">静态方法 VS 实例方法</h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>静态方法</strong></th><th><strong>实例方法</strong></th></tr></thead><tbody><tr><td><strong>调用方式</strong></td><td><code>类名.方法名()</code></td><td><code>对象.方法名()</code></td></tr><tr><td><strong>内存归属</strong></td><td>类级别（方法区/元空间）</td><td>对象级别（堆内存）</td></tr><tr><td><strong><code>this</code>引用</strong></td><td>不可用（无对象上下文）</td><td>可用（指向当前对象）</td></tr><tr><td><strong>访问成员权限</strong></td><td>仅能直接访问静态成员</td><td>可访问所有成员（静态+实例）</td></tr><tr><td><strong>多态支持</strong></td><td>不支持重写（隐藏而非覆盖）</td><td>支持重写（动态绑定）</td></tr><tr><td><strong>静态方法</strong>：仅能直接访问静态成员，需通过对象间接访问实例成员</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">population</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        population++; <span class="comment">// 允许访问静态变量</span></span><br><span class="line">        <span class="comment">// name = &quot;Alice&quot;; // 编译错误：无法直接访问实例变量</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 通过对象间接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载-VS-重写">重载 VS 重写</h2><blockquote><p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</p><p>重写发生在运行期，就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p></blockquote><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr><tr><td>重写补充：</td><td></td><td></td></tr></tbody></table><ol><li>方法名、参数列表必须相同，子类方法返回值类型应&lt;=父类方法返回值类型，抛出的异常范围&lt;=父类，访问修饰符范围&gt;=父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h2 id="可变长参数">可变长参数</h2><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method1(String... args) &#123;</span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method2(String arg1, String... args) &#123;</span><br><span class="line">   //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><ul><li><strong>固定参数优先</strong>：当重载方法中存在固定参数和可变参数版本时，编译器优先匹配固定参数方法。</li><li><strong>可变参数本质</strong>：可变参数在编译后会被转换为数组（如<code>String... args</code> → <code>String[] args</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定参数方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String arg1, String arg2)</span> &#123;</span><br><span class="line">        System.out.println(arg1 + arg2); <span class="comment">// 优先匹配</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);      <span class="comment">// 调用固定参数方法 → 输出 ab</span></span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 调用可变参数方法 → 输出 a b c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译后的字节码分析</strong>：<br>可变参数方法<code>printVariable(String... args)</code>会被编译为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环遍历数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载冲突场景"><strong>重载冲突场景</strong></h3><ul><li><strong>避免歧义</strong>：若同时存在<code>method(String[])</code>和<code>method(String...)</code>，编译器会报错，因两者本质相同。</li><li><strong>类型明确性</strong>：调用时传入明确数组会优先匹配数组参数方法。</li></ul><h1>面向对象基础</h1><h2 id="面向对象-OOP-VS-面向过程-POP">面向对象 (OOP) VS 面向过程 (POP)</h2><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><table><thead><tr><th><strong>维度</strong></th><th><strong>面向过程 (POP)</strong></th><th><strong>面向对象 (OOP)</strong></th></tr></thead><tbody><tr><td><strong>核心思想</strong></td><td>以<strong>过程</strong>为中心，将问题拆解为一系列步骤（方法/函数）</td><td>以<strong>对象</strong>为中心，通过对象交互解决问题</td></tr><tr><td><strong>代码组织方式</strong></td><td>按<strong>执行流程</strong>组织代码</td><td>按<strong>对象职责</strong>组织代码（类、属性、方法）</td></tr><tr><td><strong>数据与行为</strong></td><td>数据与操作分离（函数操作外部数据）</td><td>数据与行为封装在对象内部（对象管理自身状态）</td></tr><tr><td><strong>典型语言</strong></td><td>C、Pascal、Fortran</td><td>Java、C++、Python</td></tr></tbody></table><h3 id="OOP-的核心优势"><strong>OOP 的核心优势</strong></h3><ol><li><strong>易维护</strong><ul><li>封装性：隐藏对象内部状态，通过方法暴露安全操作。</li><li>示例：<code>Circle</code>类封装半径，外部无法直接修改非法值。</li></ul></li><li><strong>易复用</strong><ul><li>继承与多态：复用父类逻辑，扩展子类行为。</li><li>示例：<code>Animal</code>类派生出<code>Dog</code>和<code>Cat</code>，复用<code>eat()</code>方法。</li></ul></li><li><strong>易扩展</strong><ul><li>模块化设计：新增功能只需扩展类或接口，无需修改全局逻辑。</li><li>示例：新增<code>Square</code>类实现<code>Shape</code>接口，系统无需重构。<br>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</li></ul></li></ol><p>面向过程：<strong>面向过程性能比面向对象高</strong>。因为对象调用需要实例化，开销比较大，较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等，一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</p><p>面向对象：<strong>面向对象易维护、易复用、易扩展</strong>。因为面向对象有封装、继承、多态性的特性，所以可设计出低耦合的系统，使得系统更加灵活、更加易于维护。</p><p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。</p><p><strong>面向过程性能比面向对象高的背后原因？</strong></p><blockquote><p>面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是因为 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机器码。</p><p>而面向过程语言大多都是直接编译成机器码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p></blockquote><p><strong>代码示例对比</strong></p><h4 id="面向对象实现"><strong>面向对象实现</strong></h4><p>定义一个 <code>Circle</code> 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius; <span class="comment">// 封装半径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (radius &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;半径必须为正数&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius; <span class="comment">// 行为与数据绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;面积: &quot;</span> + circle.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面向过程实现"><strong>面向过程实现</strong></h4><p>直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">3.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> calculateArea(radius); <span class="comment">// 数据与逻辑分离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;面积: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">(<span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><strong>面向对象实现</strong></th><th><strong>面向过程实现</strong></th></tr></thead><tbody><tr><td><strong>封装性</strong></td><td>数据与操作封装在类中，避免非法修改</td><td>数据暴露在外，需外部校验合法性</td></tr><tr><td><strong>复用性</strong></td><td>可通过继承/组合复用<code>Circle</code>类逻辑</td><td>函数可复用，但数据传递需重复管理</td></tr><tr><td><strong>扩展性</strong></td><td>新增功能（如颜色属性）只需扩展类</td><td>需修改全局函数或添加新函数，易破坏现有逻辑</td></tr><tr><td><strong>性能开销</strong></td><td>轻微对象创建开销（JVM优化后几乎可忽略）</td><td>无对象开销，直接计算</td></tr></tbody></table><p><strong>如何选择编程范式？</strong></p><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐范式</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td>复杂业务系统（如电商平台）</td><td>OOP</td><td>模块化设计、易维护、团队协作高效</td></tr><tr><td>底层驱动开发（如嵌入式）</td><td>POP</td><td>资源受限、需直接操作硬件，逻辑简单直接</td></tr><tr><td>脚本工具（如数据处理脚本）</td><td>POP</td><td>快速开发、无需复杂架构</td></tr><tr><td>框架/库开发</td><td>OOP</td><td>提供高扩展性API，支持多态和接口隔离</td></tr></tbody></table><ol><li><strong>OOP核心价值</strong>：提升代码可维护性、复用性和扩展性，适合中大型项目。</li><li><strong>POP适用场景</strong>：简单任务、资源敏感型开发，或与硬件直接交互的底层逻辑。</li><li><strong>性能误区</strong>：语言实现（如编译方式）对性能影响远大于编程范式本身。</li><li><strong>现代语言趋势</strong>：多数语言支持多范式（如Python、C++），开发者需灵活选择。</li></ol><p><strong>最终建议</strong>：</p><ul><li>优先考虑代码结构和长期维护成本，而非单纯追求性能。</li><li>在性能关键路径（如高频循环）中，可局部使用POP优化，但整体架构仍保持OOP优势。</li></ul><h2 id="创建对象的运算符：对象实体-vs-对象引用">创建对象的运算符：对象实体 vs 对象引用</h2><ul><li><strong><code>new</code> 运算符</strong>：用于在堆内存中创建对象实例。</li><li><strong>对象引用</strong>：指向堆内存中对象实例的变量，存储在栈内存中。</li></ul><table><thead><tr><th><strong>比喻</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>对象实例（气球）</strong></td><td>存在于堆内存中的实际数据。</td></tr><tr><td><strong>对象引用（绳子）</strong></td><td>指向对象的变量，可以指向0个或1个对象（绳子不系或系一个气球）。</td></tr><tr><td><strong>多引用共享</strong></td><td>多个引用可指向同一对象（多条绳子系同一个气球）。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象引用未指向任何对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象引用指向一个新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个引用指向同一对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2;</span><br></pre></td></tr></table></figure><h2 id="对象相等-vs-引用相等">对象相等 vs 引用相等</h2><table><thead><tr><th><strong>对比维度</strong></th><th><strong>引用相等（==）</strong></th><th><strong>对象相等（equals()）</strong></th></tr></thead><tbody><tr><td><strong>比较内容</strong></td><td>内存地址是否相同</td><td>对象内部数据是否相同</td></tr><tr><td><strong>适用场景</strong></td><td>判断两个引用是否指向同一对象</td><td>判断两个对象逻辑上是否相等（如字符串内容）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;          <span class="comment">// 字符串常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 堆中新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;          <span class="comment">// 指向常量池中的同一对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用相等比较（内存地址）</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false（不同对象）</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">// true（同一对象）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象相等比较（内容）</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true（内容相同）</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">// true（内容相同）</span></span><br></pre></td></tr></table></figure><h2 id="如果一个类没有声明构造方法，程序能正确执行吗？"><a href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97">如果一个类没有声明构造方法，程序能正确执行吗？</a></h2><p><strong>默认构造方法</strong>：</p><ul><li>若类未显式定义任何构造方法，Java会自动生成一个<strong>无参默认构造方法</strong>。</li><li>若类显式定义了构造方法（无论是否有参数），Java不再生成默认构造方法。</li></ul><h2 id="构造方法的特点与重写问题"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9-%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override">构造方法的特点与重写问题</a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>名称与类名相同</strong></td><td>构造方法必须与类名完全一致（区分大小写）。</td></tr><tr><td><strong>无返回值声明</strong></td><td>无返回类型（包括<code>void</code>）。</td></tr><tr><td><strong>自动执行</strong></td><td>创建对象时自动调用，无法手动调用。</td></tr></tbody></table><table><thead><tr><th><strong>操作</strong></th><th><strong>是否支持</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>重载</strong></td><td>✅ 支持</td><td>同一类中定义多个参数列表不同的构造方法。</td></tr><tr><td><strong>重写</strong></td><td>❌ 不支持</td><td>构造方法不能被继承，因此子类无法重写父类构造方法。子类需通过super调用父类构造方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 无参构造方法（可被重载）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法（参数不同）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物名称：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 子类构造方法默认调用父类无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 隐式调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式调用父类有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 必须通过super调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三大特征">三大特征</h2><h4 id="封装"><a href="#%E5%B0%81%E8%A3%85">封装</a></h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int id;//id属性私有化</span><br><span class="line">    private String name;//name属性私有化</span><br><span class="line"></span><br><span class="line">    //获取id的方法</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置id的方法</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取name的方法</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置name的方法</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#%E7%BB%A7%E6%89%BF">继承</a></h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="多态"><a href="#%E5%A4%9A%E6%80%81">多态</a></h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="接口和抽象类有什么共同点和区别？"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">接口和抽象类有什么共同点和区别？</a></h3><h4 id="接口和抽象类的共同点"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">接口和抽象类的共同点</a></h4><ul><li><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</li><li><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li></ul><h4 id="接口和抽象类的区别"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB">接口和抽象类的区别</a></h4><ul><li><strong>设计目的</strong>：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li><strong>继承和实现</strong>：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。</li><li><strong>成员变量</strong>：接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（<code>private</code>, <code>protected</code>, <code>public</code>），可以在子类中被重新定义或赋值。</li><li><strong>方法</strong>：<ul><li>Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 <code>default</code>（默认） 方法和 <code>static</code> （静态）方法。 自 Java 9 起，接口可以包含 <code>private</code> 方法。</li><li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li></ul></li></ul><p>在 Java 8 及以上版本中，接口引入了新的方法类型：<code>default</code> 方法、<code>static</code> 方法和 <code>private</code> 方法。这些方法让接口的使用更加灵活。</p><p>Java 8 引入的<code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    default void defaultMethod() &#123;</span><br><span class="line">        System.out.println(&quot;This is a default method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 引入的<code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code> 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    static void staticMethod() &#123;</span><br><span class="line">        System.out.println(&quot;This is a static method in the interface.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 9 允许在接口中使用 <code>private</code> 方法。<code>private</code>方法可以用于在接口内部共享代码，不对外暴露。<br>public interface MyInterface {<br>// default 方法<br>default void defaultMethod() {<br>commonMethod();<br>}</p><pre><code>// static 方法static void staticMethod() &#123;    commonMethod();&#125;// 私有静态方法，可以被 static 和 default 方法调用private static void commonMethod() &#123;    System.out.println(&quot;This is a private method used internally.&quot;);&#125;  // 实例私有方法，只能被 default 方法调用。private void instanceCommonMethod() &#123;    System.out.println(&quot;This is a private instance method used internally.&quot;);&#125;</code></pre><p>}</p><h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><h4 id="浅拷贝"><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D">浅拷贝</a></h4><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。<br>public class Address implements Cloneable{<br>private String name;<br>// 省略构造函数、Getter&amp;Setter方法<br>@Override<br>public Address clone() {<br>try {<br>return (Address) super.clone();<br>} catch (CloneNotSupportedException e) {<br>throw new AssertionError();<br>}<br>}<br>}</p><p>public class Person implements Cloneable {<br>private Address address;<br>// 省略构造函数、Getter&amp;Setter方法<br>@Override<br>public Person clone() {<br>try {<br>Person person = (Person) super.clone();<br>return person;<br>} catch (CloneNotSupportedException e) {<br>throw new AssertionError();<br>}<br>}<br>}<br>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">// true</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><h4 id="深拷贝"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D">深拷贝</a></h4><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Person clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Person person = (Person) super.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        return person;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">// false</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><h2 id="我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：Pasted-image-20250310210416">我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：<br><img src="https://obsidian-1322827540.cos.ap-guangzhou.myqcloud.com/img/Pasted%20image%2020250310210416.png" alt="Pasted image 20250310210416"></h2><h2 id="Object">Object</h2><h3 id="Object-类的常见方法有哪些？"><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Object 类的常见方法有哪些？</a></h3><p>Object 类是一个特殊的类，是所有类的父类，主要提供了以下 11 个方法：<br>/**</p><ul><li>native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。<br><em>/<br>public final native Class&lt; ?&gt; getClass()<br>/</em>*</li><li>native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。<br><em>/<br>public native int hashCode()<br>/</em>*</li><li>用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。<br><em>/<br>public boolean equals(Object obj)<br>/</em>*</li><li>native 方法，用于创建并返回当前对象的一份拷贝。<br><em>/<br>protected native Object clone() throws CloneNotSupportedException<br>/</em>*</li><li>返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。<br><em>/<br>public String toString()<br>/</em>*</li><li>native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。<br><em>/<br>public final native void notify()<br>/</em>*</li><li>native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。<br><em>/<br>public final native void notifyAll()<br>/</em>*</li><li>native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。<br><em>/<br>public final native void wait(long timeout) throws InterruptedException<br>/</em>*</li><li>多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。<br><em>/<br>public final void wait(long timeout, int nanos) throws InterruptedException<br>/</em>*</li><li>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念<br><em>/<br>public final void wait() throws InterruptedException<br>/</em>*</li><li>实例被垃圾回收器回收的时候触发的操作<br>*/<br>protected void finalize() throws Throwable { }</li></ul><h3 id="和-equals-的区别"><a href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">== 和 equals() 的区别</a></h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">     return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">System.out.println(aa == bb);// true</span><br><span class="line">System.out.println(a == b);// false</span><br><span class="line">System.out.println(a.equals(b));// true</span><br><span class="line">System.out.println(42 == 42.0);// true</span><br></pre></td></tr></table></figure><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><p><code>String</code>类<code>equals()</code>方法：<br>public boolean equals(Object anObject) {<br>if (this == anObject) {<br>return true;<br>}<br>if (anObject instanceof String) {<br>String anotherString = (String)anObject;<br>int n = value.length;<br>if (n == anotherString.value.length) {<br>char v1[] = value;<br>char v2[] = anotherString.value;<br>int i = 0;<br>while (n-- != 0) {<br>if (v1[i] != v2[i])<br>return false;<br>i++;<br>}<br>return true;<br>}<br>}<br>return false;<br>}</p><h3 id="hashCode-有什么用？"><a href="#hashcode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">hashCode() 有什么用？</a></h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png" alt="hashCode() 方法"></p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><blockquote><p>⚠️ 注意：该方法在 <strong>Oracle OpenJDK8</strong> 中默认是 “使用线程局部状态来实现 Marsaglia’s xor-shift 随机数生成”, 并不是 “地址” 或者 “地址转换而来”, 不同 JDK/VM 可能不同。在 <strong>Oracle OpenJDK8</strong> 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。参考源码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line"></span><br><span class="line">散列表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）**</span><br><span class="line"></span><br><span class="line">### [为什么要有 hashCode？](#为什么要有-hashcode)</span><br><span class="line"></span><br><span class="line">我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 `hashCode`？</span><br><span class="line">当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。</span><br><span class="line"></span><br><span class="line">其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。</span><br><span class="line"></span><br><span class="line">**那为什么 JDK 还要同时提供这两个方法呢？**</span><br><span class="line">这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！</span><br><span class="line"></span><br><span class="line">我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。</span><br><span class="line"></span><br><span class="line">**那为什么不只提供 `hashCode()` 方法呢？**</span><br><span class="line"></span><br><span class="line">这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。</span><br><span class="line"></span><br><span class="line">**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**</span><br><span class="line"></span><br><span class="line">因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。</span><br><span class="line"></span><br><span class="line">---总结下来就是：</span><br><span class="line"></span><br><span class="line">- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。</span><br><span class="line">- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。</span><br><span class="line">- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。</span><br><span class="line"></span><br><span class="line">相信大家看了我前面对 `hashCode()` 和 `equals()` 的介绍之后，下面这个问题已经难不倒你们了。</span><br><span class="line"></span><br><span class="line">### [为什么重写 equals() 时必须重写 hashCode() 方法？](#为什么重写-equals-时必须重写-hashcode-方法)</span><br><span class="line">因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。</span><br><span class="line"></span><br><span class="line">如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。</span><br><span class="line"></span><br><span class="line">**思考**：重写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现什么问题。</span><br><span class="line"></span><br><span class="line">**总结**：</span><br><span class="line"></span><br><span class="line">- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。</span><br><span class="line">- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。</span><br><span class="line">## [String](#string)</span><br><span class="line"></span><br><span class="line">### [String、StringBuffer、StringBuilder 的区别？](#string、stringbuffer、stringbuilder-的区别)</span><br><span class="line"></span><br><span class="line">**可变性**</span><br><span class="line"></span><br><span class="line">`String` 是不可变的（后面会详细分析原因）。</span><br><span class="line"></span><br><span class="line">`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">   char[] value;</span><br><span class="line">   public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">       if (str == null)</span><br><span class="line">           return appendNull();</span><br><span class="line">       int len = str.length();</span><br><span class="line">       ensureCapacityInternal(count + len);</span><br><span class="line">       str.getChars(0, len, value, count);</span><br><span class="line">       count += len;</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br><span class="line">**线程安全性**</span><br><span class="line"></span><br><span class="line">`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。</span><br><span class="line"></span><br><span class="line">**性能**</span><br><span class="line"></span><br><span class="line">每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</span><br><span class="line"></span><br><span class="line">**对于三者使用的总结：**</span><br><span class="line"></span><br><span class="line">- 操作少量的数据: 适用 `String`</span><br><span class="line">- 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`</span><br><span class="line">- 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`</span><br><span class="line"></span><br><span class="line">### [String 为什么是不可变的?](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84)</span><br><span class="line">`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，~~所以`String` 对象是不可变的。~~</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>public final class String implements java.io.Serializable, Comparable<String>, CharSequence {<br>private final char value[];<br>//…<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 🐛 修正：我们知道被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，`final` 关键字修饰的数组保存字符串并不是 `String` 不可变的根本原因，因为这个数组保存的字符串是可变的（`final` 修饰引用类型变量的情况）。</span><br><span class="line">&gt;</span><br><span class="line">&gt; `String` 真正不可变有下面几点原因：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。</span><br><span class="line">&gt; 2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 相关阅读：[如何理解 String 类型值的不可变？ - 知乎提问](https://www.zhihu.com/question/20618891/answer/114125846)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>public final class String implements java.io.Serializable,Comparable<String>, CharSequence {<br>// @Stable 注解表示变量最多被修改一次，称为“稳定的”。<br>@Stable<br>private final byte[] value;<br>}</p><p>abstract class AbstractStringBuilder implements Appendable, CharSequence {<br>byte[] value;</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Java 9 为何要将 `String` 的底层实现由 `char[]` 改成了 `byte[]` ?**</span><br><span class="line"></span><br><span class="line">新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。</span><br><span class="line"></span><br><span class="line">JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/jdk9-string-latin1.png)</span><br><span class="line"></span><br><span class="line">如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，`byte` 和 `char` 所占用的空间是一样的。</span><br><span class="line"></span><br><span class="line">这是官方的介绍：[https://openjdk.java.net/jeps/254](https://openjdk.java.net/jeps/254) 。</span><br><span class="line"></span><br><span class="line">### [字符串拼接用“+” 还是 StringBuilder?](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder)</span><br><span class="line"></span><br><span class="line">Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>String str1 = “he”;<br>String str2 = “llo”;<br>String str3 = “world”;<br>String str4 = str1 + str2 + str3;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的代码对应的字节码如下：</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png)</span><br><span class="line"></span><br><span class="line">可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。</span><br><span class="line"></span><br><span class="line">不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String[] arr = {“he”, “llo”, “world”};<br>String s = “”;<br>for (int i = 0; i &lt; arr.length; i++) {<br>s += arr[i];<br>}<br>System.out.println(s);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`StringBuilder` 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 `StringBuilder` 对象。</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/java/image-20220422161320823.png)</span><br><span class="line"></span><br><span class="line">如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String[] arr = {“he”, “llo”, “world”};<br>StringBuilder s = new StringBuilder();<br>for (String value : arr) {<br>s.append(value);<br>}<br>System.out.println(s);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/github/javaguide/java/image-20220422162327415.png)</span><br><span class="line"></span><br><span class="line">如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。</span><br><span class="line"></span><br><span class="line">在 JDK 9 中，字符串相加“+”改为用动态方法 `makeConcatWithConstants()` 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： `a+b+c` 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。这个改进是 JDK9 的 [JEP 280](https://openjdk.org/jeps/280) 提出的，关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 [StringBuilder？来重温一下字符串拼接吧](https://juejin.cn/post/7182872058743750715) 以及参考 [issue#2442](https://github.com/Snailclimb/JavaGuide/issues/2442)。</span><br><span class="line"></span><br><span class="line">### [String#equals() 和 Object#equals() 有何区别？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-equals-%E5%92%8C-object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB)</span><br><span class="line"></span><br><span class="line">`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。</span><br><span class="line"></span><br><span class="line">### [字符串常量池的作用了解吗？](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97)</span><br><span class="line"></span><br><span class="line">**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 在字符串常量池中创建字符串对象 ”ab“<br>// 将字符串对象 ”ab“ 的引用赋值给 aa<br>String aa = “ab”;<br>// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb<br>String bb = “ab”;<br>System.out.println(aa==bb); // true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">更多关于字符串常量池的介绍可以看一下 [Java 内存区域详解](https://javaguide.cn/java/jvm/memory-area.html) 这篇文章。</span><br><span class="line"></span><br><span class="line">### [String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-s1-new-string-abc-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1)</span><br><span class="line"></span><br><span class="line">先说答案：会创建 1 或 2 个字符串对象。</span><br><span class="line"></span><br><span class="line">1. 字符串常量池中不存在 &quot;abc&quot;：会创建 2 个 字符串对象。一个在字符串常量池中，由 `ldc` 指令触发创建。一个在堆中，由 `new String()` 创建，并使用常量池中的 &quot;abc&quot; 进行初始化。</span><br><span class="line">2. 字符串常量池中已存在 &quot;abc&quot;：会创建 1 个 字符串对象。该对象在堆中，由 `new String()` 创建，并使用常量池中的 &quot;abc&quot; 进行初始化。</span><br><span class="line"></span><br><span class="line">下面开始详细分析。</span><br><span class="line"></span><br><span class="line">1、如果字符串常量池中不存在字符串对象 “abc”，那么它首先会在字符串常量池中创建字符串对象 &quot;abc&quot;，然后在堆内存中再创建其中一个字符串对象 &quot;abc&quot;。</span><br><span class="line"></span><br><span class="line">示例代码（JDK 1.8）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String s1 = new String(“abc”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的字节码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 在堆内存中分配一个尚未初始化的 String 对象。<br>// #2 是常量池中的一个符号引用，指向 java/lang/String 类。<br>// 在类加载的解析阶段，这个符号引用会被解析成直接引用，即指向实际的 java/lang/String 类。<br>0 new #2 &lt;java/lang/String&gt;<br>// 复制栈顶的 String 对象引用，为后续的构造函数调用做准备。<br>// 此时操作数栈中有两个相同的对象引用：一个用于传递给构造函数，另一个用于保持对新对象的引用，后续将其存储到局部变量表。<br>3 dup<br>// JVM 先检查字符串常量池中是否存在 “abc”。<br>// 如果常量池中已存在 “abc”，则直接返回该字符串的引用；<br>// 如果常量池中不存在 “abc”，则 JVM 会在常量池中创建该字符串字面量并返回它的引用。<br>// 这个引用被压入操作数栈，用作构造函数的参数。<br>4 ldc #3 <abc><br>// 调用构造方法，使用从常量池中加载的 “abc” 初始化堆中的 String 对象<br>// 新的 String 对象将包含与常量池中的 “abc” 相同的内容，但它是一个独立的对象，存储于堆中。<br>6 invokespecial #4 &lt;java/lang/String.<init> : (Ljava/lang/String;)V&gt;<br>// 将堆中的 String 对象引用存储到局部变量表<br>9 astore_1<br>// 返回，结束方法<br>10 return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`ldc (load constant)` 指令的确是从常量池中加载各种类型的常量，包括字符串常量、整数常量、浮点数常量，甚至类引用等。对于字符串常量，`ldc` 指令的行为如下：</span><br><span class="line"></span><br><span class="line">1. **从常量池加载字符串**：`ldc` 首先检查字符串常量池中是否已经有内容相同的字符串对象。</span><br><span class="line">2. **复用已有字符串对象**：如果字符串常量池中已经存在内容相同的字符串对象，`ldc` 会将该对象的引用加载到操作数栈上。</span><br><span class="line">3. **没有则创建新对象并加入常量池**：如果字符串常量池中没有相同内容的字符串对象，JVM 会在常量池中创建一个新的字符串对象，并将其引用加载到操作数栈中。</span><br><span class="line"></span><br><span class="line">2、如果字符串常量池中已存在字符串对象“abc”，则只会在堆中创建 1 个字符串对象“abc”。</span><br><span class="line"></span><br><span class="line">示例代码（JDK 1.8）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 字符串常量池中已存在字符串对象“abc”<br>String s1 = “abc”;<br>// 下面这段代码只会在堆中创建 1 个字符串对象“abc”<br>String s2 = new String(“abc”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的字节码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0 ldc #2 <abc><br>2 astore_1<br>3 new #3 &lt;java/lang/String&gt;<br>6 dup<br>7 ldc #2 <abc><br>9 invokespecial #4 &lt;java/lang/String.<init> : (Ljava/lang/String;)V&gt;<br>12 astore_2<br>13 return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里就不对上面的字节码进行详细注释了，7 这个位置的 `ldc` 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 `ldc` 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 `ldc` 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</span><br><span class="line"></span><br><span class="line">### [String#intern 方法有什么作用?](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8)</span><br><span class="line"></span><br><span class="line">`String.intern()` 是一个 `native` (本地) 方法，用来处理字符串常量池中的字符串对象引用。它的工作流程可以概括为以下两种情况：</span><br><span class="line"></span><br><span class="line">1. **常量池中已有相同内容的字符串对象**：如果字符串常量池中已经有一个与调用 `intern()` 方法的字符串内容相同的 `String` 对象，`intern()` 方法会直接返回常量池中该对象的引用。</span><br><span class="line">2. **常量池中没有相同内容的字符串对象**：如果字符串常量池中还没有一个与调用 `intern()` 方法的字符串内容相同的对象，`intern()` 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">- `intern()` 方法的主要作用是确保字符串引用在常量池中的唯一性。</span><br><span class="line">- 当调用 `intern()` 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</span><br><span class="line"></span><br><span class="line">示例代码（JDK 1.8） :</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// s1 指向字符串常量池中的 “Java” 对象<br>String s1 = “Java”;<br>// s2 也指向字符串常量池中的 “Java” 对象，和 s1 是同一个对象<br>String s2 = s1.intern();<br>// 在堆中创建一个新的 “Java” 对象，s3 指向它<br>String s3 = new String(“Java”);<br>// s4 指向字符串常量池中的 “Java” 对象，和 s1 是同一个对象<br>String s4 = s3.intern();<br>// s1 和 s2 指向的是同一个常量池中的对象<br>System.out.println(s1 == s2); // true<br>// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同<br>System.out.println(s3 == s4); // false<br>// s1 和 s4 都指向常量池中的同一个对象<br>System.out.println(s1 == s4); // true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### [String 类型的变量和常量做“+”运算时发生了什么？](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A-%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)</span><br><span class="line"></span><br><span class="line">先来看字符串不加 `final` 关键字拼接的情况（JDK1.8）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String str1 = “str”;<br>String str2 = “ing”;<br>String str3 = “str” + “ing”;<br>String str4 = str1 + str2;<br>String str5 = “string”;<br>System.out.println(str3 == str4);//false<br>System.out.println(str3 == str5);//true<br>System.out.println(str4 == str5);//false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; **注意**：比较 String 字符串的值是否相等，可以使用 `equals()` 方法。 `String` 中的 `equals` 方法是被重写过的。 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是字符串的值是否相等。如果你使用 `==` 比较两个字符串是否相等的话，IDEA 还是提示你使用 `equals()` 方法替换。</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/java-guide-blog/image-20210817123252441.png)</span><br><span class="line"></span><br><span class="line">**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**</span><br><span class="line"></span><br><span class="line">在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</span><br><span class="line"></span><br><span class="line">![](https://oss.javaguide.cn/javaguide/image-20210817142715396.png)</span><br><span class="line"></span><br><span class="line">常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</span><br><span class="line"></span><br><span class="line">对于 `String str3 = &quot;str&quot; + &quot;ing&quot;;` 编译器会给你优化成 `String str3 = &quot;string&quot;;` 。</span><br><span class="line"></span><br><span class="line">并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</span><br><span class="line"></span><br><span class="line">- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。</span><br><span class="line">- `final` 修饰的基本数据类型和字符串变量</span><br><span class="line">- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</span><br><span class="line"></span><br><span class="line">**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**</span><br><span class="line"></span><br><span class="line">对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String str4 = new StringBuilder().append(str1).append(str2).toString();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。</span><br><span class="line"></span><br><span class="line">不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>final String str1 = “str”;<br>final String str2 = “ing”;<br>// 下面两个表达式其实是等价的<br>String c = “str” + “ing”;// 常量池中的对象<br>String d = str1 + str2; // 常量池中的对象<br>System.out.println(c == d);// true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</span><br><span class="line"></span><br><span class="line">如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</span><br><span class="line"></span><br><span class="line">示例代码（`str2` 在运行时才能确定其值）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>final String str1 = “str”;<br>final String str2 = getStr();<br>String c = “str” + “ing”;// 常量池中的对象<br>String d = str1 + str2; // 在堆上创建的新的对象<br>System.out.println(c == d);// false<br>public static String getStr() {<br>return “ing”;<br>}</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
